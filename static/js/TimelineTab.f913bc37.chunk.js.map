{"version":3,"sources":["interface/common/DragScroll.tsx","interface/report/Results/Timeline/Buffs.js","interface/report/Results/Timeline/Casts.js","interface/report/Results/Timeline/Lane.js","interface/report/Results/Timeline/Cooldowns.js","interface/report/Results/Timeline/Component.js","interface/report/Results/Timeline/Container.js"],"names":["DragScroll","children","style","otherProps","useState","dragging","setDragging","container","useRef","clientPosition","draggingRef","handleMouseUp","useCallback","current","handleMouseMove","event","scrollLeft","clientX","scrollTop","clientY","useEffect","window","addEventListener","removeEventListener","onMouseDown","button","preventDefault","ref","cursor","Buffs","_applied","_levels","_maxLevel","renderEvent","bind","timestamp","this","props","start","secondWidth","parser","toPlayer","spellId","ability","guid","buff","buffs","getBuff","timelineHighlight","type","EventType","ApplyBuff","isApplicableBuffEvent","renderApplyBuff","RemoveBuff","renderRemoveBuff","FightEnd","renderLeftOverBuffs","level","undefined","_getLevel","Math","max","renderIcon","className","applied","left","getOffsetLeft","duration","fightDuration","indexOf","Tooltip","key","content","id","formatDuration","name","toFixed","width","data-effect","elems","Object","keys","forEach","push","SpellLink","icon","Icon","abilityIcon","replace","alt","eventHistory","map","React","PureComponent","Casts","_lastLowered","_level","byPlayer","CASTS_THAT_ARENT_CASTS","includes","Cast","isApplicableCastEvent","renderCast","BeginChannel","renderBeginChannel","EndChannel","renderChannel","GlobalCooldown","renderGlobalCooldown","channel","castReason","lower","globalCooldown","margin","meta","isInefficientCast","inefficientCastReason","isEnhancedCast","enhancedCastReason","tooltip","isCancelled","trigger","BeginCast","castEvent","linkIcon","Fragment","Lane","fightStartTimestamp","FilterCooldownInfo","UpdateSpellUsable","RestoreCharge","renderCooldown","renderRecharge","min","fightEndTimestamp","nextChildren","slice","length","nextCast","findIndex","e","nextCD","find","end","splice","Cooldowns","events","abilities","getAbility","timelineSortIndex","eventsBySpellId","growUp","Array","from","sort","a","b","getSortIndex","item","renderLane","renderLanes","Timeline","state","zoom","padding","setContainerRef","isApplicableUpdateSpellUsableEvent","cooldown","EndCooldown","Map","isApplicableEvent","_getCanonicalId","has","set","get","spell","elem","getBoundingClientRect","setState","x","skipInterval","ceil","getEventsBySpellId","totalWidth","paddingTop","paddingBottom","paddingLeft","paddingRight","seconds","_","second","offset","data-duration","fight","start_time","end_time","offset_time","defaultProps","showCooldowns","showGlobalCooldownDuration","Container","Component","getModule","Abilities"],"mappings":"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","file":"static/js/TimelineTab.f913bc37.chunk.js","sourcesContent":["/**\r\n * Created by joe on 16/9/2.\r\n * Source: https://raw.githubusercontent.com/qiaolb/react-dragscroll/master/src/DragScroll.jsx\r\n * This was cleaned up. A lot.\r\n */\r\n\r\nimport React, { useCallback, useEffect, useRef, useState } from 'react';\r\n\r\nexport interface Props extends React.HTMLAttributes<HTMLDivElement> {\r\n  children: React.ReactNode\r\n  style?: Record<string, unknown>\r\n}\r\n\r\nconst DragScroll = ({ children, style = {}, ...otherProps }: Props) => {\r\n  const [dragging, setDragging] = useState(false)\r\n  const container = useRef<HTMLDivElement>(null)\r\n\r\n  const clientPosition = useRef<[number, number]>([0, 0])\r\n  const draggingRef = useRef(dragging) // to be used in useEffect so that the effect is not triggered every time the dragging value changes, so that event listeners are only added and removed once\r\n\r\n  const handleMouseDown = (event: React.MouseEvent<HTMLDivElement, MouseEvent>) => {\r\n    if (event.button !== 0) {\r\n      // Only handle left click\r\n      return;\r\n    }\r\n\r\n    setDragging(true)\r\n    draggingRef.current = true\r\n    clientPosition.current = [event.clientX, event.clientY]\r\n    event.preventDefault();\r\n  }\r\n\r\n  const handleMouseUp = useCallback(() => {\r\n    setDragging(false)\r\n    draggingRef.current = false\r\n  }, [])\r\n\r\n  const handleMouseMove = useCallback((event) => {\r\n    if (draggingRef.current && container.current !== null) {\r\n      container.current.scrollLeft -= -clientPosition.current[0] + event.clientX;\r\n      container.current.scrollTop -= -clientPosition.current[1] + event.clientY;\r\n      clientPosition.current = [event.clientX, event.clientY]\r\n    }\r\n  }, [])\r\n\r\n  useEffect(() => {\r\n    window.addEventListener('mouseup', handleMouseUp);\r\n    window.addEventListener('mousemove', handleMouseMove);\r\n    \r\n    return () => {\r\n      window.removeEventListener('mouseup', handleMouseUp);\r\n      window.removeEventListener('mousemove', handleMouseMove);\r\n    }\r\n  }, [handleMouseUp, handleMouseMove])\r\n\r\n  return (\r\n    <div\r\n      onMouseDown={handleMouseDown}\r\n      ref={container}\r\n      style={{\r\n        ...style,\r\n        cursor: dragging ? 'grabbing' : 'grab',\r\n      }}\r\n      {...otherProps}\r\n    >\r\n      {children}\r\n    </div>\r\n  );\r\n\r\n}\r\n\r\nexport default DragScroll;\r\n","import React from 'react';\r\nimport PropTypes from 'prop-types';\r\nimport { Trans } from '@lingui/macro';\r\n\r\nimport { formatDuration } from 'common/format';\r\nimport Icon from 'common/Icon';\r\nimport SpellLink from 'common/SpellLink';\r\nimport BuffsModule from 'parser/core/modules/Buffs';\r\nimport { EventType } from 'parser/core/Events';\r\nimport Tooltip from 'common/Tooltip';\r\n\r\nimport './Buffs.scss';\r\n\r\nclass Buffs extends React.PureComponent {\r\n  static propTypes = {\r\n    start: PropTypes.number.isRequired,\r\n    secondWidth: PropTypes.number.isRequired,\r\n    parser: PropTypes.shape({\r\n      eventHistory: PropTypes.arrayOf(PropTypes.shape({\r\n        type: PropTypes.string.isRequired,\r\n      })).isRequired,\r\n      toPlayer: PropTypes.func.isRequired,\r\n    }).isRequired,\r\n    buffs: PropTypes.instanceOf(BuffsModule).isRequired,\r\n  };\r\n\r\n  constructor() {\r\n    super();\r\n    this.renderEvent = this.renderEvent.bind(this);\r\n  }\r\n\r\n  getOffsetLeft(timestamp) {\r\n    return (timestamp - this.props.start) / 1000 * this.props.secondWidth;\r\n  }\r\n\r\n  // TODO: Fabricate removebuff events for buffs that expired after the fight\r\n\r\n  isApplicableBuffEvent(event) {\r\n    const parser = this.props.parser;\r\n\r\n    if (!parser.toPlayer(event)) {\r\n      // Ignore pet/boss buffs\r\n      return false;\r\n    }\r\n    const spellId = event.ability.guid;\r\n    const buff = this.props.buffs.getBuff(spellId);\r\n    if (!buff || !buff.timelineHighlight) {\r\n      return false;\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  renderEvent(event) {\r\n    switch (event.type) {\r\n      case EventType.ApplyBuff:\r\n        if (this.isApplicableBuffEvent(event)) {\r\n          return this.renderApplyBuff(event);\r\n        } else {\r\n          return null;\r\n        }\r\n      case EventType.RemoveBuff:\r\n        if (this.isApplicableBuffEvent(event)) {\r\n          return this.renderRemoveBuff(event);\r\n        } else {\r\n          return null;\r\n        }\r\n      case EventType.FightEnd:\r\n        return this.renderLeftOverBuffs(event);\r\n      default:\r\n        return null;\r\n    }\r\n  }\r\n  _applied = {};\r\n  _levels = [];\r\n  _maxLevel = 0;\r\n  _getLevel() {\r\n    // Look for the first available level, reusing levels that are no longer used\r\n    let level = 0;\r\n    while (this._levels[level] !== undefined) {\r\n      level += 1;\r\n    }\r\n    return level;\r\n  }\r\n  renderApplyBuff(event) {\r\n    const spellId = event.ability.guid;\r\n\r\n    // Avoid overlapping icons\r\n    const level = this._getLevel();\r\n    this._applied[spellId] = event;\r\n    this._levels[level] = spellId;\r\n    this._maxLevel = Math.max(this._maxLevel, level);\r\n\r\n    return this.renderIcon(event, {\r\n      className: 'hoist',\r\n      style: {\r\n        '--level': level,\r\n      },\r\n      children: <div className=\"time-indicator\" />,\r\n    });\r\n  }\r\n  renderRemoveBuff(event) {\r\n    const applied = this._applied[event.ability.guid];\r\n    if (!applied) {\r\n      // This may occur for broken logs with missing events due to range/logger issues\r\n      return null;\r\n    }\r\n    const left = this.getOffsetLeft(applied.timestamp);\r\n    const duration = event.timestamp - applied.timestamp;\r\n    const fightDuration = (applied.timestamp - this.props.start) / 1000;\r\n\r\n    const level = this._levels.indexOf(event.ability.guid);\r\n    this._levels[level] = undefined;\r\n    delete this._applied[event.ability.guid];\r\n\r\n    // TODO: tooltip renders at completely wrong places\r\n    return (\r\n      <Tooltip\r\n        key={`buff-${left}-${event.ability.guid}`}\r\n        content={(\r\n          <Trans id=\"interface.report.results.timeline.buffs.tooltip.gainedAbilityForXSec\">\r\n            {formatDuration(fightDuration, 3)}: gained {event.ability.name} for {(duration / 1000).toFixed(2)}s\r\n          </Trans>\r\n        )}\r\n      >\r\n        <div\r\n          className=\"buff hoist\"\r\n          style={{\r\n            left,\r\n            width: (event.timestamp - applied.timestamp) / 1000 * this.props.secondWidth,\r\n            '--level': level,\r\n          }}\r\n          data-effect=\"float\"\r\n        />\r\n      </Tooltip>\r\n    );\r\n  }\r\n  renderLeftOverBuffs(event) {\r\n    // We don't have a removebuff event for buffs that end *after* the fight, so instead we go through all remaining active buffs and manually trigger the removebuff render.\r\n    const elems = [];\r\n    Object.keys(this._applied).forEach(spellId => {\r\n      const applied = this._applied[spellId];\r\n      elems.push(this.renderRemoveBuff({\r\n        ...applied,\r\n        timestamp: event.timestamp,\r\n      }));\r\n    });\r\n    return elems;\r\n  }\r\n  renderIcon(event, { className = '', style = {}, children } = {}) {\r\n    const left = this.getOffsetLeft(event.timestamp);\r\n    return (\r\n      <SpellLink\r\n        key={`cast-${left}-${event.ability.guid}`}\r\n        id={event.ability.guid}\r\n        icon={false}\r\n        className={`cast ${className}`}\r\n        style={{\r\n          left,\r\n          ...style,\r\n        }}\r\n      >\r\n        <Icon\r\n          icon={event.ability.abilityIcon.replace('.jpg', '')}\r\n          alt={event.ability.name}\r\n        />\r\n        {children}\r\n      </SpellLink>\r\n    );\r\n  }\r\n  render() {\r\n    const { parser } = this.props;\r\n\r\n    const buffs = parser.eventHistory.map(this.renderEvent);\r\n\r\n    return (\r\n      <div className=\"buffs\" style={{ '--levels': this._maxLevel + 1 }}>\r\n        {buffs}\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Buffs;\r\n","import React from 'react';\r\nimport PropTypes from 'prop-types';\r\nimport { Trans } from '@lingui/macro';\r\n\r\nimport Tooltip from 'common/Tooltip';\r\nimport { formatDuration } from 'common/format';\r\nimport Icon from 'common/Icon';\r\nimport SpellLink from 'common/SpellLink';\r\nimport CASTS_THAT_ARENT_CASTS from 'parser/core/CASTS_THAT_ARENT_CASTS';\r\nimport { EventType } from 'parser/core/Events';\r\n\r\nimport './Casts.scss';\r\n\r\nconst ICON_WIDTH = 22;\r\n\r\nclass Casts extends React.PureComponent {\r\n  static propTypes = {\r\n    start: PropTypes.number.isRequired,\r\n    secondWidth: PropTypes.number.isRequired,\r\n    parser: PropTypes.shape({\r\n      eventHistory: PropTypes.arrayOf(PropTypes.shape({\r\n        type: PropTypes.string.isRequired,\r\n      })).isRequired,\r\n      toPlayer: PropTypes.func.isRequired,\r\n      byPlayer: PropTypes.func.isRequired,\r\n    }).isRequired,\r\n  };\r\n\r\n  constructor() {\r\n    super();\r\n    this.renderEvent = this.renderEvent.bind(this);\r\n  }\r\n\r\n  getOffsetLeft(timestamp) {\r\n    return (timestamp - this.props.start) / 1000 * this.props.secondWidth;\r\n  }\r\n\r\n  isApplicableCastEvent(event) {\r\n    const parser = this.props.parser;\r\n\r\n    if (!parser.byPlayer(event)) {\r\n      // Ignore pet/boss casts\r\n      return false;\r\n    }\r\n    const spellId = event.ability.guid;\r\n    if (CASTS_THAT_ARENT_CASTS.includes(spellId)) {\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  renderEvent(event) {\r\n    switch (event.type) {\r\n      case EventType.Cast:\r\n        if (this.isApplicableCastEvent(event)) {\r\n          return this.renderCast(event);\r\n        } else {\r\n          return null;\r\n        }\r\n      case EventType.BeginChannel:\r\n        if (this.isApplicableCastEvent(event)) {\r\n          return this.renderBeginChannel(event);\r\n        } else {\r\n          return null;\r\n        }\r\n      case EventType.EndChannel:\r\n        return this.renderChannel(event);\r\n      case EventType.GlobalCooldown:\r\n        return this.renderGlobalCooldown(event);\r\n      default:\r\n        return null;\r\n    }\r\n  }\r\n  _lastLowered = null;\r\n  _level = 0;\r\n  _maxLevel = 0;\r\n  renderCast(event) {\r\n    if (event.channel) {\r\n      // If a spell has a channel event, it has a cast time/is channeled and we already rendered it in the `beginchannel` event\r\n      return null;\r\n    }\r\n\r\n    let className = '';\r\n    const left = this.getOffsetLeft(event.timestamp);\r\n\r\n    // Hoist abilities off the GCD below the main timeline-bar\r\n    const lower = !event.globalCooldown;\r\n    let level = 0;\r\n    if (lower) {\r\n      className += ' lower';\r\n      // Avoid overlapping icons\r\n      const margin = left - this._lastLowered;\r\n      if (this._lastLowered && margin < ICON_WIDTH) {\r\n        this._level += 1;\r\n        level = this._level;\r\n        this._maxLevel = Math.max(this._maxLevel, level);\r\n      } else {\r\n        this._level = 0;\r\n      }\r\n      this._lastLowered = left;\r\n    }\r\n\r\n    let castReason;\r\n    const meta = event.meta;\r\n    if (meta) {\r\n      if (meta.isInefficientCast) {\r\n        className += ' inefficient';\r\n        castReason = meta.inefficientCastReason;\r\n      } else if (meta.isEnhancedCast) {\r\n        className += ' enhanced';\r\n        castReason = meta.enhancedCastReason;\r\n      }\r\n    }\r\n\r\n    return this.renderIcon(event, {\r\n      className,\r\n      style: {\r\n        '--level': level > 0 ? level : undefined,\r\n      },\r\n      children: lower ? (\r\n        <div className=\"time-indicator\" />\r\n      ) : undefined,\r\n      tooltip: castReason,\r\n    });\r\n  }\r\n  renderBeginChannel(event) {\r\n    let className = '';\r\n    let castReason;\r\n    if (event.isCancelled) {\r\n      className += ' cancelled';\r\n      castReason = <Trans id=\"interface.report.results.timeline.casts.neverFinished\">Cast never finished.</Trans>;\r\n    }\r\n    // If the beginchannel has a meta prop use that.\r\n    // If it doesn't, look inside the trigger (which should be a begincast).\r\n    // If the trigger doesn't have a meta prop, and it's a begincast event, use the cast event's instead. We need to do this since often we can only determine if something was a bad cast on cast finish, e.g. if a player should only cast something while a buff is up on finish.\r\n    // Using the cast event's meta works here since the timeline is only ever called when parsing has finished, so it doesn't matter that it's not chronological.\r\n    // This is kind of an ugly hack, but it's the only way to render an icon on the beginchannel event while allowing maintainers to mark the cast events bad. We could have forced everyone to modify meta on the beginchannel/begincast event instead, but that would be inconvenient and unexpected with no real gain.\r\n    const meta = event.meta || (event.trigger && event.trigger.meta) || (event.trigger && event.trigger.type === EventType.BeginCast && event.trigger.castEvent && event.trigger.castEvent.meta);\r\n    if (meta) {\r\n      if (meta.isInefficientCast) {\r\n        className += ' inefficient';\r\n        castReason = meta.inefficientCastReason;\r\n      } else if (meta.isEnhancedCast) {\r\n        className += ' enhanced';\r\n        castReason = meta.enhancedCastReason;\r\n      }\r\n    }\r\n\r\n    return this.renderIcon(event, {\r\n      className,\r\n      tooltip: castReason,\r\n    });\r\n  }\r\n  renderIcon(event, { className = '', style = {}, children, tooltip } = {}) {\r\n    const left = this.getOffsetLeft(event.timestamp);\r\n\r\n    const linkIcon = children => (\r\n      <SpellLink\r\n        id={event.ability.guid}\r\n        icon={false}\r\n        className={`cast ${className}`}\r\n        style={{\r\n          left,\r\n          ...style,\r\n        }}\r\n      >\r\n        {children}\r\n      </SpellLink>\r\n    );\r\n    const icon = (\r\n      <>\r\n        <Icon\r\n          icon={event.ability.abilityIcon.replace('.jpg', '')}\r\n          alt={event.ability.name}\r\n        />\r\n        {children}\r\n      </>\r\n    );\r\n\r\n    return (\r\n      <React.Fragment\r\n        // It's possible this complains about \"encountered two children with the same key\". This is probably caused by fabricating a channel event at a cast time. If you can fix it by removing one of the events that would be great, otherwise you may just have to ignore this as while it's showing a warning, deduplicting the icons is correct behavior.\r\n        key={`cast-${left}-${event.ability.guid}`}\r\n      >\r\n        {tooltip ? (\r\n          <Tooltip content={tooltip}>\r\n            <div className={`cast ${className}`} style={{ left, ...style }}>\r\n               {icon}\r\n            </div>\r\n          </Tooltip>\r\n        ) : linkIcon(icon)}\r\n      </React.Fragment>\r\n    );\r\n  }\r\n  renderChannel(event) {\r\n    const start = this.props.start;\r\n    const left = this.getOffsetLeft(event.start);\r\n    const fightDuration = (event.start - start) / 1000;\r\n\r\n    return (\r\n      <Tooltip\r\n        key={`channel-${left}-${event.ability.guid}`}\r\n        content={(\r\n          <Trans id=\"interface.report.results.timeline.casts.tooltip.xSecChannelByAbility\">\r\n            {formatDuration(fightDuration, 3)}: {(event.duration / 1000).toFixed(2)}s channel by {event.ability.name}\r\n          </Trans>\r\n        )}\r\n      >\r\n        <div\r\n          className=\"channel\"\r\n          style={{\r\n            left,\r\n            width: event.duration / 1000 * this.props.secondWidth,\r\n          }}\r\n        />\r\n      </Tooltip>\r\n    );\r\n  }\r\n  renderGlobalCooldown(event) {\r\n    const start = this.props.start;\r\n    const left = this.getOffsetLeft(event.timestamp);\r\n    const fightDuration = (event.timestamp - start) / 1000;\r\n\r\n    return (\r\n      <Tooltip\r\n        key={`gcd-${left}-${event.ability.guid}`}\r\n        content={(\r\n          <Trans id=\"interface.report.results.timeline.casts.tooltip.xSecGCDByAbility\">\r\n            {formatDuration(fightDuration, 3)}: {(event.duration / 1000).toFixed(2)}s Global Cooldown by {event.ability.name}\r\n          </Trans>\r\n        )}\r\n      >\r\n        <div\r\n          className=\"gcd\"\r\n          style={{\r\n            left,\r\n            width: event.duration / 1000 * this.props.secondWidth,\r\n          }}\r\n        />\r\n      </Tooltip>\r\n    );\r\n  }\r\n  render() {\r\n    const { parser } = this.props;\r\n\r\n    const content = parser.eventHistory.map(this.renderEvent);\r\n\r\n    return (\r\n      <div className=\"casts\" style={{ '--levels': this._maxLevel + 1 }}>\r\n        {content}\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Casts;\r\n","import React from 'react';\r\nimport PropTypes from 'prop-types';\r\nimport { Trans } from '@lingui/macro';\r\n\r\nimport Tooltip from 'common/Tooltip';\r\nimport SpellLink from 'common/SpellLink';\r\nimport Icon from 'common/Icon';\r\n\r\nimport { EventType } from 'parser/core/Events';\r\n\r\nconst PREPHASE_BUFFER = 1000; //ms a prephase event gets displayed before the phase start\r\n\r\nclass Lane extends React.PureComponent {\r\n  static propTypes = {\r\n    children: PropTypes.arrayOf(PropTypes.object).isRequired,\r\n    fightStartTimestamp: PropTypes.number.isRequired,\r\n    fightEndTimestamp: PropTypes.number.isRequired,\r\n    secondWidth: PropTypes.number.isRequired,\r\n    style: PropTypes.object,\r\n  };\r\n\r\n  getOffsetLeft(timestamp) {\r\n    return (timestamp - this.props.fightStartTimestamp) / 1000 * this.props.secondWidth;\r\n  }\r\n\r\n  renderEvent(event) {\r\n    switch (event.type) {\r\n      case EventType.FilterCooldownInfo:\r\n      case EventType.Cast:\r\n        return this.renderCast(event);\r\n      case EventType.UpdateSpellUsable:\r\n        if (event.trigger === EventType.RestoreCharge) {\r\n          return (\r\n            <React.Fragment key={`restorecharge-${event.timestamp}`}>\r\n              {this.renderCooldown(event)}\r\n              {this.renderRecharge(event)}\r\n            </React.Fragment>\r\n          );\r\n        } else {\r\n          return this.renderCooldown(event);\r\n        }\r\n      default:\r\n        return null;\r\n    }\r\n  }\r\n  renderCast(event) {\r\n    //let pre phase events be displayed one second tick before the phase\r\n    const left = this.getOffsetLeft(Math.max(this.props.fightStartTimestamp - PREPHASE_BUFFER, event.timestamp));\r\n    const spellId = event.ability.guid;\r\n\r\n    return (\r\n      <SpellLink\r\n        key={`cast-${spellId}-${left}`}\r\n        id={spellId}\r\n        icon={false}\r\n        className=\"cast\"\r\n        style={{ left }}\r\n      >\r\n        {/*<div style={{ height: level * 30 + 55, top: negative ? 0 : undefined, bottom: negative ? undefined : 0 }} />*/}\r\n        <Icon\r\n          icon={event.ability.abilityIcon.replace('.jpg', '')}\r\n          alt={event.ability.name}\r\n        />\r\n      </SpellLink>\r\n    );\r\n  }\r\n  renderCooldown(event) {\r\n    //let pre phase events be displayed one second tick before the phase\r\n    const left = this.getOffsetLeft(Math.max(this.props.fightStartTimestamp - PREPHASE_BUFFER, event.start));\r\n    const width = (Math.min(this.props.fightEndTimestamp, event.timestamp) - Math.max(this.props.fightStartTimestamp - PREPHASE_BUFFER, event.start)) / 1000 * this.props.secondWidth;\r\n    return (\r\n      <Tooltip\r\n        key={`cooldown-${left}`}\r\n        content={(\r\n          <Trans id=\"interface.report.results.timeline.lane.tooltip.eventOrAbilityCooldown\">\r\n            {event.name || event.ability.name} cooldown: {((event.timestamp - event.start) / 1000).toFixed(1)}s\r\n          </Trans>\r\n        )}\r\n      >\r\n        <div\r\n          className=\"cooldown\"\r\n          style={{\r\n            left,\r\n            width,\r\n          }}\r\n          data-effect=\"float\"\r\n        />\r\n      </Tooltip>\r\n    );\r\n  }\r\n  renderRecharge(event) {\r\n    if (event.timestamp > this.props.fightEndTimestamp) {\r\n      return null;\r\n    }\r\n    const left = this.getOffsetLeft(event.timestamp);\r\n    return (\r\n      <Tooltip content={<Trans id=\"interface.report.results.timeline.lane.tooltip.chargeRestored\">Charge restored</Trans>}>\r\n        <div\r\n          key={`recharge-${left}`}\r\n          className=\"recharge\"\r\n          style={{\r\n            left,\r\n          }}\r\n        />\r\n      </Tooltip>\r\n    );\r\n  }\r\n\r\n  render() {\r\n    const { children, style } = this.props;\r\n\r\n    const ability = children[0].ability;\r\n    if(children[0].type === EventType.FilterCooldownInfo || children[0].type === EventType.Cast){ //if first cast happened before phase\r\n      const nextChildren = children.slice(1, children.length); //all children following the first cast\r\n      const nextCast = nextChildren.findIndex(e => e.type === EventType.Cast || e.type === EventType.FilterCooldownInfo) + 1; //add 1 since we're searching through the events FOLLOWING the initial cast\r\n      const nextCD = nextChildren.find(e => e.type === EventType.UpdateSpellUsable && e.trigger === \"endcooldown\"); //find next end CD event\r\n      if((nextCD && nextCD.end < this.props.fightStartTimestamp - PREPHASE_BUFFER)){//if cooldown ended before the phase (including buffer), remove it to avoid visual overlaps\r\n        children.splice(0, nextCast || children.length); //remove events before the next cast, remove all if there is no next cast to clean up the list\r\n      }\r\n    }\r\n\r\n    return children.length > 0 && (\r\n      <div\r\n        className=\"lane\"\r\n        style={style}\r\n      >\r\n        <div className=\"legend\">\r\n          <Icon\r\n            icon={ability.abilityIcon.replace('.jpg', '')}\r\n            alt={ability.name}\r\n          />\r\n        </div>\r\n\r\n        {children.map(event => this.renderEvent(event))}\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Lane;\r\n","import React from 'react';\r\nimport PropTypes from 'prop-types';\r\n\r\nimport Abilities from 'parser/core/modules/Abilities';\r\n\r\nimport './Cooldowns.scss';\r\nimport Lane from './Lane';\r\n\r\nclass Cooldowns extends React.PureComponent {\r\n  static propTypes = {\r\n    start: PropTypes.number.isRequired,\r\n    end: PropTypes.number.isRequired,\r\n    secondWidth: PropTypes.number.isRequired,\r\n    eventsBySpellId: PropTypes.instanceOf(Map).isRequired,\r\n    abilities: PropTypes.instanceOf(Abilities).isRequired,\r\n  };\r\n\r\n  getSortIndex([spellId, events]) {\r\n    const ability = this.props.abilities.getAbility(spellId);\r\n    if (!ability || ability.timelineSortIndex === undefined) {\r\n      return 1000 - events.length;\r\n    } else {\r\n      return ability.timelineSortIndex;\r\n    }\r\n  }\r\n\r\n  renderLanes(eventsBySpellId, growUp) {\r\n    return Array.from(eventsBySpellId)\r\n      .sort((a, b) => this.getSortIndex(growUp ? b : a) - this.getSortIndex(growUp ? a : b))\r\n      .map(item => this.renderLane(item));\r\n  }\r\n  renderLane([spellId, events]) {\r\n    return (\r\n      <Lane\r\n        key={spellId}\r\n        spellId={spellId}\r\n        fightStartTimestamp={this.props.start}\r\n        fightEndTimestamp={this.props.end}\r\n        secondWidth={this.props.secondWidth}\r\n      >\r\n        {events}\r\n      </Lane>\r\n    );\r\n  }\r\n  render() {\r\n    const { eventsBySpellId } = this.props;\r\n    return (\r\n      <div className=\"cooldowns\">\r\n        {this.renderLanes(eventsBySpellId, false)}\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Cooldowns;\r\n","import React from 'react';\r\nimport PropTypes from 'prop-types';\r\n\r\nimport { EventType } from 'parser/core/Events';\r\n\r\nimport { formatDuration } from 'common/format';\r\nimport DragScroll from 'interface/common/DragScroll';\r\nimport CASTS_THAT_ARENT_CASTS from 'parser/core/CASTS_THAT_ARENT_CASTS';\r\nimport Abilities from 'parser/core/modules/Abilities';\r\nimport BuffsModule from 'parser/core/modules/Buffs';\r\nimport CombatLogParser from 'parser/core/CombatLogParser';\r\n\r\nimport './Timeline.scss';\r\nimport Buffs from './Buffs';\r\nimport Casts from './Casts';\r\nimport Cooldowns from './Cooldowns';\r\n\r\nclass Timeline extends React.PureComponent {\r\n  static propTypes = {\r\n    abilities: PropTypes.instanceOf(Abilities).isRequired,\r\n    buffs: PropTypes.instanceOf(BuffsModule).isRequired,\r\n    parser: PropTypes.instanceOf(CombatLogParser).isRequired,\r\n  };\r\n  static defaultProps = {\r\n    showCooldowns: true,\r\n    showGlobalCooldownDuration: false,\r\n  };\r\n\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      zoom: 2,\r\n      padding: 0,\r\n    };\r\n    this.setContainerRef = this.setContainerRef.bind(this);\r\n  }\r\n\r\n  get fight() {\r\n    return this.props.parser.fight;\r\n  }\r\n  get start() {\r\n    return this.fight.start_time;\r\n  }\r\n  get end() {\r\n    return this.fight.end_time;\r\n  }\r\n  get offset() {\r\n    return this.fight.offset_time;\r\n  }\r\n  get duration() {\r\n    return this.end - this.start;\r\n  }\r\n  get seconds() {\r\n    return this.duration / 1000;\r\n  }\r\n  get secondWidth() {\r\n    return 120 / this.state.zoom;\r\n  }\r\n  get totalWidth() {\r\n    return this.seconds * this.secondWidth;\r\n  }\r\n\r\n  isApplicableEvent(event) {\r\n    switch (event.type) {\r\n      case EventType.FilterCooldownInfo:\r\n      case EventType.Cast:\r\n        return this.isApplicableCastEvent(event);\r\n      case EventType.UpdateSpellUsable:\r\n        return this.isApplicableUpdateSpellUsableEvent(event);\r\n      default:\r\n        return false;\r\n    }\r\n  }\r\n  isApplicableCastEvent(event) {\r\n    const parser = this.props.parser;\r\n\r\n    if (!parser.byPlayer(event)) {\r\n      // Ignore pet/boss casts\r\n      return false;\r\n    }\r\n    const spellId = event.ability.guid;\r\n    if (CASTS_THAT_ARENT_CASTS.includes(spellId)) {\r\n      return false;\r\n    }\r\n    const ability = this.props.abilities.getAbility(spellId);\r\n    if (!ability || !ability.cooldown) {\r\n      return false;\r\n    }\r\n    if(event.timestamp >= this.end){\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n  isApplicableUpdateSpellUsableEvent(event) {\r\n    if (event.trigger !== EventType.EndCooldown && event.trigger !== EventType.RestoreCharge) {\r\n      // begincooldown is unnecessary since endcooldown includes the start time\r\n      return false;\r\n    }\r\n    if(event.trigger === EventType.RestoreCharge && event.timestamp < this.start){\r\n      //ignore restore charge events if they happen before the phase\r\n      return false;\r\n    }\r\n    const spellId = event.ability.guid;\r\n    if (CASTS_THAT_ARENT_CASTS.includes(spellId)) {\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n  /**\r\n   * @param {object[]} events\r\n   * @returns {Map<int, object[]>} Events grouped by spell id.\r\n   */\r\n  getEventsBySpellId(events) {\r\n    const eventsBySpellId = new Map();\r\n    events.forEach(event => {\r\n      if (!this.isApplicableEvent(event)) {\r\n        return;\r\n      }\r\n\r\n      const spellId = this._getCanonicalId(event.ability.guid);\r\n      if (!eventsBySpellId.has(spellId)) {\r\n        eventsBySpellId.set(spellId, []);\r\n      }\r\n      eventsBySpellId.get(spellId).push(event);\r\n    });\r\n    return eventsBySpellId;\r\n  }\r\n\r\n  _getCanonicalId(spellId){\r\n    const ability = this.props.abilities.getAbility(spellId);\r\n    if (!ability) {\r\n      return spellId; // not a class ability\r\n    }\r\n    if (ability.spell instanceof Array) {\r\n      return ability.spell[0].id;\r\n    } else {\r\n      return ability.spell.id;\r\n    }\r\n  }\r\n\r\n  setContainerRef(elem) {\r\n    if (!elem || !elem.getBoundingClientRect) {\r\n      return;\r\n    }\r\n    this.setState({\r\n      padding: elem.getBoundingClientRect().x + 15, // 15 for padding\r\n    });\r\n  }\r\n\r\n  render() {\r\n    const { parser, abilities, buffs } = this.props;\r\n\r\n    const skipInterval = Math.ceil(40 / this.secondWidth);\r\n\r\n    const eventsBySpellId = this.getEventsBySpellId(parser.eventHistory);\r\n\r\n    return (\r\n      <>\r\n        <div className=\"container\" ref={this.setContainerRef} />\r\n        <DragScroll className=\"spell-timeline-container\">\r\n          <div\r\n            className=\"spell-timeline\"\r\n            style={{\r\n              width: this.totalWidth + this.state.padding * 2,\r\n              paddingTop: 0,\r\n              paddingBottom: 0,\r\n              paddingLeft: this.state.padding,\r\n              paddingRight: this.state.padding, // we also want the user to have the satisfying feeling of being able to get the right side to line up\r\n              margin: \"auto\", //center horizontally if it's too small to take up the page\r\n            }}\r\n          >\r\n            <Buffs\r\n              start={this.start}\r\n              secondWidth={this.secondWidth}\r\n              parser={parser}\r\n              buffs={buffs}\r\n            />\r\n            <div className=\"time-line\">\r\n              {this.seconds > 0 && [...Array(Math.ceil(this.seconds))].map((_, second) => (\r\n                <div\r\n                  key={second+this.offset/1000}\r\n                  style={{ width: this.secondWidth * skipInterval }}\r\n                  data-duration={formatDuration(second+this.offset/1000)}\r\n                />\r\n              ))}\r\n            </div>\r\n            <Casts\r\n              start={this.start}\r\n              secondWidth={this.secondWidth}\r\n              parser={parser}\r\n            />\r\n            <Cooldowns\r\n              start={this.start}\r\n              end={this.end}\r\n              secondWidth={this.secondWidth}\r\n              eventsBySpellId={eventsBySpellId}\r\n              abilities={abilities}\r\n            />\r\n          </div>\r\n        </DragScroll>\r\n      </>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Timeline;\r\n","import React from 'react';\r\nimport PropTypes from 'prop-types';\r\n\r\nimport Abilities from 'parser/core/modules/Abilities';\r\nimport Buffs from 'parser/core/modules/Buffs';\r\n// import SpellUsable from 'parser/shared/modules/SpellUsable';\r\n// import GlobalCooldown from 'parser/shared/modules/GlobalCooldown';\r\n\r\nimport Component from './Component';\r\n\r\nconst Container = props => {\r\n  const { parser } = props;\r\n\r\n  return (\r\n    <Component\r\n      parser={parser}\r\n      abilities={parser.getModule(Abilities)}\r\n      buffs={parser.getModule(Buffs)}\r\n      // isAbilityCooldownsAccurate={parser.getModule(SpellUsable).isAccurate}\r\n      // isGlobalCooldownAccurate={parser.getModule(GlobalCooldown).isAccurate}\r\n    />\r\n  );\r\n};\r\n\r\nContainer.propTypes = {\r\n  parser: PropTypes.shape({\r\n    fight: PropTypes.shape({\r\n      // replace with actual fight interface when converting to TS\r\n      // eslint-disable-next-line @typescript-eslint/camelcase\r\n      start_time: PropTypes.number.isRequired,\r\n      // eslint-disable-next-line @typescript-eslint/camelcase\r\n      end_time: PropTypes.number.isRequired,\r\n    }),\r\n    getModule: PropTypes.func.isRequired,\r\n  }).isRequired,\r\n};\r\n\r\nexport default Container;\r\n"],"sourceRoot":""}