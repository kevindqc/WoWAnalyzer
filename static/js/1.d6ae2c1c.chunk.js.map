{"version":3,"sources":["parser/core/modules/Ability.ts","parser/core/Enemy.ts","interface/report/Results/ThroughputPerformance.ts","parser/shared/modules/items/EnchantChecker.tsx","parser/shared/modules/items/FlaskChecker.ts","parser/shared/modules/items/FoodChecker.ts","parser/shared/modules/items/WeaponEnhancementChecker.tsx","parser/shared/modules/racials/dwarf/MightOfTheMountain.js","parser/core/Pet.ts","parser/shared/modules/Pets.ts","interface/icons/Link.js","interface/statistics/Statistic.tsx","interface/others/STATISTIC_ORDER.js","interface/others/StatisticBox.js","interface/ItemDamageDone/ItemDamageDone.tsx","parser/core/modules/Abilities.ts","parser/shared/modules/SpellUsable.ts","parser/shared/modules/AbilityTracker.ts","parser/shared/modules/Enemies.ts","parser/shared/modules/Combatants.ts","parser/hunter/shared/constants.tsx","parser/core/EnemyInstance.ts","parser/shared/modules/EnemyInstances.js","interface/ItemHealingDone/ItemHealingDone.tsx","game/HIT_TYPES.ts","interface/CastEfficiency/CastEfficiency.tsx","parser/shared/modules/CastEfficiency.tsx","parser/core/EventsNormalizer.ts","common/DEFENSIVE_BUFFS.js","parser/shared/modules/items/Potion.ts","parser/shared/modules/items/Healthstone.ts","interface/others/DeathRecap.js","interface/others/DeathRecapTracker.js","parser/shared/normalizers/ApplyBuff.ts","parser/shared/normalizers/CancelledCasts.ts","parser/shared/normalizers/PrePullCooldowns.js","parser/shared/normalizers/FightEnd.ts","parser/shared/normalizers/PhaseChanges.ts","parser/shared/normalizers/MissingCasts.ts","parser/shared/enhancers/SpellTimeWaitingOnGlobalCooldown.ts","parser/shared/modules/throughput/ThroughputStatisticGroup.tsx","parser/shared/modules/FilteredActiveTime.tsx","parser/shared/modules/AbilitiesMissing.js","parser/shared/modules/downtime/TotalDowntime.js","parser/shared/modules/DispelTracker.tsx","parser/shared/modules/features/RaidHealthTab/TabComponent/RaidHealthChart.js","parser/shared/modules/features/RaidHealthTab/TabComponent/Graph.js","parser/shared/modules/features/RaidHealthTab/TabComponent/index.js","parser/shared/modules/features/RaidHealthTab/index.js","parser/shared/modules/items/HealthPotion.ts","parser/shared/modules/items/CombatPotion.ts","parser/shared/modules/racials/draenei/GiftOfTheNaaru.ts","parser/shared/modules/racials/dwarf/Stoneform.js","parser/shared/modules/racials/troll/Berserking.js","parser/shared/modules/racials/orc/BloodFury.ts","interface/statistics/components/BoringItemValueText/index.tsx","parser/shared/modules/spells/VantusRune.js","parser/core/CombatLogParser.ts","parser/shared/modules/features/Checklist/PreparationRuleAnalyzer.js","interface/others/BaseChart.tsx","parser/shared/modules/AlwaysBeCasting.tsx","parser/hunter/marksmanship/constants.tsx","parser/shared/modules/throughput/HealingDone.tsx","parser/core/modules/Buff.js","parser/core/modules/Buffs.js","parser/shared/modules/Haste.js","game/BLOODLUST_BUFFS.ts","parser/shared/modules/GlobalCooldown.js","interface/statistics/Panel.js","parser/shared/modules/Channeling.js","parser/shared/modules/racials/bloodelf/ArcaneTorrent.ts","parser/shared/modules/ManaValues.js","parser/shared/modules/HealingValue.js","game/MAGIC_SCHOOLS.ts","parser/shared/modules/EventHistory.ts","parser/shared/modules/helpers/CritEffectBonus.js","parser/shared/modules/SpellResourceCost.js","parser/core/CASTS_THAT_ARENT_CASTS.ts","parser/shared/modules/throughput/DamageDone.tsx","interface/statistics/StatisticBar.js","parser/shared/modules/DeathTracker.tsx","interface/others/FlushLineChart.tsx","parser/shared/modules/DamageValue.js","parser/shared/modules/throughput/DamageTaken.tsx","parser/shared/modules/SpellManaCost.js","interface/icons/Info.js","common/getRankingColor.ts","parser/core/CASTABLE_WHILE_CASTING_SPELLS.ts","parser/shared/modules/SpellHistory.ts","parser/shared/modules/Entities.ts","interface/others/FooterChart.tsx","interface/statistics/StatisticGroup.js","parser/shared/modules/downtime/DeathDowntime.js","parser/shared/modules/others/DistanceMoved.tsx"],"names":["Ability","owner","options","spell","primaryOverride","_name","category","_cooldown","_channel","gcd","extraSuggestion","recommendedEfficiency","isDefensive","isUndetectable","castEfficiency","suggestion","undefined","averageIssueEfficiency","majorIssueEfficiency","casts","maxCasts","importance","charges","enabled","timelineSortIndex","buffSpellId","shownSpell","this","_setProps","haste","cooldownTriggerEvent","call","Array","primarySpell","name","value","getCooldown","current","props","Object","keys","forEach","prop","_setProp","propTypes","PropTypes","oneOfType","shape","id","number","isRequired","string","icon","arrayOf","cooldown","func","channel","static","base","minimum","bool","node","primaryCoefficient","healSpellIds","damageSpellIds","Enemy","baseInfo","_baseInfo","type","guid","Entity","TOTAL_SPECS","SPECS","count","UNAVAILABLE","ThroughputPerformance","state","performance","topThroughput","load","loadRankings","rankings","topRank","_getRank","setState","total","throughput","console","error","parser","context","fetchWcl","fight","boss","class","selectedCombatant","spec","ranking","difficulty","metric","cache","_getCacheKey","index","specIndex","specStaggerOffset","DAYS_PER_WEEK","specAdjustedNow","Date","getTime","onejan","getFullYear","staggeredWeek","Math","ceil","valueOf","getDay","process","desiredRank","children","React","PureComponent","contextTypes","object","AGI_SPECS","GUARDIAN_DRUID","FERAL_DRUID","BEAST_MASTERY_HUNTER","MARKSMANSHIP_HUNTER","ASSASSINATION_ROGUE","OUTLAW_ROGUE","SUBTLETY_ROGUE","ENHANCEMENT_SHAMAN","BREWMASTER_MONK","WINDWALKER_MONK","VENGEANCE_DEMON_HUNTER","HAVOC_DEMON_HUNTER","SURVIVAL_HUNTER","STR_SPECS","PROTECTION_PALADIN","PROTECTION_WARRIOR","BLOOD_DEATH_KNIGHT","RETRIBUTION_PALADIN","ARMS_WARRIOR","FURY_WARRIOR","FROST_DEATH_KNIGHT","UNHOLY_DEATH_KNIGHT","EnchantChecker","item","Boolean","permanentEnchant","MAX_ENCHANT_IDS","includes","when","gear","enchantableGear","enchantSlots","specId","AGI_ENCHANTABLE_SLOTS","STR_ENCHANTABLE_SLOTS","INT_ENCHANTABLE_SLOTS","slot","Number","slotName","hasEnchant","isFalse","addSuggestion","suggest","actual","recommended","quality","details","staticImportance","SUGGESTION_IMPORTANCE","MAJOR","noMaxEnchant","hasMaxEnchant","isTrue","MINOR","reduce","obj","_getGearItemBySlotId","length","filter","slotsMissingEnchant","slotsMissingMaxEnchant","Analyzer","4","7","10","11","14","15","16","9","8","MIN_ENCHANT_IDS","ITEMS","ENCHANT_RING_BARGAIN_OF_CRITICAL_STRIKE","effectId","ENCHANT_RING_BARGAIN_OF_HASTE","ENCHANT_RING_BARGAIN_OF_MASTERY","ENCHANT_RING_BARGAIN_OF_VERSATILITY","ENCHANT_CHEST_SACRED_STATS","ENCHANT_BRACERS_ILLUMINATED_SOUL","ENCHANT_GLOVES_STRENGTH_OF_SOUL","ENCHANT_BOOTS_AGILE_SOULWALKER","ENCHANT_RING_TENET_OF_CRITICAL_STRIKE","ENCHANT_RING_TENET_OF_HASTE","ENCHANT_RING_TENET_OF_MASTERY","ENCHANT_RING_TENET_OF_VERSATILITY","ENCHANT_CHEST_ETERNAL_STATS","ENCHANT_CHEST_ETERNAL_BOUNDS","ENCHANT_CHEST_ETERNAL_INSIGHT","ENCHANT_CHEST_ETERNAL_BULWARK","ENCHANT_CHEST_ETERNAL_SKIRMISH","ENCHANT_BRACERS_ETERNAL_INTELLECT","ENCHANT_GLOVES_ETERNAL_STRENGTH","ENCHANT_BOOTS_ETERNAL_AGILITY","ENCHANT_CLOAK_FORTIFIED_AVOIDANCE","ENCHANT_CLOAK_FORTIFIED_LEECH","ENCHANT_CLOAK_FORTIFIED_SPEED","ENCHANT_CLOAK_SOUL_VITALITY","ENCHANT_WEAPON_SINFUL_REVELATION","ENCHANT_WEAPON_ASCENDED_VIGOR","ENCHANT_WEAPON_CELESTIAL_GUIDANCE","ENCHANT_WEAPON_LIGHTLESS_FORCE","SPELLS","RUNE_OF_THE_FALLEN_CRUSADER","RUNE_OF_RAZORICE","RUNE_OF_THE_STONESKIN_GARGOYLE","RUNE_OF_HYSTERIA","RUNE_OF_SANGUINATION","RUNE_OF_APOCALYPSE","RUNE_OF_UNENDING_THIRST","RUNE_OF_SPELLWARDING","MIN_FLASK_IDS","GREATER_FLASK_OF_THE_CURRENTS","GREATER_FLASK_OF_ENDLESS_FATHOMS","GREATER_FLASK_OF_THE_UNDERTOW","GREATER_FLASK_OF_THE_VAST_HORIZON","MAX_FLASK_IDS","SPECTRAL_FLASK_OF_POWER","SPECTRAL_FLASK_OF_STAMINA","ETERNAL_FLASK","FlaskChecker","startFightWithFlaskUp","strongFlaskUsed","addEventListener","Events","applybuff","to","SELECTED_PLAYER","onApplybuff","bind","event","spellId","ability","prepull","flaskSuggestionThresholds","flaskStrengthSuggestion","isEqual","style","ThresholdStyle","BOOLEAN","LOWER_FOOD_IDS","FAMINE_EVALUATOR_AND_SNACK_TABLE_FEAST_AGI","FAMINE_EVALUATOR_AND_SNACK_TABLE_FEAST_INT","FAMINE_EVALUATOR_AND_SNACK_TABLE_FEAST_STR","FAMINE_EVALUATOR_AND_SNACK_TABLE_FEAST_STA","FRAGRANT_KAKAVIA","ABYSSAL_FRIED_RISSOLE","BIL_TONG","MECH_DOWELS_BIG_MECH","BAKED_PORT_TATO","MID_TIER_FOOD_IDS","SURPRISINGLY_PALATABLE_FEAST_INT","SURPRISINGLY_PALATABLE_FEAST_AGI","SURPRISINGLY_PALATABLE_FEAST_STR","PICKLED_MEAT_SMOOTHIE","BUTTERSCOTCH_MARINATED_RIBS","CINNAMON_BONEFISH_STEW","MEATY_APPLE_DUMPLINGS","SWEET_SILVERGILL_SAUSAGES","HIGHER_FOOD_IDS","FEAST_OF_GLUTTONOUS_HEDONISM_INT","FEAST_OF_GLUTTONOUS_HEDONISM_AGI","FEAST_OF_GLUTTONOUS_HEDONISM_STR","BANANA_BEEF_PUDDING","SPINEFIN_SOUFFLE_AND_FRIES","TENEBROUS_CROWN_ROAST_ASPIC","IRIDESCENT_RAVIOLI_WITH_APPLE_SAUCE","STEAK_A_LA_MODE","FoodChecker","lowerFoodUp","midTierFoodUp","higherFoodUp","suggestionText","higherFoodSuggestionThresholds","WeaponEnhancementChecker","temporaryEnchant","MAX_ENHANCEMENT_IDS","enhanceableWeapons","weaponSlots","WEAPON_SLOTS","hasEnhancement","REGULAR","hasMaxEnhancement","weaponsMissingEnhancement","weaponsMissingMaxEnhancement","SHADOWCORE_OIL","EMBALMERS_OIL","SHADED_SHARPENING_STONE","SHADED_WEIGHTSTONE","CRIT_EFFECT","MightOfTheMountain","args","damage","healing","active","race","RACES","Dwarf","critEffectBonus","hook","getCritEffectBonus","heal","by","onHeal","onDamage","abilities","constructor","abilitiesAffectedByHealingIncreases","hitType","HIT_TYPES","CRIT","abilitiesAffectedByDamageIncreases","targetIsFriendly","critEffectModifier","isApplicableHeal","amount","absorbed","overheal","rawContribution","getBonus","effectiveHealing","max","isApplicableDamage","role","ROLES","HEALER","DPS","MIGHT_OF_THE_MOUNTAIN","label","tooltip","formatItemDamageDone","formatItemHealingDone","dependencies","CritEffectBonus","Pet","Pets","pets","getEntityFromEvent","fromTarget","entityId","HasTarget","targetID","HasSource","sourceIsFriendly","sourceID","pet","playerPets","find","Entities","Icon","other","xmlns","viewBox","className","d","transform","Statistic","expanded","toggleExpansion","prevProps","drilldown","isAbsolute","Tooltip","content","href","target","rel","dropdown","onClick","wide","ultrawide","size","others","zIndex","renderDropdown","data-place","Info","renderDrilldown","defaultProps","CORE","offset","DEFAULT","OPTIONAL","UNIMPORTANT","StatisticBox","footer","position","height","marginTop","STATISTIC_CATEGORY","GENERAL","ItemDamageDone","approximate","src","alt","formatNumber","fightDuration","formatPercentage","getPercentageOfTotalDamageDone","Abilities","abilityTracker","activeAbilities","loadSpellbook","spellbook","map","push","some","findIndex","getAbility","round","Module","AbilityTracker","Haste","SPELL_CATEGORIES","ROTATIONAL","i18n","_","ROTATIONAL_AOE","COOLDOWNS","DEFENSIVE","SEMI_DEFENSIVE","OTHERS","UTILITY","HEALER_DAMAGING_SPELL","CONSUMABLE","HIDDEN","ABILITY_CLASS","INVALID_COOLDOWN_CONFIG_LAG_MARGIN","fullExplanation","spellName","SpellUsable","eventEmitter","_currentCooldowns","_errors","_lastTimestamp","any","onEvent","cast","onCast","prefiltercd","ChangeHaste","onChangehaste","fightend","onFightend","minutesElapsed","errorsPerMinute","canSpellId","_getCanonicalId","isOnCooldown","getMaxCharges","chargesOnCooldown","maxCharges","timestamp","currentTimestamp","Error","expectedEnd","start","expectedDuration","totalReductionTime","expectedCooldownDuration","getExpectedCooldownDuration","isAvailable","_triggerEvent","_makeEvent","EventType","AddCooldownCharge","remainingCooldown","cooldownRemaining","reductionInfo","endCooldown","beginCooldown","BeginCooldown","resetAllCharges","remainingCDR","EndCooldown","end","RestoreCharge","refreshCooldown","reduceCooldown","RefreshCooldown","reductionMs","extensionMS","trigger","UpdateSpellUsable","abilityIcon","chargesAvailable","timePassed","playerId","__fabricated","fabricateEvent","FilterCooldownInfo","_checkCooldownExpiry","originalExpectedDuration","progress","cooldownDurationWithCurrentHaste","newExpectedDuration","_calculateNewCooldownDuration","end_time","remainingDuration","sort","a","b","newDuration","EventEmitter","spellManaCost","Map","resourceCost","RESOURCE_TYPES","MANA","manaUsed","abilityInfo","get","damageHits","damageEffective","damageAbsorbed","damageCriticalHits","damageCriticalEffective","damageCriticalAbsorbed","healingHits","healingEffective","healingAbsorbed","healingOverheal","healingCriticalHits","healingCriticalEffective","healingCriticalAbsorbed","healingCriticalOverheal","set","SpellManaCost","DamageTracker","SELECTED_PLAYER_PET","Heal","Enemies","enemies","targetId","enemy","report","spellIds","events","getDebuffHistory","history","getEntities","values","getBuffHistory","buff","Combatants","players","_selected","combatantInfoEvents","combatantInfo","Combatant","combatant","hastedCooldown","baseCD","MIN_GCD","MAX_GCD","MS_BUFFER","ONE_SECOND_IN_MS","TIME_SPENT_DEAD_THRESHOLD","KILL_SHOT_EXECUTE_RANGE","BASELINE_TURTLE_CHEETAH_CD","MULTISHOT_BM","MULTISHOT_MM","DIRE_BEAST_HASTE_PERCENT","AMOC_TICK_RATE","AMOC_BASE_DURATION","BARRAGE_HITS_PER_CAST","BORN_TO_BE_WILD_AFFECTED_SPELLS","ASPECT_OF_THE_CHEETAH","ASPECT_OF_THE_TURTLE","ASPECT_OF_THE_EAGLE","MM_SV_CDR_PER_FOCUS","BM_CDR_PER_FOCUS","HUNTER_BASE_FOCUS_REGEN","HUNTER_BASE_FOCUS_MAX","RESOURCES_HUNTER_MINOR_THRESHOLD","RESOURCES_HUNTER_AVERAGE_THRESHOLD","RESOURCES_HUNTER_MAJOR_THRESHOLD","LIST_OF_FOCUS_SPENDERS_SHARED","REVIVE_PET","A_MURDER_OF_CROWS_TALENT","BARRAGE_TALENT","ARCANE_SHOT","NESINGWARY_FOCUS_GAIN_MULTIPLIER","ASPECT_OF_THE_WILD","TRUESHOT","COORDINATED_ASSAULT","RESONATING_ARROW_CRIT_INCREASE","WILD_MARK_DAMAGE_AMP","WILD_SPIRITS_BASELINE_DURATION","FLAYED_SHOT_RESET_CHANCE","ENFEEBLED_MARK_DAMAGE_INCREASE","NECROTIC_BARRAGE_DAMAGE_INCREASE","SPIRIT_ATTUNEMENT_DAMAGE_INCREASE","EMPOWERED_RELEASE_INCREASED_FLAYED_PROC_CHANCE","EMPOWERED_RELEASE_INCREASE_KS_DAMAGE","EnemyInstance","instanceID","_instanceID","encodeTargetString","instance","EnemyInstances","targetInstance","enemyId","ItemHealingDone","greaterThan","lessThan","getPercentageOfTotalHealingDone","MISS","NORMAL","ABSORB","BLOCKED_NORMAL","BLOCKED_CRIT","DODGE","PARRY","IMMUNE","CastEfficiency","categories","marginBottom","key","cpm","efficiency","canBeImproved","width","SpellLink","color","iconStyle","minWidth","toFixed","Infinity","floor","backgroundColor","paddingRight","minutes","ms","seconds","spellHistory","mainSpellId","historyBySpellId","completedRechargeTime","endingRechargeTime","recharges","castTimestamps","lastRechargeTimestamp","acc","start_time","Cast","beginCastTimestamp","BeginCast","castTime","getGcdValue","gcdReduction","cdInfo","getCooldownInfo","averagetimeSpentOnAbility","_getTimeSpentCasting","getGcd","abilityId","timeSpentCasting","gcdSpent","getTimeSpentOnGcd","timeWaitingOnGCD","getCastEfficiencyForAbility","includeNoCooldownEfficiency","rawMaxCasts","availableFightDuration","cooldownMs","_getTimeWaitingOnGCD","averageTimeSpentCasting","averageTimeWaitingOnGCD","averageCooldown","averagetimeSpentOnNoCooldownAbility","min","timeOnCd","lastCastTimestamp","timeOffset","timeUnavailable","gotMaxCasts","getCastEfficiency","mainSpell","suggestionThresholds","isLessThan","minor","average","major","PERCENTAGE","Panel","title","pad","SpellHistory","EventsNormalizer","i","CombatantInfo","DEFENSIVE_BUFFS","IRONBARK","LIFE_COCOON","BLESSING_OF_PROTECTION","BLESSING_OF_SACRIFICE","GUARDIAN_SPIRIT","PAIN_SUPPRESSION","POWER_WORD_BARRIER_BUFF","BONE_SHIELD","SHROUD_OF_PURGATORY","FRAILTY_SPIRIT_BOMB_DEBUFF","DEFENSIVE_STANCE_TALENT","RALLYING_CRY_BUFF","SPIRIT_WOLF_BUFF","Potion","buffs","spellUsable","lastDeathWithPotionReady","add","spells","ONE_HOUR_MS","extraAbilityInfo","buffIndex","triggeredBySpellId","spellIndex","death","onDeath","increaseMaxCasts","potionCasts","Buffs","Healthstone","combatants","Class","Warlock","HEALTHSTONE","DeathRecap","detailedView","amountThreshold","handleClick","filterDeath","clicked","offset_time","deathtime","applyTimeFilter","lastHitPoints","lastMaxHitPoints","sortByTimelineIndex","step","marks","0","0.05","0.1","0.15","0.2","0.25","0.3","0.35","0.4","0.45","0.5","margin","defaultValue","onChange","code","player","fontSize","WarcraftLogs","Fragment","display","padding","cursor","e","SHOW_SECONDS_BEFORE_DEATH","maxHitPoints","Instakill","eventIndex","hitPoints","hitPercent","percent","output","sourceName","source","_combatantInfo","Damage","overkill","formatDuration","time","opacity","buffsUp","SpellIcon","border","debuffsUp","defensiveCooldowns","cooldownReady","colSpan","DeathRecapTracker","deaths","healed","damaged","cooldowns","lastBuffs","instakill","onInstakill","buffsModule","activeBuffs","extendedEvent","cooldownsOnly","getBuff","debuff","isDebuff","addEvent","url","render","secondsBeforeDeath","open","healthstone","ApplyBuff","_combatantInfoEvents","_buffsAppliedByPlayerId","firstEventIndex","getFightStartIndex","firstStartTimestamp","HasAbility","sourceId","RemoveBuff","ApplyBuffStack","RemoveBuffStack","RefreshBuff","FilterBuffInfo","targetInfo","combatantInfoEvent","__fromCombatantinfo","auras","aura","splice","CancelledCasts","lastBeginCast","isCancelled","castEvent","markLastBeginCastCancelled","CASTS_THAT_ARENT_CASTS","CASTABLE_WHILE_CASTING_SPELLS","byPlayer","handleBeginCast","handleCast","PrePullCooldowns","buffSpells","damageSpells","addBuff","buffId","castId","damageIds","getApplicableSpells","prepullCasts","precastClassResources","fightStartTimestamp","firstTimestamp","_fabricateCastEvent","classResources","totalGCD","_resolveAbilityGcd","unshift","captureException","gcdProp","applyBuff","FightEnd","phaseEvents","PhaseStart","PhaseEnd","nonPhaseEvents","phaseEvent","MissingCasts","ctor","missingCastBuffs","SpellTimeWaitingOnGlobalCooldown","lastGlobalCooldown","handleUpdateSpellUsable","GlobalCooldown","handleGlobalCooldown","resetBufferMS","duration","earlyByMS","ThroughputStatisticGroup","damageDone","healingDone","damageTaken","StatisticGroup","large","subStatistic","DamageDone","HealingDone","DamageTaken","FilteredActiveTime","EndChannel","eventHistory","activeTime","lastGCD","filteredEvents","filterEvents","BeginChannel","getActiveTime","AbilitiesMissing","warn","EventSubscriber","TotalDowntime","deathDowntime","totalDowntime","totalBaseDowntime","DeathDowntime","DispelTracker","dispelEvents","dispelCount","blackList","WINDWALKING","dispel","onDispel","abilityDispelled","extraAbility","dispelledId","currentCount","replace","STATISTIC_ORDER","from","flex","textAlign","RaidHealthChart","disabled","togglePlayer","prevState","startTime","endTime","xValues","yValues","xAxis","field","axis","labelExpr","formatTime","deathSpec","data","mark","encoding","x","hpSpec","selection","fields","y","stack","condition","hp","concat","p","datum","layer","disableHeight","BaseChart","Component","CLASS_CHART_LINE_COLORS","DeathKnight","Druid","Hunter","Mage","Monk","Paladin","Priest","Rogue","Shaman","Warrior","DemonHunter","Graph","reportCode","abilityid","then","json","log","series","entities","newSeries","lastValue","secIntoFight","health","deathsBySecond","fightDurationSec","playerHealth","entries","borderColor","offsetTime","Mana","explanation","actorId","RaidHealthTab","TabComponent","HealthPotion","SPIRITUAL_HEALING_POTION","CombatPotion","POTION_OF_SPECTRAL_INTELLECT","POTION_OF_SPECTRAL_STRENGTH","POTION_OF_SPECTRAL_AGILITY","POTION_OF_SPECTRAL_STAMINA","POTION_OF_DEATHLY_FIXATION","POTION_OF_EMPOWERED_EXORCISMS","POTION_OF_PHANTOM_FIRE","POTION_OF_DIVINE_AWAKENING","POTION_OF_SACRIFICIAL_ANIMA","POTION_OF_HARDENED_SHADOWS","SPIRITUAL_MANA_POTION","SPIRITUAL_REJUVENATION_POTION","POTION_OF_SPIRITUAL_CLARITY","GiftOfTheNaaru","Draenei","GIFT_OF_THE_NAARU_DK","GIFT_OF_THE_NAARU_HUNTER","GIFT_OF_THE_NAARU_MONK","GIFT_OF_THE_NAARU_MAGE","GIFT_OF_THE_NAARU_PRIEST","GIFT_OF_THE_NAARU_PALADIN","GIFT_OF_THE_NAARU_SHAMAN","GIFT_OF_THE_NAARU_WARRIOR","Stoneform","damageReduced","physicalDamageTaken","onDamageTaken","MAGIC_SCHOOLS","ids","PHYSICAL","hasBuff","STONEFORM_BUFF","drps","Berserking","Troll","BERSERKING","BloodFury","Orc","BLOOD_FURY_PHYSICAL","BLOOD_FURY_SPELL_AND_PHYSICAL","BLOOD_FURY_SPELL","BoringItemValueText","ItemIcon","ItemLink","runes","VANTUS_RUNE_CASTLE_NATHRIA","VantusRune","activeRune","vantusRuneBuffId","match","rune","masterRune","statTracker","forceChangeStats","versatility","effective","StatTracker","CombatLogParser","selectedPlayer","selectedFight","characterProfile","build","builds","applyPhaseFilter","phase","disabledModules","adjustForDowntime","_modules","_timestamp","finished","_moduleCache","eventCount","friendlyPets","petOwner","findByBossId","ModuleError","initializeModules","internalModules","defaultModules","specModules","getModule","module","friendlies","selected","emitter","numTriggeredEvents","numEventListeners","numListenersCalled","numActualExecutions","config","moduleClass","availableDependencies","missingDependencies","desiredDependencyName","dependencyClass","dependencyModule","getOptionalModule","desiredModuleName","modules","iteration","failedModules","moduleConfig","_getModuleClass","_resolveDependencies","priority","loadModule","INITIALIZATION","DEPENDENCY","newBatch","join","allModulesInitialized","cacheEntry","activeModules","normalizer","normalize","eventFilter","listener","deps","depClass","deepDisable","absorbDone","precision","results","ParseResults","addStatistic","statistic","basePosition","statistics","cloneElement","generated","tabs","every","analyzer","statisticOrder","isArray","statisticIndex","tab","suggestions","RESULTS","fightEndNormalizer","FightEndNormalizer","applyBuffNormalizer","ApplyBuffNormalizer","cancelledCastsNormalizer","CancelledCastsNormalizer","prepullNormalizer","PrePullCooldownsNormalizer","phaseChangesNormalizer","PhaseChangesNormalizer","missingCastsNormalize","MissingCastsNormalizer","spellTimeWaitingOnGlobalCooldown","throughputStatisticGroup","deathTracker","DeathTracker","enemyInstances","channeling","Channeling","EventHistory","alwaysBeCasting","AlwaysBeCasting","filteredActiveTime","abilitiesMissing","globalCooldown","manaValues","ManaValues","vantusRune","distanceMoved","DistanceMoved","deathRecapTracker","dispels","raidHealthTab","potionChecker","PotionChecker","enchantChecker","flaskChecker","foodChecker","healthPotion","combatPotion","weaponEnhancementChecker","preparationRuleAnalyzer","PreparationRuleAnalyzer","arcaneTorrent","ArcaneTorrent","giftOfTheNaaru","mightOfTheMountain","stoneform","berserking","bloodFury","potionsUsed","maxPotions","NUMBER","bestPotionUsed","strongPotionsUsed","itemsEnchanted","numEnchantableGear","numSlotsMissingEnchant","itemsBestEnchanted","numSlotsMissingMaxEnchant","weaponsEnhanced","numWeapons","numWeaponsMissingEnhancement","bestWeaponEnhancements","numWeaponsMissingMaxEnhancement","higherFlaskPresent","flaskPresent","higherFoodPresent","foodPresent","isPresentFoodSuggestionThresholds","defaultConfig","autosize","contains","background","view","stroke","domainColor","labelColor","tickColor","prp","renderer","datasets","theme","actions","_lastGlobalCooldownDuration","showStatistic","onGCD","onEndChannel","activeTimePercentage","isOnGlobalCooldown","disableDowntimeStatistic","isAccurate","downtimePercentage","icons","downtime","downtimeSuggestionThresholds","isGreaterThan","regular","RAPID_FIRE_FOCUS_PER_TICK","AIMED_SHOT_BASELINE_CAST_TIME","AIMED_SHOT_FOCUS_COST","TRUESHOT_AIMED_SHOT_RECHARGE_INCREASE","TRUESHOT_RAPID_FIRE_RECHARGE_INCREASE","TRUESHOT_AIMED_SHOT_CAST_TIME_SPEED_UP","TRUESHOT_DURATION_BASELINE","TRUESHOT_FOCUS_INCREASE","MAX_LONE_WOLF_MODIFIER","LONE_WOLF_RAMP_INTERVAL_MS","LONE_WOLF_INCREASE_PER_RAMP","START_LONE_WOLF_MODIFIER","LONE_WOLF_AFFECTED_SPELLS","AUTO_SHOT","AIMED_SHOT","STEADY_SHOT","A_MURDER_OF_CROWS_DEBUFF","CHIMAERA_SHOT_MM_FROST_DAMAGE","CHIMAERA_SHOT_MM_NATURE_DAMAGE","BURSTING_SHOT","EXPLOSIVE_SHOT_DAMAGE","SERPENT_STING_TALENT","VOLLEY_DAMAGE","RAPID_FIRE","KILL_SHOT_MM_BM","PRECISE_SHOTS_ASSUMED_PROCS","PRECISE_SHOTS_MODIFIER","ARCANE_SHOT_MAX_TRAVEL_TIME","TRICK_SHOTS_BASELINE_DAMAGE","STEADY_SHOT_FOCUS_REGEN","STREAMLINE_RAPID_FIRE_DAMAGE_INCREASE","STREAMLINE_AIMED_SHOT_CAST_SPEED_UP","STEADY_FOCUS_HASTE_PERCENT","DEAD_EYE_AIMED_SHOT_RECHARGE_INCREASE","CTS_CDR_MS","CAREFUL_AIM_THRESHOLD","CA_MODIFIER","LNL_PROC_CHANCE","LNL_COST_MULTIPLIER","LETHAL_SHOTS_CHANCE","LETHAL_SHOTS_REDUCTION","SERPENT_STING_MM_BASE_DURATION","SERPENT_STING_MM_PANDEMIC","LIST_OF_FOCUS_SPENDERS_MM","EXPLOSIVE_SHOT_TALENT","BRUTAL_PROJECTILES_RAMP_DAMAGE","DEADLY_CHAIN_TRICKSHOTS_DAMAGE_INCREASE","POWERFUL_PRECISION_DAMAGE_INCREASE","SHARPSHOOTERS_FOCUS_INCREASE_TRUESHOT_DURATION","SURGING_SHOTS_DAMAGE_INCREASE","SURGING_SHOTS_RESET_CHANCE","EAGLETALONS_TRUE_FOCUS_COST_REDUCTION","SECRETS_UNBLINKING_PROC_CHANCE","_total","HealingValue","_healingByAbsorbs","bySecond","_byAbility","onAbsorbed","removebuff","onRemovebuff","_addHealing","_addHealingByAbsorb","absorb","secondsIntoFight","overhealing","perSecond","wclUrl","makeWclUrl","fightId","overflow","formatThousands","specName","rankingColor","disableWidth","Buff","timelineHighlight","loadBuffs","BLOODLUST_BUFFS","POWER_INFUSION","BUFF_CLASS","currentHastePercentage","_triggerChangeHaste","onApplyBuff","changebuffstack","onChangeBuffStack","onRemoveBuff","applydebuff","onApplyDebuff","changedebuffstack","onChangeDebuffStack","removedebuff","onRemoveDebuff","ChangeStats","onChangeStats","EventFilter","_applyActiveBuff","_changeBuffStack","_removeActiveBuff","delta","remainingHasteBuffs","removeHaste","hastePercentage","before","newHastePercentage","addHaste","after","_setHaste","hasteGain","_getBaseHasteGain","_applyHasteGain","_applyHasteLoss","hasteBuff","HASTE_BUFFS","_getHasteValue","_getHastePerStackGain","baseHaste","oldStacks","newStacks","hastePerStack","itemId","itemDetails","getItem","isNaN","oldHaste","newHaste","fabricatedEvent","hasteLoss","HOLY_AVENGER_TALENT","ICY_VEINS","IN_FOR_THE_KILL_TALENT_BUFF","METAMORPHOSIS_HAVOC_BUFF","DARK_SOUL_MISERY_TALENT","REVERSE_ENTROPY_BUFF","ENRAGE","FROTHING_BERSERKER","EMPOWER_RUNE_WEAPON","DIRE_BEAST_BUFF","STEADY_FOCUS_BUFF","CRUSADE_TALENT","OPULENCE_AMETHYST_OF_THE_SHADOW_KING","BLOODLUST","HEROISM","TIME_WARP","PRIMAL_RAGE_1","PRIMAL_RAGE_2","DRUMS_OF_FURY","DRUMS_OF_THE_MOUNTAIN","DRUMS_OF_RAGE","_currentChannel","onBeginChannel","onGlobalcooldown","getGlobalCooldownDuration","isOnGCD","triggerGlobalCooldown","isChannelingSameSpell","_resolveAbilityGcdField","baseGCD","minimumGCD","calculateGlobalCooldown","_verifyAccuracy","timeSince","formatMilliseconds","baseGcd","minGcd","PANELS","begincast","onBegincast","isChanneling","cancelChannel","channelingEvent","currentChannel","beginChannel","CancelChannel","isChannelingSpell","endChannel","BloodElf","ARCANE_TORRENT_MANA1","ARCANE_TORRENT_MANA2","ARCANE_TORRENT_MANA3","ARCANE_TORRENT_RAGE","ARCANE_TORRENT_ENERGY","ARCANE_TORRENT_RUNIC_POWER","ARCANE_TORRENT_MONK","ARCANE_TORRENT_FOCUS","ARCANE_TORRENT_FURY","lowestMana","endingMana","maxMana","manaUpdates","resource","cost","manaCost","currentMana","used","kill","manaLeftPercentage","_regular","_absorbed","_overheal","names","1","2","28","32","33","34","36","40","48","64","96","100","124","HOLY","FIRE","NATURE","FROST","SHADOW","ARCANE","maxTime","filterDef","minTime","prevFilter","ee","eventType","filterTo","getTo","toFilter","createToCheck","filterBy","getBy","byFilter","createByCheck","filterSpell","getSpell","spellFilter","createSpellCheck","slice","_hooks","BASE_CRIT_EFFECT_MOD","SpellResourceCost","resourceType","getResourceCost","rawResourceCost","getRawResourceCost","totalCost","getCostFromEventObject","MELEE","CHI_BURST_HEAL","REFRESHING_JADE_WIND_HEAL","SHADOWY_APPARITION","SHADOWY_APPARITION_CAST","PRIMAL_FURY","BLOW_DARKMOON_WHISTLE","DARKMOON_FIREWORK","BIG_RED_RAYS","FRACTURE_MAIN_HAND","FRACTURE_OFF_HAND","SOUL_FRAGMENT_KILLING_BLOW","MUTILATE_OFFHAND","DIVINE_HYMN_HEAL","CHARGE_2","CLOUDBURST_TOTEM_RECALL","SPIRITWALKERS_GRACE","CELESTIAL_GUIDANCE_CAST","SHADOWCORE_OIL_BLAST","SINFUL_REVELATION_PROC","BREATH_OF_SINDRAGOSA_TALENT_DAMAGE_TICK","RUNE_1","RUNE_2","RUNE_3","BARBED_SHOT_PET_BUFF","DIRE_BEAST_SUMMON","WILD_MARK","RESONATING_ARROW_DEBUFF","RESONATING_ARROW_DAMAGE","RUNE_OF_POWER_BUFF","COMBAT_MEDITATION_TRIGGER","COMBAT_MEDITATION_PICK_UP","DamageValue","_byPet","onByPlayerDamage","onByPlayerPetDamage","petId","blocked","byPet","parseInt","damageValue","StatisticBar","resurrections","lastDeathTimestamp","lastResurrectionTimestamp","_timeDead","_didCast","isAlive","resurrect","onResurrect","onBeginCast","onHealTaken","die","disableDeathSuggestion","isWipeDeath","totalTimeDead","timeDeadPercent","makeAnalyzerUrl","deathSuggestionThresholds","FlushLineChart","line","strokeWidth","calculate","as","impute","keyvals","stop","apply","method","window","op","order","frame","scale","nice","left","top","right","bottom","largestHit","_largestHit","_blocked","_overkill","IGNORED_ABILITIES","SPIRIT_LINK_TOTEM_REDISTRIBUTE","_byMagicSchool","onToPlayerDamage","magicSchool","_addDamage","physical","magical","incorrectCosts","hardcodedCost","getHardcodedManaCost","actualCost","INNERVATE","incorrectCostCount","percentage","FIRE_BLAST","SHIMMER_TALENT","ICE_FLOES_TALENT","COMBUSTION","SEARING_NIGHTMARE_TALENT","append","primarySpellUd","removeBuff","applybuffstack","updateBuffStack","applydebuffstack","removebuffstack","removedebuffstack","toPlayer","byPlayerPet","toPlayerPet","entity","getEntity","ApplyDebuff","stacks","_triggerChangeBuffStack","existingBuff","stackHistory","RemoveDebuff","ChangeDebuffStack","ChangeBuffStack","stacksGained","uptime","FooterChart","default_data","_lastDeathTimestamp","_isAlive","_deathHistory","resurrectionTimestamp","until","lastPosition","lastPositionChange","totalDistanceMoved","timeSpentMoving","updatePlayerPosition","energize","x1","y1","x2","y2","sqrt","newData","calculateDistance","updatedPosition","updateTotalDistance","marginLeft"],"mappings":"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","file":"static/js/1.d6ae2c1c.chunk.js","sourcesContent":["import CombatLogParser from 'parser/core/CombatLogParser';\r\nimport ISSUE_IMPORTANCE from 'parser/core/ISSUE_IMPORTANCE';\r\nimport Combatant from 'parser/core/Combatant';\r\n\r\nimport { TrackedAbility } from 'parser/shared/modules/AbilityTracker';\r\n\r\nimport Spell from 'common/SPELLS/Spell';\r\n\r\nimport React from 'react';\r\nimport PropTypes from 'prop-types';\r\n\r\n\r\nimport { AnyEvent } from '../Events';\r\nimport Abilities from './Abilities';\r\n\r\nexport interface SpellbookAbility<TrackedAbilityType extends TrackedAbility = TrackedAbility> {\r\n  /**\r\n   * REQUIRED The spell definition. If an array of spell definitions is\r\n   * provided, the first element in the array will be what shows in suggestions\r\n   * / cast timeline. Multiple spell definitions in the same ability can be\r\n   * used to tie multiple cast / buff IDs together as the same ability (with a\r\n   * shared cooldown)\r\n   */\r\n  spell: Spell | Spell[];\r\n  /**\r\n   * The name to use if it is different from the name provided by the `spell`\r\n   * object. This should only be used in rare situations.\r\n   */\r\n  name?: string;\r\n  /**\r\n   * REQUIRED The name of the category to place this spell in, you should\r\n   * usually use the SPELL_CATEGORIES enum for these values.\r\n   */\r\n  category: string;\r\n  /**\r\n   * The cooldown of a spell at the time of the cast, this can be a function\r\n   * for more complicated calls or even to check for buffs. Parameters\r\n   * provided: `hastePercentage`, `selectedCombatant`\r\n   */\r\n  cooldown?: ((haste: number, trigger?: AnyEvent) => number) | number;\r\n  /**\r\n   * NYI, do not use\r\n   */\r\n  channel?: ((haste: number) => number) | number;\r\n  /**\r\n   * The amount of charges the spell has by default. Reminder: only 1 charge\r\n   * will recharge at a time, so a spell having multiple charges will only have\r\n   * the amount of charges as extra possible casts during a fight.\r\n   */\r\n  charges?: number;\r\n  /**\r\n   * `null` is the spell is off the GCD, or an object if the spell is on the\r\n   * GCD. If this spell overlaps in the Spell Timeline it likely is incorrectly\r\n   * marked as on the GCD and should be removed.\r\n   */\r\n  gcd?:\r\n    | {\r\n        static?: number | ((combatant: Combatant) => number);\r\n        base?: number | ((combatant: Combatant) => number);\r\n        minimum?: number | ((combatant: Combatant) => number);\r\n      }\r\n    | ((combatant: Combatant) => number)\r\n    | null;\r\n  castEfficiency?: {\r\n    name?: string;\r\n    /**\r\n     * If this is set to `true`, this spell will trigger a Cast Efficiency\r\n     * suggestion when the efficiency is below the set threshold (with one of\r\n     * the props below, or the default 80%).\r\n     */\r\n    suggestion?: boolean;\r\n    /**\r\n     * The custom recommended cast efficiency. Default is 80% (0.8).\r\n     */\r\n    recommendedEfficiency?: number;\r\n    averageIssueEfficiency?: number;\r\n    majorIssueEfficiency?: number;\r\n    /**\r\n     * Extra suggestion text for after the Cast Efficiency suggestion. Use this\r\n     * for example to give the user a reason why.\r\n     */\r\n    extraSuggestion?: React.ReactNode;\r\n    /**\r\n     * A function to get the amount of casts done of a spell.\r\n     * @deprecated Usage should be avoided. This may be removed in the future.\r\n     */\r\n    casts?: (\r\n      castCount: TrackedAbilityType,\r\n      parser: CombatLogParser,\r\n    ) => number;\r\n    /**\r\n     * A function to get the max amount of casts for a spell.\r\n     * @deprecated Usage should be avoided. This may be removed in the future.\r\n     */\r\n    maxCasts?: (cooldown: number) => number;\r\n    /**\r\n     * If set, this suggestion will get this static importance value. Use this\r\n     * ISSUE_IMPORTANCE enum for this.\r\n     */\r\n    importance?: ISSUE_IMPORTANCE;\r\n  };\r\n  /**\r\n   * Whether the spell is enabled (available to the player) and should be\r\n   * displayed. This should only be used for hiding spells that are\r\n   * unavailable, for example due to talents.\r\n   */\r\n  enabled?: boolean;\r\n\r\n  /**\r\n   * The ability's priority on the timeline. The lower the number the higher on\r\n   * the timeline it will be displayed.\r\n   */\r\n  timelineSortIndex?: number;\r\n  /**\r\n   * DEPRECATED. Use the Buffs module to define your buffs instead. If your\r\n   * spec has no Buffs module, this prop will be used to prefill it.\r\n   *\r\n   * The buff(s) belonging to the ability. Setting this will display the buff\r\n   * on the timeline.\r\n   */\r\n  buffSpellId?: number | number[];\r\n  /**\r\n   * A boolean to indicate the spell is a defensive.\r\n   */\r\n  isDefensive?: boolean;\r\n  /**\r\n   * A boolean to indicate it can not be detected whether the player his this\r\n   * spells. This makes it so the spell is hidden when there are 0 casts in the\r\n   * fight. This should only be used for spells that can't be detected if a\r\n   * player has access to them, like racials.\r\n   */\r\n  isUndetectable?: boolean;\r\n  /**\r\n   * The ability's primary coefficient for calculating its damage or healing\r\n   * from the player's attackpower or spellpower.\r\n   */\r\n  primaryCoefficient?: number;\r\n  /**\r\n   * An array of healing effects that this spell cast causes.\r\n   */\r\n  healSpellIds?: number[];\r\n  /**\r\n   * An array of damage spell ids that this spell cast causes.\r\n   */\r\n  damageSpellIds?: number[];\r\n  /**\r\n   * The spell that'll forcibly shown on the timeline if set.\r\n   */\r\n  shownSpell?: Spell;\r\n}\r\n\r\nclass Ability {\r\n  static propTypes: { [key: string]: any } = {\r\n    /**\r\n     * REQUIRED The spell definition. If an array of spell definitions is\r\n     * provided, the first element in the array will be what shows in\r\n     * suggestions / cast timeline. Multiple spell definitions in the same\r\n     * ability can be used to tie multiple cast / buff IDs together as the same\r\n     * ability (with a shared cooldown)\r\n     */\r\n    spell: PropTypes.oneOfType([\r\n      PropTypes.shape({\r\n        id: PropTypes.number.isRequired,\r\n        name: PropTypes.string.isRequired,\r\n        icon: PropTypes.string.isRequired,\r\n      }),\r\n      PropTypes.arrayOf(\r\n        PropTypes.shape({\r\n          id: PropTypes.number.isRequired,\r\n          name: PropTypes.string.isRequired,\r\n          icon: PropTypes.string.isRequired,\r\n        }),\r\n      ),\r\n    ]).isRequired,\r\n    /**\r\n     * The name to use if it is different from the name provided by the `spell`\r\n     * object. This should only be used in rare situations.\r\n     */\r\n    name: PropTypes.string,\r\n    /**\r\n     * REQUIRED The name of the category to place this spell in, you should\r\n     * usually use the SPELL_CATEGORIES enum for these values.\r\n     */\r\n    category: PropTypes.string.isRequired,\r\n    /**\r\n     * The cooldown of a spell at the time of the cast, this can be a function\r\n     * for more complicated calls or even to check for buffs. Parameters\r\n     * provided: `hastePercentage`, `selectedCombatant`\r\n     */\r\n    cooldown: PropTypes.oneOfType([PropTypes.func, PropTypes.number]),\r\n    /**\r\n     * NYI, do not use\r\n     */\r\n    channel: PropTypes.oneOfType([PropTypes.func, PropTypes.number]),\r\n    /**\r\n     * The amount of charges the spell has by default. Reminder: only 1 charge\r\n     * will recharge at a time, so a spell having multiple charges will only\r\n     * have the amount of charges as extra possible casts during a fight.\r\n     */\r\n    charges: PropTypes.number,\r\n    /**\r\n     * `null` is the spell is off the GCD, or an object if the spell is on the\r\n     * GCD. If this spell overlaps in the Spell Timeline it likes is\r\n     * incorrectly marked as on the GCD and should be removed.\r\n     */\r\n    gcd: PropTypes.oneOfType([\r\n      PropTypes.func,\r\n      PropTypes.shape({\r\n        static: PropTypes.oneOfType([PropTypes.number, PropTypes.func]),\r\n        base: PropTypes.oneOfType([PropTypes.number, PropTypes.func]),\r\n        minimum: PropTypes.oneOfType([PropTypes.number, PropTypes.func]),\r\n      }),\r\n    ]),\r\n    castEfficiency: PropTypes.shape({\r\n      /**\r\n       * If this is set to `true`, this spell will trigger a Cast Efficiency\r\n       * suggestion when the efficiency is below the set threshold (with one of\r\n       * the props below, or the default 80%).\r\n       */\r\n      suggestion: PropTypes.bool,\r\n      /**\r\n       * The custom recommended cast efficiency. Default is 80% (0.8).\r\n       */\r\n      recommendedEfficiency: PropTypes.number,\r\n      averageIssueEfficiency: PropTypes.number,\r\n      majorIssueEfficiency: PropTypes.number,\r\n      /**\r\n       * Extra suggestion text for after the Cast Efficiency suggestion. Use\r\n       * this for example to give the user a reason why.\r\n       */\r\n      extraSuggestion: PropTypes.node,\r\n      /**\r\n       * A function to get the amount of casts done of a spell. Parameters\r\n       * provided: `castCount`, `parser`\r\n       * @deprecated Usage should be avoided. This may be removed in the\r\n       *   future.\r\n       */\r\n      casts: PropTypes.func,\r\n      /**\r\n       * A function to get the max amount of casts for a spell. Parameters\r\n       * provided: `cooldown`, `fightDuration`, `getAbility`, `parser`\r\n       * @deprecated Usage should be avoided. This may be removed in the\r\n       *   future.\r\n       */\r\n      maxCasts: PropTypes.func,\r\n      /**\r\n       * If set, this suggestion will get this static importance value. Use\r\n       * this ISSUE_IMPORTANCE enum for this.\r\n       */\r\n      importance: PropTypes.string,\r\n    }),\r\n    /**\r\n     * Whether the spell is enabled (available to the player) and should be\r\n     * displayed. This should only be used for hiding spells that are\r\n     * unavailable, for example due to talents.\r\n     */\r\n    enabled: PropTypes.bool,\r\n\r\n    /**\r\n     * The ability's priority on the timeline. The lower the number the higher\r\n     * on the timeline it will be displayed.\r\n     */\r\n    timelineSortIndex: PropTypes.number,\r\n    /**\r\n     * DEPRECATED. Use the Buffs module to define your buffs instead. If your\r\n     * spec has no Buffs module, this prop will be used to prefill it.\r\n     *\r\n     * The buff(s) belonging to the ability. Setting this will display the buff\r\n     * on the timeline.\r\n     */\r\n    buffSpellId: PropTypes.oneOfType([\r\n      PropTypes.number,\r\n      PropTypes.arrayOf(PropTypes.number),\r\n    ]),\r\n    /**\r\n     * A boolean to indicate the spell is a defensive.\r\n     */\r\n    isDefensive: PropTypes.bool,\r\n    /**\r\n     * A boolean to indicate it can not be detected whether the player his this\r\n     * spells. This makes it so the spell is hidden when there are 0 casts in\r\n     * the fight. This should only be used for spells that can't be detected if\r\n     * a player has access to them, like racials.\r\n     */\r\n    isUndetectable: PropTypes.bool,\r\n    /**\r\n     * The ability's primary coefficient for calculating its damage or healing\r\n     * from the player's attackpower or spellpower.\r\n     */\r\n    primaryCoefficient: PropTypes.number,\r\n    /**\r\n     * An array of healing effects that this spell cast causes.\r\n     */\r\n    healSpellIds: PropTypes.arrayOf(PropTypes.number),\r\n    /**\r\n     * An array of damage spell ids that this spell cast causes.\r\n     */\r\n    damageSpellIds: PropTypes.arrayOf(PropTypes.number),\r\n    /**\r\n     * The spell that'll forcibly shown on the timeline if set.\r\n     */\r\n    shownSpell: PropTypes.shape({\r\n      id: PropTypes.number.isRequired,\r\n      name: PropTypes.string.isRequired,\r\n      icon: PropTypes.string.isRequired,\r\n    }),\r\n  };\r\n\r\n  private readonly owner: Abilities;\r\n\r\n  spell!: SpellbookAbility['spell'];\r\n  primaryOverride: number | undefined;\r\n  get primarySpell() {\r\n    if (this.spell instanceof Array) {\r\n      return this.spell[this.primaryOverride || 0];\r\n    } else {\r\n      return this.spell;\r\n    }\r\n  }\r\n  // region name\r\n  _name: SpellbookAbility['name'];\r\n  get name() {\r\n    if (this._name) {\r\n      return this._name;\r\n    }\r\n    return this.primarySpell.name;\r\n  }\r\n  set name(value) {\r\n    this._name = value;\r\n  }\r\n  // endregion\r\n  category = null;\r\n  // region cooldown\r\n  _cooldown: SpellbookAbility['cooldown'];\r\n  /** @param {func|number|undefined} value */\r\n  set cooldown(value) {\r\n    this._cooldown = value;\r\n  }\r\n  /** @return {number} */\r\n  get cooldown() {\r\n    return this.getCooldown(this.owner.haste.current);\r\n  }\r\n  getCooldown(haste: number, cooldownTriggerEvent?: AnyEvent) {\r\n    if (this._cooldown === undefined) {\r\n      // Most abilities will always be active and don't provide this prop at all\r\n      return 0;\r\n    }\r\n    if (typeof this._cooldown === 'function') {\r\n      return this._cooldown.call(null, haste, cooldownTriggerEvent);\r\n    }\r\n\r\n    return this._cooldown;\r\n  }\r\n  // endregion\r\n  // region channel\r\n  _channel: SpellbookAbility['channel'];\r\n  /** @param {func|number|undefined} value */\r\n  set channel(value) {\r\n    this._channel = value;\r\n  }\r\n  /** @return {number} */\r\n  get channel() {\r\n    if (this._channel === undefined) {\r\n      // Most abilities will always be active and don't provide this prop at all\r\n      return 0;\r\n    }\r\n    if (typeof this._channel === 'function') {\r\n      return this._channel.call(this.owner, this.owner.haste.current);\r\n    }\r\n\r\n    return this._channel;\r\n  }\r\n  // endregion\r\n  gcd: SpellbookAbility['gcd'];\r\n  extraSuggestion = null;\r\n  recommendedEfficiency = null;\r\n  isDefensive = null;\r\n  isUndetectable = null;\r\n  castEfficiency: NonNullable<SpellbookAbility['castEfficiency']> = {\r\n    suggestion: false,\r\n    recommendedEfficiency: undefined,\r\n    averageIssueEfficiency: undefined,\r\n    majorIssueEfficiency: undefined,\r\n    extraSuggestion: undefined,\r\n    casts: undefined,\r\n    maxCasts: undefined,\r\n    importance: undefined,\r\n  };\r\n  charges = 1;\r\n  enabled = true;\r\n  timelineSortIndex: number | null = null;\r\n  /** @deprecated Use the Buffs module to define your buffs instead. If your spec has no Buffs module, this prop will be used to prefill it. */\r\n  buffSpellId: number | number[] | null = null;\r\n  shownSpell = null;\r\n\r\n  /**\r\n   * When extending this class you MUST copy-paste this function into the new\r\n   * class. Otherwise your new props will not be set properly.\r\n   * @param owner\r\n   * @param options\r\n   */\r\n  constructor(owner: Abilities, options: SpellbookAbility) {\r\n    this.owner = owner;\r\n    this._setProps(options);\r\n  }\r\n\r\n  _setProps(props: SpellbookAbility) {\r\n    if (process.env.NODE_ENV === 'development') {\r\n      /**\r\n       * We verify the sanity of the abilities props to avoid mistakes. First\r\n       * we check the types by reusing React's PropTypes which prints to your\r\n       * console, and next we verify if all the props of the abilities exist in\r\n       * the possible proptypes. If not they're likely mislocated.\r\n       */\r\n      PropTypes.checkPropTypes(\r\n        // eslint-disable-next-line react/forbid-foreign-prop-types\r\n        (this.constructor as typeof Ability).propTypes,\r\n        props,\r\n        'prop',\r\n        'Ability',\r\n      );\r\n      Object.keys(props).forEach(prop => {\r\n        if (\r\n          // eslint-disable-next-line react/forbid-foreign-prop-types\r\n          (this.constructor as typeof Ability).propTypes[prop] === undefined\r\n        ) {\r\n          console.log(prop);\r\n          throw new Error(\r\n            `Property not recognized in Abilities: ${prop} seems misplaced in ${JSON.stringify(\r\n              props.spell,\r\n            )}`,\r\n          );\r\n        }\r\n      });\r\n    }\r\n    Object.keys(props).forEach(prop => {\r\n      // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\r\n      // @ts-ignore\r\n      this._setProp(prop, props[prop]);\r\n    });\r\n  }\r\n  _setProp(prop: string, value: any) {\r\n    // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\r\n    // @ts-ignore\r\n    this[prop] = value;\r\n  }\r\n}\r\n\r\nexport default Ability;\r\n","import CombatLogParser from './CombatLogParser';\r\nimport Entity from './Entity';\r\n\r\nexport interface EnemyInfo {\r\n  name: string;\r\n  type: string;\r\n  guid: string;\r\n  id: number;\r\n}\r\n\r\nclass Enemy extends Entity {\r\n  get name() {\r\n    return this._baseInfo.name;\r\n  }\r\n\r\n  get type() {\r\n    return this._baseInfo.type;\r\n  }\r\n\r\n  get guid() {\r\n    return this._baseInfo.guid;\r\n  }\r\n\r\n  get id() {\r\n    return this._baseInfo.id;\r\n  }\r\n\r\n  _baseInfo: EnemyInfo;\r\n\r\n  constructor(owner: CombatLogParser, baseInfo: EnemyInfo) {\r\n    super(owner);\r\n    this._baseInfo = baseInfo;\r\n  }\r\n}\r\n\r\nexport default Enemy;\r\n","import React, { ReactNode } from 'react';\r\nimport PropTypes from 'prop-types';\r\n\r\nimport SPECS from 'game/SPECS';\r\nimport fetchWcl from 'common/fetchWclApi';\r\nimport { WCLRanking, WCLRankingsResponse } from 'common/WCL_TYPES';\r\n\r\nconst DAYS_PER_WEEK = 7;\r\nconst SECONDS_PER_DAY = 86400;\r\nconst TOTAL_SPECS = SPECS.count;\r\nexport const UNAVAILABLE = -1;\r\n\r\ninterface Props {\r\n  children: (state: State) => ReactNode;\r\n  metric: string;\r\n  throughput: number;\r\n}\r\n\r\ninterface State {\r\n  performance: number | null;\r\n  topThroughput: number | null;\r\n}\r\n\r\nclass ThroughputPerformance extends React.PureComponent<Props, State> {\r\n  static contextTypes = {\r\n    parser: PropTypes.object.isRequired, // unable to use instanceof CombatLogParser as that would cause a circular import\r\n  };\r\n\r\n  constructor(props: Props) {\r\n    super(props);\r\n    this.state = {\r\n      performance: null,\r\n      topThroughput: null,\r\n    };\r\n  }\r\n  componentDidMount() {\r\n    this.load();\r\n  }\r\n\r\n  async load() {\r\n    try {\r\n      if (process.env.NODE_ENV === 'test') {\r\n        // Skip during tests since we can't do WCL calls\r\n        return;\r\n      }\r\n      const { rankings } = await this.loadRankings();\r\n      // We want the 100th rank to give people a reasonable and easy to grasp goal to aim for.\r\n      const topRank = this._getRank(rankings, 100);\r\n      if (!topRank) {\r\n        this.setState({\r\n          performance: UNAVAILABLE,\r\n          topThroughput: UNAVAILABLE,\r\n        });\r\n        return;\r\n      }\r\n      const topThroughput = topRank.total;\r\n      this.setState({\r\n        // If the player is in the top 100, this may be >=100%.\r\n        performance: this.props.throughput && (this.props.throughput / topThroughput),\r\n        topThroughput,\r\n      });\r\n    } catch (err) {\r\n      console.error('Failed to load encounter rankings. Not logging since this will happen as expected when WCL partitions the data.', err);\r\n      this.setState({\r\n        performance: UNAVAILABLE,\r\n        topThroughput: UNAVAILABLE,\r\n      });\r\n    }\r\n  }\r\n  async loadRankings() {\r\n    const parser = this.context.parser;\r\n\r\n    // TODO: Move this to a method that can be shared with the EncounterStats component\r\n    return fetchWcl<WCLRankingsResponse>(`rankings/encounter/${parser.fight.boss}`, {\r\n      class: parser.selectedCombatant.spec.ranking.class,\r\n      spec: parser.selectedCombatant.spec.ranking.spec,\r\n      difficulty: parser.fight.difficulty,\r\n      metric: this.props.metric,\r\n      // hehe jk this is actually the opposite of a cache key since without this it would be cached indefinitely. This is more like a \"cache bust key\" in that this changes weekly so that it auto-refreshes weekly. Super clever.\r\n      cache: this._getCacheKey(parser.selectedCombatant.spec.index),\r\n    });\r\n  }\r\n  _getCacheKey(specIndex: number) {\r\n    // We want to cache data for 1 week. To avoid refreshing all specs at at the same time, we also want to stagger the requests.\r\n    // We achieve this by adding a static amount of time to `now` based on the spec index (0-35).\r\n    const specStaggerOffset = (DAYS_PER_WEEK * SECONDS_PER_DAY * specIndex / TOTAL_SPECS);\r\n    // We mutate now so that if there's a year crossover it will properly go to week 1 instead of 53/54\r\n    const specAdjustedNow = new Date((new Date()).getTime() + (specStaggerOffset * 1000));\r\n    // We need this to calculate the amount of weeks difference\r\n    const onejan = new Date(specAdjustedNow.getFullYear(), 0, 1);\r\n    // Calculate the current week number\r\n    const staggeredWeek = Math.ceil((((specAdjustedNow.valueOf() - onejan.valueOf()) / SECONDS_PER_DAY / 1000) + onejan.getDay() + 1) / DAYS_PER_WEEK);\r\n    return `${staggeredWeek}-${process.env.REACT_APP_CURRENT_GAME_PATCH}`; // current calendar-week\r\n  }\r\n  _getRank(rankings: WCLRanking[], desiredRank: number) {\r\n    return rankings[desiredRank - 1];\r\n  }\r\n\r\n  render() {\r\n    const { children } = this.props;\r\n\r\n    return children(this.state);\r\n  }\r\n}\r\n\r\nexport default ThroughputPerformance;\r\n","\r\nimport ItemLink from 'common/ItemLink';\r\nimport ITEMS from 'common/ITEMS';\r\nimport SPECS from 'game/SPECS';\r\n\r\nimport Analyzer from 'parser/core/Analyzer';\r\nimport SUGGESTION_IMPORTANCE from 'parser/core/ISSUE_IMPORTANCE';\r\nimport { When } from 'parser/core/ParseResults';\r\nimport { Item } from 'parser/core/Events';\r\n\r\nimport React from 'react';\r\nimport { Trans } from '@lingui/macro';\r\nimport SPELLS from 'common/SPELLS';\r\n\r\n// Example logs with missing enchants:\r\n// https://www.warcraftlogs.com/reports/ydxavfGq1mBrM9Vc/#fight=1&source=14\r\n\r\nconst AGI_SPECS = [\r\n  SPECS.GUARDIAN_DRUID.id,\r\n  SPECS.FERAL_DRUID.id,\r\n  SPECS.BEAST_MASTERY_HUNTER.id,\r\n  SPECS.MARKSMANSHIP_HUNTER.id,\r\n  SPECS.ASSASSINATION_ROGUE.id,\r\n  SPECS.OUTLAW_ROGUE.id,\r\n  SPECS.SUBTLETY_ROGUE.id,\r\n  SPECS.ENHANCEMENT_SHAMAN.id,\r\n  SPECS.BREWMASTER_MONK.id,\r\n  SPECS.WINDWALKER_MONK.id,\r\n  SPECS.VENGEANCE_DEMON_HUNTER.id,\r\n  SPECS.HAVOC_DEMON_HUNTER.id,\r\n  SPECS.SURVIVAL_HUNTER.id,\r\n];\r\n\r\nconst STR_SPECS = [\r\n  SPECS.PROTECTION_PALADIN.id,\r\n  SPECS.PROTECTION_WARRIOR.id,\r\n  SPECS.BLOOD_DEATH_KNIGHT.id,\r\n  SPECS.RETRIBUTION_PALADIN.id,\r\n  SPECS.ARMS_WARRIOR.id,\r\n  SPECS.FURY_WARRIOR.id,\r\n  SPECS.FROST_DEATH_KNIGHT.id,\r\n  SPECS.UNHOLY_DEATH_KNIGHT.id,\r\n];\r\n\r\nclass EnchantChecker extends Analyzer {\r\n\r\n  static AGI_ENCHANTABLE_SLOTS = {\r\n    4: <Trans id=\"common.slots.chest\">Chest</Trans>,\r\n    7: <Trans id=\"common.slots.boots\">Boots</Trans>,\r\n    10: <Trans id=\"common.slots.ring\">Ring</Trans>,\r\n    11: <Trans id=\"common.slots.ring\">Ring</Trans>,\r\n    14: <Trans id=\"common.slots.cloak\">Cloak</Trans>,\r\n    15: <Trans id=\"common.slots.weapon\">Weapon</Trans>,\r\n    16: <Trans id=\"common.slots.offhand\">OffHand</Trans>,\r\n  };\r\n\r\n  static STR_ENCHANTABLE_SLOTS = {\r\n    4: <Trans id=\"common.slots.chest\">Chest</Trans>,\r\n    9: <Trans id=\"common.slots.gloves\">Gloves</Trans>,\r\n    10: <Trans id=\"common.slots.ring\">Ring</Trans>,\r\n    11: <Trans id=\"common.slots.ring\">Ring</Trans>,\r\n    14: <Trans id=\"common.slots.cloak\">Cloak</Trans>,\r\n    15: <Trans id=\"common.slots.weapon\">Weapon</Trans>,\r\n    16: <Trans id=\"common.slots.offhand\">OffHand</Trans>,\r\n  };\r\n\r\n  static INT_ENCHANTABLE_SLOTS = {\r\n    4: <Trans id=\"common.slots.chest\">Chest</Trans>,\r\n    8: <Trans id=\"common.slots.bracers\">Bracers</Trans>,\r\n    10: <Trans id=\"common.slots.ring\">Ring</Trans>,\r\n    11: <Trans id=\"common.slots.ring\">Ring</Trans>,\r\n    14: <Trans id=\"common.slots.cloak\">Cloak</Trans>,\r\n    15: <Trans id=\"common.slots.weapon\">Weapon</Trans>,\r\n    16: <Trans id=\"common.slots.offhand\">OffHand</Trans>,\r\n  };\r\n\r\n  static MIN_ENCHANT_IDS = [\r\n    ITEMS.ENCHANT_RING_BARGAIN_OF_CRITICAL_STRIKE.effectId,\r\n    ITEMS.ENCHANT_RING_BARGAIN_OF_HASTE.effectId,\r\n    ITEMS.ENCHANT_RING_BARGAIN_OF_MASTERY.effectId,\r\n    ITEMS.ENCHANT_RING_BARGAIN_OF_VERSATILITY.effectId,\r\n    ITEMS.ENCHANT_CHEST_SACRED_STATS.effectId,\r\n    ITEMS.ENCHANT_BRACERS_ILLUMINATED_SOUL.effectId,\r\n    ITEMS.ENCHANT_GLOVES_STRENGTH_OF_SOUL.effectId,\r\n    ITEMS.ENCHANT_BOOTS_AGILE_SOULWALKER.effectId,\r\n  ];\r\n\r\n  // TODO add the new weapon enchants\r\n  static MAX_ENCHANT_IDS = [\r\n    ITEMS.ENCHANT_RING_TENET_OF_CRITICAL_STRIKE.effectId,\r\n    ITEMS.ENCHANT_RING_TENET_OF_HASTE.effectId,\r\n    ITEMS.ENCHANT_RING_TENET_OF_MASTERY.effectId,\r\n    ITEMS.ENCHANT_RING_TENET_OF_VERSATILITY.effectId,\r\n    ITEMS.ENCHANT_CHEST_ETERNAL_STATS.effectId,\r\n    ITEMS.ENCHANT_CHEST_ETERNAL_BOUNDS.effectId,\r\n    ITEMS.ENCHANT_CHEST_ETERNAL_INSIGHT.effectId,\r\n    ITEMS.ENCHANT_CHEST_ETERNAL_BULWARK.effectId,\r\n    ITEMS.ENCHANT_CHEST_ETERNAL_SKIRMISH.effectId,\r\n    ITEMS.ENCHANT_BRACERS_ETERNAL_INTELLECT.effectId,\r\n    ITEMS.ENCHANT_GLOVES_ETERNAL_STRENGTH.effectId,\r\n    ITEMS.ENCHANT_BOOTS_ETERNAL_AGILITY.effectId,\r\n    ITEMS.ENCHANT_CLOAK_FORTIFIED_AVOIDANCE.effectId,\r\n    ITEMS.ENCHANT_CLOAK_FORTIFIED_LEECH.effectId,\r\n    ITEMS.ENCHANT_CLOAK_FORTIFIED_SPEED.effectId,\r\n    ITEMS.ENCHANT_CLOAK_SOUL_VITALITY.effectId,\r\n    ITEMS.ENCHANT_WEAPON_SINFUL_REVELATION.effectId,\r\n    ITEMS.ENCHANT_WEAPON_ASCENDED_VIGOR.effectId,\r\n    ITEMS.ENCHANT_WEAPON_CELESTIAL_GUIDANCE.effectId,\r\n    ITEMS.ENCHANT_WEAPON_LIGHTLESS_FORCE.effectId,\r\n\r\n    // Death Knight only\r\n    SPELLS.RUNE_OF_THE_FALLEN_CRUSADER.effectId,\r\n    SPELLS.RUNE_OF_RAZORICE.effectId,\r\n    SPELLS.RUNE_OF_THE_STONESKIN_GARGOYLE.effectId,\r\n    SPELLS.RUNE_OF_HYSTERIA.effectId,\r\n    SPELLS.RUNE_OF_SANGUINATION.effectId,\r\n    SPELLS.RUNE_OF_APOCALYPSE.effectId,\r\n    SPELLS.RUNE_OF_UNENDING_THIRST.effectId,\r\n    SPELLS.RUNE_OF_SPELLWARDING.effectId,\r\n  ];\r\n\r\n  get enchantableGear() {\r\n    const enchantSlots = AGI_SPECS.includes(this.selectedCombatant.specId) ? EnchantChecker.AGI_ENCHANTABLE_SLOTS : STR_SPECS.includes(this.selectedCombatant.specId) ? EnchantChecker.STR_ENCHANTABLE_SLOTS : EnchantChecker.INT_ENCHANTABLE_SLOTS;\r\n    return Object.keys(enchantSlots).reduce((obj: {[key: number]: Item}, slot) => {\r\n      const item = this.selectedCombatant._getGearItemBySlotId(Number(slot));\r\n\r\n      // If there is no offhand, disregard the item.\r\n      // If the icon has `offhand` in the name, we know it's not a weapon and doesn't need an enchant.\r\n      // This is not an ideal way to determine if an offhand is a weapon.\r\n      if (item.id === 0 || item.icon.includes('offhand') || item.icon.includes('shield')) {\r\n        return obj;\r\n      }\r\n      obj[Number(slot)] = this.selectedCombatant._getGearItemBySlotId(Number(slot));\r\n\r\n      return obj;\r\n    }, {});\r\n  }\r\n  get numEnchantableGear() {\r\n    return Object.keys(this.enchantableGear).length;\r\n  }\r\n  get slotsMissingEnchant() {\r\n    const gear = this.enchantableGear;\r\n    return Object.keys(gear).filter(slot => !this.hasEnchant(gear[Number(slot)]));\r\n  }\r\n  get numSlotsMissingEnchant() {\r\n    return this.slotsMissingEnchant.length;\r\n  }\r\n  get slotsMissingMaxEnchant() {\r\n    const gear = this.enchantableGear;\r\n    return Object.keys(gear).filter(slot => this.hasEnchant(gear[Number(slot)]) && !this.hasMaxEnchant(gear[Number(slot)]));\r\n  }\r\n  get numSlotsMissingMaxEnchant() {\r\n    return this.slotsMissingMaxEnchant.length;\r\n  }\r\n  hasEnchant(item: Item) {\r\n    return Boolean(item.permanentEnchant);\r\n  }\r\n  hasMaxEnchant(item: Item) {\r\n    return EnchantChecker.MAX_ENCHANT_IDS.includes(item.permanentEnchant);\r\n  }\r\n\r\n  suggestions(when: When) {\r\n    const gear = this.enchantableGear;\r\n    const enchantSlots: {[key: number]: JSX.Element} = AGI_SPECS.includes(this.selectedCombatant.specId) ? EnchantChecker.AGI_ENCHANTABLE_SLOTS : STR_SPECS.includes(this.selectedCombatant.specId) ? EnchantChecker.STR_ENCHANTABLE_SLOTS : EnchantChecker.INT_ENCHANTABLE_SLOTS;\r\n    // iterating with keys instead of value because the values don't store what slot is being looked at\r\n    Object.keys(gear)\r\n      .forEach(slot => {\r\n        const item = gear[Number(slot)];\r\n        const slotName = enchantSlots[Number(slot)];\r\n        const hasEnchant = this.hasEnchant(item);\r\n\r\n        when(hasEnchant).isFalse()\r\n          .addSuggestion((suggest, actual, recommended) => suggest(\r\n              <Trans id=\"shared.enchantChecker.suggestions.noEnchant.label\">\r\n                Your <ItemLink id={item.id} quality={item.quality} details={item} icon={false}>{slotName}</ItemLink> is missing an enchant. Apply a strong enchant to very easily increase your throughput slightly.\r\n              </Trans>,\r\n            )\r\n              .icon(item.icon)\r\n              .staticImportance(SUGGESTION_IMPORTANCE.MAJOR));\r\n\r\n        const noMaxEnchant = hasEnchant && !this.hasMaxEnchant(item);\r\n        when(noMaxEnchant).isTrue()\r\n          .addSuggestion((suggest, actual, recommended) => suggest(\r\n              <Trans id=\"shared.enchantChecker.suggestions.weakEnchant.label\">\r\n                Your <ItemLink id={item.id} quality={item.quality} details={item} icon={false}>{slotName}</ItemLink> has a cheap enchant. Apply a strong enchant to very easily increase your throughput slightly.\r\n              </Trans>,\r\n            )\r\n              .icon(item.icon)\r\n              .staticImportance(SUGGESTION_IMPORTANCE.MINOR));\r\n      });\r\n  }\r\n}\r\n\r\nexport default EnchantChecker;\r\n","import Analyzer, { SELECTED_PLAYER, Options } from 'parser/core/Analyzer';\r\nimport SUGGESTION_IMPORTANCE from 'parser/core/ISSUE_IMPORTANCE';\r\nimport SPELLS from 'common/SPELLS/index';\r\nimport { When, ThresholdStyle } from 'parser/core/ParseResults';\r\nimport Events, { ApplyBuffEvent } from 'parser/core/Events';\r\n\r\nconst MIN_FLASK_IDS = [\r\n  SPELLS.GREATER_FLASK_OF_THE_CURRENTS.id,\r\n  SPELLS.GREATER_FLASK_OF_ENDLESS_FATHOMS.id,\r\n  SPELLS.GREATER_FLASK_OF_THE_UNDERTOW.id,\r\n  SPELLS.GREATER_FLASK_OF_THE_VAST_HORIZON.id,\r\n];\r\n\r\nconst MAX_FLASK_IDS = [\r\n  SPELLS.SPECTRAL_FLASK_OF_POWER.id,\r\n  SPELLS.SPECTRAL_FLASK_OF_STAMINA.id,\r\n  SPELLS.ETERNAL_FLASK.id,\r\n];\r\n\r\nclass FlaskChecker extends Analyzer {\r\n  startFightWithFlaskUp = false;\r\n  strongFlaskUsed = false;\r\n\r\n  constructor(options: Options){\r\n    super(options);\r\n    this.addEventListener(Events.applybuff.to(SELECTED_PLAYER), this.onApplybuff.bind(this));\r\n  }\r\n\r\n  onApplybuff(event: ApplyBuffEvent) {\r\n    const spellId = event.ability.guid;\r\n    if (MIN_FLASK_IDS.includes(spellId) && event.prepull) {\r\n      this.startFightWithFlaskUp = true;\r\n    }\r\n    if (MAX_FLASK_IDS.includes(spellId) && event.prepull) {\r\n      this.startFightWithFlaskUp = true;\r\n      this.strongFlaskUsed = true;\r\n    }\r\n  }\r\n  get flaskStrengthSuggestion() {\r\n    return {\r\n      actual: this.strongFlaskUsed,\r\n      isEqual: false,\r\n      style: ThresholdStyle.BOOLEAN,\r\n    };\r\n  }\r\n  get flaskSuggestionThresholds() {\r\n    return {\r\n      actual: this.startFightWithFlaskUp,\r\n      isEqual: false,\r\n      style: ThresholdStyle.BOOLEAN,\r\n    };\r\n  }\r\n  suggestions(when: When) {\r\n    when(this.flaskSuggestionThresholds)\r\n      .addSuggestion((suggest) => suggest('You did not have a flask up before combat. Having a flask during combat increases your primary stat significantly.')\r\n          .icon(SPELLS.SPECTRAL_FLASK_OF_POWER.icon)\r\n          .staticImportance(SUGGESTION_IMPORTANCE.MINOR));\r\n    when(this.flaskStrengthSuggestion)\r\n      .addSuggestion((suggest) => suggest('You did not have the best flask active when starting the fight. Using the best flask available is an easy way to improve performance.')\r\n          .icon(SPELLS.SPECTRAL_FLASK_OF_POWER.icon)\r\n          .staticImportance(SUGGESTION_IMPORTANCE.MINOR));\r\n  }\r\n}\r\n\r\nexport default FlaskChecker;\r\n","import SPELLS from 'common/SPELLS';\r\nimport Analyzer, { SELECTED_PLAYER, Options } from 'parser/core/Analyzer';\r\nimport SUGGESTION_IMPORTANCE from 'parser/core/ISSUE_IMPORTANCE';\r\nimport { When, ThresholdStyle } from 'parser/core/ParseResults';\r\nimport Events, { ApplyBuffEvent } from 'parser/core/Events';\r\n\r\nconst LOWER_FOOD_IDS = [\r\n  //BFA Food\r\n  SPELLS.FAMINE_EVALUATOR_AND_SNACK_TABLE_FEAST_AGI.id,\r\n  SPELLS.FAMINE_EVALUATOR_AND_SNACK_TABLE_FEAST_INT.id,\r\n  SPELLS.FAMINE_EVALUATOR_AND_SNACK_TABLE_FEAST_STR.id,\r\n  SPELLS.FAMINE_EVALUATOR_AND_SNACK_TABLE_FEAST_STA.id,\r\n  SPELLS.FRAGRANT_KAKAVIA.id,\r\n  SPELLS.ABYSSAL_FRIED_RISSOLE.id,\r\n  SPELLS.BIL_TONG.id,\r\n  SPELLS.MECH_DOWELS_BIG_MECH.id,\r\n  SPELLS.BAKED_PORT_TATO.id,\r\n];\r\n\r\nconst MID_TIER_FOOD_IDS = [\r\n  //18 Primary Stat\r\n  SPELLS.SURPRISINGLY_PALATABLE_FEAST_INT.id,\r\n  SPELLS.SURPRISINGLY_PALATABLE_FEAST_AGI.id,\r\n  SPELLS.SURPRISINGLY_PALATABLE_FEAST_STR.id,\r\n\r\n  //14 Stam\r\n  SPELLS.PICKLED_MEAT_SMOOTHIE.id,\r\n\r\n  //18 Secondary Stat\r\n  SPELLS.BUTTERSCOTCH_MARINATED_RIBS.id,\r\n  SPELLS.CINNAMON_BONEFISH_STEW.id,\r\n  SPELLS.MEATY_APPLE_DUMPLINGS.id,\r\n  SPELLS.SWEET_SILVERGILL_SAUSAGES.id,\r\n];\r\n\r\nconst HIGHER_FOOD_IDS = [\r\n  //20 Primary Stat\r\n  SPELLS.FEAST_OF_GLUTTONOUS_HEDONISM_INT.id,\r\n  SPELLS.FEAST_OF_GLUTTONOUS_HEDONISM_AGI.id,\r\n  SPELLS.FEAST_OF_GLUTTONOUS_HEDONISM_STR.id,\r\n\r\n  //22 Stam\r\n  SPELLS.BANANA_BEEF_PUDDING.id,\r\n\r\n  //30 Secondary Stat\r\n  SPELLS.SPINEFIN_SOUFFLE_AND_FRIES.id,\r\n  SPELLS.TENEBROUS_CROWN_ROAST_ASPIC.id,\r\n  SPELLS.IRIDESCENT_RAVIOLI_WITH_APPLE_SAUCE.id,\r\n  SPELLS.STEAK_A_LA_MODE.id,\r\n];\r\n\r\nclass FoodChecker extends Analyzer {\r\n  lowerFoodUp = false;\r\n  midTierFoodUp = false;\r\n  higherFoodUp = false;\r\n\r\n  constructor(options: Options){\r\n    super(options);\r\n    this.addEventListener(Events.applybuff.to(SELECTED_PLAYER), this.onApplybuff.bind(this));\r\n  }\r\n\r\n  onApplybuff(event: ApplyBuffEvent) {\r\n    const spellId = event.ability.guid;\r\n    if (event.prepull) {\r\n      if (LOWER_FOOD_IDS.includes(spellId)) {\r\n        this.lowerFoodUp = true;\r\n      }\r\n      if (HIGHER_FOOD_IDS.includes(spellId)) {\r\n        this.higherFoodUp = true;\r\n      }\r\n      if (MID_TIER_FOOD_IDS.includes(spellId)) {\r\n        this.midTierFoodUp = true;\r\n      }\r\n    }\r\n  }\r\n  get higherFoodSuggestionThresholds() {\r\n    return {\r\n      actual: this.higherFoodUp,\r\n      isEqual: false,\r\n      style: ThresholdStyle.BOOLEAN,\r\n    };\r\n  }\r\n  get isPresentFoodSuggestionThresholds() {\r\n    return {\r\n      actual: this.higherFoodUp || this.lowerFoodUp || this.midTierFoodUp,\r\n      isEqual: false,\r\n      style: ThresholdStyle.BOOLEAN,\r\n    };\r\n  }\r\n  suggestions(when: When) {\r\n    let importance = SUGGESTION_IMPORTANCE.MINOR;\r\n    let suggestionText = 'You did not have any food active when starting the fight. Having the right food buff during combat is an easy way to improve performance.';\r\n    if (!this.higherFoodUp && (this.lowerFoodUp || this.midTierFoodUp)) {\r\n      suggestionText = 'You did not have the best food active when starting the fight. Using the best food available is an easy way to improve performance.';\r\n    }\r\n    if (!this.higherFoodUp && !this.lowerFoodUp && !this.midTierFoodUp) {\r\n      importance = SUGGESTION_IMPORTANCE.MAJOR;\r\n    }\r\n    when(this.higherFoodSuggestionThresholds)\r\n      .addSuggestion((suggest) => suggest(suggestionText)\r\n          .icon(SPELLS.FEAST_OF_GLUTTONOUS_HEDONISM_INT.icon)\r\n          .staticImportance(importance));\r\n  }\r\n}\r\nexport default FoodChecker;\r\n","\r\nimport ItemLink from 'common/ItemLink';\r\nimport ITEMS from 'common/ITEMS';\r\n\r\nimport Analyzer from 'parser/core/Analyzer';\r\nimport SUGGESTION_IMPORTANCE from 'parser/core/ISSUE_IMPORTANCE';\r\nimport { When } from 'parser/core/ParseResults';\r\nimport { Item } from 'parser/core/Events';\r\n\r\nimport React from 'react';\r\nimport { Trans } from '@lingui/macro';\r\n\r\n// Example logs with missing enhancement:\r\n// /report/XQrLTRC1bFWGAt3m/21-Mythic+The+Council+of+Blood+-+Wipe+10+(3:17)/Odsuv/standard\r\n\r\nclass WeaponEnhancementChecker extends Analyzer {\r\n\r\n  static WEAPON_SLOTS = {\r\n    15: <Trans id=\"common.slots.weapon\">Weapon</Trans>,\r\n    16: <Trans id=\"common.slots.offhand\">OffHand</Trans>,\r\n  };\r\n\r\n  static MAX_ENHANCEMENT_IDS = [\r\n    ITEMS.SHADOWCORE_OIL.effectId,\r\n    ITEMS.EMBALMERS_OIL.effectId,\r\n    ITEMS.SHADED_SHARPENING_STONE.effectId,\r\n    ITEMS.SHADED_WEIGHTSTONE.effectId,\r\n  ]\r\n\r\n  get enhanceableWeapons() {\r\n    return Object.keys(WeaponEnhancementChecker.WEAPON_SLOTS).reduce((obj: {[key: number]: Item}, slot) => {\r\n      const item = this.selectedCombatant._getGearItemBySlotId(Number(slot));\r\n\r\n      // If there is no offhand, disregard the item.\r\n      // If the icon has `offhand` in the name, we know it's not a weapon and doesn't need an enhancement.\r\n      // This is not an ideal way to determine if an offhand is a weapon.\r\n      if (item.id === 0 || item.icon.includes('offhand') || item.icon.includes('shield')) {\r\n        return obj;\r\n      }\r\n      obj[Number(slot)] = this.selectedCombatant._getGearItemBySlotId(Number(slot));\r\n\r\n      return obj;\r\n    }, {});\r\n  }\r\n  get numWeapons() {\r\n    return Object.keys(this.enhanceableWeapons).length;\r\n  }\r\n  get weaponsMissingEnhancement() {\r\n    const gear = this.enhanceableWeapons;\r\n    return Object.keys(gear).filter(slot => !this.hasEnhancement(gear[Number(slot)]));\r\n  }\r\n  get numWeaponsMissingEnhancement() {\r\n    return this.weaponsMissingEnhancement.length;\r\n  }\r\n  get weaponsMissingMaxEnhancement() {\r\n    const gear = this.enhanceableWeapons;\r\n    return Object.keys(gear).filter(slot => this.hasEnhancement(gear[Number(slot)]) && !this.hasMaxEnhancement(gear[Number(slot)]));\r\n  }\r\n  get numWeaponsMissingMaxEnhancement() {\r\n    return this.weaponsMissingMaxEnhancement.length;\r\n  }\r\n  hasEnhancement(item: Item) {\r\n    return Boolean(item.temporaryEnchant);\r\n  }\r\n  hasMaxEnhancement(item: Item) {\r\n    return WeaponEnhancementChecker.MAX_ENHANCEMENT_IDS.includes(item.temporaryEnchant);\r\n  }\r\n\r\n  suggestions(when: When) {\r\n    const gear = this.enhanceableWeapons;\r\n    const weaponSlots: {[key: number]: JSX.Element} = WeaponEnhancementChecker.WEAPON_SLOTS;\r\n    // iterating with keys instead of value because the values don't store what slot is being looked at\r\n    Object.keys(gear)\r\n      .forEach(slot => {\r\n        const item = gear[Number(slot)];\r\n        const slotName = weaponSlots[Number(slot)];\r\n        const hasEnhancement = this.hasEnhancement(item);\r\n\r\n        when(hasEnhancement).isFalse()\r\n          .addSuggestion((suggest, actual, recommended) => suggest(\r\n              <Trans id=\"shared.weaponEnhancementChecker.suggestions.noWeaponEnhancement.label\">\r\n                Your <ItemLink id={item.id} quality={item.quality} details={item} icon={false}>{slotName}</ItemLink> is missing a weapon enhancement (weapon oil/sharpening stone/weightstone) . Apply an enhancement to very easily increase your throughput slightly.\r\n              </Trans>,\r\n            )\r\n              .icon(item.icon)\r\n              .staticImportance(SUGGESTION_IMPORTANCE.REGULAR));\r\n\r\n        const noMaxEnchant = hasEnhancement && !this.hasMaxEnhancement(item);\r\n        when(noMaxEnchant).isTrue()\r\n          .addSuggestion((suggest, actual, recommended) => suggest(\r\n              <Trans id=\"shared.weaponEnhancementChecker.suggestions.weakWeaponEnhancement.label\">\r\n                Your <ItemLink id={item.id} quality={item.quality} details={item} icon={false}>{slotName}</ItemLink> has a cheap weapon enhancement (weapon oil/sharpening stone/weightstone). Apply a strong enhancement to very easily increase your throughput slightly.\r\n              </Trans>,\r\n            )\r\n              .icon(item.icon)\r\n              .staticImportance(SUGGESTION_IMPORTANCE.MINOR));\r\n      });\r\n  }\r\n}\r\n\r\nexport default WeaponEnhancementChecker;\r\n","import React from 'react';\r\n\r\nimport SPELLS from 'common/SPELLS/index';\r\nimport SpellIcon from 'common/SpellIcon';\r\nimport RACES from 'game/RACES';\r\nimport Analyzer, { SELECTED_PLAYER } from 'parser/core/Analyzer';\r\nimport HIT_TYPES from 'game/HIT_TYPES';\r\nimport CritEffectBonus from 'parser/shared/modules/helpers/CritEffectBonus';\r\nimport StatisticBox from 'interface/others/StatisticBox';\r\nimport ItemDamageDone from 'interface/ItemDamageDone';\r\nimport ItemHealingDone from 'interface/ItemHealingDone';\r\nimport ROLES from 'game/ROLES';\r\nimport Events from 'parser/core/Events';\r\n\r\nexport const CRIT_EFFECT = 0.02;\r\n\r\nclass MightOfTheMountain extends Analyzer {\r\n  static dependencies = {\r\n    critEffectBonus: CritEffectBonus,\r\n  };\r\n\r\n  damage = 0;\r\n  healing = 0;\r\n\r\n  constructor(...args) {\r\n    super(...args);\r\n    this.active = this.selectedCombatant.race === RACES.Dwarf;\r\n    if (!this.active) {\r\n      return;\r\n    }\r\n\r\n    this.critEffectBonus.hook(this.getCritEffectBonus.bind(this));\r\n    this.addEventListener(Events.heal.by(SELECTED_PLAYER), this.onHeal);\r\n    this.addEventListener(Events.damage.by(SELECTED_PLAYER), this.onDamage);\r\n  }\r\n\r\n  isApplicableHeal(event) {\r\n    const abilities = this.owner.constructor.abilitiesAffectedByHealingIncreases;\r\n    if (abilities.length > 0 && !abilities.includes(event.ability.guid)) {\r\n      // When this isn't configured, assume everything is affected\r\n      return false;\r\n    }\r\n    if (event.hitType !== HIT_TYPES.CRIT) {\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n  isApplicableDamage(event) {\r\n    const abilities = this.owner.constructor.abilitiesAffectedByDamageIncreases;\r\n    if (abilities.length > 0 && !abilities.includes(event.ability.guid)) {\r\n      // When this isn't configured, assume everything is affected\r\n      return false;\r\n    }\r\n    if (event.hitType !== HIT_TYPES.CRIT) {\r\n      return false;\r\n    }\r\n    if (event.targetIsFriendly) {\r\n      // Friendly fire does not get increased\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  getCritEffectBonus(critEffectModifier, event) {\r\n    if (!this.isApplicableHeal(event)) {\r\n      return critEffectModifier;\r\n    }\r\n\r\n    return critEffectModifier + CRIT_EFFECT;\r\n  }\r\n\r\n  onHeal(event) {\r\n    if (!this.isApplicableHeal(event)) {\r\n      return;\r\n    }\r\n\r\n    const amount = event.amount;\r\n    const absorbed = event.absorbed || 0;\r\n    const overheal = event.overheal || 0;\r\n    const raw = amount + absorbed + overheal;\r\n    const rawNormalPart = raw / this.critEffectBonus.getBonus(event);\r\n    const rawContribution = rawNormalPart * CRIT_EFFECT;\r\n\r\n    const effectiveHealing = Math.max(0, rawContribution - overheal);\r\n\r\n    this.healing += effectiveHealing;\r\n  }\r\n  onDamage(event) {\r\n    if (!this.isApplicableDamage(event)) {\r\n      return;\r\n    }\r\n\r\n    const amount = event.amount;\r\n    const absorbed = event.absorbed || 0;\r\n    const raw = amount + absorbed;\r\n    const rawNormalPart = raw / this.critEffectBonus.getBonus(event);\r\n    const rawContribution = rawNormalPart * CRIT_EFFECT;\r\n\r\n    this.damage += rawContribution;\r\n  }\r\n\r\n  statistic() {\r\n    let value;\r\n    switch (this.selectedCombatant.spec.role) {\r\n      case ROLES.HEALER:\r\n        value = <ItemHealingDone amount={this.healing} />;\r\n        break;\r\n      case ROLES.DPS:\r\n        value = <ItemDamageDone amount={this.damage} />;\r\n        break;\r\n      default:\r\n        value = (\r\n          <>\r\n            <ItemHealingDone amount={this.healing} /><br />\r\n            <ItemDamageDone amount={this.damage} />\r\n          </>\r\n        );\r\n        break;\r\n    }\r\n\r\n    return (\r\n      <StatisticBox\r\n        icon={<SpellIcon id={SPELLS.MIGHT_OF_THE_MOUNTAIN.id} />}\r\n        value={value}\r\n        label=\"Dwarf crit racial\"\r\n        tooltip={(\r\n          <>\r\n            The racial contributed {this.owner.formatItemDamageDone(this.damage)} and {this.owner.formatItemHealingDone(this.healing)}.\r\n          </>\r\n        )}\r\n      />\r\n    );\r\n  }\r\n}\r\n\r\nexport default MightOfTheMountain;\r\n","import CombatLogParser from './CombatLogParser';\r\nimport Entity from './Entity';\r\n\r\ninterface PetInfo {\r\n  name: string;\r\n  type: string;\r\n  guid: number;\r\n}\r\n\r\nclass Pet extends Entity {\r\n  get name() {\r\n    return this._baseInfo.name;\r\n  }\r\n\r\n  get type() {\r\n    return this._baseInfo.type;\r\n  }\r\n\r\n  get guid() {\r\n    return this._baseInfo.guid;\r\n  }\r\n\r\n  _baseInfo: PetInfo;\r\n\r\n  constructor(owner: CombatLogParser, baseInfo: PetInfo) {\r\n    super(owner);\r\n    this._baseInfo = baseInfo;\r\n  }\r\n}\r\n\r\nexport default Pet;\r\n","import Pet from 'parser/core/Pet';\r\nimport { AnyEvent, HasSource, HasTarget } from 'parser/core/Events';\r\n\r\nimport Entities from './Entities';\r\n\r\nconst debug = false;\r\n\r\nclass Pets extends Entities<Pet> {\r\n  pets: { [petId: number]: Pet } = {};\r\n\r\n  getEntities() {\r\n    return this.pets;\r\n  }\r\n\r\n  getSourceEntity(event: AnyEvent) {\r\n    return this.getEntityFromEvent(event, false);\r\n  }\r\n\r\n  getEntity(event: AnyEvent) {\r\n    return this.getEntityFromEvent(event, true);\r\n  }\r\n\r\n  getEntityFromEvent(event: AnyEvent, fromTarget: boolean): Pet | null {\r\n    let entityId: number;\r\n    if (fromTarget) {\r\n      if (!HasTarget(event) || !event.targetIsFriendly) {\r\n        return null;\r\n      }\r\n      entityId = event.targetID;\r\n    } else {\r\n      if (!HasSource(event) || !event.sourceIsFriendly) {\r\n        return null;\r\n      }\r\n      entityId = event.sourceID;\r\n    }\r\n    let pet = this.pets[entityId];\r\n    if (!pet) {\r\n      const baseInfo = this.owner.playerPets.find(pet => pet.id === entityId);\r\n      if (!baseInfo) {\r\n        debug && console.warn('Pet not noteworthy enough:', entityId, event);\r\n        return null;\r\n      }\r\n      pet = new Pet(this.owner, baseInfo);\r\n      this.pets[entityId] = pet;\r\n    }\r\n    return pet;\r\n  }\r\n}\r\n\r\nexport default Pets;\r\n","import React from 'react';\r\n\r\n// https://thenounproject.com/search/?q=link&i=1063944\r\n// link by arjuazka from the Noun Project\r\nconst Icon = ({ ...other }) => (\r\n  <svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 100 100\" className=\"icon\" {...other}>\r\n    <path d=\"m 21,1019.3619 c -9.36611,0 -17.0000001,-7.6338 -17.0000001,-16.9997 0,-9.36596 7.6338901,-16.99972 17.0000001,-16.99972 l 20,0 c 8.95969,0 16.35051,6.95967 16.96875,15.78102 a 3.0068688,3.0068157 0 1 1 -6,0.4062 C 51.56591,995.80186 46.87823,991.36237 41,991.36237 l -20,0 c -6.14589,0 -11.0000001,4.85403 -11.0000001,10.99983 0,6.1458 4.8541101,10.9998 11.0000001,10.9998 l 20,0 a 3.0003,3.0002471 0 1 1 0,5.9999 l -20,0 z m 38,0 c -8.95969,0 -16.35051,-6.9597 -16.96875,-15.781 a 3.0068688,3.0068157 0 1 1 6,-0.4062 c 0.40284,5.7478 5.09052,10.1873 10.96875,10.1873 l 20,0 c 6.14589,0 11,-4.854 11,-10.9998 0,-6.1458 -4.85411,-10.99983 -11,-10.99983 l -20,0 a 3.0003,3.0002471 0 1 1 0,-5.99989 l 20,0 c 9.36611,0 17,7.63376 17,16.99972 0,9.3659 -7.63389,16.9997 -17,16.9997 l -20,0 z\" transform=\"translate(0,-952.36218)\" />\r\n  </svg>\r\n);\r\n\r\nexport default Icon;\r\n","import React from 'react';\r\nimport { Link } from 'react-router-dom';\r\n\r\nimport Tooltip from 'common/Tooltip';\r\nimport InfoIcon from 'interface/icons/Info';\r\nimport DrilldownIcon from 'interface/icons/Link';\r\nimport STATISTIC_CATEGORY from 'interface/others/STATISTIC_CATEGORY';\r\n\r\nimport './Statistic.scss';\r\n\r\ntype Props = {\r\n  children: React.ReactNode,\r\n  /**\r\n   * A tooltip node to be displayed when the user hovers over an information *(i)* icon in the\r\n   * statistic box's top right corner.\r\n   */\r\n  tooltip?: React.ReactNode,\r\n  wide: boolean,\r\n  ultrawide: boolean,\r\n  category?: STATISTIC_CATEGORY,\r\n  position?: number,\r\n  size: 'standard' | 'small' | 'medium' | 'large' | 'flexible',\r\n  /**\r\n   * A relative or absolute URL. If set, a button will be attached to the bottom of the statistic\r\n   * box that a user can click to be sent to the given URL.\r\n   */\r\n  drilldown?: string,\r\n  /**\r\n   * A node to display upon the user clicking an *expand* arrow at the bottom of the statistic box.\r\n   */\r\n  dropdown?: React.ReactNode,\r\n  /**\r\n   * CSS class name(s) to apply to the statistic box.\r\n   */\r\n  className: string,\r\n  expanded?: boolean,\r\n}\r\n\r\nclass Statistic extends React.PureComponent<Props, { expanded?: boolean }> {\r\n  static defaultProps = {\r\n    size: 'standard',\r\n    wide: false,\r\n    ultrawide: false,\r\n    className: '',\r\n  };\r\n\r\n  constructor(props: Props) {\r\n    super(props);\r\n    this.state = {\r\n      expanded: props.expanded,\r\n    };\r\n\r\n    this.toggleExpansion = this.toggleExpansion.bind(this);\r\n  }\r\n\r\n  componentDidUpdate(prevProps: Props) {\r\n    if (prevProps.expanded !== this.props.expanded) {\r\n      this.setState({\r\n        expanded: this.props.expanded,\r\n      });\r\n    }\r\n  }\r\n\r\n  toggleExpansion() {\r\n    this.setState({\r\n      expanded: !this.state.expanded,\r\n    });\r\n  }\r\n\r\n  renderDrilldown(drilldown: string) {\r\n    const isAbsolute = drilldown.includes('://');\r\n\r\n    return (\r\n      <div className=\"drilldown\">\r\n        <Tooltip content=\"Drill down\">\r\n          {isAbsolute ? (\r\n            <a href={drilldown} target=\"_blank\" rel=\"noopener noreferrer\">\r\n              <DrilldownIcon />\r\n            </a>\r\n          ) : (\r\n            <Link to={drilldown}>\r\n              <DrilldownIcon />\r\n            </Link>\r\n          )}\r\n        </Tooltip>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  renderDropdown(dropdown: React.ReactNode) {\r\n    return (\r\n      <>\r\n        <div className=\"row\">\r\n          <div className=\"col-xs-12\">\r\n            {this.state.expanded && (\r\n              <div className=\"statistic-expansion\">\r\n                {dropdown}\r\n              </div>\r\n            )}\r\n          </div>\r\n        </div>\r\n\r\n        <div className=\"statistic-expansion-button-holster\">\r\n          <button onClick={this.toggleExpansion} className=\"btn btn-primary\">\r\n            {!this.state.expanded && <span className=\"glyphicon glyphicon-chevron-down\" />}\r\n            {this.state.expanded && <span className=\"glyphicon glyphicon-chevron-up\" />}\r\n          </button>\r\n        </div>\r\n      </>\r\n    );\r\n  }\r\n\r\n  render() {\r\n    const { children, wide, ultrawide, tooltip, size, drilldown, className, dropdown, ...others } = this.props;\r\n\r\n    return (\r\n      <div className={ultrawide ? 'col-md-12' : (wide ? 'col-md-6 col-sm-12 col-xs-12' : 'col-lg-3 col-md-4 col-sm-6 col-xs-12')}>\r\n        <div\r\n          className={`panel statistic ${size} ${className}`}\r\n          // only add zIndex property if a dropdown exists, to preserve backwards compatiblity with StatisticBox utilizing Statistic\r\n          style={dropdown ? { zIndex: this.state.expanded ? 2 : 1 } : undefined}\r\n          {...others}\r\n        >\r\n          <div className=\"panel-body\">\r\n            {children}\r\n            {dropdown && this.renderDropdown(dropdown)}\r\n          </div>\r\n          {tooltip && (\r\n            <Tooltip content={tooltip}>\r\n              <div className=\"detail-corner\" data-place=\"top\">\r\n                <InfoIcon />\r\n              </div>\r\n            </Tooltip>\r\n          )}\r\n          {drilldown && this.renderDrilldown(drilldown)}\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Statistic;\r\n","export default {\r\n  CORE(offset = 0) {\r\n    return offset;\r\n  },\r\n  DEFAULT: 100,\r\n  OPTIONAL(offset = 0) {\r\n    return 1000 + offset;\r\n  },\r\n  UNIMPORTANT(offset = 0) {\r\n    return 10000 + offset;\r\n  },\r\n};\r\n","import React from 'react';\r\nimport PropTypes from 'prop-types';\r\n\r\nimport Statistic from 'interface/statistics/Statistic';\r\n\r\nimport STATISTIC_CATEGORY from './STATISTIC_CATEGORY';\r\nimport './StatisticBox.css';\r\n\r\nexport { default as STATISTIC_ORDER } from './STATISTIC_ORDER';\r\n\r\n/**\r\n * @deprecated Use `interface/statistic/Statistic` instead.\r\n */\r\nclass StatisticBox extends React.PureComponent {\r\n  static propTypes = {\r\n    icon: PropTypes.node,\r\n    value: PropTypes.node.isRequired,\r\n    tooltip: PropTypes.node,\r\n    label: PropTypes.node.isRequired,\r\n    footer: PropTypes.node,\r\n    category: PropTypes.string,\r\n    position: PropTypes.number,\r\n    children: PropTypes.node,\r\n    style: PropTypes.object,\r\n    expanded: PropTypes.bool,\r\n  };\r\n  static defaultProps = {\r\n    category: STATISTIC_CATEGORY.GENERAL,\r\n    style: {},\r\n  };\r\n\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      expanded: props.expanded,\r\n    };\r\n\r\n    this.toggleExpansion = this.toggleExpansion.bind(this);\r\n  }\r\n\r\n  componentDidUpdate(prevProps) {\r\n    if (prevProps.expanded !== this.props.expanded) {\r\n      this.setState({\r\n        expanded: this.props.expanded,\r\n      });\r\n    }\r\n  }\r\n\r\n  toggleExpansion() {\r\n    this.setState({\r\n      expanded: !this.state.expanded,\r\n    });\r\n  }\r\n\r\n  render() {\r\n    const { icon, value, label, footer, children, style, ...others } = this.props;\r\n    delete others.category;\r\n    delete others.position;\r\n    // TODO: make sure \"tooltip\" properties are correctly passed, if some contain HTML tags, fix them into <>...</>\r\n    return (\r\n      <Statistic\r\n        {...others}\r\n        className=\"statistic-box\"\r\n        style={{ ...style, height: 'auto', zIndex: this.state.expanded ? 2 : 1 }}\r\n      >\r\n        <div className=\"pad\">\r\n          <label>\r\n            {icon} {label}\r\n          </label>\r\n          <div className=\"value\">\r\n            {value}\r\n          </div>\r\n\r\n          {footer && (\r\n            <div style={{ marginTop: '0.5em' }}>\r\n              {footer}\r\n            </div>\r\n          )}\r\n        </div>\r\n        {children && (\r\n          <>\r\n            <div className=\"row\">\r\n              <div className=\"col-xs-12\">\r\n                {this.state.expanded && (\r\n                  <div className=\"statistic-expansion\">\r\n                    {children}\r\n                  </div>\r\n                )}\r\n              </div>\r\n            </div>\r\n\r\n            <div className=\"statistic-expansion-button-holster\">\r\n              <button onClick={this.toggleExpansion} className=\"btn btn-primary\">\r\n                {!this.state.expanded && <span className=\"glyphicon glyphicon-chevron-down\" />}\r\n                {this.state.expanded && <span className=\"glyphicon glyphicon-chevron-up\" />}\r\n              </button>\r\n            </div>\r\n          </>\r\n        )}\r\n      </Statistic>\r\n    );\r\n  }\r\n}\r\n\r\nexport default StatisticBox;\r\n","import React from 'react';\r\nimport PropTypes from 'prop-types';\r\n\r\nimport { formatNumber, formatPercentage } from 'common/format';\r\nimport CombatLogParser from 'parser/core/CombatLogParser';\r\n\r\ninterface Props {\r\n  amount: number;\r\n  approximate?: boolean;\r\n}\r\ninterface Context {\r\n  parser: CombatLogParser;\r\n}\r\n\r\nconst ItemDamageDone = (\r\n  { amount, approximate }: Props,\r\n  { parser }: Context,\r\n) => (\r\n  <>\r\n    <img src=\"/img/sword.png\" alt=\"Damage\" className=\"icon\" />{' '}\r\n    {approximate && '≈'}\r\n    {formatNumber((amount / parser.fightDuration) * 1000)} DPS{' '}\r\n    <small>\r\n      {formatPercentage(parser.getPercentageOfTotalDamageDone(amount))} % of\r\n      total\r\n    </small>\r\n  </>\r\n);\r\nItemDamageDone.contextTypes = {\r\n  parser: PropTypes.object.isRequired,\r\n};\r\n\r\nexport default ItemDamageDone;\r\n","import Module, { Options } from 'parser/core/Module';\r\nimport { i18n } from '@lingui/core';\r\nimport { t } from '@lingui/macro';\r\n\r\nimport Haste from 'parser/shared/modules/Haste';\r\n\r\nimport { AnyEvent } from '../Events';\r\nimport Ability, { SpellbookAbility } from './Ability';\r\nimport AbilityTracker from '../../shared/modules/AbilityTracker';\r\n\r\nclass Abilities extends Module {\r\n  static dependencies = {\r\n    abilityTracker: AbilityTracker,\r\n    haste: Haste,\r\n  };\r\n  abilityTracker!: AbilityTracker;\r\n  haste!: Haste;\r\n\r\n  // TODO - Enum?\r\n  static SPELL_CATEGORIES = {\r\n    ROTATIONAL: i18n._(t('core.abilities.spellCategories.rotational')`Rotational Spell`),\r\n    ROTATIONAL_AOE: i18n._(t('core.abilities.spellCategories.rotationalAoe')`Spell (AOE)`),\r\n    ITEMS: i18n._(t('core.abilities.spellCategories.items')`Item`),\r\n    COOLDOWNS: i18n._(t('core.abilities.spellCategories.cooldowns')`Cooldown`),\r\n    DEFENSIVE: i18n._(t('core.abilities.spellCategories.defensive')`Defensive Cooldown`),\r\n    SEMI_DEFENSIVE: i18n._(t('core.abilities.spellCategories.semiDefensive')`Offensive & Defensive Cooldown`),\r\n    OTHERS: i18n._(t('core.abilities.spellCategories.others')`Spell`),\r\n    UTILITY: i18n._(t('core.abilities.spellCategories.utility')`Utility`),\r\n    HEALER_DAMAGING_SPELL: i18n._(t('core.abilities.spellCategories.healerDamagingSpell')`Damaging Spell`),\r\n    CONSUMABLE: i18n._(t('core.abilities.spellCategories.consumable')`Consumable`),\r\n    HIDDEN: i18n._(t('core.abilities.spellCategories.hidden')`Hidden`),\r\n  };\r\n  static ABILITY_CLASS = Ability;\r\n\r\n  /**\r\n   * This will be called *once* during initialization. See the Ability class for the available properties. This should contain ALL spells available to a player of your spec, including utility such as interrupts, dispells, etc\r\n   * @returns {object[]}\r\n   */\r\n  spellbook(): SpellbookAbility[] {\r\n    // This list will NOT be recomputed during the fight. If a cooldown changes based on something like Haste or a Buff you need to put it in a function.\r\n    // While you can put checks for talents/traits outside of the cooldown prop, you generally should aim to keep everything about a single spell together. In general only move a prop up if you're regularly checking for the same talent/trait in multiple spells.\r\n    return [];\r\n  }\r\n\r\n  abilities: Ability[] = [];\r\n  activeAbilities: Ability[] = [];\r\n  constructor(args: Options) {\r\n    super(args);\r\n    this.loadSpellbook(this.spellbook());\r\n  }\r\n  loadSpellbook(spellbook: SpellbookAbility[]) {\r\n    this.abilities = spellbook.map(options => new Ability(this, options));\r\n    this.activeAbilities = this.abilities.filter(ability => ability.enabled);\r\n  }\r\n\r\n  /**\r\n   * Add an ability to the list of active abilities.\r\n   * @param {object} options An object with all the properties and their values that gets passed to the Ability class.\r\n   */\r\n  add(options: SpellbookAbility) {\r\n    const ability = new Ability(this, options);\r\n    this.abilities.push(ability);\r\n    this.activeAbilities.push(ability);\r\n  }\r\n\r\n  /**\r\n   * Returns the first ACTIVE spellInfo with the given spellId (or undefined if there is no such spellInfo)\r\n   *\r\n   * @return {Ability}\r\n   */\r\n  getAbility(spellId: number) {\r\n    const ability = this.activeAbilities.find(ability => {\r\n      if (ability.spell instanceof Array) {\r\n        return ability.spell.some(spell => spell.id === spellId);\r\n      } else {\r\n        return ability.spell.id === spellId;\r\n      }\r\n    });\r\n\r\n    if(ability && ability.spell instanceof Array && ability.primaryOverride === undefined) {\r\n      ability.primaryOverride = ability.spell.findIndex((spell) => spell.id === spellId);\r\n    }\r\n\r\n    return ability;\r\n  }\r\n\r\n  /**\r\n   * Returns the expected cooldown (in seconds) of the given spellId at the current timestamp (or undefined if there is no such spellInfo)\r\n   */\r\n  getExpectedCooldownDuration(spellId: number, cooldownTriggerEvent?: AnyEvent) {\r\n    const ability = this.getAbility(spellId);\r\n    return ability ? Math.round(ability.getCooldown(this.haste.current, cooldownTriggerEvent) * 1000) : undefined;\r\n  }\r\n\r\n  /**\r\n   * Returns the max charges of the given spellId, or 1 if the spell doesn't have charges (or undefined if there is no such spellInfo)\r\n   */\r\n  getMaxCharges(spellId: number) {\r\n    const ability = this.getAbility(spellId);\r\n    return ability ? (ability.charges || 1) : undefined;\r\n  }\r\n\r\n  /**\r\n   * Returns the timeline sort index, or null if none is set. (or undefined if there is no such spellInfo)\r\n   */\r\n  getTimelineSortIndex(spellId: number) {\r\n    const ability = this.getAbility(spellId);\r\n    return ability ? ability.timelineSortIndex : undefined;\r\n  }\r\n}\r\n\r\nexport default Abilities;\r\n","import SPELLS from 'common/SPELLS';\r\nimport { formatPercentage } from 'common/format';\r\nimport Analyzer, { Options, SELECTED_PLAYER } from 'parser/core/Analyzer';\r\nimport EventEmitter from 'parser/core/modules/EventEmitter';\r\nimport Events, { AnyEvent, CastEvent, ChangeHasteEvent, EventType, FilterCooldownInfoEvent, UpdateSpellUsableEvent } from 'parser/core/Events';\r\n\r\nimport Abilities from '../../core/modules/Abilities';\r\n\r\nconst debug = false;\r\nexport const INVALID_COOLDOWN_CONFIG_LAG_MARGIN = 150; // not sure what this is based around, but <150 seems to catch most false positives\r\nlet fullExplanation = true;\r\n\r\nfunction spellName(spellId: number) {\r\n  return SPELLS[spellId] ? SPELLS[spellId].name : '???';\r\n}\r\n\r\ntype CooldownInfo = {\r\n  start: number,\r\n  chargesOnCooldown: number,\r\n  expectedDuration: number,\r\n  totalReductionTime: number,\r\n  cooldownTriggerEvent: AnyEvent,\r\n}\r\n/**\r\n * @property {EventEmitter} eventEmitter\r\n * @property {Abilities} abilities\r\n */\r\nclass SpellUsable extends Analyzer {\r\n  static dependencies = {\r\n    eventEmitter: EventEmitter,\r\n    abilities: Abilities,\r\n  };\r\n  protected eventEmitter!: EventEmitter;\r\n  protected abilities!: Abilities;\r\n\r\n  _currentCooldowns: { [spellId: number]: CooldownInfo } = {};\r\n  _errors = 0;\r\n\r\n  get errorsPerMinute() {\r\n    const minutesElapsed = (this.owner.fightDuration / 1000) / 60;\r\n    return this._errors / minutesElapsed;\r\n  }\r\n\r\n  get isAccurate() {\r\n    return this.errorsPerMinute < 1.5;\r\n  }\r\n\r\n  constructor(options: Options){\r\n    super(options);\r\n    this.addEventListener(Events.any, this.onEvent);\r\n    this.addEventListener(Events.cast.by(SELECTED_PLAYER), this.onCast);\r\n    this.addEventListener(Events.prefiltercd.by(SELECTED_PLAYER), this.onCast);\r\n    this.addEventListener(Events.ChangeHaste, this.onChangehaste);\r\n    this.addEventListener(Events.fightend, this.onFightend);\r\n  }\r\n\r\n  /**\r\n   * Find the canonical spell id of an ability. For most abilities, this\r\n   * is just the spell ID. For abilities with shared CDs / charges, this is\r\n   * the first ability in the list of abilities that share with it.\r\n   */\r\n  _getCanonicalId(spellId: number) {\r\n    const ability = this.abilities.getAbility(spellId);\r\n    if (!ability) {\r\n      return spellId; // not a class ability\r\n    }\r\n    if (ability.spell instanceof Array) {\r\n      return ability.spell[0].id;\r\n    } else {\r\n      return ability.spell.id;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Whether the spell can be cast. This is not the opposite of `isOnCooldown`!\r\n   * A spell with 2 charges, 1 available and 1 on cooldown would be both\r\n   * available and on cooldown at the same time\r\n   */\r\n  isAvailable(spellId: number) {\r\n    const canSpellId = this._getCanonicalId(spellId);\r\n    if (!this.isOnCooldown(canSpellId)) {\r\n      return true;\r\n    }\r\n    const maxCharges = this.abilities.getMaxCharges(canSpellId) || 1;\r\n    if (maxCharges > this._currentCooldowns[canSpellId].chargesOnCooldown) {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * For abilities with charges, gets the number of charges currently available.\r\n   * @param spellId An ability spell id.\r\n   * @returns The number of charges available for the given spell.\r\n   * @throws Error if no ability definition found.\r\n   */\r\n  chargesAvailable(spellId: number) {\r\n    const canSpellId = this._getCanonicalId(spellId);\r\n    const maxCharges = this.abilities.getMaxCharges(canSpellId) || 1;\r\n    if (this.isOnCooldown(canSpellId)) {\r\n      return maxCharges - this._currentCooldowns[canSpellId].chargesOnCooldown;\r\n    } else {\r\n      return maxCharges;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Whether the spell is on cooldown. If a spell has multiple charges with 1 charge on cooldown and 1 available, this will return `true`. Use `isAvailable` if you just want to know if a spell is castable. Use this if you want to know if a spell is current cooling down, regardless of being able to cast it.\r\n   */\r\n  isOnCooldown(spellId: number) {\r\n    const canSpellId = this._getCanonicalId(spellId);\r\n    return Boolean(this._currentCooldowns[canSpellId]);\r\n  }\r\n\r\n  /**\r\n   * Returns the amount of time remaining on the cooldown.\r\n   * @param {number} spellId\r\n   * @param {number} timestamp Override the timestamp if it may be different from the current timestamp.\r\n   * @returns {number}\r\n   */\r\n  cooldownRemaining(spellId: number, timestamp = this.owner.currentTimestamp) {\r\n    const canSpellId = this._getCanonicalId(spellId);\r\n    if (!this.isOnCooldown(canSpellId)) {\r\n      throw new Error(`Tried to retrieve the remaining cooldown of ${canSpellId}, but it's not on cooldown.`);\r\n    }\r\n    const cooldown = this._currentCooldowns[canSpellId];\r\n    const expectedEnd = Math.round(cooldown.start + cooldown.expectedDuration - cooldown.totalReductionTime);\r\n    return expectedEnd - timestamp;\r\n  }\r\n\r\n  cooldownTriggerEvent(spellId: number) {\r\n    const canSpellId = this._getCanonicalId(spellId);\r\n    if (!this.isOnCooldown(canSpellId)) {\r\n      throw new Error(`Tried to retrieve the remaining cooldown of ${canSpellId}, but it's not on cooldown.`);\r\n    }\r\n    const cooldown = this._currentCooldowns[canSpellId];\r\n    return cooldown.cooldownTriggerEvent;\r\n  }\r\n\r\n  /**\r\n   * Start the cooldown for the provided spell.\r\n   * @param {number} spellId The ID of the spell.\r\n   * @param {object} cooldownTriggerEvent Which event triggered the cooldown. This MUST include a timestamp. This is used by potions to determine if it was a prepull cast, but may be used for other things too.\r\n   */\r\n  beginCooldown(spellId: number, cooldownTriggerEvent: AnyEvent) {\r\n    if (process.env.NODE_ENV === 'development') {\r\n      if (cooldownTriggerEvent.timestamp === undefined) {\r\n        throw new Error('cooldownTriggerEvent must at least have a timestamp property.');\r\n      }\r\n    }\r\n\r\n    const canSpellId = this._getCanonicalId(spellId);\r\n    const expectedCooldownDuration = this.abilities.getExpectedCooldownDuration(canSpellId, cooldownTriggerEvent);\r\n    if (!expectedCooldownDuration) {\r\n      debug && this.warn('Spell', spellName(canSpellId), canSpellId, 'doesn\\'t have a cooldown.');\r\n      return;\r\n    }\r\n\r\n    if (!this.isOnCooldown(canSpellId)) {\r\n      this._currentCooldowns[canSpellId] = {\r\n        start: cooldownTriggerEvent.timestamp,\r\n        cooldownTriggerEvent,\r\n        expectedDuration: expectedCooldownDuration,\r\n        totalReductionTime: 0,\r\n        chargesOnCooldown: 1,\r\n      };\r\n      this._triggerEvent(this._makeEvent(canSpellId, cooldownTriggerEvent.timestamp, EventType.BeginCooldown));\r\n    } else {\r\n      if (this.isAvailable(canSpellId)) {\r\n        // Another charge is available\r\n        this._currentCooldowns[canSpellId].chargesOnCooldown += 1;\r\n        this._triggerEvent(this._makeEvent(canSpellId, cooldownTriggerEvent.timestamp, EventType.AddCooldownCharge));\r\n      } else {\r\n        const remainingCooldown = this.cooldownRemaining(canSpellId, cooldownTriggerEvent.timestamp);\r\n        if (remainingCooldown > INVALID_COOLDOWN_CONFIG_LAG_MARGIN) {\r\n          // No need to report if it was expected to reset within the set margin, as latency can cause this fluctuation.\r\n          // Count errors so we can disable features if this exceeds a threshold\r\n          this._errors += 1;\r\n          // Only mention reduction times if applicable (this is pretty rare)\r\n          const reductionInfo = this._currentCooldowns[canSpellId].totalReductionTime > 0 ? [\r\n            'totalReductionTime:', this._currentCooldowns[canSpellId].totalReductionTime,\r\n            'adjusted expected duration:', this._currentCooldowns[canSpellId].expectedDuration - this._currentCooldowns[canSpellId].totalReductionTime,\r\n          ] : [];\r\n          if (fullExplanation) {\r\n            this.error('A cooldown error has occured. The most likely cause is missing a Haste buff, but the cooldown might also have multiple charges, can be reset early, cooldown can be reduced, the configured CD is invalid, the combatlog records multiple casts per player cast (e.g. ticks of a channel) or this is a latency issue. There\\'s already handling for latency, but if it\\'s extremely high, there might still be false positives. But usually it\\'s a Haste issue.');\r\n          }\r\n          this.error(\r\n            spellName(canSpellId), canSpellId, 'was cast while already marked as on cooldown.',\r\n            'time passed:', (cooldownTriggerEvent.timestamp - this._currentCooldowns[canSpellId].start),\r\n            'cooldown remaining:', remainingCooldown,\r\n            'expectedDuration:', this._currentCooldowns[canSpellId].expectedDuration,\r\n            ...reductionInfo,\r\n          );\r\n          fullExplanation = false;\r\n        }\r\n        this.endCooldown(canSpellId, false, cooldownTriggerEvent.timestamp);\r\n        this.beginCooldown(canSpellId, cooldownTriggerEvent);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Finishes the cooldown for the provided spell.\r\n   * @param {number} spellId The ID of the spell.\r\n   * @param {boolean} resetAllCharges Whether all charges should be reset or just the last stack. Does nothing for spells with just 1 stack.\r\n   * @param {number} timestamp Override the timestamp if it may be different from the current timestamp.\r\n   * @param {number} remainingCDR For abilities with charges, the remaining cooldown reduction if the reduction is more than the remaining cooldown of the charge and more than 1 charge is on cooldown\r\n   * @returns {*}\r\n   */\r\n  endCooldown(spellId: number, resetAllCharges = false, timestamp = this.owner.currentTimestamp, remainingCDR = 0): number {\r\n    const canSpellId = this._getCanonicalId(spellId);\r\n    if (!this.isOnCooldown(canSpellId)) {\r\n      // We want implementers to check this themselves so they *have* to think about how to handle it properly in whatever module they're working on.\r\n      throw new Error(`Tried to end the cooldown of ${canSpellId}, but it's not on cooldown.`);\r\n    }\r\n\r\n    const cooldown = this._currentCooldowns[canSpellId];\r\n    if (cooldown.chargesOnCooldown === 1 || resetAllCharges) {\r\n      delete this._currentCooldowns[canSpellId];\r\n      this._triggerEvent(this._makeEvent(canSpellId, timestamp, EventType.EndCooldown, {\r\n        ...cooldown,\r\n        end: timestamp,\r\n      }));\r\n      return 0;\r\n    } else {\r\n      // We have another charge ready to go on cooldown, this simply adds a charge and then refreshes the cooldown (spells with charges don't cooldown simultaneously)\r\n      cooldown.chargesOnCooldown -= 1;\r\n      this._triggerEvent(this._makeEvent(canSpellId, timestamp, EventType.RestoreCharge, cooldown));\r\n      this.refreshCooldown(canSpellId, {\r\n        timestamp,\r\n      });\r\n      if (remainingCDR !== 0) {\r\n        return this.reduceCooldown(canSpellId, remainingCDR, timestamp);\r\n      }\r\n    }\r\n    return 0;\r\n  }\r\n\r\n  /**\r\n   * Refresh (restart) the cooldown for the provided spell.\r\n   * @param {number} spellId The ID of the spell.\r\n   * @param {object} cooldownTriggerEvent Which event triggered the cooldown. This MUST include a timestamp. This is used by potions to determine if it was a prepull cast, but may be used for other things too.\r\n   */\r\n  refreshCooldown(spellId: number, cooldownTriggerEvent: { timestamp: number }) {\r\n    const canSpellId = this._getCanonicalId(spellId);\r\n    if (!this.isOnCooldown(canSpellId)) {\r\n      throw new Error(`Tried to refresh the cooldown of ${canSpellId}, but it's not on cooldown.`);\r\n    }\r\n    const expectedCooldownDuration = this.abilities.getExpectedCooldownDuration(canSpellId);\r\n    if (!expectedCooldownDuration) {\r\n      debug && this.warn('Spell', spellName(canSpellId), canSpellId, 'doesn\\'t have a cooldown.');\r\n      return;\r\n    }\r\n\r\n    this._currentCooldowns[canSpellId].start = cooldownTriggerEvent.timestamp;\r\n    this._currentCooldowns[canSpellId].expectedDuration = expectedCooldownDuration;\r\n    this._currentCooldowns[canSpellId].totalReductionTime = 0;\r\n    this._triggerEvent(this._makeEvent(canSpellId, cooldownTriggerEvent.timestamp, EventType.RefreshCooldown));\r\n  }\r\n\r\n  /**\r\n   * Reduces the cooldown for the provided spell by the provided duration.\r\n   * @param {number} spellId The ID of the spell.\r\n   * @param {number} reductionMs The duration to reduce the cooldown with, in milliseconds.\r\n   * @param {number} timestamp Override the timestamp if it may be different from the current timestamp.\r\n   * @returns {number}\r\n   */\r\n  reduceCooldown(spellId: number, reductionMs: number, timestamp = this.owner.currentTimestamp) {\r\n    const canSpellId = this._getCanonicalId(spellId);\r\n    if (!this.isOnCooldown(canSpellId)) {\r\n      throw new Error(`Tried to reduce the cooldown of ${canSpellId}, but it's not on cooldown.`);\r\n    }\r\n    const cooldownRemaining = this.cooldownRemaining(canSpellId, timestamp);\r\n    if (cooldownRemaining < reductionMs) {\r\n      const remainingCDR = reductionMs - cooldownRemaining;\r\n      return cooldownRemaining + this.endCooldown(canSpellId, false, timestamp, remainingCDR);\r\n    } else {\r\n      this._currentCooldowns[canSpellId].totalReductionTime += reductionMs;\r\n      debug && this.log('Reduced', spellName(canSpellId), canSpellId, 'by', reductionMs, 'remaining:', this.cooldownRemaining(canSpellId, timestamp), 'old:', cooldownRemaining, 'new expected duration:', this._currentCooldowns[canSpellId].expectedDuration - this._currentCooldowns[canSpellId].totalReductionTime, 'total CDR:', this._currentCooldowns[canSpellId].totalReductionTime);\r\n      return reductionMs;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Extends the cooldown for the provided spell by the provided duration.\r\n   * @param {any} spellId The ID of the spell.\r\n   * @param {number} extensionMS The duration to extend the cooldown with, in milliseconds.\r\n   * @param {number} timestamp Override the timestamp if it may be different from the current timestamp.\r\n   * @returns {*}\r\n   */\r\n  extendCooldown(spellId: number, extensionMS: number, timestamp = this.owner.currentTimestamp) {\r\n    const canSpellId = this._getCanonicalId(spellId);\r\n    if (!this.isOnCooldown(canSpellId)) {\r\n      throw new Error(`Tried to extend the cooldown of ${canSpellId}, but it's not on cooldown.`);\r\n    }\r\n    const cooldownRemaining = this.cooldownRemaining(canSpellId, timestamp);\r\n    this._currentCooldowns[canSpellId].totalReductionTime -= extensionMS;\r\n    debug && this.log('Extended', spellName(canSpellId), canSpellId, 'by', extensionMS, 'remaining:', this.cooldownRemaining(canSpellId, timestamp), 'old:', cooldownRemaining, 'new expected duration:', this._currentCooldowns[canSpellId].expectedDuration - this._currentCooldowns[canSpellId].totalReductionTime, 'total extension:', -this._currentCooldowns[canSpellId].totalReductionTime);\r\n    return extensionMS;\r\n  }\r\n\r\n  _makeEvent(spellId: number, timestamp: number, trigger: UpdateSpellUsableEvent['trigger'], others = {}): UpdateSpellUsableEvent {\r\n    const cooldown = this._currentCooldowns[spellId];\r\n    const chargesOnCooldown = cooldown ? cooldown.chargesOnCooldown : 0;\r\n    const ability = this.abilities.getAbility(spellId);\r\n    const maxCharges = this.abilities.getMaxCharges(spellId) || 1;\r\n    const spell = SPELLS[spellId];\r\n\r\n    return {\r\n      type: EventType.UpdateSpellUsable,\r\n      ability: {\r\n        guid: spellId,\r\n        name: spell ? spell.name : undefined,\r\n        abilityIcon: spell ? spell.icon : undefined,\r\n      },\r\n      name: ability ? ability.name : undefined,\r\n      trigger,\r\n      timestamp,\r\n      isOnCooldown: this.isOnCooldown(spellId),\r\n      isAvailable: this.isAvailable(spellId),\r\n      chargesAvailable: maxCharges - chargesOnCooldown,\r\n      maxCharges,\r\n      timePassed: cooldown ? timestamp - cooldown.start : undefined,\r\n      sourceID: this.owner.playerId,\r\n      targetIsFriendly: true,\r\n      targetID: this.owner.playerId,\r\n      // __fabricated is technically added in eventemitter, but it makes typing much simpler to add it here\r\n      __fabricated: true,\r\n      ...cooldown,\r\n      ...others,\r\n    };\r\n  }\r\n\r\n  _triggerEvent(event: UpdateSpellUsableEvent) {\r\n    if (debug) {\r\n      const spellId = event.ability.guid;\r\n      switch (event.trigger) {\r\n        case EventType.BeginCooldown:\r\n          this.log('Cooldown started:', spellName(spellId), spellId, 'expected duration:', event.expectedDuration, `(charges on cooldown: ${this._currentCooldowns[spellId].chargesOnCooldown})`);\r\n          break;\r\n        case EventType.AddCooldownCharge:\r\n          this.log('Used another charge:', spellName(spellId), spellId, `(charges on cooldown: ${this._currentCooldowns[spellId].chargesOnCooldown})`);\r\n          break;\r\n        case EventType.RefreshCooldown:\r\n          this.log('Cooldown refreshed:', spellName(spellId), spellId);\r\n          break;\r\n        case EventType.RestoreCharge:\r\n          this.log('Charge restored:', spellName(spellId), spellId, `(charges left on cooldown: ${this._currentCooldowns[spellId].chargesOnCooldown})`);\r\n          break;\r\n        case EventType.EndCooldown:\r\n          this.log('Cooldown finished:', spellName(spellId), spellId);\r\n          break;\r\n        default:\r\n          break;\r\n      }\r\n    }\r\n\r\n    this.eventEmitter.fabricateEvent(event);\r\n  }\r\n\r\n  onCast(event: CastEvent | FilterCooldownInfoEvent) {\r\n    const spellId = event.ability.guid;\r\n    this.beginCooldown(spellId, event);\r\n  }\r\n\r\n  _checkCooldownExpiry(timestamp: number) {\r\n    Object.keys(this._currentCooldowns).map(Number).forEach(spellId => {\r\n      const remainingDuration = this.cooldownRemaining(spellId, timestamp);\r\n      if (remainingDuration <= 0) {\r\n        const cooldown = this._currentCooldowns[spellId];\r\n        const expectedEnd = Math.round(cooldown.start + cooldown.expectedDuration - cooldown.totalReductionTime);\r\n        debug && this.log('Clearing', spellName(spellId), spellId, 'due to expiry');\r\n        this.endCooldown(Number(spellId), false, expectedEnd);\r\n      }\r\n    });\r\n  }\r\n\r\n  _lastTimestamp: number = -1;\r\n\r\n  onEvent(event: AnyEvent) {\r\n    const timestamp = (event && event.timestamp) || this.owner.currentTimestamp;\r\n    //if cast event from previous phase was found, add it to the cooldown tracker without adding it to the phase itself\r\n    if (event.type === EventType.FilterCooldownInfo && timestamp === this._lastTimestamp) {\r\n      return;\r\n    }\r\n    this._lastTimestamp = timestamp;\r\n    this._checkCooldownExpiry(timestamp);\r\n  }\r\n\r\n  // Haste-based cooldowns gets longer/shorter when your Haste changes\r\n  // `newDuration = timePassed + (newCooldownDuration * (1 - progress))` (where `timePassed` is the time since the spell went on cooldown, `newCooldownDuration` is the full cooldown duration based on the new Haste, `progress` is the percentage of progress cooling down the spell)\r\n  onChangehaste(event: ChangeHasteEvent) {\r\n    Object.keys(this._currentCooldowns).map(Number).forEach(spellId => {\r\n      const cooldown = this._currentCooldowns[spellId];\r\n      const originalExpectedDuration = cooldown.expectedDuration;\r\n      const cooldownTriggerEvent = cooldown.cooldownTriggerEvent;\r\n\r\n      const timePassed = event.timestamp - cooldown.start;\r\n      const progress = timePassed / originalExpectedDuration;\r\n\r\n      const cooldownDurationWithCurrentHaste = this.abilities.getExpectedCooldownDuration(Number(spellId), cooldownTriggerEvent);\r\n      if (cooldownDurationWithCurrentHaste === undefined) {\r\n        throw new Error(`Attempting to get cooldown duration for spell with no ability info: ${spellId}`);\r\n      }\r\n      // The game only works with integers so round the new expected duration\r\n      const newExpectedDuration = Math.round(timePassed + this._calculateNewCooldownDuration(progress, cooldownDurationWithCurrentHaste));\r\n      // NOTE: This does NOT scale any cooldown reductions applicable, their reduction time is static. (confirmed for absolute reductions (1.5 seconds), percentual reductions might differ but it is unlikely)\r\n\r\n      cooldown.expectedDuration = newExpectedDuration;\r\n\r\n      debug && this.log('Adjusted', spellName(spellId), spellId, 'cooldown duration due to Haste change; old duration without CDRs:', originalExpectedDuration, 'CDRs:', cooldown.totalReductionTime, 'time expired:', timePassed, 'progress:', `${formatPercentage(progress)}%`, 'cooldown duration with current Haste:', cooldownDurationWithCurrentHaste, '(without CDRs)', 'actual new expected duration:', newExpectedDuration, '(without CDRs)');\r\n    });\r\n  }\r\n\r\n  onFightend() {\r\n    const timestamp = this.owner.fight.end_time;\r\n    // Get the remaining cooldowns in order of expiration\r\n    const expiringCooldowns = Object.keys(this._currentCooldowns).map(Number).map(spellId => {\r\n      const remainingDuration = this.cooldownRemaining(spellId, timestamp);\r\n      return {\r\n        spellId,\r\n        remainingDuration,\r\n      };\r\n    }).sort((a, b) => a.remainingDuration - b.remainingDuration);\r\n    // Expire them\r\n    expiringCooldowns.forEach(({ spellId }) => {\r\n      const cooldown = this._currentCooldowns[spellId];\r\n      const expectedEnd = Math.round(cooldown.start + cooldown.expectedDuration - cooldown.totalReductionTime);\r\n      debug && this.log('Clearing', spellName(spellId), spellId, 'due to fightend');\r\n      this.endCooldown(Number(spellId), false, expectedEnd);\r\n    });\r\n  }\r\n\r\n  _calculateNewCooldownDuration(progress: number, newDuration: number) {\r\n    return newDuration * (1 - progress);\r\n  }\r\n}\r\n\r\nexport default SpellUsable;\r\n","import RESOURCE_TYPES from 'game/RESOURCE_TYPES';\r\nimport Analyzer, { Options, SELECTED_PLAYER, SELECTED_PLAYER_PET } from 'parser/core/Analyzer';\r\nimport Events, { Ability, AbsorbedEvent, CastEvent, DamageEvent, EventType, HealEvent } from 'parser/core/Events';\r\nimport HIT_TYPES from 'game/HIT_TYPES';\r\n\r\nimport SpellManaCost from './SpellManaCost';\r\n\r\nexport interface TrackedAbility {\r\n  ability: Ability | null;\r\n  casts: number;\r\n  manaUsed: number;\r\n  damageHits: number;\r\n  damageEffective: number;\r\n  damageAbsorbed: number;\r\n  damageCriticalHits: number;\r\n  damageCriticalEffective: number;\r\n  damageCriticalAbsorbed: number;\r\n  healingHits: number;\r\n  healingEffective: number;\r\n  healingAbsorbed: number;\r\n  healingOverheal: number;\r\n  healingCriticalHits: number;\r\n  healingCriticalEffective: number;\r\n  healingCriticalAbsorbed: number;\r\n  healingCriticalOverheal: number;\r\n}\r\n\r\nclass AbilityTracker extends Analyzer {\r\n  static dependencies = {\r\n    // Needed for the `resourceCost` prop of events\r\n    spellManaCost: SpellManaCost,\r\n  };\r\n  protected spellManaCost!: SpellManaCost;\r\n\r\n  abilities = new Map<number, TrackedAbility>();\r\n\r\n  constructor(options: Options){\r\n    super(options);\r\n    this.addEventListener(Events.cast.by(SELECTED_PLAYER), this.onCast);\r\n  }\r\n\r\n  onCast(event: CastEvent) {\r\n    const spellId = event.ability.guid;\r\n\r\n    const cast = this.getAbility(spellId, event.ability);\r\n    cast.casts = cast.casts + 1;\r\n    if (event.resourceCost && event.resourceCost[RESOURCE_TYPES.MANA.id] !== undefined) {\r\n      cast.manaUsed = cast.manaUsed + event.resourceCost[RESOURCE_TYPES.MANA.id];\r\n    }\r\n  }\r\n\r\n  getAbility(spellId: number, abilityInfo: Ability | null = null) {\r\n    let ability = this.abilities.get(spellId);\r\n    if (ability === undefined) {\r\n      ability = {\r\n        ability: abilityInfo,\r\n        casts: 0,\r\n        manaUsed: 0,\r\n        damageHits: 0,\r\n        damageEffective: 0,\r\n        damageAbsorbed: 0,\r\n        damageCriticalHits: 0,\r\n        damageCriticalEffective: 0,\r\n        damageCriticalAbsorbed: 0,\r\n        healingHits: 0,\r\n        healingEffective: 0,\r\n        healingAbsorbed: 0,\r\n        healingOverheal: 0,\r\n        healingCriticalHits: 0,\r\n        healingCriticalEffective: 0,\r\n        healingCriticalAbsorbed: 0,\r\n        healingCriticalOverheal: 0\r\n      };\r\n      this.abilities.set(spellId, ability);\r\n    }\r\n    if (!ability.ability && abilityInfo) {\r\n      ability.ability = abilityInfo;\r\n    }\r\n    return ability;\r\n  }\r\n}\r\n\r\nclass HealingTracker extends AbilityTracker {\r\n  constructor(options: Options) {\r\n    super(options);\r\n    this.addEventListener(Events.heal.by(SELECTED_PLAYER), this.onHeal);\r\n    this.addEventListener(Events.absorbed.by(SELECTED_PLAYER), this.onHeal);\r\n    this.addEventListener(Events.heal.by(SELECTED_PLAYER_PET), this.onHeal);\r\n    this.addEventListener(Events.absorbed.by(SELECTED_PLAYER_PET), this.onHeal);\r\n  }\r\n\r\n  onHeal(event: HealEvent | AbsorbedEvent) {\r\n    const spellId = event.ability.guid;\r\n    const cast = this.getAbility(spellId, event.ability);\r\n\r\n    cast.healingHits = cast.healingHits + 1;\r\n    // TODO: Use HealingValue class\r\n    cast.healingEffective = cast.healingEffective + (event.amount || 0);\r\n    if (event.type === EventType.Heal) {\r\n      cast.healingAbsorbed = cast.healingAbsorbed + (event.absorbed || 0);\r\n      cast.healingOverheal = cast.healingOverheal + (event.overheal || 0);\r\n      if (event.hitType === HIT_TYPES.CRIT) {\r\n        cast.healingCriticalHits = cast.healingCriticalHits + 1;\r\n        cast.healingCriticalEffective = cast.healingCriticalEffective + (event.amount || 0);\r\n        cast.healingCriticalAbsorbed = cast.healingCriticalAbsorbed + (event.absorbed || 0);\r\n        cast.healingCriticalOverheal = cast.healingCriticalOverheal + (event.overheal || 0);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nclass DamageTracker extends HealingTracker {\r\n  constructor(options: Options) {\r\n    super(options);\r\n    this.addEventListener(Events.damage.by(SELECTED_PLAYER), this.onDamage);\r\n  }\r\n\r\n  onDamage(event: DamageEvent) {\r\n    const spellId = event.ability.guid;\r\n    const cast = this.getAbility(spellId, event.ability);\r\n\r\n    cast.damageHits = cast.damageHits + 1;\r\n    // TODO: Use DamageValue class\r\n    cast.damageEffective = cast.damageEffective + (event.amount || 0);\r\n    cast.damageAbsorbed = cast.damageAbsorbed + (event.absorbed || 0); // Not sure\r\n\r\n    const isCrit = event.hitType === HIT_TYPES.CRIT;\r\n    if (isCrit) {\r\n      cast.damageCriticalHits = cast.damageCriticalHits + 1;\r\n      cast.damageCriticalEffective = cast.damageCriticalEffective + (event.amount || 0);\r\n      cast.damageCriticalAbsorbed = cast.damageCriticalAbsorbed + (event.absorbed || 0); // Not sure\r\n    }\r\n  }\r\n}\r\n\r\nexport default DamageTracker;\r\n","import Enemy from 'parser/core/Enemy';\r\nimport { TrackedBuffEvent } from 'parser/core/Entity';\r\nimport { AnyEvent, HasTarget } from 'parser/core/Events';\r\n\r\nimport Entities from './Entities';\r\n\r\nconst debug = false;\r\n\r\ntype EnemyBuffHistory = {\r\n  start: number,\r\n  end: number,\r\n}\r\nclass Enemies extends Entities<Enemy> {\r\n  enemies: { [enemyId: number]: Enemy } = {};\r\n\r\n  getEntities() {\r\n    return this.enemies;\r\n  }\r\n\r\n  /**\r\n   * @param {object} event\r\n   * @returns {Enemy|null}\r\n   */\r\n  getEntity(event: AnyEvent): Enemy | null {\r\n    if (!HasTarget(event)) {\r\n      return null;\r\n    }\r\n    if (event.targetIsFriendly) {\r\n      return null;\r\n    }\r\n    const targetId = event.targetID;\r\n    let enemy = this.enemies[targetId];\r\n    if (!enemy) {\r\n      const baseInfo = this.owner.report.enemies.find((enemy: { id: number }) => enemy.id === targetId);\r\n      if (!baseInfo) {\r\n        debug && console.warn('Enemy not noteworthy enough:', targetId, event);\r\n        return null;\r\n      }\r\n      this.enemies[targetId] = enemy = new Enemy(this.owner, baseInfo);\r\n    }\r\n    return enemy;\r\n  }\r\n\r\n  /**\r\n   * Gets the combined history of multiple debuffs. Works exactly like `getDebuffHistory` but this is meant to be used with multiple debuff IDs that are regarded as \"same\".\r\n   * A perfect example is Unstable Affliction - while being a single spell, it applies up to 5 different debuffs to the same target\r\n   * @param spellIds Variable number of debuff IDs\r\n   * @returns {Array} Combined debuff history for the debuffs\r\n   */\r\n  getCombinedDebuffHistory(spellIds: number[]) {\r\n    const events: EnemyBuffHistory[] = [];\r\n    spellIds.forEach(spellId => {\r\n      events.push(...this.getDebuffHistory(spellId));\r\n    });\r\n\r\n    const history = [];\r\n    let current: EnemyBuffHistory | null = null;\r\n    events.sort((a, b) => a.start - b.start)\r\n      .forEach(event => {\r\n        if (current === null) {\r\n          current = event;\r\n        } else {\r\n          /*\r\n           As, Ae = start, end of current buff A\r\n           Bs, Be = start, end of another buff B\r\n\r\n           3 situations can occur with 2 buffs A and B:\r\n\r\n           1) B is \"inside\" A\r\n             As ----- Bs ---- Be ---- Ae\r\n             do nothing\r\n           2) B is completely \"outside\" A\r\n             As --- Ae --- Bs --- Be\r\n             push A into history, current = B\r\n           3) B overlaps A and ends later\r\n             As --- Bs --- Ae --- Be\r\n             set current end to Be (current: As - Be)\r\n          */\r\n          if (current.end <= event.start) {\r\n            // situation 2\r\n            history.push(current);\r\n            current = event;\r\n          } else if (event.start <= current.end && current.end < event.end) {\r\n            // situation 3\r\n            current.end = event.end;\r\n          }\r\n        }\r\n      });\r\n    // the latest processed event doesn't get added to history, push it\r\n    history.push(current);\r\n    return history;\r\n  }\r\n\r\n  /**\r\n   * Gets history of the debuff given by the argument. Returns an array of objects with properties `start` and `end` (both timestamps), so we know when certain debuff was active (on any enemy) and when it dropped. Used e.g. with <UptimeBar />\r\n   * @param spellId ID of the debuff\r\n   * @returns {Array} History of the debuff\r\n   */\r\n  getDebuffHistory(spellId: number): EnemyBuffHistory[] {\r\n    type TempBuffInfo = {\r\n      timestamp: number,\r\n      type: 'apply' | 'remove',\r\n      buff: TrackedBuffEvent,\r\n    };\r\n    const events: TempBuffInfo[] = [];\r\n    const enemies = this.getEntities();\r\n    Object.values(enemies)\r\n      .forEach(enemy => {\r\n        enemy.getBuffHistory(spellId, this.owner.playerId)\r\n          .forEach(buff => {\r\n            events.push({\r\n              timestamp: buff.start,\r\n              type: 'apply',\r\n              buff,\r\n            });\r\n            events.push({\r\n              timestamp: buff.end !== null ? buff.end : this.owner.currentTimestamp, // buff end is null if it's still active, it can also be 0 if buff ended at pull\r\n              type: 'remove',\r\n              buff,\r\n            });\r\n          });\r\n      });\r\n\r\n    const history: EnemyBuffHistory[] = [];\r\n    let current: EnemyBuffHistory | null = null;\r\n    let active = 0;\r\n    events.sort((a, b) => a.timestamp - b.timestamp)\r\n      .forEach(event => {\r\n        if (event.type === 'apply') {\r\n          if (current === null) {\r\n            current = { start: event.timestamp, end: this.owner.currentTimestamp };\r\n          }\r\n          active += 1;\r\n        }\r\n        if (event.type === 'remove') {\r\n          active -= 1;\r\n          if (active === 0) {\r\n            // We know for a fact that there will be a temp 'apply' before a temp 'remove'\r\n            // because of the previous forEach, so its safe to non-null assert these\r\n            current!.end = event.timestamp;\r\n            history.push(current!);\r\n            current = null;\r\n          }\r\n        }\r\n      });\r\n    // if buff lasted till end of combat, maybe doesn't ever happen due to some normalizing\r\n    if (current !== null) {\r\n      history.push(current);\r\n    }\r\n    return history;\r\n  }\r\n}\r\n\r\nexport default Enemies;\r\n","import { AnyEvent, HasTarget } from 'parser/core/Events';\r\nimport { Options } from 'parser/core/Module';\r\nimport Combatant from 'parser/core/Combatant';\r\n\r\nimport Entities from './Entities';\r\n\r\nclass Combatants extends Entities<Combatant> {\r\n  players: { [playerId: number]: Combatant } = {};\r\n  get playerCount() {\r\n    return Object.keys(this.players).length;\r\n  }\r\n  getEntities() {\r\n    return this.players;\r\n  }\r\n  getEntity(event: AnyEvent) {\r\n    if (!HasTarget(event)) {\r\n      return null;\r\n    }\r\n    const combatant = this.players[event.targetID];\r\n    if (!combatant) {\r\n      return null; // a pet or something probably, either way we don't care.\r\n    }\r\n    return combatant;\r\n  }\r\n\r\n  _selected: Combatant;\r\n  /** @returns Combatant */\r\n  get selected() {\r\n    return this._selected;\r\n  }\r\n\r\n  constructor(options: Options) {\r\n    super(options);\r\n    this.owner.combatantInfoEvents.forEach(combatantInfo => {\r\n      if (combatantInfo.error) {\r\n        console.error(`Error retrieving combatant information for player with sourceID ${combatantInfo.sourceID}`);\r\n        return;\r\n      }\r\n\r\n      this.players[combatantInfo.sourceID] = new Combatant(this.owner, combatantInfo);\r\n    });\r\n    this._selected = this.players[this.owner.playerId];\r\n  }\r\n}\r\n\r\nexport default Combatants;\r\n","import SPELLS from 'common/SPELLS';\r\n\r\n//region Core\r\n/** Abilities */\r\n//A simple function to calculate hasted cooldowns\r\nexport const hastedCooldown = (baseCD: number, haste: number) => (baseCD / (1 + haste));\r\n/** GCDs */\r\n//Hunter GCDs don't go below 750ms\r\nexport const MIN_GCD = 750;\r\n//Hunter GCDs don't go above 1500ms\r\nexport const MAX_GCD = 1500;\r\n/** MS Buffers */\r\n//A 100ms buffer is standard to use since logs aren't precise to the millisecond for events\r\nexport const MS_BUFFER = 100;\r\n//Whenever we ned to use 1 second buffers\r\nexport const ONE_SECOND_IN_MS = 1000;\r\n//Whenever we need to use a buffer that is slightly above that of the maximum GCD\r\nexport const OVER_1_GCD_BUFFER = 2000;\r\n/** Death Tracker */\r\n//The override we use in the hunter version of the Death Tracker that allows for a hunter to be dead for 0.25% of an encounter without it counting towards death time as it could just be Feign Death\r\nexport const TIME_SPENT_DEAD_THRESHOLD = 0.0025; //0.25%\r\n//endregion\r\n\r\n//region Spells\r\n/** Kill Shot */\r\n//Kill Shot is castable on enemies sub 20% hp\r\nexport const KILL_SHOT_EXECUTE_RANGE = 0.2;\r\n/** Multi Shot */\r\n//List of Multi Shots for use in Rapid Reload module\r\nexport const MULTI_SHOTS_LIST = [\r\n  SPELLS.MULTISHOT_BM,\r\n  SPELLS.MULTISHOT_MM,\r\n];\r\n/** Aspects */\r\n//This is the baseline cooldown of Aspect of the Turtle / Cheetah\r\nexport const BASELINE_TURTLE_CHEETAH_CD = 180000;\r\n/** Dire Beast (and also Dire Consequences) */\r\n//Dire Beast (and therefore also Dire Consequences) increases haste by 5% while active\r\nexport const DIRE_BEAST_HASTE_PERCENT = 0.05;\r\n//endregion\r\n\r\n//region Talents\r\n/** A Murder of Crows */\r\n//A Murder of Crows ticks every 1 seconds\r\nexport const AMOC_TICK_RATE = 1000;\r\n//A murder of Crows lasts up to 15 seconds, we use this to calculate whether or not it has been reset\r\nexport const AMOC_BASE_DURATION = 15000;\r\n/** Barrage */\r\n//Barrage hits up to 10 times per cast\r\nexport const BARRAGE_HITS_PER_CAST = 10;\r\n/** Born to be Wild */\r\n//Born To Be Wild reduces the cooldown of these three aspect abilities\r\nexport const BORN_TO_BE_WILD_AFFECTED_SPELLS = [\r\n  SPELLS.ASPECT_OF_THE_CHEETAH.id,\r\n  SPELLS.ASPECT_OF_THE_TURTLE.id,\r\n  SPELLS.ASPECT_OF_THE_EAGLE.id,\r\n];\r\n\r\n/** Natural Mending */\r\n//1 second per 20 focus spent\r\nexport const MM_SV_CDR_PER_FOCUS = 1000 / 20;\r\n//1 second per 30 focus spent\r\nexport const BM_CDR_PER_FOCUS = 1000 / 30;\r\n//endregion\r\n\r\n//region Resources\r\n/** Focus */\r\n//Hunter has a baseline focus regen of 5\r\nexport const HUNTER_BASE_FOCUS_REGEN = 5;\r\n//Hunter has a baseline max focus of 100\r\nexport const HUNTER_BASE_FOCUS_MAX = 100;\r\n//Generic minor threshold for focus waste\r\nexport const RESOURCES_HUNTER_MINOR_THRESHOLD = 0.05;\r\n//Generic average threshold for focus waste\r\nexport const RESOURCES_HUNTER_AVERAGE_THRESHOLD = 0.1;\r\n//Generic major threshold for focus waste\r\nexport const RESOURCES_HUNTER_MAJOR_THRESHOLD = 0.15;\r\n/** Focus Spenders that are shared across the specs */\r\nexport const LIST_OF_FOCUS_SPENDERS_SHARED = [\r\n  SPELLS.REVIVE_PET,\r\n  SPELLS.A_MURDER_OF_CROWS_TALENT,\r\n  SPELLS.BARRAGE_TALENT,\r\n  SPELLS.ARCANE_SHOT,\r\n];\r\n//endregion\r\n\r\n//region Legendaries\r\nexport const CALL_OF_THE_WILD_AFFECTED_SPELLS = [\r\n  SPELLS.ASPECT_OF_THE_CHEETAH,\r\n  SPELLS.ASPECT_OF_THE_TURTLE,\r\n  SPELLS.ASPECT_OF_THE_EAGLE,\r\n  SPELLS.ASPECT_OF_THE_WILD,\r\n  SPELLS.TRUESHOT,\r\n  SPELLS.COORDINATED_ASSAULT,\r\n];\r\n//Nesingwary's Trapping Apparatus increases focus generation by 100%\r\nexport const NESINGWARY_FOCUS_GAIN_MULTIPLIER = 2;\r\n//endregion\r\n\r\n//region Covenants\r\n\r\n//region Kyrian\r\n/** Resonating Arrow */\r\n//Resonating Arrow increases crit chance for enemies affected by its debuff\r\nexport const RESONATING_ARROW_CRIT_INCREASE = 0.3;\r\n//endregion\r\n\r\n//region Night Fae\r\n/** Wild Spirits */\r\n//Wild Mark is a Hunters Mark-like effect increasing damage done to targets affected by it by 5%\r\nexport const WILD_MARK_DAMAGE_AMP = 0.05;\r\n//Wild Spirits lasts 15 seconds baseline\r\nexport const WILD_SPIRITS_BASELINE_DURATION = 15000;\r\n//endregion\r\n\r\n//region Venthyr\r\n/** Flayed Shot */\r\n//Flayed Shot has a 15% chance to reset Kill Shot (and allow it to be used on a target regardless of HP) every damage tick\r\nexport const FLAYED_SHOT_RESET_CHANCE = 0.15;\r\n//endregion\r\n\r\n//endregion\r\n\r\n//region Conduits\r\n//region Kyrian\r\n/** Enfeebled Mark */\r\n//Enfeebled Mark increases the damage against targets affected by Resonating Arrow\r\nexport const ENFEEBLED_MARK_DAMAGE_INCREASE = [0, 0.05, 0.055, 0.06, 0.0675, 0.075, 0.0825, 0.09, 0.0975, 0.105, 0.1125, 0.12, 0.1275, 0.135, 0.1425, 0.15];\r\n//endregion\r\n\r\n//region Necrolord\r\n/** Necrotic Barrage  */\r\n//Necrotic Barrage makes Death Chakram generate 2 additional focus\r\nexport const NECROTIC_BARRAGE_ADDITIONAL_FOCUS = 2;\r\n//Necrotic Barrage makes Death Chakram do additional damage\r\nexport const NECROTIC_BARRAGE_DAMAGE_INCREASE = [0, 0.05, 0.06, 0.07, 0.085, 0.095, 0.105, 0.115, 0.13, 0.14, 0.15, 0.16, 0.17, 0.18, 0.19, 0.20];\r\n//endregion\r\n\r\n//region Night Fae\r\n/** Spirit Attunement */\r\n//Spirit Attunement increases the duration of Wild Spirits by 3 seconds\r\nexport const SPIRIT_ATTUNEMENT_DURATION_INCREASE = 3000;\r\n//Spirit Attunement increases damage done by Wild Spirits by X%\r\nexport const SPIRIT_ATTUNEMENT_DAMAGE_INCREASE = [0, 0.10, 0.11, 0.12, 0.135, 0.145, 0.155, 0.165, 0.18, 0.19, 0.20, 0.21, 0.22, 0.23, 0.24, 0.25];\r\n//endregion\r\n\r\n//region Venthyr\r\n/** Empowered Release */\r\n//Empowered Release increases Flayed Shot proc chance by 5%, not increasing with ranks.\r\nexport const EMPOWERED_RELEASE_INCREASED_FLAYED_PROC_CHANCE = 0.05;\r\n//Empowered Release makes Flayer's Mark also increase the damage of next Kill Shot by 5.0% (scaling)\r\nexport const EMPOWERED_RELEASE_INCREASE_KS_DAMAGE = [0, 0.05, 0.06, 0.07, 0.085, 0.095, 0.105, 0.115, 0.13, 0.14, 0.15, 0.16, 0.17, 0.18, 0.19, 0.20];\r\n//endregion\r\n\r\n//region Endurance\r\n\r\n//endregion\r\n\r\n//region Finesse\r\n\r\n//endregion\r\n\r\n//endregion\r\n","import { default as Enemy, EnemyInfo } from './Enemy';\r\nimport CombatLogParser from './CombatLogParser';\r\n\r\n\r\nclass EnemyInstance extends Enemy {\r\n  _instanceID: number;\r\n\r\n  get instanceID() {\r\n    return this._instanceID;\r\n  }\r\n\r\n  constructor(owner: CombatLogParser, baseInfo: EnemyInfo, instanceID = 0) {\r\n    super(owner, baseInfo);\r\n\r\n    this._instanceID = instanceID;\r\n  }\r\n}\r\n\r\nexport default EnemyInstance;\r\n","import Enemies from './Enemies';\r\nimport EnemyInstance from '../../core/EnemyInstance';\r\n\r\nexport function encodeTargetString(id, instance = 0) {\r\n  return `${id}.${instance}`;\r\n}\r\n\r\nexport function decodeTargetString(string) {\r\n  const [ id, instance = 0 ] = string.split('.');\r\n  return { id, instance };\r\n}\r\n\r\nconst debug = false;\r\n\r\nclass EnemyInstances extends Enemies {\r\n  getEntity(event) {\r\n    if (event.targetIsFriendly) {\r\n      return null;\r\n    }\r\n    const targetId = event.targetID;\r\n    const targetInstance = event.targetInstance;\r\n\r\n    const enemyId = encodeTargetString(targetId, targetInstance);\r\n\r\n    let enemy = this.enemies[enemyId];\r\n    if (!enemy) {\r\n      const baseInfo = this.owner.report.enemies.find(enemy => enemy.id === targetId);\r\n      if (!baseInfo) {\r\n        debug && console.warn('Enemy not noteworthy enough:', targetId, event);\r\n        return null;\r\n      }\r\n      this.enemies[enemyId] = enemy = new EnemyInstance(this.owner, baseInfo, targetInstance);\r\n    }\r\n    return enemy;\r\n  }\r\n}\r\n\r\nexport default EnemyInstances;\r\n","import React from 'react';\r\nimport PropTypes from 'prop-types';\r\n\r\nimport { formatPercentage, formatNumber } from 'common/format';\r\nimport CombatLogParser from 'parser/core/CombatLogParser';\r\n\r\ninterface Props {\r\n  amount: number;\r\n  approximate?: boolean;\r\n  greaterThan?: boolean;\r\n  lessThan?: boolean;\r\n}\r\ninterface Context {\r\n  parser: CombatLogParser;\r\n}\r\n\r\nconst ItemHealingDone = (\r\n  { amount, approximate, greaterThan, lessThan }: Props,\r\n  { parser }: Context,\r\n) => (\r\n  <>\r\n    <img src=\"/img/healing.png\" alt=\"Healing\" className=\"icon\" />{' '}\r\n    {approximate && '≈'}\r\n    {greaterThan && '>'}\r\n    {lessThan && '<'}\r\n    {formatNumber((amount / parser.fightDuration) * 1000)} HPS{' '}\r\n    <small>\r\n      {formatPercentage(parser.getPercentageOfTotalHealingDone(amount))}% of\r\n      total\r\n    </small>\r\n  </>\r\n);\r\nItemHealingDone.contextTypes = {\r\n  parser: PropTypes.object.isRequired,\r\n};\r\n\r\nexport default ItemHealingDone;\r\n","const HIT_TYPES: {\r\n  [key: string]: number;\r\n} = {\r\n  MISS: 0,\r\n  NORMAL: 1,\r\n  CRIT: 2,\r\n  ABSORB: 3, // seen at Aura of Sacrifice + Absorbed hits that cause atonement\r\n  BLOCKED_NORMAL: 4,\r\n  BLOCKED_CRIT: 5,\r\n  DODGE: 7,\r\n  PARRY: 8,\r\n  IMMUNE: 10,\r\n};\r\nexport default HIT_TYPES;\r\n","import React from 'react';\r\n\r\nimport SpellLink from 'common/SpellLink';\r\nimport { TooltipElement } from 'common/Tooltip';\r\n\r\nimport Abilities from 'parser/core/modules/Abilities';\r\nimport { AbilityCastEfficiency } from 'parser/shared/modules/CastEfficiency';\r\nimport { Trans } from '@lingui/macro';\r\n\r\ninterface Props {\r\n  abilities: AbilityCastEfficiency[];\r\n  categories: {\r\n    [key: string]: string;\r\n  };\r\n}\r\n\r\nconst CastEfficiency = ({ categories, abilities }: Props) => (\r\n  <div style={{ marginTop: -10, marginBottom: -10 }}>\r\n    <table className=\"data-table\" style={{ marginTop: 10, marginBottom: 10 }}>\r\n      {Object.keys(categories)\r\n        .filter(key =>\r\n          abilities.some(item => item.ability.category === categories[key]),\r\n        ) // filters out categories without any abilities in it\r\n        .filter(key => categories[key] !== Abilities.SPELL_CATEGORIES.HIDDEN) //filters out the hidden category\r\n        .map(key => (\r\n          <tbody key={key}>\r\n            <tr>\r\n              <th>\r\n                <b>{categories[key]}</b>\r\n              </th>\r\n              <th className=\"text-center\">\r\n                <TooltipElement content={<Trans id=\"shared.castEfficiency.cpm.tooltip\">Casts Per Minute</Trans>}><Trans id=\"shared.castEfficiency.cpm\">CPM</Trans></TooltipElement>\r\n              </th>\r\n              <th className=\"text-right\">\r\n                <TooltipElement content={<Trans id=\"shared.castEfficiency.casts.tooltip\">Maximum possible casts are based on the ability's cooldown and the fight duration. For abilities that can have their cooldowns dynamically reduced or reset, it's based on the average actual time it took the ability to cooldown over the course of this encounter.</Trans>}>\r\n                  <Trans id=\"shared.castEfficiency.casts\">Casts</Trans>\r\n                </TooltipElement>\r\n              </th>\r\n              <th className=\"text-center\">\r\n                <TooltipElement content={<Trans id=\"shared.castEfficiency.timeOnCooldown.tooltip\">The percentage of time the spell was kept on cooldown. For spells without charges this also includes when the spell was unavailable due to cast time or time spent waiting for a GCD when the spell was reset due to a proc. Spells with multiple charges count as on cooldown as long as you have fewer than maximum charges. For spells with long cooldowns, it's possible to have well below 100% on cooldown and still achieve maximum casts.</Trans>}>\r\n                  <Trans id=\"shared.castEfficiency.timeOnCooldown\">Time on Cooldown</Trans>\r\n                </TooltipElement>\r\n              </th>\r\n              <th />\r\n            </tr>\r\n            {abilities\r\n              .filter(item => item.ability.category === categories[key])\r\n              .map(\r\n                ({\r\n                  ability,\r\n                  cpm,\r\n                  casts,\r\n                  maxCasts,\r\n                  efficiency,\r\n                  canBeImproved,\r\n                }) => {\r\n                  const name = ability.castEfficiency.name || ability.name;\r\n                  return (\r\n                    <tr key={name}>\r\n                      <td style={{ width: '35%' }}>\r\n                        <SpellLink\r\n                          id={ability.primarySpell.id}\r\n                          style={{ color: '#fff' }}\r\n                          icon\r\n                          iconStyle={{\r\n                            height: undefined,\r\n                            marginTop: undefined,\r\n                          }}\r\n                        >\r\n                          {name}\r\n                        </SpellLink>\r\n                      </td>\r\n                      <td className=\"text-center\" style={{ minWidth: 80 }}>\r\n                        {cpm.toFixed(2)}\r\n                      </td>\r\n                      <td className=\"text-right\" style={{ minWidth: 110 }}>\r\n                        {casts}\r\n                        {maxCasts === Infinity\r\n                          ? ''\r\n                          : `/${Math.floor(maxCasts)}`}{' '}\r\n                        casts\r\n                      </td>\r\n                      <td style={{ width: '20%' }}>\r\n                        {maxCasts === Infinity || efficiency === null ? (\r\n                          ''\r\n                        ) : (\r\n                            <div className=\"flex performance-bar-container\">\r\n                              <div\r\n                                className=\"flex-sub performance-bar\"\r\n                                style={{\r\n                                  width: `${efficiency * 100}%`,\r\n                                  backgroundColor:\r\n                                    canBeImproved &&\r\n                                      ability.castEfficiency &&\r\n                                      ability.castEfficiency.suggestion\r\n                                      ? '#ff8000'\r\n                                      : '#70b570',\r\n                                }}\r\n                              />\r\n                            </div>\r\n                          )}\r\n                      </td>\r\n                      <td\r\n                        className=\"text-left\"\r\n                        style={{ minWidth: 50, paddingRight: 5 }}\r\n                      >\r\n                        {efficiency !== null\r\n                          ? `${(efficiency * 100).toFixed(2)}%`\r\n                          : ''}\r\n                      </td>\r\n                      <td style={{ width: '25%', color: 'orange' }}>\r\n                        {canBeImproved &&\r\n                          ability.castEfficiency &&\r\n                          ability.castEfficiency.suggestion &&\r\n                          <Trans id=\"shared.castEfficiency.canBeImproved\">Can be improved.</Trans>}\r\n                      </td>\r\n                    </tr>\r\n                  );\r\n                },\r\n              )}\r\n          </tbody>\r\n        ))}\r\n    </table>\r\n  </div>\r\n);\r\n\r\nexport default CastEfficiency;\r\n","import React from 'react';\r\nimport { Trans } from '@lingui/macro';\r\n\r\nimport SpellLink from 'common/SpellLink';\r\nimport { formatPercentage } from 'common/format';\r\nimport Panel from 'interface/statistics/Panel';\r\nimport CastEfficiencyComponent from 'interface/CastEfficiency';\r\nimport Analyzer from 'parser/core/Analyzer';\r\nimport { ThresholdStyle, When } from 'parser/core/ParseResults';\r\nimport SpellHistory from 'parser/shared/modules/SpellHistory';\r\nimport Abilities from 'parser/core/modules/Abilities';\r\n\r\nimport Haste from 'parser/shared/modules/Haste';\r\n\r\nimport AbilityTracker from './AbilityTracker';\r\n\r\nimport { EventType, UpdateSpellUsableEvent } from '../../core/Events';\r\nimport Combatant from '../../core/Combatant';\r\nimport Ability, { SpellbookAbility } from '../../core/modules/Ability';\r\n\r\nconst DEFAULT_RECOMMENDED = 0.8;\r\nconst DEFAULT_AVERAGE_DOWNSTEP = 0.05;\r\nconst DEFAULT_MAJOR_DOWNSTEP = 0.15;\r\nconst seconds = (ms: number) => ms / 1000;\r\nconst minutes = (ms: number) => seconds(ms) / 60;\r\n\r\nexport interface AbilityCastEfficiency {\r\n  ability: Ability;\r\n  cpm: number;\r\n  casts: number;\r\n  maxCasts: number;\r\n  efficiency: number | null;\r\n  recommendedEfficiency: number;\r\n  averageIssueEfficiency: number;\r\n  majorIssueEfficiency: number;\r\n  gotMaxCasts: boolean;\r\n  canBeImproved?: boolean;\r\n}\r\n\r\nclass CastEfficiency extends Analyzer {\r\n  static dependencies = {\r\n    abilityTracker: AbilityTracker,\r\n    haste: Haste,\r\n    spellHistory: SpellHistory,\r\n    abilities: Abilities,\r\n  };\r\n  protected abilityTracker!: AbilityTracker;\r\n  protected haste!: Haste;\r\n  protected spellHistory!: SpellHistory;\r\n  protected abilities!: Abilities;\r\n\r\n  /**\r\n   * Gets info about spell's cooldown behavior. All values are as of the current timestamp.\r\n   * completedRechargeTime is the total ms of completed cooldowns\r\n   * endingRechargeTime is the total ms into current cooldown\r\n   * recharges is the total number of times the spell has recharged (either come off cooldown or gained a charge)\r\n   * Only works on spells entered into CastEfficiency list.\r\n   */\r\n  private getCooldownInfo(ability: any) {\r\n    const mainSpellId = ability.primarySpell.id;\r\n    const history = this.spellHistory.historyBySpellId[mainSpellId];\r\n    if (!history) {\r\n      // spell either never been cast, or not in abilities list\r\n      return {\r\n        completedRechargeTime: 0,\r\n        endingRechargeTime: 0,\r\n        recharges: 0,\r\n        casts: 0,\r\n        castTimestamps: [],\r\n      };\r\n    }\r\n\r\n    let lastRechargeTimestamp: number | undefined = undefined;\r\n    let recharges = 0;\r\n    const completedRechargeTime = history.filter(\r\n      (event): event is UpdateSpellUsableEvent =>\r\n        event.type === EventType.UpdateSpellUsable,\r\n    ).reduce((acc, event) => {\r\n      if (event.trigger === EventType.BeginCooldown) {\r\n        lastRechargeTimestamp = event.timestamp;\r\n        return acc;\r\n      } else if (event.trigger === EventType.EndCooldown) {\r\n        //limit by start time in case of pre phase events\r\n        recharges += 1;\r\n        lastRechargeTimestamp = undefined;\r\n        // this is just event.timePassed except `endcooldown` events\r\n        // don't have `timePassed` filled in.\r\n        return acc + event.timestamp - event.start;\r\n        // This might cause oddness if we add anything that externally refreshes charges, but so far nothing does\r\n      } else if (event.trigger === EventType.RestoreCharge) {\r\n        //limit by start time in case of pre phase events\r\n        recharges += 1;\r\n        let timePassed = event.timePassed;\r\n        if (timePassed === undefined) {\r\n          // This should never happen...\r\n          if (process.env.NODE_ENV === 'development') {\r\n            throw new Error('timePassed not set on restorecharge updatespellusable event');\r\n          }\r\n          timePassed = 0;\r\n        }\r\n        lastRechargeTimestamp = event.timestamp;\r\n        return acc + timePassed;\r\n      } else {\r\n        return acc;\r\n      }\r\n    }, 0);\r\n    //limit by start time in case of pre phase events\r\n    const endingRechargeTime = !lastRechargeTimestamp\r\n      ? 0\r\n      : this.owner.currentTimestamp -\r\n      Math.max(lastRechargeTimestamp, this.owner.fight.start_time);\r\n\r\n    const casts = history.filter(event => event.type === EventType.Cast).length;\r\n\r\n    const castEvents = history.filter(event => event.type === EventType.Cast);\r\n    const castTimestamps = castEvents.map(\r\n      event => event.timestamp - this.owner.fight.start_time,\r\n    );\r\n\r\n    return {\r\n      completedRechargeTime,\r\n      endingRechargeTime,\r\n      recharges,\r\n      casts,\r\n      castTimestamps,\r\n    };\r\n  }\r\n\r\n  private _getTimeSpentCasting(spellId: number) {\r\n    const history = this.spellHistory.historyBySpellId[spellId];\r\n    if (!history) {\r\n      // spell either never been cast, or not in abilities list\r\n      return 0;\r\n    }\r\n\r\n    let beginCastTimestamp: number | undefined;\r\n    const timeSpentCasting = history.reduce((acc, event) => {\r\n      if (event.type === EventType.BeginCast) {\r\n        beginCastTimestamp = event.timestamp;\r\n        return acc;\r\n      } else if (event.type === EventType.Cast) {\r\n        //limit by start time in case of pre phase events\r\n        const castTime = beginCastTimestamp\r\n          ? event.timestamp -\r\n          Math.max(beginCastTimestamp, this.owner.fight.start_time)\r\n          : 0;\r\n        beginCastTimestamp = undefined;\r\n        return acc + castTime;\r\n      } else {\r\n        return acc;\r\n      }\r\n    }, 0);\r\n\r\n    return timeSpentCasting;\r\n  }\r\n\r\n  private getGcd(gcd: SpellbookAbility['gcd']) {\r\n    const getGcdValue = (value: ((combatant: Combatant) => number) | number) =>\r\n      typeof value === 'function' ? value(this.owner.selectedCombatant) : value;\r\n\r\n    if (typeof gcd === 'function') {\r\n      return gcd(this.owner.selectedCombatant);\r\n    } else if (gcd && gcd.static) {\r\n      return getGcdValue(gcd.static);\r\n    } else if (gcd && gcd.base) {\r\n      const base = getGcdValue(gcd.base);\r\n      const minimum = gcd.minimum ? getGcdValue(gcd.minimum) : base / 2;\r\n      const gcdReduction = base * this.haste.current;\r\n      const gcdActual = Math.max(minimum, base - gcdReduction);\r\n\r\n      return gcdActual;\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  private getTimeSpentOnGcd(spellId: number) {\r\n    const ability = this.abilities.getAbility(spellId);\r\n\r\n    if (ability && ability.gcd) {\r\n      const cdInfo = this.getCooldownInfo(ability);\r\n\r\n      let casts;\r\n      if (ability.castEfficiency.casts) {\r\n        casts = ability.castEfficiency.casts(\r\n          this.abilityTracker.getAbility(spellId),\r\n          this.owner,\r\n        );\r\n      } else {\r\n        casts = cdInfo.casts;\r\n      }\r\n\r\n      const averagetimeSpentOnAbility =\r\n        this._getTimeSpentCasting(ability.primarySpell.id) / casts;\r\n      // If the abilities GCD is longer than the time spent casting, use the GCD\r\n      const gcd = this.getGcd(ability.gcd);\r\n      if (gcd && gcd > averagetimeSpentOnAbility) {\r\n        return gcd * casts;\r\n      }\r\n    }\r\n    return 0;\r\n  }\r\n\r\n  getTimeSpentCasting(abilityId: number) {\r\n    const timeSpentCasting = this._getTimeSpentCasting(abilityId);\r\n    const gcdSpent = this.getTimeSpentOnGcd(abilityId);\r\n\r\n    return {\r\n      timeSpentCasting,\r\n      gcdSpent,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Time spent waiting for a GCD that reset the cooldown of the spell to finish\r\n   */\r\n  private _getTimeWaitingOnGCD(spellId: number) {\r\n    const history = this.spellHistory.historyBySpellId[spellId];\r\n    if (!history) {\r\n      // spell either never been cast, or not in abilities list\r\n      return 0;\r\n    }\r\n\r\n    const timeWaitingOnGCD = history.reduce((acc, event) => {\r\n      if (event.type === EventType.UpdateSpellUsable && event.timeWaitingOnGCD) {\r\n        return acc + event.timeWaitingOnGCD;\r\n      } else {\r\n        return acc;\r\n      }\r\n    }, 0);\r\n\r\n    return timeWaitingOnGCD;\r\n  }\r\n\r\n  /**\r\n   * Packs cast efficiency results for use by suggestions / tab\r\n   */\r\n  getCastEfficiency() {\r\n    return this.abilities.activeAbilities\r\n      .map(ability => this.getCastEfficiencyForAbility(ability))\r\n      .filter(item => item !== null) as AbilityCastEfficiency[]; // getCastEfficiencyForAbility can return null, remove those from the result\r\n  }\r\n\r\n  getCastEfficiencyForSpellId(\r\n    spellId: number,\r\n    includeNoCooldownEfficiency = false,\r\n  ) {\r\n    const ability = this.abilities.getAbility(spellId);\r\n    return ability\r\n      ? this.getCastEfficiencyForAbility(ability, includeNoCooldownEfficiency)\r\n      : null;\r\n  }\r\n\r\n  getCastEfficiencyForAbility(\r\n    ability: Ability,\r\n    includeNoCooldownEfficiency = false,\r\n  ): AbilityCastEfficiency | null {\r\n    const spellId = ability.primarySpell.id;\r\n    const availableFightDuration = this.owner.fightDuration;\r\n\r\n    const cooldown = ability.cooldown;\r\n    const cooldownMs = !cooldown ? null : cooldown * 1000;\r\n    const cdInfo = this.getCooldownInfo(ability);\r\n    const timeSpentCasting =\r\n      cooldown && ability.charges < 2\r\n        ? this._getTimeSpentCasting(ability.primarySpell.id)\r\n        : 0;\r\n    const timeWaitingOnGCD =\r\n      cooldown && ability.charges < 2 && ability.gcd\r\n        ? this._getTimeWaitingOnGCD(ability.primarySpell.id)\r\n        : 0;\r\n\r\n    // ability.casts is used for special cases that show the wrong number of cast events, like Penance\r\n    // and also for splitting up differently buffed versions of the same spell\r\n    let casts;\r\n    if (ability.castEfficiency.casts) {\r\n      casts = ability.castEfficiency.casts(\r\n        this.abilityTracker.getAbility(spellId),\r\n        this.owner,\r\n      );\r\n    } else {\r\n      casts = cdInfo.casts;\r\n    }\r\n    const cpm = casts / minutes(availableFightDuration);\r\n    const averageTimeSpentCasting = timeSpentCasting / casts;\r\n    const averageTimeWaitingOnGCD = timeWaitingOnGCD / casts;\r\n\r\n    if (ability.isUndetectable && casts === 0) {\r\n      // Some spells (most notably Racials) can not be detected if a player has them. This hides those spells if they have 0 casts.\r\n      return null;\r\n    }\r\n\r\n    // ability.maxCasts is used for special cases for spells that have a variable availability or CD based on state, like Void Bolt.\r\n    // This same behavior should be managable using SpellUsable's interface, so maxCasts is deprecated.\r\n    // Legacy support: if maxCasts is defined, cast efficiency will be calculated using casts/rawMaxCasts\r\n    let rawMaxCasts: number | undefined;\r\n    const averageCooldown = cdInfo.recharges === 0 ? null : cdInfo.completedRechargeTime / cdInfo.recharges;\r\n    if (ability.castEfficiency.maxCasts) {\r\n      // maxCasts expects cooldown in seconds\r\n      rawMaxCasts = ability.castEfficiency.maxCasts(cooldown);\r\n    } else if (averageCooldown) {\r\n      // no average CD if spell hasn't been cast\r\n      rawMaxCasts =\r\n        availableFightDuration /\r\n        (averageCooldown + averageTimeSpentCasting + averageTimeWaitingOnGCD) +\r\n        (ability.charges || 1) - 1;\r\n    } else if (!includeNoCooldownEfficiency) {\r\n      rawMaxCasts = availableFightDuration / cooldownMs! + (ability.charges || 1) - 1;\r\n    } else if (casts > 0) {\r\n      let averagetimeSpentOnNoCooldownAbility =\r\n        this._getTimeSpentCasting(ability.primarySpell.id) / casts;\r\n      const gcd = this.getGcd(ability.gcd);\r\n      if (gcd && averagetimeSpentOnNoCooldownAbility < gcd) {\r\n        // edge case for no cast time spells and spells with cast time lower than the gcd.\r\n        averagetimeSpentOnNoCooldownAbility = gcd;\r\n      }\r\n      rawMaxCasts =\r\n        availableFightDuration / averagetimeSpentOnNoCooldownAbility;\r\n    } else {\r\n      // If we don't have any way to tell the cast time of the spell, return null.\r\n      rawMaxCasts = undefined;\r\n    }\r\n\r\n    // Shouldn't this floor it?\r\n    const maxCasts = Math.ceil(rawMaxCasts || 0);\r\n\r\n    let efficiency;\r\n    if (ability.castEfficiency.maxCasts) {\r\n      // legacy support for custom maxCasts\r\n      efficiency = Math.min(1, ((casts / rawMaxCasts!) || 0));\r\n    } else {\r\n      // Cast efficiency calculated as the percent of fight time spell was unavailable\r\n      // The spell is considered unavailable if it is on cooldown, the time since it came off cooldown is less than the cast time or the cooldown was reset through a proc during a GCD\r\n      // Time Offset reduces the Unavailable time to account for the portion of the CD that extended beyond the end of the fight\r\n      if (cooldown && availableFightDuration) {\r\n        const timeOnCd =\r\n          cdInfo.completedRechargeTime + cdInfo.endingRechargeTime;\r\n        const lastCastTimestamp =\r\n          cdInfo.castTimestamps[cdInfo.castTimestamps.length - 1];\r\n        const timeOffset =\r\n          lastCastTimestamp + cooldown * 1000 > availableFightDuration\r\n            ? cooldown * 1000 - (availableFightDuration - lastCastTimestamp)\r\n            : 0;\r\n        const timeUnavailable =\r\n          timeOnCd + timeSpentCasting + timeWaitingOnGCD - timeOffset;\r\n        efficiency = timeUnavailable / availableFightDuration;\r\n      } else if (includeNoCooldownEfficiency) {\r\n        efficiency = casts / rawMaxCasts!;\r\n      } else {\r\n        efficiency = null;\r\n      }\r\n    }\r\n\r\n    const recommendedEfficiency =\r\n      ability.castEfficiency.recommendedEfficiency || DEFAULT_RECOMMENDED;\r\n    const averageIssueEfficiency =\r\n      ability.castEfficiency.averageIssueEfficiency ||\r\n      recommendedEfficiency - DEFAULT_AVERAGE_DOWNSTEP;\r\n    const majorIssueEfficiency =\r\n      ability.castEfficiency.majorIssueEfficiency ||\r\n      recommendedEfficiency - DEFAULT_MAJOR_DOWNSTEP;\r\n\r\n    const gotMaxCasts = casts === maxCasts;\r\n    const canBeImproved =\r\n      ability.castEfficiency.suggestion &&\r\n      efficiency !== null &&\r\n      efficiency < recommendedEfficiency &&\r\n      !gotMaxCasts;\r\n\r\n    return {\r\n      ability,\r\n      cpm,\r\n      casts,\r\n      maxCasts,\r\n      efficiency,\r\n      recommendedEfficiency,\r\n      averageIssueEfficiency,\r\n      majorIssueEfficiency,\r\n      gotMaxCasts,\r\n      canBeImproved,\r\n    };\r\n  }\r\n\r\n  suggestions(when: When) {\r\n    const castEfficiencyInfo = this.getCastEfficiency();\r\n    castEfficiencyInfo.forEach(abilityInfo => {\r\n      if (\r\n        !abilityInfo ||\r\n        !abilityInfo.ability.castEfficiency.suggestion ||\r\n        abilityInfo.efficiency === null ||\r\n        abilityInfo.gotMaxCasts\r\n      ) {\r\n        return;\r\n      }\r\n      const ability = abilityInfo.ability;\r\n      const mainSpell =\r\n        ability.spell instanceof Array ? ability.spell[0] : ability.spell;\r\n\r\n      const suggestionThresholds = {\r\n        actual: abilityInfo.efficiency,\r\n        isLessThan: {\r\n          minor: abilityInfo.recommendedEfficiency,\r\n          average: abilityInfo.averageIssueEfficiency,\r\n          major: abilityInfo.majorIssueEfficiency,\r\n        },\r\n        style: ThresholdStyle.PERCENTAGE,\r\n      };\r\n\r\n      when(suggestionThresholds).addSuggestion(\r\n        (suggest, actual, recommended) => suggest(\r\n          <>\r\n            <Trans id=\"shared.modules.castEfficiency.suggest\">\r\n              Try to cast <SpellLink id={mainSpell.id} /> more often.\r\n            </Trans>{' '}\r\n            {ability.castEfficiency.extraSuggestion || ''}\r\n          </>,\r\n        )\r\n          .icon(mainSpell.icon)\r\n          .actual(\r\n            <Trans id=\"shared.modules.castEfficiency.actual\">\r\n              {abilityInfo.casts} out of {abilityInfo.maxCasts} possible\r\n              casts. You kept it on cooldown {formatPercentage(actual, 0)}% of\r\n              the time.\r\n            </Trans>,\r\n          )\r\n          .recommended(\r\n            <Trans id=\"shared.modules.castEfficiency.recommended\">\r\n              &gt;{formatPercentage(recommended, 0)}% is recommended\r\n            </Trans>,\r\n          )\r\n          .staticImportance(ability.castEfficiency.importance || null),\r\n      );\r\n    });\r\n  }\r\n\r\n  statistic() {\r\n    return (\r\n      <Panel title={<Trans id=\"common.abilities\">Abilities</Trans>} position={500} pad={false}>\r\n        <CastEfficiencyComponent\r\n          categories={\r\n            (this.abilities.constructor as typeof Abilities).SPELL_CATEGORIES\r\n          }\r\n          abilities={this.getCastEfficiency()}\r\n        />\r\n      </Panel>\r\n    );\r\n  }\r\n}\r\n\r\nexport default CastEfficiency;\r\n","import { AnyEvent, EventType } from 'parser/core/Events';\r\n\r\nimport Module from './Module';\r\n\r\nabstract class EventsNormalizer extends Module {\r\n  /**\r\n   * The combatlog has a lot of issues that make it harder to analyze things.\r\n   * You can use this to normalize the log, for example by changing the order of\r\n   * events to match reality (e.g. a heal should never be logged before the cast\r\n   * event that triggers it, but Blizzard don't care about no logic).\r\n   * Caution: advanced usage, this should only be used as an exception.\r\n   * @param {Array} events\r\n   * @returns {Array}\r\n   */\r\n  abstract normalize(events: AnyEvent[]): AnyEvent[];\r\n\r\n  // Convenience methods\r\n  getFightStartIndex(events: AnyEvent[]): number {\r\n    for (let i = 0; i < events.length; i += 1) {\r\n      const event = events[i];\r\n      if (event.type !== EventType.CombatantInfo) {\r\n        return i;\r\n      }\r\n    }\r\n    throw new Error(\r\n      \"Fight doesn't have an event other than combatants, something must have gone wrong.\",\r\n    );\r\n  }\r\n}\r\n\r\nexport default EventsNormalizer;\r\n","import SPELLS from 'common/SPELLS';\r\n\r\n//saving it as spell-prop as this might be a good place to add further information about the externals (for issue #1083)\r\n\r\nconst DEFENSIVE_BUFFS = [\r\n  {\r\n    spell: SPELLS.IRONBARK,\r\n  },\r\n  {\r\n    spell: SPELLS.LIFE_COCOON,\r\n  },\r\n  {\r\n    spell: SPELLS.BLESSING_OF_PROTECTION,\r\n  },\r\n  {\r\n    spell: SPELLS.BLESSING_OF_SACRIFICE,\r\n  },\r\n  {\r\n    spell: SPELLS.GUARDIAN_SPIRIT,\r\n  },\r\n  {\r\n    spell: SPELLS.PAIN_SUPPRESSION,\r\n  },\r\n  {\r\n    spell: SPELLS.POWER_WORD_BARRIER_BUFF,\r\n  },\r\n\r\n  //Blood Death-Knight\r\n  {\r\n    spell: SPELLS.BONE_SHIELD,\r\n  },\r\n  {\r\n    spell: SPELLS.SHROUD_OF_PURGATORY,\r\n  },\r\n  //Vengence Demon Hunter\r\n  {\r\n    spell: SPELLS.FRAILTY_SPIRIT_BOMB_DEBUFF,\r\n  },\r\n  //Arms Warrior\r\n  {\r\n    spell: SPELLS.DEFENSIVE_STANCE_TALENT,\r\n  },\r\n  //Arms & Fury Warrior\r\n  {\r\n    spell: SPELLS.RALLYING_CRY_BUFF,\r\n  },\r\n  //Shaman\r\n  {\r\n    spell: SPELLS.SPIRIT_WOLF_BUFF,\r\n  },\r\n];\r\n\r\nexport default DEFENSIVE_BUFFS;\r\n","import Analyzer, { Options, SELECTED_PLAYER } from 'parser/core/Analyzer';\r\nimport Abilities from 'parser/core/modules/Abilities';\r\nimport Buffs from 'parser/core/modules/Buffs';\r\nimport AbilityTracker from 'parser/shared/modules/AbilityTracker';\r\nimport SpellUsable from 'parser/shared/modules/SpellUsable';\r\nimport Spell from 'common/SPELLS/Spell';\r\nimport Events, { DeathEvent } from 'parser/core/Events';\r\nimport { ThresholdStyle } from 'parser/core/ParseResults';\r\n\r\nconst ONE_HOUR_MS = 3600000; // one hour\r\nconst COOLDOWN_MS = 60000; // one minute\r\n\r\n/**\r\n * Abstract class for potions and healthstone.\r\n * There are three different categories of pots that share cooldown:\r\n * Healthstones, health pots and combat pots (DPS, HPS, mana and mitigation).\r\n * pot cooldown is one minute, but the cooldown does not start until the\r\n * actor is out of combat or dead.\r\n *\r\n * @property {Abilities} abilities\r\n * @property {Buffs} buffs\r\n * @property {SpellUsable} spellUsable\r\n * @property {AbilityTracker} abilityTracker\r\n */\r\nclass Potion extends Analyzer {\r\n  static dependencies = {\r\n    abilities: Abilities,\r\n    buffs: Buffs,\r\n    spellUsable: SpellUsable,\r\n    abilityTracker: AbilityTracker,\r\n  };\r\n\r\n  protected abilities!: Abilities;\r\n  protected buffs!: Buffs;\r\n  protected spellUsable!: SpellUsable;\r\n  protected abilityTracker!: AbilityTracker;\r\n\r\n  static spells: Spell[];\r\n  static recommendedEfficiency: number;\r\n  static extraAbilityInfo: {name?: string, buffSpellId?: number[], isDefensive?: boolean,};\r\n\r\n  maxCasts = 1;\r\n  lastDeathWithPotionReady?: number;\r\n\r\n  get static(){\r\n    return this.constructor as typeof Potion;\r\n  }\r\n\r\n  constructor(options: Options) {\r\n    super(options);\r\n    if (!this.isAvailable) {\r\n      this.active = false;\r\n      return;\r\n    }\r\n    (options.abilities as Abilities).add({\r\n      spell: this.static.spells,\r\n      category: Abilities.SPELL_CATEGORIES.CONSUMABLE,\r\n      cooldown: (_, cooldownTriggerEvent) => {\r\n        if (cooldownTriggerEvent && cooldownTriggerEvent.prepull) {\r\n          return 60;\r\n        }\r\n\r\n        // The cooldown does not start while in combat so setting it to one hour.\r\n        return ONE_HOUR_MS / 1000;\r\n      },\r\n      castEfficiency: {\r\n        suggestion: false,\r\n        maxCasts: () => this.maxCasts,\r\n      },\r\n      ...this.static.extraAbilityInfo,\r\n    });\r\n    if (this.static.extraAbilityInfo.buffSpellId) {\r\n      //assign each buff its corresponding spell ID\r\n      this.static.extraAbilityInfo.buffSpellId.forEach((buff, buffIndex) => {\r\n        (options.buffs as Buffs).add({\r\n          spellId: buff,\r\n          triggeredBySpellId: this.static.spells.find((_, spellIndex) => spellIndex === buffIndex)!.id,\r\n        });\r\n      });\r\n    }\r\n\r\n    this.addEventListener(Events.death.to(SELECTED_PLAYER), this.onDeath);\r\n  }\r\n\r\n  // To be overwriten by classes extending the Potion module.\r\n  get isAvailable() {\r\n    return true;\r\n  }\r\n\r\n  get spellId() {\r\n    const spells = this.static.spells;\r\n    const ability = this.abilities.getAbility(spells[0].id)!;\r\n    return ability.primarySpell.id;\r\n  }\r\n\r\n  onDeath(event: DeathEvent) {\r\n    if (!this.spellUsable.isOnCooldown(this.spellId)) {\r\n      // If the potion was not on cooldown, only increase maxCasts if it would have been ready again since the previous death.\r\n      if (this.lastDeathWithPotionReady) {\r\n        const timeSince = event.timestamp - this.lastDeathWithPotionReady;\r\n        if (timeSince < COOLDOWN_MS) { // The potion would not have been ready if used on previous death\r\n          return;\r\n        }\r\n      }\r\n      // The potion was ready for this death so increase maxCasts and save timestamp\r\n      this.lastDeathWithPotionReady = event.timestamp;\r\n      this.increaseMaxCasts(event);\r\n      return;\r\n    }\r\n    const cooldownRemaining = this.spellUsable.cooldownRemaining(this.spellId);\r\n    // Only start cooldown if not already started.\r\n    if (cooldownRemaining < COOLDOWN_MS) {\r\n      return;\r\n    }\r\n    this.spellUsable.reduceCooldown(this.spellId, cooldownRemaining - COOLDOWN_MS);\r\n    this.increaseMaxCasts(event);\r\n  }\r\n\r\n  increaseMaxCasts(event: DeathEvent) {\r\n    // If the death starts the cooldown and there is more than 60 seconds remaining of the encounter another cast was possible.\r\n    const nextAvailablePotionCast = event.timestamp + COOLDOWN_MS;\r\n    if (nextAvailablePotionCast < this.owner.fight.end_time) {\r\n      this.maxCasts += 1;\r\n    }\r\n  }\r\n\r\n  get potionCasts() {\r\n    return this.abilityTracker.getAbility(this.spellId).casts;\r\n  }\r\n\r\n  get suggestionThresholds() {\r\n    return {\r\n      actual: this.potionCasts / this.maxCasts,\r\n      isLessThan: {\r\n        minor: this.static.recommendedEfficiency,\r\n      },\r\n      style: ThresholdStyle.PERCENTAGE,\r\n    };\r\n  }\r\n}\r\n\r\nexport default Potion;\r\n","import SPELLS from 'common/SPELLS/index';\r\n\r\nimport Combatants from 'parser/shared/modules/Combatants';\r\nimport { Class } from 'parser/core/Events';\r\n\r\nimport Potion from './Potion';\r\n/**\r\n * Tracks Healthstone cooldown.\r\n */\r\nclass Healthstone extends Potion {\r\n  static dependencies = {\r\n    ...Potion.dependencies,\r\n    combatants: Combatants,\r\n  };\r\n\r\n  protected combatants!: Combatants;\r\n\r\n  static spells = [\r\n    SPELLS.HEALTHSTONE,\r\n  ];\r\n  static recommendedEfficiency = 0;\r\n  static extraAbilityInfo = {\r\n    isDefensive: true,\r\n  };\r\n\r\n  get isAvailable() {\r\n    const players = Object.values(this.combatants.players);\r\n    return players.some(combatant => (combatant.spec.className === Class.Warlock));\r\n  }\r\n}\r\n\r\nexport default Healthstone;\r\n","import React from 'react';\r\nimport PropTypes from 'prop-types';\r\nimport Slider from 'rc-slider';\r\nimport 'rc-slider/assets/index.css';\r\n\r\nimport SpellIcon from 'common/SpellIcon';\r\nimport SpellLink from 'common/SpellLink';\r\nimport Icon from 'common/Icon';\r\nimport { formatDuration, formatNumber, formatPercentage } from 'common/format';\r\nimport WarcraftLogsIcon from 'interface/icons/WarcraftLogs';\r\nimport Tooltip, { TooltipElement } from 'common/Tooltip';\r\nimport { EventType } from 'parser/core/Events';\r\n\r\nconst SHOW_SECONDS_BEFORE_DEATH = 10;\r\nconst AMOUNT_THRESHOLD = 0;\r\n\r\nclass DeathRecap extends React.PureComponent {\r\n  static propTypes = {\r\n    events: PropTypes.array.isRequired,\r\n    enemies: PropTypes.object.isRequired,\r\n    combatants: PropTypes.object.isRequired,\r\n    report: PropTypes.object.isRequired,\r\n  };\r\n\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      detailedView: 0,\r\n      amountThreshold: AMOUNT_THRESHOLD,\r\n    };\r\n    this.handleClick = this.handleClick.bind(this);\r\n    this.filterDeath = this.filterDeath.bind(this);\r\n  }\r\n\r\n  handleClick(event) {\r\n    const clicked = event === this.state.detailedView ? -1 : event;\r\n    this.setState({ detailedView: clicked });\r\n  }\r\n\r\n  filterDeath(event, i) {\r\n    const start = this.props.report.fight.offset_time + (i !== 0 && this.props.events[i-1].deathtime - this.props.report.fight.start_time);\r\n    const end = event.deathtime + this.props.report.fight.offset_time - this.props.report.fight.start_time;\r\n    this.props.report.applyTimeFilter(start, end);\r\n  }\r\n\r\n  render() {\r\n    let lastHitPoints = 0;\r\n    let lastMaxHitPoints = 0;\r\n\r\n    function sortByTimelineIndex(a, b) {\r\n      return a.timelineSortIndex - b.timelineSortIndex;\r\n    }\r\n\r\n    const sliderProps = {\r\n      min: 0,\r\n      max: 0.5,\r\n      step: 0.05,\r\n      marks: {\r\n        0: '0%',\r\n        0.05: '5%',\r\n        0.1: '10%',\r\n        0.15: '15%',\r\n        0.2: '20%',\r\n        0.25: '25%',\r\n        0.3: '30%',\r\n        0.35: '35%',\r\n        0.4: '40%',\r\n        0.45: '45%',\r\n        0.5: '50%',\r\n      },\r\n      style: {\r\n        margin: '0 5px',\r\n      },\r\n    };\r\n\r\n    const events = this.props.events;\r\n    /* eslint-disable no-script-url */\r\n    /* eslint-disable jsx-a11y/anchor-is-valid */\r\n    return (\r\n      <>\r\n        <div className=\"pad\" style={{ marginBottom: 15 }}>\r\n          <div className=\"row\">\r\n            <div className=\"col-md-8\">\r\n              <div>\r\n                Filter events based on min amount (percentage of players health):\r\n              </div>\r\n              <Slider\r\n                {...sliderProps}\r\n                defaultValue={this.state.amountThreshold}\r\n                onChange={(value) => {\r\n                  this.setState({\r\n                    amountThreshold: value,\r\n                  });\r\n                }}\r\n              />\r\n            </div>\r\n            <div className=\"col-md-4\">\r\n              <Tooltip content=\"Open the deaths on Warcraft Logs\">\r\n                <a\r\n                  href={`https://www.warcraftlogs.com/reports/${this.props.report.report.code}#fight=${this.props.report.fight.id}&type=deaths&source=${this.props.report.player.id}`}\r\n                  target=\"_blank\"\r\n                  rel=\"noopener noreferrer\"\r\n                  className=\"btn\"\r\n                  style={{ fontSize: 24 }}\r\n                >\r\n                  <WarcraftLogsIcon /> Warcraft Logs\r\n                </a>\r\n              </Tooltip>\r\n            </div>\r\n          </div>\r\n        </div>\r\n        {events.map((death, i) => (\r\n          <React.Fragment key={i}>\r\n            <div style={{display: 'block'}}>\r\n              <h2 onClick={() => this.handleClick(i)} style={{ padding: '10px 20px', cursor: 'pointer', display: 'inline-block' }}>Death #{i + 1}</h2>\r\n              <TooltipElement content=\"Filter events to the time between either the start of combat or your last death (whichever happened more recently) and this death.\">\r\n                <a href=\"javascript:\" onClick={() => this.filterDeath(death, i)}>Filter to prior events</a>\r\n              </TooltipElement>\r\n            </div>\r\n            <table style={{ display: this.state.detailedView === i ? 'block' : 'none' }} className=\"data-table\">\r\n              <thead>\r\n                <tr>\r\n                  <th>Time</th>\r\n                  <th>Ability</th>\r\n                  <th>HP</th>\r\n                  <th>Amount</th>\r\n                  <th>Defensive Buffs/Debuffs</th>\r\n                  <th>Personals available</th>\r\n                </tr>\r\n              </thead>\r\n              <tbody>\r\n                {death.events\r\n                  .filter(e => e.timestamp <= death.deathtime && e.timestamp >= death.deathtime - (SHOW_SECONDS_BEFORE_DEATH * 1000))\r\n                  .filter(e => ((e.amount + (e.absorbed || 0)) / e.maxHitPoints > this.state.amountThreshold) || e.type === EventType.Instakill)\r\n                  .map((event, eventIndex) => {\r\n                    if (event.hitPoints && event.maxHitPoints) {\r\n                      lastHitPoints = event.hitPoints;\r\n                      lastMaxHitPoints = event.maxHitPoints;\r\n                    }\r\n\r\n                    const hitPercent = event.amount / lastMaxHitPoints;\r\n                    let percent = 0;\r\n                    let output = null;\r\n                    //name = either NPC-Name > sourceID-Name > Ability-Name as fallback\r\n                    let sourceName = event.source && event.source.type === 'NPC' ? event.source.name : null;\r\n                    if (!sourceName && event.type === EventType.Heal) {\r\n                      sourceName = this.props.combatants[event.sourceID] ? this.props.combatants[event.sourceID]._combatantInfo.name : null;\r\n                    }\r\n                    if (!sourceName && event.type === EventType.Damage) {\r\n                      sourceName = this.props.enemies[event.sourceID] ? this.props.enemies[event.sourceID]._baseInfo.name : null;\r\n                    }\r\n                    if (!sourceName && event.type !== EventType.Instakill) {\r\n                      sourceName = event.ability.name;\r\n                    }\r\n\r\n                    if (event.type === EventType.Heal) {\r\n                      percent = (lastHitPoints - event.amount) / lastMaxHitPoints;\r\n                      output = (\r\n                        <TooltipElement\r\n                          content={(\r\n                            <>\r\n                              {event.sourceID === event.targetID ?\r\n                                `You healed yourself for ${formatNumber(event.amount)}` :\r\n                                `${sourceName} healed you for ${formatNumber(event.amount)}`\r\n                              }\r\n                              {event.absorbed > 0 ? `, ${formatNumber(event.absorbed)} of that healing was absorbed` : ''}\r\n                              {event.overheal > 0 ? ` and overhealed for ${formatNumber(event.overheal)}` : ''}\r\n                            </>\r\n                          )}\r\n                          style={(event.amount === 0 && event.absorbed > 0) ? { color: 'orange' } : { color: 'green' }}\r\n                        >\r\n                          +{formatNumber(event.amount)} {event.absorbed > 0 ? `(A: ${formatNumber(event.absorbed)} )` : ''} {event.overheal > 0 ? `(O: ${formatNumber(event.overheal)} )` : ''}\r\n                        </TooltipElement>\r\n                      );\r\n                    } else if (event.type === EventType.Damage) {\r\n                      percent = lastHitPoints / lastMaxHitPoints;\r\n                      output = (\r\n                        <TooltipElement\r\n                          content={(\r\n                            <>\r\n                              {event.sourceID === event.targetID ?\r\n                                `You damaged yourself for ${formatNumber(event.amount)}` :\r\n                                `${sourceName} damaged you for a total of ${formatNumber(event.amount + (event.absorbed || 0))}`\r\n                              }<br />\r\n                              {event.absorbed > 0 ? <>{formatNumber(event.absorbed)} of this damage was absorbed and you took {formatNumber(event.amount)} damage<br /></> : ''}\r\n                            </>\r\n                          )}\r\n                          style={{ color: 'red' }}\r\n                        >\r\n                          -{formatNumber(event.amount)} {event.absorbed > 0 ? `(A: ${formatNumber(event.absorbed)} )` : ''}\r\n                        </TooltipElement>\r\n                      );\r\n                    } else if (event.type === EventType.Instakill) {\r\n                      percent = 0;\r\n                      output = '1-Shot';\r\n                    }\r\n\r\n                    if (event.overkill || event.hitPoints === 0) {\r\n                      percent = 0;\r\n                    }\r\n\r\n                    return (\r\n                      <tr key={eventIndex}>\r\n                        <td style={{ width: '5%' }}>\r\n                          {formatDuration((event.time + this.props.report.fight.offset_time) / 1000, 2)}\r\n                        </td>\r\n                        <td style={{ width: '20%' }}>\r\n                          <SpellLink id={event.ability.guid} icon={false}>\r\n                            <Icon icon={event.ability.abilityIcon} /> {event.ability.name}\r\n                          </SpellLink>\r\n                        </td>\r\n                        <td style={{ width: '20%' }}>\r\n                          <div className=\"flex performance-bar-container\">\r\n                            {percent !== 0 && (\r\n                              <div className=\"flex-sub performance-bar\" style={{ color: 'white', width: formatPercentage(percent) + '%' }} />\r\n                            )}\r\n                            <div\r\n                              className=\"flex-sub performance-bar\"\r\n                              style={{\r\n                                backgroundColor: event.type === EventType.Heal ? 'green' : 'red',\r\n                                width: formatPercentage(hitPercent) + '%',\r\n                                opacity: event.type === EventType.Heal ? .8 : .4,\r\n                              }}\r\n                            />\r\n                          </div>\r\n                        </td>\r\n                        <td style={{ width: '15%' }}>\r\n                          {output}\r\n                        </td>\r\n                        <td style={{ width: '20%' }}>\r\n                          {event.buffsUp && event.buffsUp.sort(sortByTimelineIndex).map(e =>\r\n                            <SpellIcon key={e.id} style={{ border: '1px solid rgba(0, 0, 0, 0)' }} id={e.id} />,\r\n                          )}<br />\r\n                          {event.debuffsUp && event.debuffsUp.sort(sortByTimelineIndex).map(e =>\r\n                            <SpellIcon key={e.id} style={{ border: '1px solid red' }} id={e.id} />,\r\n                          )}\r\n                        </td>\r\n                        <td style={{ width: '20%' }}>\r\n                          {event.defensiveCooldowns.sort(sortByTimelineIndex).map(e =>\r\n                            <SpellIcon key={e.id} style={{ opacity: e.cooldownReady ? 1 : .2 }} id={e.id} />,\r\n                          )}\r\n                        </td>\r\n                      </tr>\r\n                    );\r\n                  })}\r\n                <tr>\r\n                  <td />\r\n                  <td colSpan=\"6\">\r\n                    You died\r\n                  </td>\r\n                </tr>\r\n              </tbody>\r\n            </table>\r\n          </React.Fragment>\r\n        ))}\r\n      </>\r\n    );\r\n  }\r\n}\r\n\r\nexport default DeathRecap;\r\n","import React from 'react';\r\n\r\nimport SPELLS from 'common/SPELLS';\r\nimport DEFENSIVE_BUFFS from 'common/DEFENSIVE_BUFFS';\r\nimport Analyzer, { SELECTED_PLAYER } from 'parser/core/Analyzer';\r\nimport Combatants from 'parser/shared/modules/Combatants';\r\nimport Abilities from 'parser/core/modules/Abilities';\r\nimport Buffs from 'parser/core/modules/Buffs';\r\nimport SpellUsable from 'parser/shared/modules/SpellUsable';\r\nimport Enemies from 'parser/shared/modules/Enemies';\r\nimport Healthstone from 'parser/shared/modules/items/Healthstone';\r\nimport Panel from 'interface/others/Panel';\r\nimport Events from 'parser/core/Events';\r\n\r\nimport DeathRecap from './DeathRecap';\r\n\r\nclass DeathRecapTracker extends Analyzer {\r\n  deaths = [];\r\n  events = [];\r\n  healed = [];\r\n  damaged = [];\r\n  cooldowns = [];\r\n  buffs = [];\r\n  lastBuffs = [];\r\n\r\n  static dependencies = {\r\n    combatants: Combatants,\r\n    abilities: Abilities,\r\n    buffsModule: Buffs,\r\n    spellUsable: SpellUsable,\r\n    enemies: Enemies,\r\n    healthstone: Healthstone,\r\n  };\r\n\r\n  constructor(...args) {\r\n    super(...args);\r\n    this.addEventListener(Events.heal.to(SELECTED_PLAYER), this.onHeal);\r\n    this.addEventListener(Events.damage.to(SELECTED_PLAYER), this.onDamage);\r\n    this.addEventListener(Events.instakill.to(SELECTED_PLAYER), this.onInstakill);\r\n    this.addEventListener(Events.death.to(SELECTED_PLAYER), this.onDeath);\r\n    this.cooldowns = this.abilities.activeAbilities.filter(ability => (\r\n      ability.category === Abilities.SPELL_CATEGORIES.DEFENSIVE\r\n      || ability.category === Abilities.SPELL_CATEGORIES.SEMI_DEFENSIVE\r\n      || ability.isDefensive\r\n    ));\r\n    // Add additional defensive buffs/debuffs to common/DEFENSIVE_BUFFS\r\n    DEFENSIVE_BUFFS.forEach(e => {\r\n      this.buffs.push({\r\n        id: e.spell.id,\r\n      });\r\n    });\r\n    this.buffsModule.activeBuffs.forEach(buff => {\r\n      if (buff.spellId instanceof Array) {\r\n        buff.spellId.forEach(spellId => {\r\n          this.buffs.push({\r\n            id: spellId,\r\n          });\r\n        });\r\n      } else {\r\n        this.buffs.push({\r\n          id: buff.spellId,\r\n        });\r\n      }\r\n    });\r\n  }\r\n\r\n  addEvent(event) {\r\n    const extendedEvent = { ...event };\r\n    extendedEvent.time = event.timestamp - this.owner.fight.start_time;\r\n\r\n    const cooldownsOnly = this.cooldowns.filter(e => e.cooldown);\r\n    extendedEvent.defensiveCooldowns = cooldownsOnly.map(e => ({ id: e.primarySpell.id, cooldownReady: this.spellUsable.isAvailable(e.primarySpell.id) }));\r\n    if (event.hitPoints > 0) {\r\n      this.lastBuffs = this.buffs.filter(e => {\r\n        const buff = this.selectedCombatant.getBuff(e.id);\r\n        const hasBuff = buff !== undefined;\r\n        if (!hasBuff) {\r\n          return false;\r\n        }\r\n        if (e.id === SPELLS.BLESSING_OF_SACRIFICE.id) {\r\n          return buff.sourceID === this.selectedCombatant.id;\r\n        }\r\n        return true;\r\n      });\r\n    }\r\n    extendedEvent.buffsUp = this.lastBuffs;\r\n\r\n    if (!event.sourceIsFriendly && this.enemies.enemies[event.sourceID]) {\r\n      const sourceHasDebuff = debuff => (!debuff.end || event.timestamp <= debuff.end) && event.timestamp >= debuff.start && debuff.isDebuff && this.buffs.some(e => e.id === debuff.ability.guid);\r\n      extendedEvent.debuffsUp = this.enemies.enemies[event.sourceID].buffs.filter(sourceHasDebuff)\r\n        .map(e => ({ id: e.ability.guid }));\r\n    }\r\n\r\n    this.events.push(extendedEvent);\r\n  }\r\n\r\n  onHeal(event) {\r\n    this.addEvent(event);\r\n  }\r\n  onDamage(event) {\r\n    this.addEvent(event);\r\n  }\r\n  onInstakill(event) {\r\n    this.addEvent(event);\r\n  }\r\n  onDeath(event) {\r\n    if(event.timestamp <= this.owner.fight.start_time){\r\n      return;\r\n    }\r\n    this.addEvent(event);\r\n    this.deaths.push(event.timestamp);\r\n  }\r\n\r\n  get secondsBeforeDeath() {\r\n    return this.deaths.map(deathtime => ({\r\n      deathtime,\r\n      events: this.events,\r\n      open: false,\r\n    }));\r\n  }\r\n\r\n  // TODO: Turn this into a core component that is used directly by Results instead (tab is deprecated)\r\n  tab() {\r\n    if (this.deaths.length === 0) {\r\n      return null;\r\n    }\r\n\r\n    return {\r\n      title: 'Death Recap',\r\n      url: 'death-recap',\r\n      render: () => (\r\n        <Panel\r\n          title=\"Death recap\"\r\n          pad={false}\r\n        >\r\n          <DeathRecap\r\n            report={this.owner}\r\n            events={this.secondsBeforeDeath}\r\n            combatants={this.combatants.players}\r\n            enemies={this.enemies.enemies}\r\n          />\r\n        </Panel>\r\n      ),\r\n    };\r\n  }\r\n}\r\n\r\nexport default DeathRecapTracker;\r\n","import SPELLS from 'common/SPELLS';\r\n\r\nimport EventsNormalizer from 'parser/core/EventsNormalizer';\r\nimport {\r\n  AnyEvent,\r\n  ApplyBuffEvent,\r\n  CombatantInfoEvent,\r\n  EventType,\r\n  HasAbility,\r\n  HasTarget,\r\n  HasSource,\r\n} from 'parser/core/Events';\r\nimport { Options } from 'parser/core/Module';\r\nimport { Player } from 'parser/core/CombatLogParser';\r\n\r\nconst debug = false;\r\n\r\n/**\r\n * Some buffs like Bloodlust and Holy Avenger when they are applied pre-combat it doesn't show up as an `applybuff` event nor in the `combatantinfo` buffs array. It can still be detected by looking for a `removebuff` event, this uses that to detect it and then fabricates an `applybuff` event at the start of the log.\r\n */\r\nclass ApplyBuff extends EventsNormalizer {\r\n  // We need to track `combatantinfo` events this way since they aren't included in the `events` passed to `normalize` due to technical reasons (it's a different API call). We still need `combatantinfo` for all players, so cache it manually.\r\n  _combatantInfoEvents: CombatantInfoEvent[] | undefined = [];\r\n  constructor(options: Options) {\r\n    super(options);\r\n    this._combatantInfoEvents = this.owner.combatantInfoEvents;\r\n  }\r\n\r\n  _buffsAppliedByPlayerId: {\r\n    [playerid: number]: number[];\r\n  } = {};\r\n\r\n  normalize(events: AnyEvent[]) {\r\n    const firstEventIndex = this.getFightStartIndex(events);\r\n    const firstStartTimestamp = this.owner.fight.start_time;\r\n    const playersById = this.owner.players.reduce<{\r\n      [id: number]: Player;\r\n    }>((obj, player) => {\r\n      obj[player.id] = player;\r\n      return obj;\r\n    }, {});\r\n    const playerId = this.owner.playerId;\r\n\r\n    // region Buff event based detection\r\n    // This catches most relevant buffs and is most accurate. If a player is good at juggling certain buffs they can achieve 100% uptime, if that happens `removebuff` is never called, so we also check for other indicators that are just as reliable, such as `applybuffstack`, `removebuffstack` and `refreshbuff`.\r\n    for (let i = 0; i < events.length; i += 1) {\r\n      const event = events[i];\r\n      if (!HasAbility(event) || !HasTarget(event)) {\r\n        continue;\r\n      }\r\n      const targetId = event.targetID;\r\n      const sourceId = HasSource(event) ? event.sourceID : undefined;\r\n\r\n      // A player can have the same buff twice given that the buff was applied by someone else. Because we only want to fabricate buffs once, we use `_buffsAppliedByPlayerId` to ensure we don't do it twice, but because it doesn't track a source we can't track other people's buffs. And that's fine too since we only care about stuff by/to the player.\r\n      if (![targetId, sourceId].includes(playerId)) {\r\n        continue;\r\n      }\r\n\r\n      this._buffsAppliedByPlayerId[targetId] = this._buffsAppliedByPlayerId[targetId] || [];\r\n\r\n      if (event.type === EventType.ApplyBuff) {\r\n        const spellId = event.ability.guid;\r\n        this._buffsAppliedByPlayerId[targetId].push(spellId);\r\n      }\r\n      if (\r\n        event.type === EventType.RemoveBuff ||\r\n        event.type === EventType.ApplyBuffStack ||\r\n        event.type === EventType.RemoveBuffStack ||\r\n        event.type === EventType.RefreshBuff ||\r\n        event.type === EventType.FilterBuffInfo\r\n      ) {\r\n        const spellId = event.ability.guid;\r\n        if (this._buffsAppliedByPlayerId[targetId].includes(spellId)) {\r\n          // This buff has an `applybuff` event and so isn't broken :D\r\n          continue;\r\n        }\r\n\r\n        debug &&\r\n          this.warn(\r\n            'Found a buff on',\r\n            (playersById[targetId] && playersById[targetId].name) || '???',\r\n            'that was applied before the pull:',\r\n            event.ability.name,\r\n            spellId,\r\n            \"! Fabricating an `applybuff` event so you don't have to do anything special to take this into account.\",\r\n          );\r\n        const targetInfo =\r\n          this._combatantInfoEvents &&\r\n          this._combatantInfoEvents.find(\r\n            (combatantInfoEvent) => combatantInfoEvent.sourceID === targetId,\r\n          );\r\n        const applybuff: ApplyBuffEvent = {\r\n          // These are all the properties a normal `applybuff` event would have.\r\n          timestamp:\r\n            event.type === EventType.FilterBuffInfo\r\n              ? firstStartTimestamp - this.owner.fight.offset_time\r\n              : firstStartTimestamp,\r\n          type: EventType.ApplyBuff,\r\n          ability: event.ability,\r\n          sourceID: sourceId,\r\n          sourceIsFriendly: event.sourceIsFriendly,\r\n          targetID: targetId,\r\n          targetIsFriendly: event.targetIsFriendly,\r\n          // Custom properties:\r\n          prepull: true,\r\n          __fabricated: true,\r\n          // If we see a prepull buff from both its removebuff and in combatantinfo, we populate fabricated applybuff from the removebuff because this requires us to make up fewer fields. We still need to mark it as in the combatantinfo.\r\n          __fromCombatantinfo:\r\n            targetInfo &&\r\n            targetInfo.auras &&\r\n            targetInfo.auras.some((aura) => aura.ability === spellId),\r\n        };\r\n\r\n        events.splice(firstEventIndex, 0, applybuff);\r\n        // It shouldn't happen twice, but better be safe than sorry.\r\n        this._buffsAppliedByPlayerId[targetId].push(spellId);\r\n      }\r\n    }\r\n    // endregion\r\n\r\n    // region `combatantinfo` based detection\r\n    if (!this._combatantInfoEvents) {\r\n      return events;\r\n    }\r\n    // This catches buffs that never drop, such as Flasks and more importantly Atonements, Beacons and Vantus runes.\r\n    this._combatantInfoEvents.forEach((event) => {\r\n      const targetId = event.sourceID;\r\n      // event.auras can be undefined if combatantinfo for any player in the fight errored\r\n      event.auras &&\r\n        event.auras.forEach((aura) => {\r\n          const spellId = aura.ability;\r\n          const sourceId = aura.source;\r\n\r\n          // A player can have the same buff twice given that the buff was applied by someone else. Because we only want to fabricate buffs once, we use `_buffsAppliedByPlayerId` to ensure we don't do it twice, but because it doesn't track a source we can't track other people's buffs. And that's fine too since we only care about stuff by/to the player.\r\n          if (![targetId, sourceId].includes(playerId)) {\r\n            return;\r\n          }\r\n\r\n          this._buffsAppliedByPlayerId[targetId] = this._buffsAppliedByPlayerId[targetId] || [];\r\n\r\n          if (this._buffsAppliedByPlayerId[targetId].includes(spellId)) {\r\n            // This buff has an `applybuff` event and so isn't broken :D\r\n            return;\r\n          }\r\n\r\n          debug &&\r\n            console.warn(\r\n              'Found a buff on',\r\n              (playersById[targetId] && playersById[targetId].name) || '???',\r\n              'in the combatantinfo that was applied before the pull and never dropped:',\r\n              (SPELLS[spellId] && SPELLS[spellId].name) || '???',\r\n              spellId,\r\n              \"! Fabricating an `applybuff` event so you don't have to do anything special to take this into account.\",\r\n            );\r\n          const applybuff: ApplyBuffEvent = {\r\n            // These are all the properties a normal `applybuff` event would have.\r\n            timestamp: firstStartTimestamp,\r\n            type: EventType.ApplyBuff,\r\n            ability: {\r\n              guid: spellId,\r\n              name: SPELLS[spellId] ? SPELLS[spellId].name : 'Unknown',\r\n              abilityIcon: aura.icon,\r\n              type: 0,\r\n            },\r\n            sourceID: sourceId,\r\n            sourceIsFriendly: true,\r\n            targetID: targetId,\r\n            targetIsFriendly: true,\r\n            // Custom properties:\r\n            prepull: true,\r\n            __fabricated: true,\r\n            __fromCombatantinfo: true,\r\n          };\r\n          events.splice(firstEventIndex, 0, applybuff);\r\n          // It shouldn't happen twice, but better be safe than sorry.\r\n          this._buffsAppliedByPlayerId[targetId].push(spellId);\r\n        });\r\n    });\r\n    // We don't need it anymore, this might introduce a crash if this method is ever called twice, but we're under the presumption that never happens so if it does crash we might have to verify if everything works properly with this behavior.\r\n    this._combatantInfoEvents = undefined;\r\n    // endregion\r\n\r\n    return events;\r\n  }\r\n}\r\n\r\nexport default ApplyBuff;\r\n","import EventsNormalizer from 'parser/core/EventsNormalizer';\r\nimport CASTS_THAT_ARENT_CASTS from 'parser/core/CASTS_THAT_ARENT_CASTS';\r\nimport CASTABLE_WHILE_CASTING_SPELLS from 'parser/core/CASTABLE_WHILE_CASTING_SPELLS';\r\nimport { AnyEvent, BeginCastEvent, EventType, CastEvent } from 'parser/core/Events';\r\n\r\nconst MS_BUFFER = 100;\r\n\r\n/**\r\n * During analysis there's no way to know at a `begincast` event if it will end up being canceled. This marks all `begincast` events by the player with an `isCancelled` property whether it was cancelled.\r\n */\r\nclass CancelledCasts extends EventsNormalizer {\r\n  lastBeginCast: BeginCastEvent | null = null;\r\n\r\n  markLastBeginCastCancelled() {\r\n    if (this.lastBeginCast === null) {\r\n      return;\r\n    }\r\n    this.lastBeginCast.isCancelled = true;\r\n    this.lastBeginCast.castEvent = null;\r\n    this.lastBeginCast = null;\r\n  }\r\n  handleBeginCast(event: BeginCastEvent) {\r\n    if (this.lastBeginCast !== null && event.timestamp - this.lastBeginCast.timestamp > MS_BUFFER) {\r\n      this.markLastBeginCastCancelled();\r\n    }\r\n    this.lastBeginCast = event;\r\n  }\r\n  handleCast(event: CastEvent) {\r\n    if (this.lastBeginCast === null) {\r\n      return;\r\n    }\r\n    if (CASTS_THAT_ARENT_CASTS.includes(event.ability.guid) || CASTABLE_WHILE_CASTING_SPELLS.includes(event.ability.guid)) {\r\n      return;\r\n    }\r\n    if (this.lastBeginCast.ability.guid !== event.ability.guid) {\r\n      // The player started to cast something else. Sometimes this is incorrectly called due to boss mechanics being recorded as `cast` event during a non-cancelled channel. We handle that by ignoring these spells in the CASTS_THAT_ARENT_CASTS.js file.\r\n      this.markLastBeginCastCancelled();\r\n    } else {\r\n      // Mark cast completed\r\n      this.lastBeginCast.isCancelled = false;\r\n      this.lastBeginCast.castEvent = event;\r\n      this.lastBeginCast = null;\r\n    }\r\n  }\r\n\r\n  normalize(events: AnyEvent[]) {\r\n    events.forEach(event => {\r\n      if (!this.owner.byPlayer(event)) {\r\n        // We don't get `begincast` events from other players, but we do get `cast` events. This might confuse this method so just ignore all events from other players.\r\n        return;\r\n      }\r\n\r\n      if (event.type === EventType.BeginCast) {\r\n        this.handleBeginCast(event);\r\n      } else if (event.type === EventType.Cast) {\r\n        this.handleCast(event);\r\n      }\r\n    });\r\n    return events;\r\n  }\r\n}\r\n\r\nexport default CancelledCasts;\r\n","import SPELLS from 'common/SPELLS';\r\nimport Abilities from 'parser/core/modules/Abilities';\r\nimport Buffs from 'parser/core/modules/Buffs';\r\nimport { EventType } from 'parser/core/Events';\r\nimport EventsNormalizer from 'parser/core/EventsNormalizer';\r\nimport { captureException } from 'common/errorLogger';\r\n\r\nimport ApplyBuff from './ApplyBuff';\r\n\r\nconst debug = false;\r\n\r\n/**\r\n * This normalizer attempts to track all potentially relevant casts that\r\n * happened before the pull. It then fabricates cast events in order to help\r\n * other modules (like cast efficiency) be more accurate.\r\n *\r\n * Additionally, because there is currently no ability info on whether or not a\r\n * spell is instant or has a cast time, we cannot (yet) accurately fabricate\r\n * the right type of event (begincast + cast vs only a cast).\r\n *\r\n * @property {Abilities} abilities\r\n * @property {Buffs} buffs\r\n * @property {ApplyBuff} applyBuff\r\n */\r\nclass PrePullCooldowns extends EventsNormalizer {\r\n  /*\r\n   * Abilities is an analyzer, which means that accessing it from a\r\n   * normalizer like this one is not ideal design. For now, to avoid having to\r\n   * rewrite Abilities (a core module heavily coupled with pretty much every\r\n   * specialization), just be aware that using any Ability properties that\r\n   * require event data (like .cooldown if it's a func, etc.) will *not*\r\n   * produce intended results. In this normalizer I only access parts of the\r\n   * spellbook with static values.\r\n   */\r\n  static dependencies = {\r\n    abilities: Abilities,\r\n    buffs: Buffs,\r\n    applyBuff: ApplyBuff, // we need fabricated events for untracked prepull applied buffs\r\n  };\r\n\r\n  /**\r\n   * Rather than constantly querying Abilities, here we simplify into two\r\n   * new arrays that we can modify without messing with the spellbook\r\n   */\r\n  getApplicableSpells() {\r\n    const buffSpells = [];\r\n    const damageSpells = [];\r\n    const addBuff = (buff, buffId) => {\r\n      if (!buff.triggeredBySpellId) {\r\n        // This normalizer is to fabricate prepull cast events that can be detected from buffs (and damage). If a buff isn't triggered by a spell, then there's nothing to fabricate.\r\n        return;\r\n      }\r\n\r\n      buffSpells.push({\r\n        castId: buff.triggeredBySpellId,\r\n        buffId,\r\n      });\r\n    };\r\n\r\n    this.buffs.activeBuffs.forEach(buff => {\r\n      if (buff.spellId instanceof Array) {\r\n        // Add each buff separate to make usage easier\r\n        buff.spellId.forEach(spellId => {\r\n          addBuff(buff, spellId);\r\n        });\r\n      } else {\r\n        addBuff(buff, buff.spellId);\r\n      }\r\n    });\r\n\r\n    this.abilities.activeAbilities.forEach(ability => {\r\n      if (ability.damageSpellIds) {\r\n        damageSpells.push({\r\n          castId: ability.spell.id,\r\n          damageIds: ability.damageSpellIds,\r\n        });\r\n      }\r\n    });\r\n\r\n    return {\r\n      buffSpells,\r\n      damageSpells,\r\n    };\r\n  }\r\n\r\n  normalize(events) {\r\n    const { buffSpells, damageSpells } = this.getApplicableSpells();\r\n    const prepullCasts = [];\r\n    let precastClassResources = null;\r\n\r\n    // When the fight started. Used for instants.\r\n    const fightStartTimestamp = this.owner.fight.start_time;\r\n    // When the player first cast something. Used for everything else (this is intended to optimally estimate channeled spells).\r\n    const firstEventIndex = this.getFightStartIndex(events);\r\n    const firstTimestamp = events[firstEventIndex].timestamp;\r\n    const playerId = this.owner.playerId;\r\n\r\n    for (let i = 0; i < events.length; i += 1) {\r\n      const event = events[i];\r\n      const sourceId = event.sourceID;\r\n\r\n      if (event.type === EventType.ApplyBuff) {\r\n        // We rely on the ApplyBuff normalizer to set the prepull property\r\n        if (!event.prepull) {\r\n          continue;\r\n        }\r\n\r\n        for (let i = 0; i < buffSpells.length; i += 1) {\r\n          if (buffSpells[i].buffId === event.ability.guid) {\r\n            debug && console.debug(`Detected a precast buff cooldown: ${event.ability.name}`);\r\n            if(buffSpells[i].castId instanceof Array && buffSpells[i].castId.includes(event.ability.guid)){ //try to find corresponding cast, otherwise pass list of casts\r\n              prepullCasts.push(this.constructor._fabricateCastEvent(event));\r\n            }else{\r\n              prepullCasts.push(this.constructor._fabricateCastEvent(event, buffSpells[i].castId));\r\n            }\r\n            buffSpells.splice(i, 1);\r\n            break;\r\n          }\r\n        }\r\n        continue;\r\n      }\r\n\r\n      if (sourceId !== playerId) {\r\n        continue;\r\n      }\r\n\r\n      if (event.type === EventType.Cast) {\r\n        /**\r\n         * This will copy the first resource information to all precast events.\r\n         * It's not pretty or 100% accurate, but it prevents errors on analyzers\r\n         * that require resource information and usually wont be too far off.\r\n         *\r\n         * In the future, a better way to handle this would be to make sure any\r\n         * analyzers that need the resource information check for .prepull, or\r\n         * we gain access to spell data that lets us build the resource\r\n         * information more accurately.\r\n         */\r\n        if (precastClassResources === null && event.classResources) {\r\n          debug && console.debug('Setting prepull class resources to:', event.classResources);\r\n          precastClassResources = event.classResources;\r\n        }\r\n\r\n        // If a cast is found for a damage spell, remove it from the search\r\n        for (let i = 0; i < damageSpells.length; i += 1) {\r\n          if (damageSpells[i].castId === event.ability.guid) {\r\n            damageSpells.splice(i, 1);\r\n            break;\r\n          }\r\n        }\r\n        continue;\r\n      }\r\n\r\n      if (event.type === EventType.Damage) {\r\n        // If a damage event already has a cast event, it shouldn't be in the array\r\n        for (let i = 0; i < damageSpells.length; i += 1) {\r\n          if (damageSpells[i].damageIds.some(id => id === event.ability.guid)) {\r\n            debug && console.debug(`Detected a precast damage cooldown: ${event.ability.name}`);\r\n            prepullCasts.push(this.constructor._fabricateCastEvent(event, damageSpells[i].castId));\r\n            damageSpells.splice(i, 1);\r\n            break;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Potential issue: If players cast buffs long before the pull that have a\r\n     * long duration, this normalizer doesn't know that and assumes they\r\n     * cast it optimized right before the pull. This means that the next time\r\n     * it gets cast we may get an error saying it was still on cooldown. To\r\n     * resolve this, we could also listen for buffremove events and use that\r\n     * to deduce the cast time. This would require ability info about durations.\r\n     */\r\n    // Working backwards, assume worst-case GCD timestamps\r\n    let totalGCD = 0;\r\n    for (let i = prepullCasts.length - 1; i >= 0; i -= 1) {\r\n      const event = prepullCasts[i];\r\n      const gcd = this._resolveAbilityGcd(event.ability.guid);\r\n      if (gcd === 0) {\r\n        // When the ability is off the GCD give it at least some margin so it properly appears as cast before the pull and out of combat\r\n        event.timestamp = fightStartTimestamp - this.owner.fight.offset_time - 100;\r\n      } else {\r\n        totalGCD += gcd;\r\n        event.timestamp = firstTimestamp - this.owner.fight.offset_time - totalGCD;\r\n      }\r\n      event.classResources = precastClassResources;\r\n    }\r\n    events.unshift(...prepullCasts);\r\n    return events;\r\n  }\r\n\r\n  _resolveAbilityGcd(id) {\r\n    const ability = this.abilities.getAbility(id);\r\n    if (!ability) {\r\n      captureException(new Error(`No ability available for spell: ${id}`));\r\n      return 0;\r\n    }\r\n    const gcdProp = ability.gcd;\r\n    if (!gcdProp) {\r\n      return 0;\r\n    }\r\n    if (typeof gcdProp.static === 'number') {\r\n      return gcdProp.static;\r\n    }\r\n    if (typeof gcdProp.base === 'number') {\r\n      return gcdProp.base;\r\n    }\r\n    // We can't resolve the gcd functions because this is a normalizer, so if no flat numbers are set we just assume worst-case\r\n    return 1500;\r\n  }\r\n\r\n  static _fabricateCastEvent(event, castId = null) {\r\n    let ability = event.ability;\r\n    if (castId) {\r\n      if (castId instanceof Array) {\r\n        castId = castId[0];\r\n      }\r\n      const spell = SPELLS[castId];\r\n      ability = {\r\n        ...ability,\r\n        guid: castId,\r\n        abilityIcon: spell ? spell.icon : ability.abilityIcon,\r\n        name: spell ? spell.name : event.ability.name,\r\n      };\r\n    }\r\n\r\n    return {\r\n      type: EventType.Cast,\r\n      ability: ability,\r\n      sourceID: event.sourceID,\r\n      sourceIsFriendly: event.sourceIsFriendly,\r\n      targetID: event.targetID,\r\n      targetIsFriendly: event.targetIsFriendly,\r\n\r\n      // Custom properties:\r\n      prepull: true,\r\n      __fabricated: true,\r\n    };\r\n  }\r\n}\r\n\r\nexport default PrePullCooldowns;\r\n","import EventsNormalizer from 'parser/core/EventsNormalizer';\r\nimport { AnyEvent, EventType, FightEndEvent } from 'parser/core/Events';\r\n\r\n/**\r\n * Normalizes in an event at the back of the queue to indicate that the fight\r\n * has completed and parsing will end. By subscribing to this event you can\r\n * ensure that pending analyzer logic completes cleanly.\r\n */\r\nclass FightEnd extends EventsNormalizer {\r\n  normalize(events: AnyEvent[]) {\r\n    const event: FightEndEvent = {\r\n      timestamp: this.owner.fight.end_time,\r\n      type: EventType.FightEnd,\r\n      __fabricated: true,\r\n    };\r\n    events.push(event);\r\n    return events;\r\n  }\r\n}\r\n\r\nexport default FightEnd;\r\n","import EventsNormalizer from 'parser/core/EventsNormalizer';\r\nimport { AnyEvent, EventType } from 'parser/core/Events';\r\n\r\n/**\r\n * Normalizes phase events to ensure they are ordered correctly\r\n */\r\nclass FightEnd extends EventsNormalizer {\r\n\r\n  normalize(events: AnyEvent[]) {\r\n\r\n    const phaseEvents = events.filter(event => event.type === EventType.PhaseStart || event.type === EventType.PhaseEnd);\r\n    const nonPhaseEvents = events.filter(event => event.type !== EventType.PhaseStart && event.type !== EventType.PhaseEnd);\r\n\r\n    phaseEvents.forEach(phaseEvent => {\r\n      const index = nonPhaseEvents.findIndex(e => e.timestamp > phaseEvent.timestamp);\r\n      nonPhaseEvents.splice(index, 0, phaseEvent);\r\n    });\r\n\r\n    return nonPhaseEvents;\r\n  }\r\n}\r\n\r\nexport default FightEnd;\r\n","import EventsNormalizer from 'parser/core/EventsNormalizer';\r\nimport { AnyEvent, ApplyBuffEvent, CastEvent, EventType } from 'parser/core/Events';\r\n\r\n/*\r\n * Some on use items (e.g. trinkets) provide a buff when used but do not trigger a cast event, making it more annoying to check for automatically using e.g. usage suggestions.\r\n * This normalizer adds cast events at the same timestamp as the applybuff event occured\r\n */\r\nclass MissingCasts extends EventsNormalizer {\r\n  /*\r\n   * List of buffs that do not have an associated cast event\r\n   */\r\n  static missingCastBuffs: number[] = [];\r\n\r\n  normalize(events: AnyEvent[]) {\r\n    // Just in case someone chooses to extend this module to modify missingCastBuffs instead of adding to it here...\r\n    const ctor = this.constructor as typeof MissingCasts;\r\n    const missingCastEvents = events\r\n      .filter((event): event is ApplyBuffEvent => event.type === EventType.ApplyBuff && ctor.missingCastBuffs.includes(event.ability.guid))\r\n      .map(event => ctor._fabricateCastEvent(event));\r\n    missingCastEvents.forEach(event => {\r\n      const index = events.findIndex(e => e.timestamp >= event.timestamp);\r\n      events.splice(index, 0, event); //sort into event list just before cast event\r\n    });\r\n    return events;\r\n  }\r\n\r\n  static _fabricateCastEvent(event: ApplyBuffEvent): CastEvent {\r\n    if (event.sourceID === undefined) {\r\n      throw new Error('applybuff event defined in MissingCasts does not contain a sourceID for the fabricated event');\r\n    }\r\n    return {\r\n      type: EventType.Cast,\r\n      ability: event.ability,\r\n      sourceID: event.sourceID,\r\n      sourceIsFriendly: event.sourceIsFriendly,\r\n      targetID: event.targetID,\r\n      targetIsFriendly: event.targetIsFriendly,\r\n      timestamp: event.timestamp,\r\n\r\n      // Custom properties:\r\n      __fabricated: true,\r\n    };\r\n  }\r\n}\r\n\r\nexport default MissingCasts;\r\n","import Analyzer, { Options } from 'parser/core/Analyzer';\r\nimport Events, {\r\n  EventType,\r\n  GlobalCooldownEvent,\r\n  UpdateSpellUsableEvent,\r\n} from 'parser/core/Events';\r\n\r\nimport SpellUsable from '../modules/SpellUsable';\r\n\r\nconst GCD_MATCH_BUFFER_MS = 150;\r\nconst RESET_BUFFER_PERCENT = 0.5;\r\n\r\nclass SpellTimeWaitingOnGlobalCooldown extends Analyzer {\r\n  static dependencies = {\r\n    spellUsable: SpellUsable,\r\n  };\r\n  // necessary for the UpdateSpellUsable event\r\n  protected spellUsable!: SpellUsable;\r\n\r\n  private lastGlobalCooldown: GlobalCooldownEvent | undefined;\r\n  constructor(options: Options) {\r\n    super(options);\r\n    this.addEventListener(\r\n      Events.UpdateSpellUsable,\r\n      this.handleUpdateSpellUsable,\r\n    );\r\n    this.addEventListener(Events.GlobalCooldown, this.handleGlobalCooldown);\r\n  }\r\n\r\n  private handleUpdateSpellUsable(event: UpdateSpellUsableEvent) {\r\n    if (!this.lastGlobalCooldown) {\r\n      return;\r\n    }\r\n    const resetBufferMS =\r\n      RESET_BUFFER_PERCENT * this.lastGlobalCooldown.duration;\r\n    const earlyByMS = event.start + event.expectedDuration - event.timestamp;\r\n    // check if the ability was reset early. If the reset was less than a percentage of the GCD don't consider it as a reset.\r\n    // check if the reset happened as a result of the previous cast\r\n    if (\r\n      event.trigger === EventType.EndCooldown &&\r\n      resetBufferMS < earlyByMS &&\r\n      event.timestamp < this.lastGlobalCooldown.timestamp + GCD_MATCH_BUFFER_MS\r\n    ) {\r\n      // if the time remaining was less than the GCD use that instead\r\n      event.timeWaitingOnGCD = Math.min(\r\n        earlyByMS,\r\n        this.lastGlobalCooldown.duration,\r\n      );\r\n    }\r\n  }\r\n  private handleGlobalCooldown(event: GlobalCooldownEvent) {\r\n    this.lastGlobalCooldown = event;\r\n  }\r\n}\r\n\r\nexport default SpellTimeWaitingOnGlobalCooldown;\r\n","import React from 'react';\r\n\r\nimport StatisticGroup from 'interface/statistics/StatisticGroup';\r\nimport Analyzer from 'parser/core/Analyzer';\r\n\r\nimport DamageDone from './DamageDone';\r\nimport HealingDone from './HealingDone';\r\nimport DamageTaken from './DamageTaken';\r\n\r\n/**\r\n * @property {DamageDone} damageDone\r\n * @property {HealingDone} healingDone\r\n * @property {DamageTaken} damageTaken\r\n */\r\nclass ThroughputStatisticGroup extends Analyzer {\r\n  static dependencies = {\r\n    damageDone: DamageDone,\r\n    healingDone: HealingDone,\r\n    damageTaken: DamageTaken,\r\n  };\r\n\r\n  protected damageDone!: DamageDone;\r\n  protected healingDone!: HealingDone;\r\n  protected damageTaken!: DamageTaken;\r\n\r\n  statistic() {\r\n    return (\r\n      <StatisticGroup\r\n        position={0}\r\n        wide\r\n        large={false}\r\n        style={{ marginBottom: 30 }}\r\n      >\r\n        {this.damageDone.subStatistic()}\r\n        {this.healingDone.subStatistic()}\r\n        {this.damageTaken.subStatistic()}\r\n      </StatisticGroup>\r\n    );\r\n  }\r\n}\r\n\r\nexport default ThroughputStatisticGroup;\r\n","import Analyzer from 'parser/core/Analyzer';\r\nimport { AnyEvent, EventType } from 'parser/core/Events';\r\n\r\nconst BUFFER = 3000;\r\n\r\nclass FilteredActiveTime extends Analyzer {\r\n\r\n  filterEvents(events: AnyEvent[], start: number, end: number) {\r\n    let filteredEvents = []\r\n    filteredEvents = events.filter(event => event.timestamp >= start && event.timestamp <= end && (event.type === EventType.GlobalCooldown || event.type === EventType.EndChannel));\r\n    return filteredEvents;\r\n  }\r\n\r\n  getActiveTime(start: number, end: number, events: AnyEvent[] = this.owner.eventHistory) {\r\n    let activeTime = 0;\r\n    let lastGCD: {\r\n      duration: number,\r\n      timestamp: number,\r\n    } = { duration: 0, timestamp: 0};\r\n    const filteredEvents = this.filterEvents(events, start - BUFFER, end + BUFFER);\r\n\r\n    filteredEvents.forEach(event => {\r\n\r\n      //Global Cooldown\r\n      if (event.type === EventType.GlobalCooldown) {\r\n        lastGCD = { duration: event.duration, timestamp: event.timestamp };\r\n\r\n        //If the GCD was triggered by a BeginChannel event, then this will get counted via the EndChannel event, so we need to return so we dont double count it ... unless it extends beyond the end timestamp.\r\n        //If the GCD does not extend beyond the start timestamp or was started agter the end timestamp, then we can get rid of those as well.\r\n        if ((event.trigger.type === EventType.BeginChannel && event.timestamp + event.duration < end) || event.timestamp < start - event.duration || event.timestamp > end) {\r\n          return;\r\n        }\r\n\r\n        //If a spell was on GCD at the start of the timeframe, then count the portion after the \"start\" time. Likewise if a GCD extended beyond the end of the timeframe, then count the portion before the \"end\" time.\r\n        if (start - event.timestamp > 0) {\r\n          activeTime += (event.timestamp + event.duration) - start;\r\n        } else if (event.timestamp + event.duration >= end) {\r\n          activeTime += (end - event.timestamp);\r\n        } else {\r\n          activeTime += event.duration;\r\n        }\r\n      } \r\n      \r\n      //End Channel\r\n      if (event.type === EventType.EndChannel) {\r\n\r\n        //If the channel ended before the start timestamp or began after the end timestamp, then return so it isnt counted.\r\n        //If the end channel was for an instant spell (end channel and the gcd were at the same timestamp) and it was cast after the end timestamp, then disregard that as well.\r\n        if (event.start < start - event.duration || event.start > end || (event.timestamp === lastGCD.timestamp && event.timestamp + lastGCD.duration > end)) {\r\n          return;\r\n        }\r\n\r\n        if (event.start < start) {\r\n          activeTime += Math.max(event.timestamp - start, (event.timestamp + lastGCD.duration) - start);\r\n        } else if (event.timestamp > end) {\r\n          activeTime += Math.max(end - event.start, end - lastGCD.timestamp);\r\n        } else {\r\n          activeTime += Math.max(event.duration, lastGCD.duration);\r\n        }\r\n      }\r\n    })\r\n    return activeTime;\r\n  }\r\n\r\n  getDowntime(start: number, end: number, events: AnyEvent[] = this.owner.eventHistory) {\r\n    const activeTime = this.getActiveTime(start, end, events);\r\n    const duration = end - start;\r\n    return duration - activeTime;\r\n  }\r\n}\r\n\r\nexport default FilteredActiveTime;\r\n","import EventSubscriber, { SELECTED_PLAYER } from 'parser/core/EventSubscriber';\r\nimport Abilities from 'parser/core/modules/Abilities';\r\nimport CASTS_THAT_ARENT_CASTS from 'parser/core/CASTS_THAT_ARENT_CASTS';\r\nimport Events from 'parser/core/Events';\r\n\r\n/**\r\n * Validate that all spells castable by the player is in the spellbook\r\n */\r\nclass AbilitiesMissing extends EventSubscriber {\r\n  static dependencies = {\r\n    abilities: Abilities,\r\n  };\r\n\r\n  constructor(options) {\r\n    super(options);\r\n    this.addEventListener(Events.cast.by(SELECTED_PLAYER), this.handleCast);\r\n  }\r\n\r\n  handleCast(event) {\r\n    if (!event.ability) {\r\n      return;\r\n    }\r\n    const ability = this.abilities.getAbility(event.ability.guid);\r\n    if (!ability && !CASTS_THAT_ARENT_CASTS.includes(event.ability.guid)) {\r\n      console.warn('Ability missing from spellbook:', event.ability);\r\n    }\r\n  }\r\n}\r\n\r\nexport default AbilitiesMissing;\r\n","import Analyzer from 'parser/core/Analyzer';\r\n\r\nimport DeathDowntime from './DeathDowntime';\r\n\r\n/**\r\n * Combines all the downtime modules into one value.\r\n *\r\n * @property {DeathDowntime} deathDowntime\r\n */\r\nclass TotalDowntime extends Analyzer {\r\n  static dependencies = {\r\n    deathDowntime: DeathDowntime,\r\n  };\r\n\r\n  get totalBaseDowntime() {\r\n    return this.deathDowntime.totalDowntime;\r\n  }\r\n  get totalDpsDowntime() {\r\n    return this.totalBaseDowntime;\r\n  }\r\n  get totalHealingDowntime() {\r\n    return this.totalBaseDowntime;\r\n  }\r\n  get totalTankingDowntime() {\r\n    return this.totalBaseDowntime;\r\n  }\r\n}\r\n\r\nexport default TotalDowntime;\r\n","import React from 'react';\r\nimport Analyzer, { Options, SELECTED_PLAYER } from 'parser/core/Analyzer';\r\nimport Statistic from 'interface/statistics/Statistic';\r\nimport STATISTIC_ORDER from 'interface/others/STATISTIC_ORDER';\r\nimport SpellLink from 'common/SpellLink';\r\nimport SPELLS from 'common/SPELLS';\r\nimport Events, { DispelEvent } from 'parser/core/Events';\r\nimport { Trans } from '@lingui/macro';\r\n\r\nclass DispelTracker extends Analyzer {\r\n  dispelEvents = new Map<number, number>();\r\n  dispelCount = 0;\r\n\r\n  blackList = [\r\n    SPELLS.WINDWALKING.id,\r\n  ];\r\n\r\n  constructor(options: Options) {\r\n    super(options);\r\n    this.addEventListener(Events.dispel.by(SELECTED_PLAYER), this.onDispel);\r\n  }\r\n\r\n  onDispel(event: DispelEvent) {\r\n    const abilityDispelled = event.extraAbility;\r\n    const dispelledId = abilityDispelled.guid;\r\n    if (this.blackList.includes(dispelledId)) {\r\n      return;\r\n    }\r\n    const currentCount = this.dispelEvents.get(dispelledId) || 0;\r\n    this.dispelEvents.set(dispelledId, currentCount + 1);\r\n\r\n    if (!SPELLS[dispelledId]) {\r\n      // The spells need to be defined so the view doesn't crash\r\n      SPELLS[dispelledId] = {\r\n        id: dispelledId,\r\n        name: abilityDispelled.name,\r\n        icon: abilityDispelled.abilityIcon.replace('.jpg', ''),\r\n      };\r\n    }\r\n    this.dispelCount += 1;\r\n  }\r\n\r\n  statistic() {\r\n    if (this.dispelCount < 1) {\r\n      return null;\r\n    }\r\n\r\n    return (\r\n      <Statistic position={STATISTIC_ORDER.OPTIONAL(1)} size='flexible'>\r\n        <div className=\"pad\">\r\n          <Trans id=\"shared.dispelTracker.label\" render=\"label\">\r\n            Dispels\r\n          </Trans>\r\n          {Array.from(this.dispelEvents).map(([dispelledId, count]) => (\r\n            <div className=\"flex\" key={dispelledId}>\r\n              <div className=\"flex-sub\" style={{ flex: 3 }}><SpellLink id={Number(dispelledId)} /></div>\r\n              <div className=\"flex-sub\" style={{ flex: 1, textAlign: 'right' }}>{count}</div>\r\n            </div>\r\n          ))}\r\n          <div className=\"flex\">\r\n            <div className=\"flex-sub value\" style={{ flex: 3 }}><Trans id=\"common.total\">Total</Trans></div>\r\n            <div className=\"flex-sub value\" style={{ flex: 1, textAlign: 'right' }}>{this.dispelCount}</div>\r\n          </div>\r\n        </div>\r\n      </Statistic>\r\n    );\r\n  }\r\n}\r\n\r\nexport default DispelTracker;\r\n","import React from 'react';\r\nimport PropTypes from 'prop-types';\r\nimport { AutoSizer } from 'react-virtualized';\r\nimport BaseChart, { formatTime } from 'interface/others/BaseChart';\r\nimport { i18n } from '@lingui/core';\r\nimport { t } from '@lingui/macro';\r\n\r\nconst DEATH_COLOR = 'rgba(255, 0, 0, 0.8)';\r\n\r\nclass RaidHealthChart extends React.Component {\r\n  static propTypes = {\r\n    players: PropTypes.arrayOf(PropTypes.shape({\r\n      title: PropTypes.string.isRequired,\r\n      borderColor: PropTypes.string.isRequired,\r\n      backgroundColor: PropTypes.string.isRequired,\r\n      data: PropTypes.arrayOf(PropTypes.shape({\r\n        x: PropTypes.number.isRequired,\r\n        y: PropTypes.number.isRequired,\r\n      })).isRequired,\r\n    })).isRequired,\r\n    deaths: PropTypes.arrayOf(PropTypes.shape({\r\n      x: PropTypes.number.isRequired,\r\n    })).isRequired,\r\n    startTime: PropTypes.number.isRequired,\r\n    endTime: PropTypes.number.isRequired,\r\n  };\r\n\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      players: this.props.players.map(player => ({ disabled: false, ...player })),\r\n    };\r\n    this.togglePlayer = this.togglePlayer.bind(this);\r\n  }\r\n\r\n  state = {\r\n    players: [],\r\n  };\r\n\r\n  togglePlayer(index) {\r\n    this.setState((prevState) => {\r\n      const players = prevState.players;\r\n      players[index].disabled = !players[index].disabled;\r\n      return {\r\n        players,\r\n      };\r\n    });\r\n  }\r\n\r\n  render() {\r\n    const { players, deaths, startTime, endTime } = this.props;\r\n    const xValues = [];\r\n    const yValues = [];\r\n    for (let i = 0; i < (endTime - startTime) / 1000; i += 30) {\r\n      xValues.push(i);\r\n    }\r\n    for (let i = 0; i <= players.length; i += 2) {\r\n      yValues.push(i * 100);\r\n    }\r\n\r\n    const xAxis = {\r\n      field: 'x',\r\n      type: 'quantitative',\r\n      title: 'Time',\r\n      axis: {\r\n        labelExpr: formatTime('datum.value * 1000'),\r\n      },\r\n    };\r\n\r\n    const deathSpec = {\r\n      data: {\r\n        name: 'deaths',\r\n      },\r\n      mark: {\r\n        type: 'rule',\r\n        color: DEATH_COLOR,\r\n      },\r\n      encoding: {\r\n        x: xAxis,\r\n      },\r\n    };\r\n\r\n    const hpSpec = {\r\n      data: {\r\n        name: 'hp',\r\n      },\r\n      mark: 'area',\r\n      selection: {\r\n        player: {\r\n          type: 'multi',\r\n          fields: ['title'],\r\n          bind: 'legend',\r\n        },\r\n      },\r\n      encoding: {\r\n        x: xAxis,\r\n        y: {\r\n          field: 'y',\r\n          type: 'quantitative',\r\n          stack: true,\r\n          title: i18n._(t('shared.modules.raidHealthTab.chart.title.y')`Total Raid Health`),\r\n        },\r\n        color: {\r\n          field: 'title',\r\n          type: 'nominal',\r\n          title: i18n._(t('common.player')`Player`),\r\n        },\r\n        opacity: {\r\n          condition: { selection: 'player', value: 1 },\r\n          value: 0.3,\r\n        },\r\n      },\r\n    };\r\n    const data = {\r\n      hp: [].concat(...players.map(p => p.data.map(datum => ({...datum, title: p.title })))),\r\n      deaths,\r\n    };\r\n\r\n    const spec = {\r\n      layer: [hpSpec, deathSpec],\r\n    };\r\n\r\n    return (\r\n      <AutoSizer disableHeight>\r\n        {({ width }) => (\r\n          <BaseChart\r\n            height={400}\r\n            width={width}\r\n            spec={spec}\r\n            data={data}\r\n          />\r\n        )}\r\n      </AutoSizer>\r\n    );\r\n  }\r\n}\r\n\r\nexport default RaidHealthChart;\r\n","import React from 'react';\r\nimport PropTypes from 'prop-types';\r\n\r\nimport fetchWcl from 'common/fetchWclApi';\r\n\r\nimport RaidHealthChart from './RaidHealthChart';\r\n\r\nconst CLASS_CHART_LINE_COLORS = {\r\n  DeathKnight: 'rgba(196, 31, 59, 0.6)',\r\n  Druid: 'rgba(255, 125, 10, 0.6)',\r\n  Hunter: 'rgba(171, 212, 115, 0.6)',\r\n  Mage: 'rgba(105, 204, 240, 0.6)',\r\n  Monk: 'rgba(45, 155, 120, 0.6)',\r\n  Paladin: 'rgba(245, 140, 186, 0.6)',\r\n  Priest: 'rgba(255, 255, 255, 0.6)',\r\n  Rogue: 'rgba(255, 245, 105, 0.6)',\r\n  Shaman: 'rgba(36, 89, 255, 0.6)',\r\n  Warlock: 'rgba(148, 130, 201, 0.6)',\r\n  Warrior: 'rgba(199, 156, 110, 0.6)',\r\n  DemonHunter: 'rgba(163, 48, 201, 0.6)',\r\n};\r\n\r\n\r\nclass Graph extends React.PureComponent {\r\n  static propTypes = {\r\n    reportCode: PropTypes.string.isRequired,\r\n    start: PropTypes.number.isRequired,\r\n    end: PropTypes.number.isRequired,\r\n    offset: PropTypes.number.isRequired,\r\n  };\r\n\r\n  constructor() {\r\n    super();\r\n    this.state = {\r\n      data: null,\r\n    };\r\n  }\r\n\r\n  componentDidMount() {\r\n    this.load();\r\n  }\r\n\r\n  componentDidUpdate(prevProps) {\r\n    if (prevProps.reportCode !== this.props.reportCode || prevProps.start !== this.props.start || prevProps.end !== this.props.end) {\r\n      this.load();\r\n    }\r\n  }\r\n\r\n  load() {\r\n    const { reportCode, start, end } = this.props;\r\n    fetchWcl(`report/tables/resources/${reportCode}`, {\r\n      start,\r\n      end,\r\n      abilityid: 1000,\r\n    })\r\n      .then(json => {\r\n        console.log('Received player health', json);\r\n        this.setState({\r\n          data: json,\r\n        });\r\n      });\r\n  }\r\n\r\n  render() {\r\n    const data = this.state.data;\r\n    if (!data) {\r\n      return (\r\n        <div>\r\n          Loading...\r\n        </div>\r\n      );\r\n    }\r\n\r\n    const { start, end, offset } = this.props;\r\n\r\n    const players = data.series.filter(item => Boolean(CLASS_CHART_LINE_COLORS[item.type]));\r\n\r\n    const entities = [];\r\n\r\n    players.forEach(series => {\r\n      const newSeries = {\r\n        ...series,\r\n        lastValue: 100, // fights start at full hp\r\n        data: {},\r\n      };\r\n\r\n      series.data.forEach((item) => {\r\n        const secIntoFight = Math.floor((item[0] - start) / 1000);\r\n\r\n        const health = item[1];\r\n        newSeries.data[secIntoFight] = Math.min(100, health);\r\n      });\r\n      entities.push(newSeries);\r\n    });\r\n\r\n    const deathsBySecond = {};\r\n    if (this.state.data.deaths) {\r\n      this.state.data.deaths.forEach((death) => {\r\n        const secIntoFight = Math.floor((death.timestamp - start) / 1000);\r\n\r\n        if (death.targetIsFriendly) {\r\n          deathsBySecond[secIntoFight] = true;\r\n        }\r\n      });\r\n    }\r\n\r\n    const fightDurationSec = Math.ceil((end - start) / 1000);\r\n    for (let i = 0; i <= fightDurationSec; i += 1) {\r\n      entities.forEach((series) => {\r\n        series.data[i] = series.data[i] !== undefined ? series.data[i] : series.lastValue;\r\n        series.lastValue = series.data[i];\r\n      });\r\n      deathsBySecond[i] = deathsBySecond[i] !== undefined ? deathsBySecond[i] : undefined;\r\n    }\r\n\r\n    // transform data into react-vis format\r\n    const playerHealth = entities.map(player => {\r\n      const data = Object.entries(player.data).map(([key, value]) => ({ x: Number(key), y: value }));\r\n      return {\r\n        title: player.name,\r\n        backgroundColor: CLASS_CHART_LINE_COLORS[player.type],\r\n        borderColor: CLASS_CHART_LINE_COLORS[player.type],\r\n        data,\r\n      };\r\n    });\r\n    const deaths = Object.entries(deathsBySecond).filter(([_, value]) => Boolean(value)).map(([key]) => ({ x: Number(key) }));\r\n\r\n    return (\r\n      <div className=\"graph-container\">\r\n        <RaidHealthChart\r\n          players={playerHealth}\r\n          deaths={deaths}\r\n          startTime={start}\r\n          endTime={end}\r\n          offsetTime={offset}\r\n        />\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Graph;\r\n","import React from 'react';\r\nimport PropTypes from 'prop-types';\r\n\r\nimport Panel from 'interface/others/Panel';\r\nimport { Trans } from '@lingui/macro';\r\n\r\nimport Graph from './Graph';\r\n\r\nconst Mana = ({ parser }) => (\r\n  <Panel\r\n    title={<Trans id=\"shared.raidHealth.tab.title\">Raid health</Trans>}\r\n    explanation={<Trans id=\"shared.raidHealth.tab.explanation\">The stacked health of your raid to give an idea of the healing intensity. Most progression raid fights the raid will rarely be topped.</Trans>}\r\n  >\r\n    <Graph\r\n      reportCode={parser.report.code}\r\n      actorId={parser.playerId}\r\n      start={parser.fight.start_time}\r\n      end={parser.fight.end_time}\r\n      offset={parser.fight.offset_time}\r\n    />\r\n  </Panel>\r\n);\r\nMana.propTypes = {\r\n  parser: PropTypes.object.isRequired,\r\n};\r\n\r\nexport default Mana;\r\n","import React from 'react';\r\n\r\nimport ROLES from 'game/ROLES';\r\nimport Analyzer from 'parser/core/Analyzer';\r\n\r\nimport TabComponent from './TabComponent';\r\n\r\nclass RaidHealthTab extends Analyzer {\r\n  constructor(...args) {\r\n    super(...args);\r\n    this.active = this.selectedCombatant.spec.role === ROLES.HEALER;\r\n  }\r\n\r\n  tab() {\r\n    return {\r\n      title: 'Raid health',\r\n      url: 'raid-health',\r\n      render: () => (\r\n        <TabComponent\r\n          parser={this.owner}\r\n        />\r\n      ),\r\n    };\r\n  }\r\n}\r\n\r\nexport default RaidHealthTab;\r\n","import SPELLS from 'common/SPELLS/index';\r\n\r\nimport Potion from './Potion';\r\n\r\n/**\r\n * Tracks health potion cooldown.\r\n */\r\nclass HealthPotion extends Potion {\r\n  static spells = [\r\n    SPELLS.SPIRITUAL_HEALING_POTION,\r\n  ];\r\n  static recommendedEfficiency = 0;\r\n  static extraAbilityInfo = {\r\n    isDefensive: true,\r\n  };\r\n}\r\n\r\nexport default HealthPotion;\r\n","import SPELLS from 'common/SPELLS';\r\n\r\nimport Potion from './Potion';\r\n\r\n/**\r\n * Tracks combat potion cooldown (DPS, HPS, mana, mitigation).\r\n */\r\nclass CombatPotion extends Potion {\r\n  static spells = [\r\n    SPELLS.POTION_OF_SPECTRAL_INTELLECT,\r\n    SPELLS.POTION_OF_SPECTRAL_STRENGTH,\r\n    SPELLS.POTION_OF_SPECTRAL_AGILITY,\r\n    SPELLS.POTION_OF_SPECTRAL_STAMINA,\r\n    SPELLS.POTION_OF_DEATHLY_FIXATION,\r\n    SPELLS.POTION_OF_EMPOWERED_EXORCISMS,\r\n    SPELLS.POTION_OF_PHANTOM_FIRE,\r\n    SPELLS.POTION_OF_DIVINE_AWAKENING,\r\n    SPELLS.POTION_OF_SACRIFICIAL_ANIMA,\r\n    SPELLS.POTION_OF_HARDENED_SHADOWS,\r\n    SPELLS.SPIRITUAL_MANA_POTION,\r\n    SPELLS.SPIRITUAL_REJUVENATION_POTION,\r\n    SPELLS.POTION_OF_SPIRITUAL_CLARITY,\r\n  ];\r\n  static recommendedEfficiency = 0;\r\n  static extraAbilityInfo = {\r\n    name: 'Combat Potion',\r\n    buffSpellId: [\r\n      SPELLS.POTION_OF_SPECTRAL_INTELLECT.id,\r\n      SPELLS.POTION_OF_SPECTRAL_STRENGTH.id,\r\n      SPELLS.POTION_OF_SPECTRAL_AGILITY.id,\r\n      SPELLS.POTION_OF_SPECTRAL_STAMINA.id,\r\n      SPELLS.POTION_OF_DEATHLY_FIXATION.id,\r\n      SPELLS.POTION_OF_EMPOWERED_EXORCISMS.id,\r\n      SPELLS.POTION_OF_PHANTOM_FIRE.id,\r\n      SPELLS.POTION_OF_DIVINE_AWAKENING.id,\r\n      SPELLS.POTION_OF_SACRIFICIAL_ANIMA.id,\r\n      SPELLS.POTION_OF_HARDENED_SHADOWS.id,\r\n      SPELLS.SPIRITUAL_MANA_POTION.id,\r\n      SPELLS.SPIRITUAL_REJUVENATION_POTION.id,\r\n      SPELLS.POTION_OF_SPIRITUAL_CLARITY.id,\r\n    ],\r\n  };\r\n}\r\n\r\nexport default CombatPotion;\r\n","import SPELLS from 'common/SPELLS/index';\r\nimport RACES from 'game/RACES';\r\nimport Analyzer, { Options } from 'parser/core/Analyzer';\r\nimport Abilities from 'parser/core/modules/Abilities';\r\n\r\n/**\r\n * Heals the target for 20% of the caster's total health over 5 sec.\r\n */\r\nclass GiftOfTheNaaru extends Analyzer {\r\n  static dependencies = {\r\n    abilities: Abilities,\r\n  };\r\n\r\n  constructor(options: Options) {\r\n    super(options);\r\n    this.active = this.selectedCombatant.race === RACES.Draenei;\r\n    if (!this.active) {\r\n      return;\r\n    }\r\n\r\n    (options.abilities as Abilities).add({\r\n      spell: [\r\n        SPELLS.GIFT_OF_THE_NAARU_DK,\r\n        SPELLS.GIFT_OF_THE_NAARU_HUNTER,\r\n        SPELLS.GIFT_OF_THE_NAARU_MONK,\r\n        SPELLS.GIFT_OF_THE_NAARU_MAGE,\r\n        SPELLS.GIFT_OF_THE_NAARU_PRIEST,\r\n        SPELLS.GIFT_OF_THE_NAARU_PALADIN,\r\n        SPELLS.GIFT_OF_THE_NAARU_SHAMAN,\r\n        SPELLS.GIFT_OF_THE_NAARU_WARRIOR,\r\n      ],\r\n      category: Abilities.SPELL_CATEGORIES.DEFENSIVE,\r\n      cooldown: 180,\r\n      gcd: null,\r\n    });\r\n  }\r\n}\r\n\r\nexport default GiftOfTheNaaru;\r\n","import React from 'react';\r\nimport Analyzer, { SELECTED_PLAYER } from 'parser/core/Analyzer';\r\n\r\nimport Combatants from 'parser/shared/modules/Combatants';\r\nimport { formatNumber } from 'common/format';\r\nimport MAGIC_SCHOOLS from 'game/MAGIC_SCHOOLS';\r\nimport RACES from 'game/RACES';\r\nimport SpellIcon from 'common/SpellIcon';\r\nimport SPELLS from 'common/SPELLS/index';\r\nimport StatisticBox from 'interface/others/StatisticBox';\r\nimport Events from 'parser/core/Events';\r\n\r\n/**\r\n * Removes all poison, disease, curse, magic, and bleed effects and reduces all physical damage taken by 10% for 8 sec.\r\n *\r\n * Example log: https://www.warcraftlogs.com/reports/gYCR2kZaJHVbjfxP/#fight=52&source=16&type=damage-taken\r\n */\r\n\r\nconst STONEFORM_DAMAGE_REDUCTION = 0.1;\r\nconst FALLING_DAMAGE_ABILITY_ID = 3;\r\n\r\nclass Stoneform extends Analyzer {\r\n  static dependencies = {\r\n    combatants: Combatants,\r\n  };\r\n\r\n  damageReduced = 0;\r\n  physicalDamageTaken = 0;\r\n\r\n  constructor(...args) {\r\n    super(...args);\r\n    this.active = this.selectedCombatant.race === RACES.Dwarf;\r\n    this.addEventListener(Events.damage.to(SELECTED_PLAYER), this.onDamageTaken);\r\n  }\r\n\r\n  get drps() {\r\n    return this.damageReduced / this.owner.fightDuration * 1000;\r\n  }\r\n\r\n  onDamageTaken(event) {\r\n    const spellId = event.ability.guid;\r\n\r\n    if (event.ability.type !== MAGIC_SCHOOLS.ids.PHYSICAL) {\r\n      return;\r\n    }\r\n\r\n    if (spellId === FALLING_DAMAGE_ABILITY_ID) { // Falling damage is the same type as physical but ignores DRs.\r\n      return;\r\n    }\r\n\r\n    const damageTaken = event.amount + (event.absorbed || 0);\r\n    const isStoneformActive = this.selectedCombatant.hasBuff(SPELLS.STONEFORM_BUFF.id, event.timestamp, this.owner.playerId);\r\n\r\n    if (isStoneformActive) {\r\n      this.physicalDamageTaken += damageTaken;\r\n      this.damageReduced += damageTaken / (1 - STONEFORM_DAMAGE_REDUCTION) * STONEFORM_DAMAGE_REDUCTION;\r\n    }\r\n  }\r\n\r\n  statistic() {\r\n    return(\r\n      <StatisticBox\r\n        icon={<SpellIcon id={SPELLS.STONEFORM_BUFF.id} />}\r\n        value={`≈${formatNumber(this.drps)} DRPS`}\r\n        label=\"Stoneform damage reduced\"\r\n        tooltip={(\r\n          <>\r\n            You took a total of {formatNumber(this.physicalDamageTaken)} physical damage while Stoneform was active. <br />\r\n            Stoneform reduced a total of {formatNumber(this.damageReduced)} physical damage taken.\r\n          </>\r\n        )}\r\n      />\r\n    );\r\n\r\n  }\r\n\r\n}\r\n\r\nexport default Stoneform;\r\n","import SPELLS from 'common/SPELLS';\r\nimport RACES from 'game/RACES';\r\nimport Analyzer from 'parser/core/Analyzer';\r\nimport Abilities from 'parser/core/modules/Abilities';\r\n\r\n/**\r\n * @property {Abilities} abilities\r\n */\r\nclass Berserking extends Analyzer {\r\n  static dependencies = {\r\n    abilities: Abilities,\r\n  };\r\n\r\n  castEfficiency = 0.8;\r\n  extraSuggestion = null;\r\n\r\n  constructor(options) {\r\n    super(options);\r\n    this.active = this.selectedCombatant.race === RACES.Troll;\r\n    if (!this.active) {\r\n      return;\r\n    }\r\n\r\n    this.gcd = (options.gcd === undefined) ? this.gcd : options.gcd;\r\n    this.castEfficiency = (options.castEfficiency === undefined) ? this.castEfficiency : options.castEfficiency;\r\n\r\n    this.abilities.add({\r\n      spell: SPELLS.BERSERKING,\r\n      category: Abilities.SPELL_CATEGORIES.COOLDOWNS,\r\n      cooldown: 180,\r\n      gcd: null,\r\n      timelineSortIndex: 35,\r\n      castEfficiency: {\r\n        suggestion: this.castEfficiency !== null,\r\n        recommendedEfficiency: this.castEfficiency,\r\n        extraSuggestion: this.extraSuggestion,\r\n      },\r\n    });\r\n  }\r\n}\r\n\r\nexport default Berserking;\r\n","import SPELLS from 'common/SPELLS';\r\nimport RACES from 'game/RACES';\r\nimport Analyzer, { Options } from 'parser/core/Analyzer';\r\nimport Abilities from 'parser/core/modules/Abilities';\r\n\r\n/**\r\n * @property {Abilities} abilities\r\n */\r\nclass BloodFury extends Analyzer {\r\n  static dependencies = {\r\n    abilities: Abilities,\r\n  };\r\n\r\n  castEfficiency = 0.8;\r\n  extraSuggestion = null;\r\n\r\n  constructor(options: Options & {\r\n    castEfficiency?: number\r\n    abilities: Abilities\r\n  }) {\r\n    super(options);\r\n    this.active = this.selectedCombatant.race === RACES.Orc;\r\n    if (!this.active) {\r\n      return;\r\n    }\r\n\r\n    this.castEfficiency = options.castEfficiency === undefined\r\n      ? this.castEfficiency\r\n      : options.castEfficiency;\r\n\r\n    options.abilities.add({\r\n      spell: [\r\n        SPELLS.BLOOD_FURY_PHYSICAL,\r\n        SPELLS.BLOOD_FURY_SPELL_AND_PHYSICAL,\r\n        SPELLS.BLOOD_FURY_SPELL,\r\n      ],\r\n      category: Abilities.SPELL_CATEGORIES.COOLDOWNS,\r\n      cooldown: 120,\r\n      gcd: null,\r\n      timelineSortIndex: 35,\r\n      castEfficiency: {\r\n        suggestion: this.castEfficiency !== null,\r\n        recommendedEfficiency: this.castEfficiency,\r\n        extraSuggestion: this.extraSuggestion,\r\n      },\r\n    });\r\n  }\r\n}\r\n\r\nexport default BloodFury;\r\n","/**\r\n * A simple component that shows the spell value in the most plain way possible.\r\n * Use this only as the very last resort.\r\n */\r\nimport React from 'react';\r\n\r\nimport ItemIcon from 'common/ItemIcon';\r\nimport ItemLink from 'common/ItemLink';\r\nimport { Item } from 'parser/core/Events';\r\n\r\n\r\ntype Props = {\r\n  item: Item;\r\n  children: React.ReactNode;\r\n  className?: string;\r\n};\r\n\r\nconst BoringItemValueText = ({ item, children, className }: Props) => (\r\n  <div className={`pad boring-text ${className || ''}`}>\r\n    <label>\r\n      <ItemIcon id={item.id} /> <ItemLink id={item.id} icon={false} />\r\n    </label>\r\n    <div className=\"value\">\r\n      {children}\r\n    </div>\r\n  </div>\r\n);\r\n\r\nexport default BoringItemValueText;\r\n","import React from 'react';\r\n\r\nimport { formatNumber } from 'common/format';\r\n\r\nimport Statistic from 'interface/statistics/Statistic';\r\nimport { STATISTIC_ORDER } from 'interface/others/StatisticBox';\r\nimport BoringItemValueText from 'interface/statistics/components/BoringItemValueText';\r\n\r\nimport ITEMS from 'common/ITEMS/index';\r\n\r\nimport Analyzer from 'parser/core/Analyzer';\r\nimport HealingDone from 'parser/shared/modules/throughput/HealingDone';\r\nimport DamageDone from 'parser/shared/modules/throughput/DamageDone';\r\nimport DamageTaken from 'parser/shared/modules/throughput/DamageTaken';\r\nimport StatTracker from 'parser/shared/modules/StatTracker';\r\n\r\n// https://www.wowhead.com/uncategorized-spells/name:Vantus+Rune:?filter=29:21;42:2;0:80100\r\nconst VANTUS_RUNE_VERSATILITY = 40;\r\nconst VERSATILITY_PER_PERCENT_THROUGHPUT = 40 * 100;\r\nconst VERSATILITY_PER_PERCENT_DAMAGE_REDUCTION = VERSATILITY_PER_PERCENT_THROUGHPUT * 2;\r\nconst VANTUS_RUNE_PERCENTAGE_THROUGHPUT =\r\n  VANTUS_RUNE_VERSATILITY / VERSATILITY_PER_PERCENT_THROUGHPUT;\r\nconst VANTUS_RUNE_PERCENTAGE_DAMAGE_REDUCTION =\r\n  VANTUS_RUNE_VERSATILITY / VERSATILITY_PER_PERCENT_DAMAGE_REDUCTION;\r\n\r\nconst runes = [\r\n  ITEMS.VANTUS_RUNE_CASTLE_NATHRIA,\r\n];\r\n\r\n/**\r\n * @property {HealingDone} healingDone\r\n * @property {DamageDone} damageDone\r\n * @property {DamageTaken} damageTaken\r\n */\r\nclass VantusRune extends Analyzer {\r\n  static dependencies = {\r\n    healingDone: HealingDone,\r\n    damageDone: DamageDone,\r\n    damageTaken: DamageTaken,\r\n    statTracker: StatTracker,\r\n  };\r\n\r\n  activeRune = null;\r\n  constructor(...args) {\r\n    super(...args);\r\n    const boss = this.owner.boss;\r\n\r\n    /** @var {number|null} */\r\n    const vantusRuneBuffId = boss ? boss.fight.vantusRuneBuffId : null;\r\n    if (vantusRuneBuffId) {\r\n      const match = this.selectedCombatant.getBuff(vantusRuneBuffId);\r\n      if (match !== undefined) {\r\n        this.activeRune = match;\r\n      }\r\n    }\r\n    this.active = this.activeRune !== null;\r\n    if (this.active) {\r\n      runes.forEach((rune) => {\r\n        if (this.activeRune.ability.abilityIcon === rune.icon) {\r\n          this.masterRune = rune;\r\n        }\r\n      });\r\n      // StatTracker ignores the buff because its active on pull, but the stats aren't actually in the pull stats\r\n      this.statTracker.forceChangeStats(\r\n        { versatility: VANTUS_RUNE_VERSATILITY },\r\n        vantusRuneBuffId,\r\n        true,\r\n      );\r\n    }\r\n    if (this.masterRune === null) {\r\n      //default to the icon to current tier\r\n      this.masterRune = runes[runes.length - 1];\r\n    }\r\n  }\r\n\r\n  statistic() {\r\n    const fightDuration = this.owner.fightDuration;\r\n\r\n    const damageDone =\r\n      this.damageDone.total.effective -\r\n      this.damageDone.total.effective / (1 + VANTUS_RUNE_PERCENTAGE_THROUGHPUT);\r\n    const healingDone =\r\n      this.healingDone.total.effective -\r\n      this.healingDone.total.effective / (1 + VANTUS_RUNE_PERCENTAGE_THROUGHPUT);\r\n    const damageReduced =\r\n      this.damageTaken.total.effective / (1 - VANTUS_RUNE_PERCENTAGE_DAMAGE_REDUCTION) -\r\n      this.damageTaken.total.effective;\r\n\r\n    return (\r\n      <Statistic position={STATISTIC_ORDER.UNIMPORTANT()} size=\"flexible\">\r\n        <BoringItemValueText item={this.masterRune}>\r\n          <img src=\"/img/sword.png\" alt=\"Damage\" className=\"icon\" />\r\n          {` ${formatNumber((damageDone / fightDuration) * 1000)} DPS`}\r\n          <br />\r\n          <img src=\"/img/healing.png\" alt=\"Healing\" className=\"icon\" />\r\n          {` ${formatNumber((healingDone / fightDuration) * 1000)} HPS`}\r\n          <br />\r\n          <img src=\"/img/shield.png\" alt=\"Damage Taken\" className=\"icon\" />\r\n          {` ${formatNumber((damageReduced / fightDuration) * 1000)} DRPS`}\r\n        </BoringItemValueText>\r\n      </Statistic>\r\n    );\r\n  }\r\n}\r\n\r\nexport default VantusRune;\r\n","import React from 'react';\r\n\r\nimport { Boss, findByBossId } from 'raids';\r\nimport { formatDuration, formatNumber, formatPercentage } from 'common/format';\r\nimport DeathRecapTracker from 'interface/others/DeathRecapTracker';\r\nimport ModuleError from 'parser/core/ModuleError';\r\nimport {\r\n  AnyEvent,\r\n  CombatantInfoEvent,\r\n  Event, EventType,\r\n  HasSource,\r\n  HasTarget,\r\n  MappedEvent,\r\n} from 'parser/core/Events';\r\n\r\nimport Haste from 'parser/shared/modules/Haste';\r\n\r\nimport Module, { Options } from './Module';\r\nimport Fight from './Fight';\r\nimport Analyzer from './Analyzer';\r\nimport EventFilter from './EventFilter';\r\nimport { EventListener } from './EventSubscriber';\r\nimport { Builds } from '../Config';\r\n// Normalizers\r\nimport ApplyBuffNormalizer from '../shared/normalizers/ApplyBuff';\r\nimport CancelledCastsNormalizer from '../shared/normalizers/CancelledCasts';\r\nimport PrePullCooldownsNormalizer from '../shared/normalizers/PrePullCooldowns';\r\nimport FightEndNormalizer from '../shared/normalizers/FightEnd';\r\nimport PhaseChangesNormalizer from '../shared/normalizers/PhaseChanges';\r\nimport MissingCastsNormalizer from '../shared/normalizers/MissingCasts';\r\n// Enhancers\r\nimport SpellTimeWaitingOnGlobalCooldown from '../shared/enhancers/SpellTimeWaitingOnGlobalCooldown';\r\n// Core modules\r\nimport HealingDone from '../shared/modules/throughput/HealingDone';\r\nimport DamageDone from '../shared/modules/throughput/DamageDone';\r\nimport DamageTaken from '../shared/modules/throughput/DamageTaken';\r\nimport ThroughputStatisticGroup from '../shared/modules/throughput/ThroughputStatisticGroup';\r\nimport DeathTracker from '../shared/modules/DeathTracker';\r\n\r\nimport Combatants from '../shared/modules/Combatants';\r\nimport AbilityTracker from '../shared/modules/AbilityTracker';\r\nimport StatTracker from '../shared/modules/StatTracker';\r\nimport AlwaysBeCasting from '../shared/modules/AlwaysBeCasting';\r\nimport FilteredActiveTime from '../shared/modules/FilteredActiveTime';\r\nimport Abilities from './modules/Abilities';\r\nimport Buffs from './modules/Buffs';\r\nimport AbilitiesMissing from '../shared/modules/AbilitiesMissing';\r\nimport CastEfficiency from '../shared/modules/CastEfficiency';\r\nimport SpellUsable from '../shared/modules/SpellUsable';\r\nimport EventHistory from '../shared/modules/EventHistory';\r\nimport SpellHistory from '../shared/modules/SpellHistory';\r\nimport GlobalCooldown from '../shared/modules/GlobalCooldown';\r\nimport Enemies from '../shared/modules/Enemies';\r\nimport EnemyInstances from '../shared/modules/EnemyInstances';\r\nimport Pets from '../shared/modules/Pets';\r\nimport ManaValues from '../shared/modules/ManaValues';\r\nimport SpellManaCost from '../shared/modules/SpellManaCost';\r\nimport Channeling from '../shared/modules/Channeling';\r\nimport DeathDowntime from '../shared/modules/downtime/DeathDowntime';\r\nimport TotalDowntime from '../shared/modules/downtime/TotalDowntime';\r\nimport DistanceMoved from '../shared/modules/others/DistanceMoved';\r\nimport DispelTracker from '../shared/modules/DispelTracker';\r\n// Tabs\r\nimport RaidHealthTab from '../shared/modules/features/RaidHealthTab';\r\n\r\nimport CritEffectBonus from '../shared/modules/helpers/CritEffectBonus';\r\n\r\nimport PotionChecker from '../shared/modules/items/PotionChecker';\r\nimport EnchantChecker from '../shared/modules/items/EnchantChecker';\r\nimport FlaskChecker from '../shared/modules/items/FlaskChecker';\r\nimport FoodChecker from '../shared/modules/items/FoodChecker';\r\nimport Healthstone from '../shared/modules/items/Healthstone';\r\nimport HealthPotion from '../shared/modules/items/HealthPotion';\r\nimport CombatPotion from '../shared/modules/items/CombatPotion';\r\nimport WeaponEnhancementChecker from '../shared/modules/items/WeaponEnhancementChecker';\r\nimport PreparationRuleAnalyzer from '../shared/modules/features/Checklist/PreparationRuleAnalyzer';\r\n// Racials\r\nimport ArcaneTorrent from '../shared/modules/racials/bloodelf/ArcaneTorrent';\r\nimport GiftOfTheNaaru from '../shared/modules/racials/draenei/GiftOfTheNaaru';\r\nimport MightOfTheMountain from '../shared/modules/racials/dwarf/MightOfTheMountain';\r\nimport Stoneform from '../shared/modules/racials/dwarf/Stoneform';\r\nimport Berserking from '../shared/modules/racials/troll/Berserking';\r\nimport BloodFury from '../shared/modules/racials/orc/BloodFury';\r\n// Shared Buffs\r\nimport VantusRune from '../shared/modules/spells/VantusRune';\r\n// Shadowlands\r\n// Dungeons\r\n// PVP\r\n//Enchants\r\n// Crafted\r\n// Castle Nathria\r\n\r\n// Legendaries\r\n\r\nimport ParseResults from './ParseResults';\r\nimport EventsNormalizer from './EventsNormalizer';\r\nimport EventEmitter from './modules/EventEmitter';\r\nimport Combatant from './Combatant';\r\n\r\n// This prints to console anything that the DI has to do\r\nconst debugDependencyInjection = false;\r\nconst MAX_DI_ITERATIONS = 100;\r\nconst isMinified = process.env.NODE_ENV === 'production';\r\n\r\ntype DependencyDefinition = typeof Module | readonly [typeof Module, { [option: string]: any }];\r\nexport type DependenciesDefinition = { [desiredName: string]: DependencyDefinition };\r\n\r\ninterface Talent {\r\n  id: number;\r\n}\r\nexport interface Player {\r\n  id: number;\r\n  name: string;\r\n  talents: Talent[];\r\n  artifact: unknown;\r\n  heartOfAzeroth: unknown;\r\n  gear: unknown;\r\n  auras: unknown;\r\n}\r\n\r\nclass CombatLogParser {\r\n  /** @deprecated Move this kind of info to the Abilities config */\r\n  static abilitiesAffectedByHealingIncreases: number[] = [];\r\n  /** @deprecated Move this kind of info to the Abilities config */\r\n  static abilitiesAffectedByDamageIncreases: number[] = [];\r\n\r\n  static internalModules: DependenciesDefinition = {\r\n    fightEndNormalizer: FightEndNormalizer,\r\n    eventEmitter: EventEmitter,\r\n    combatants: Combatants,\r\n    deathDowntime: DeathDowntime,\r\n    totalDowntime: TotalDowntime,\r\n  };\r\n  static defaultModules: DependenciesDefinition = {\r\n    // Normalizers\r\n    applyBuffNormalizer: ApplyBuffNormalizer,\r\n    cancelledCastsNormalizer: CancelledCastsNormalizer,\r\n    prepullNormalizer: PrePullCooldownsNormalizer,\r\n    phaseChangesNormalizer: PhaseChangesNormalizer,\r\n    missingCastsNormalize: MissingCastsNormalizer,\r\n\r\n    // Enhancers\r\n    spellTimeWaitingOnGlobalCooldown: SpellTimeWaitingOnGlobalCooldown,\r\n\r\n    // Analyzers\r\n    healingDone: HealingDone,\r\n    damageDone: DamageDone,\r\n    damageTaken: DamageTaken,\r\n    throughputStatisticGroup: ThroughputStatisticGroup,\r\n    deathTracker: DeathTracker,\r\n\r\n    enemies: Enemies,\r\n    enemyInstances: EnemyInstances,\r\n    pets: Pets,\r\n    spellManaCost: SpellManaCost,\r\n    channeling: Channeling,\r\n    eventHistory: EventHistory,\r\n    abilityTracker: AbilityTracker,\r\n    haste: Haste,\r\n    statTracker: StatTracker,\r\n    alwaysBeCasting: AlwaysBeCasting,\r\n    filteredActiveTime: FilteredActiveTime,\r\n    abilities: Abilities,\r\n    buffs: Buffs,\r\n    abilitiesMissing: AbilitiesMissing,\r\n    CastEfficiency: CastEfficiency,\r\n    spellUsable: SpellUsable,\r\n    spellHistory: SpellHistory,\r\n    globalCooldown: GlobalCooldown,\r\n    manaValues: ManaValues,\r\n    vantusRune: VantusRune,\r\n    distanceMoved: DistanceMoved,\r\n    deathRecapTracker: DeathRecapTracker,\r\n    dispels: DispelTracker,\r\n\r\n    critEffectBonus: CritEffectBonus,\r\n\r\n    // Tabs\r\n    raidHealthTab: RaidHealthTab,\r\n\r\n    potionChecker: PotionChecker,\r\n    enchantChecker: EnchantChecker,\r\n    flaskChecker: FlaskChecker,\r\n    foodChecker: FoodChecker,\r\n    healthstone: Healthstone,\r\n    healthPotion: HealthPotion,\r\n    combatPotion: CombatPotion,\r\n    weaponEnhancementChecker: WeaponEnhancementChecker,\r\n    preparationRuleAnalyzer: PreparationRuleAnalyzer,\r\n\r\n    // Racials\r\n    arcaneTorrent: ArcaneTorrent,\r\n    giftOfTheNaaru: GiftOfTheNaaru,\r\n    mightOfTheMountain: MightOfTheMountain,\r\n    stoneform: Stoneform,\r\n    berserking: Berserking,\r\n    bloodFury: BloodFury,\r\n\r\n    // Items:\r\n\r\n    // Legendaries\r\n  };\r\n  // Override this with spec specific modules when extending\r\n  static specModules: DependenciesDefinition = {};\r\n\r\n  applyTimeFilter = (start: number, end: number) => null; //dummy function gets filled in by event parser\r\n  applyPhaseFilter = (phase: any, instance: any) => null; //dummy function gets filled in by event parser\r\n\r\n  // TODO create report type\r\n  report: any;\r\n  /** Character info from the Battle.net API (optional) */\r\n  // TODO create profile type\r\n  characterProfile: any;\r\n\r\n  // Player info from WCL - required\r\n  player: SelectedPlayer;\r\n  playerPets: Array<{\r\n    name: string;\r\n    id: number;\r\n    guid: number;\r\n    type: \"Pet\",\r\n    icon: string;\r\n  }>;\r\n  fight: Fight;\r\n  build: string;\r\n  builds: Builds;\r\n  boss: Boss | null;\r\n  combatantInfoEvents: CombatantInfoEvent[];\r\n\r\n  //Disabled Modules\r\n  disabledModules!: { [state in ModuleError]: any[] };\r\n\r\n  adjustForDowntime = true;\r\n  get hasDowntime() {\r\n    return this.getModule(TotalDowntime).totalBaseDowntime > 0;\r\n  }\r\n\r\n  _modules: { [name: string]: Module } = {};\r\n  get activeModules() {\r\n    return Object.values(this._modules).filter((module) => module.active);\r\n  }\r\n\r\n  get playerId() {\r\n    return this.player.id;\r\n  }\r\n  get fightId() {\r\n    return this.fight.id;\r\n  }\r\n\r\n  _timestamp: number;\r\n  get currentTimestamp() {\r\n    return this.finished ? this.fight.end_time : this._timestamp;\r\n  }\r\n  get fightDuration() {\r\n    return (\r\n      this.currentTimestamp -\r\n      this.fight.start_time -\r\n      (this.adjustForDowntime ? this.getModule(TotalDowntime).totalBaseDowntime : 0)\r\n    );\r\n  }\r\n  finished = false;\r\n\r\n  get players(): Player[] {\r\n    return this.report.friendlies;\r\n  }\r\n  get selectedCombatant(): Combatant {\r\n    return this.getModule(Combatants).selected;\r\n  }\r\n\r\n  constructor(\r\n    report: any,\r\n    selectedPlayer: SelectedPlayer,\r\n    selectedFight: Fight,\r\n    combatantInfoEvents: CombatantInfoEvent[],\r\n    characterProfile: any,\r\n    build: string,\r\n    builds: Builds,\r\n  ) {\r\n    this.report = report;\r\n    this.player = selectedPlayer;\r\n    this.playerPets = report.friendlyPets.filter(\r\n      (pet: { petOwner: any }) => pet.petOwner === selectedPlayer.id,\r\n    );\r\n    this.fight = selectedFight;\r\n    this.build = build;\r\n    this.builds = builds;\r\n    this.combatantInfoEvents = combatantInfoEvents;\r\n    // combatantinfo events aren't included in the regular events, but they're still used to analysis. We should have them show in the history to make it complete.\r\n    combatantInfoEvents.forEach((event) => this.eventHistory.push(event));\r\n    this.characterProfile = characterProfile;\r\n    this._timestamp = selectedFight.start_time;\r\n    this.boss = findByBossId(selectedFight.boss);\r\n    // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\r\n    // @ts-ignore populated dynamically but object keys still strongly typed\r\n    this.disabledModules = {};\r\n    //initialize disabled modules for each state\r\n    Object.values(ModuleError).forEach((key) => {\r\n      this.disabledModules[key] = [];\r\n    });\r\n    const ctor = this.constructor as typeof CombatLogParser;\r\n    this.initializeModules({\r\n      ...ctor.internalModules,\r\n      ...ctor.defaultModules,\r\n      ...ctor.specModules,\r\n    });\r\n  }\r\n  finish() {\r\n    this.finished = true;\r\n    /** @var {EventEmitter} */\r\n    const emitter = this.getModule(EventEmitter);\r\n    console.log(\r\n      'Events triggered:',\r\n      emitter.numTriggeredEvents,\r\n      'Event listeners added:',\r\n      emitter.numEventListeners,\r\n      'Listeners called:',\r\n      emitter.numListenersCalled,\r\n      'Listeners called (after filters):',\r\n      emitter.numActualExecutions,\r\n      'Listeners filtered away:',\r\n      emitter.numListenersCalled - emitter.numActualExecutions,\r\n    );\r\n  }\r\n\r\n  _getModuleClass(config: DependencyDefinition): [typeof Module, any] {\r\n    let moduleClass;\r\n    let options;\r\n    if (config instanceof Array) {\r\n      moduleClass = config[0];\r\n      options = config[1];\r\n    } else {\r\n      moduleClass = config;\r\n      options = {};\r\n    }\r\n    return [moduleClass, options];\r\n  }\r\n  _resolveDependencies(dependencies: { [desiredName: string]: typeof Module }) {\r\n    const availableDependencies: { [name: string]: Module } = {};\r\n    const missingDependencies: Array<typeof Module> = [];\r\n    if (dependencies) {\r\n      Object.keys(dependencies).forEach((desiredDependencyName) => {\r\n        const dependencyClass = dependencies[desiredDependencyName];\r\n\r\n        const dependencyModule = this.getOptionalModule(dependencyClass);\r\n        if (dependencyModule) {\r\n          availableDependencies[desiredDependencyName] = dependencyModule;\r\n        } else {\r\n          missingDependencies.push(dependencyClass);\r\n        }\r\n      });\r\n    }\r\n    return [availableDependencies, missingDependencies] as const;\r\n  }\r\n  /**\r\n   * @param {Module} moduleClass\r\n   * @param {object} [options]\r\n   * @param {string} [desiredModuleName]  Deprecated: will be removed Soon™.\r\n   */\r\n  loadModule<T extends typeof Module>(\r\n    moduleClass: T,\r\n    options: { [prop: string]: any; priority: number },\r\n    desiredModuleName = `module${Object.keys(this._modules).length}`,\r\n  ) {\r\n    // eslint-disable-next-line new-cap\r\n    const module = new moduleClass({\r\n      ...options,\r\n      owner: this,\r\n    });\r\n    if (options) {\r\n      // We can't set the options via the constructor since a parent constructor can't override the values of a child's class properties.\r\n      // See https://github.com/Microsoft/TypeScript/issues/6110 for more info\r\n      Object.keys(options).forEach((key) => {\r\n        // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\r\n        // @ts-ignore\r\n        module[key] = options[key];\r\n      });\r\n    }\r\n    // TODO: Remove module naming\r\n    module.key = desiredModuleName;\r\n    this._modules[desiredModuleName] = module;\r\n    return module;\r\n  }\r\n  initializeModules(modules: DependenciesDefinition, iteration = 1) {\r\n    // TODO: Refactor and test, this dependency injection thing works really well but it's hard to understand or change.\r\n    const failedModules: string[] = [];\r\n    Object.keys(modules).forEach((desiredModuleName) => {\r\n      const moduleConfig = modules[desiredModuleName];\r\n      if (!moduleConfig) {\r\n        return;\r\n      }\r\n      const [moduleClass, options] = this._getModuleClass(moduleConfig);\r\n      const [availableDependencies, missingDependencies] = this._resolveDependencies(\r\n        moduleClass.dependencies,\r\n      );\r\n      const hasMissingDependency = missingDependencies.length === 0;\r\n\r\n      if (hasMissingDependency) {\r\n        if (debugDependencyInjection) {\r\n          if (Object.keys(availableDependencies).length === 0) {\r\n            console.log('Loading', moduleClass.name);\r\n          } else {\r\n            console.log(\r\n              'Loading',\r\n              moduleClass.name,\r\n              'with dependencies:',\r\n              Object.keys(availableDependencies),\r\n            );\r\n          }\r\n        }\r\n        // The priority goes from lowest (most important) to highest, seeing as modules are loaded after their dependencies are loaded, just using the count of loaded modules is sufficient.\r\n        const priority = Object.keys(this._modules).length;\r\n        try {\r\n          this.loadModule(\r\n            moduleClass,\r\n            {\r\n              ...options,\r\n              ...availableDependencies,\r\n              priority,\r\n            },\r\n            desiredModuleName,\r\n          );\r\n        } catch (e) {\r\n          if (process.env.NODE_ENV !== 'production') {\r\n            throw e;\r\n          }\r\n          this.disabledModules[ModuleError.INITIALIZATION].push({\r\n            key: isMinified ? desiredModuleName : moduleClass.name,\r\n            module: moduleClass,\r\n            error: e,\r\n          });\r\n          debugDependencyInjection &&\r\n            console.warn(moduleClass.name, 'disabled due to error during initialization: ', e);\r\n        }\r\n      } else {\r\n        const disabledDependencies = missingDependencies\r\n          .map((d) => d.name)\r\n          .filter((x) =>\r\n            this.disabledModules[ModuleError.INITIALIZATION].map((d) => d.module.name).includes(x),\r\n          ); // see if a dependency was previously disabled due to an error\r\n        if (disabledDependencies.length !== 0) {\r\n          // if a dependency was already marked as disabled due to an error, mark this module as disabled\r\n          this.disabledModules[ModuleError.DEPENDENCY].push({\r\n            key: isMinified ? desiredModuleName : moduleClass.name,\r\n            module: moduleClass,\r\n          });\r\n          debugDependencyInjection &&\r\n            console.warn(\r\n              moduleClass.name,\r\n              'disabled due to error during initialization of a dependency.',\r\n            );\r\n        } else {\r\n          debugDependencyInjection &&\r\n            console.warn(\r\n              moduleClass.name,\r\n              'could not be loaded, missing dependencies:',\r\n              missingDependencies.map((d) => d.name),\r\n            );\r\n          failedModules.push(desiredModuleName);\r\n        }\r\n      }\r\n    });\r\n\r\n    if (failedModules.length !== 0) {\r\n      debugDependencyInjection &&\r\n        console.warn(\r\n          `${failedModules.length} modules failed to load, trying again:`,\r\n          failedModules.map((key) => {\r\n            const def = modules[key];\r\n            if (def instanceof Array) {\r\n              return def[0].name;\r\n            } else {\r\n              return (def as typeof Module).name;\r\n            }\r\n          }),\r\n        );\r\n      const newBatch: DependenciesDefinition = {};\r\n      failedModules.forEach((key) => {\r\n        newBatch[key] = modules[key];\r\n      });\r\n      if (iteration > MAX_DI_ITERATIONS) {\r\n        // Sometimes modules can't be imported at all because they depend on modules not enabled or have a circular dependency. Stop trying after a while.\r\n        // eslint-disable-next-line no-debugger\r\n        debugger;\r\n        throw new Error(`Failed to load modules: ${Object.keys(newBatch).join(', ')}`);\r\n      }\r\n      this.initializeModules(newBatch, iteration + 1);\r\n    } else {\r\n      this.allModulesInitialized();\r\n    }\r\n  }\r\n  allModulesInitialized() {\r\n    // Executed when module initialization is complete\r\n  }\r\n  _moduleCache = new Map();\r\n  getOptionalModule<T extends Module>(type: { new (options: Options): T }): T | undefined {\r\n    // We need to use a cache and can't just set this on initialization because we sometimes search by the inheritance chain.\r\n    const cacheEntry = this._moduleCache.get(type);\r\n    if (cacheEntry !== undefined) {\r\n      return cacheEntry;\r\n    }\r\n    // Search for a specific module by its type, accepting any modules that have the type somewhere in the inheritance chain\r\n    const module = Object.values(this._modules).find((module) => module instanceof type);\r\n    this._moduleCache.set(type, module);\r\n    return module as T;\r\n  }\r\n  getModule<T extends Module>(type: { new (options: Options): T }): T {\r\n    const module = this.getOptionalModule(type);\r\n    if (module === undefined) {\r\n      throw new Error(`Module not found: ${type.name}`);\r\n    }\r\n    return module;\r\n  }\r\n  normalize(events: AnyEvent[]) {\r\n    this.activeModules\r\n      .filter((module) => module instanceof EventsNormalizer)\r\n      .map((module) => module as EventsNormalizer)\r\n      .sort((a, b) => a.priority - b.priority) // lowest should go first, as `priority = 0` will have highest prio\r\n      .forEach((normalizer) => {\r\n        if (normalizer.normalize) {\r\n          events = normalizer.normalize(events);\r\n        }\r\n      });\r\n    return events;\r\n  }\r\n\r\n  /** The amount of events parsed. This can reliably be used to determine if something should re-render. */\r\n  eventCount = 0;\r\n  eventHistory: AnyEvent[] = [];\r\n  addEventListener<ET extends EventType, E extends MappedEvent<ET>>(\r\n    eventFilter: ET | EventFilter<ET>,\r\n    listener: EventListener<ET, E>,\r\n    module: Module,\r\n  ) {\r\n    this.getModule(EventEmitter).addEventListener(eventFilter, listener, module);\r\n  }\r\n\r\n  deepDisable(module: Module, state: ModuleError, error: Error | undefined = undefined) {\r\n    if (!module.active) {\r\n      return; //return early\r\n    }\r\n    console.error('Disabling', isMinified ? module.key : module.constructor.name);\r\n    this.disabledModules[state].push({\r\n      key: isMinified ? module.key : module.constructor.name,\r\n      module: module.constructor,\r\n      ...(error && { error: error }),\r\n    });\r\n    module.active = false;\r\n    this.activeModules.forEach((active) => {\r\n      const ctor = active.constructor as typeof Module;\r\n      const deps = ctor.dependencies;\r\n      // Inspectors may light up `module instanceof depClass` because of the constructor cast\r\n      if (deps && Object.values(deps).find((depClass) => module instanceof depClass)) {\r\n        this.deepDisable(active, ModuleError.DEPENDENCY);\r\n      }\r\n    });\r\n  }\r\n\r\n  byPlayer<ET extends EventType>(event: Event<ET>, playerId = this.player.id) {\r\n    return HasSource(event) && event.sourceID === playerId;\r\n  }\r\n  toPlayer<ET extends EventType>(event: Event<ET>, playerId = this.player.id) {\r\n    return HasTarget(event) && event.targetID === playerId;\r\n  }\r\n  byPlayerPet<ET extends EventType>(event: Event<ET>) {\r\n    return HasSource(event) && this.playerPets.some((pet) => pet.id === event.sourceID);\r\n  }\r\n  toPlayerPet<ET extends EventType>(event: Event<ET>) {\r\n    return HasTarget(event) && this.playerPets.some((pet) => pet.id === event.targetID);\r\n  }\r\n\r\n  getPercentageOfTotalHealingDone(healingDone: number) {\r\n    return healingDone / this.getModule(HealingDone).total.effective;\r\n  }\r\n  formatItemHealingDone(healingDone: number) {\r\n    return `${formatPercentage(\r\n      this.getPercentageOfTotalHealingDone(healingDone),\r\n    )} % / ${formatNumber((healingDone / this.fightDuration) * 1000)} HPS`;\r\n  }\r\n  formatItemAbsorbDone(absorbDone: number) {\r\n    return `${formatNumber(absorbDone)}`;\r\n  }\r\n  getPercentageOfTotalDamageDone(damageDone: number) {\r\n    return damageDone / this.getModule(DamageDone).total.effective;\r\n  }\r\n  formatItemDamageDone(damageDone: number) {\r\n    return `${formatPercentage(this.getPercentageOfTotalDamageDone(damageDone))} % / ${formatNumber(\r\n      (damageDone / this.fightDuration) * 1000,\r\n    )} DPS`;\r\n  }\r\n  getPercentageOfTotalDamageTaken(damageTaken: number) {\r\n    return damageTaken / this.getModule(DamageTaken).total.effective;\r\n  }\r\n  formatTimestamp(timestamp: number, precision = 0) {\r\n    return formatDuration((timestamp - this.fight.start_time) / 1000, precision);\r\n  }\r\n\r\n  generateResults(adjustForDowntime: boolean): ParseResults {\r\n    this.adjustForDowntime = adjustForDowntime;\r\n\r\n    let results: ParseResults = new ParseResults();\r\n\r\n    const addStatistic = (statistic: any, basePosition: number, key: string) => {\r\n      if (!statistic) {\r\n        return;\r\n      }\r\n      const position =\r\n        statistic.props.position !== undefined ? statistic.props.position : basePosition;\r\n      results.statistics.push(\r\n        React.cloneElement(statistic, {\r\n          key,\r\n          position,\r\n        }),\r\n      );\r\n    };\r\n\r\n    const attemptResultGeneration = () =>\r\n      Object.keys(this._modules)\r\n        .filter((key) => this._modules[key].active)\r\n        .sort((a, b) => this._modules[b].priority - this._modules[a].priority)\r\n        .every((key, index) => {\r\n          const module = this._modules[key];\r\n\r\n          try {\r\n            if (module instanceof Analyzer) {\r\n              const analyzer = module as Analyzer;\r\n              if (analyzer.statistic) {\r\n                let basePosition = index;\r\n                if (analyzer.statisticOrder !== undefined) {\r\n                  basePosition = analyzer.statisticOrder;\r\n                  console.warn(\r\n                    'DEPRECATED',\r\n                    \"Setting the position of a statistic via a module's `statisticOrder` prop is deprecated. Set the `position` prop on the `StatisticBox` instead. Example commit: https://github.com/WoWAnalyzer/WoWAnalyzer/commit/ece1bbeca0d3721ede078d256a30576faacb803d\",\r\n                    module,\r\n                  );\r\n                }\r\n\r\n                // TODO - confirm removing i18n doesn't actually change anything here\r\n                const statistic = analyzer.statistic();\r\n                if (statistic) {\r\n                  if (Array.isArray(statistic)) {\r\n                    statistic.forEach((statistic, statisticIndex) => {\r\n                      addStatistic(statistic, basePosition, `${key}-statistic-${statisticIndex}`);\r\n                    });\r\n                  } else {\r\n                    addStatistic(statistic, basePosition, `${key}-statistic`);\r\n                  }\r\n                }\r\n              }\r\n              if (analyzer.tab) {\r\n                const tab = analyzer.tab();\r\n                if (tab) {\r\n                  results.tabs.push(tab);\r\n                }\r\n              }\r\n              if (analyzer.suggestions) {\r\n                analyzer.suggestions(results.suggestions.when);\r\n              }\r\n            }\r\n          } catch (e) {\r\n            //error occured during results generation of module, disable module and all modules depending on it\r\n            if (process.env.NODE_ENV !== 'production') {\r\n              throw e;\r\n            }\r\n            this.deepDisable(module, ModuleError.RESULTS, e);\r\n            //break loop and start again with inaccurate modules now disabled (in case of modules being rendered before their dependencies' errors are encountered)\r\n            return false;\r\n          }\r\n          return true;\r\n        });\r\n\r\n    //keep trying to generate results until no \"new\" errors are found anymore to weed out all the inaccurate / errored modules\r\n    let generated = false;\r\n    while (!generated) {\r\n      results = new ParseResults();\r\n\r\n      results.tabs = [];\r\n      generated = attemptResultGeneration();\r\n    }\r\n\r\n    return results;\r\n  }\r\n}\r\nexport type SelectedPlayer = {\r\n  name: string;\r\n  id: number;\r\n  guid: number;\r\n  type: string;\r\n};\r\n\r\nexport default CombatLogParser;\r\n","import Analyzer from 'parser/core/Analyzer';\r\nimport PotionChecker from 'parser/shared/modules/items/PotionChecker';\r\nimport EnchantChecker from 'parser/shared/modules/items/EnchantChecker';\r\nimport WeaponEnhancementChecker from 'parser/shared/modules/items/WeaponEnhancementChecker';\r\nimport FlaskChecker from 'parser/shared/modules/items/FlaskChecker';\r\nimport FoodChecker from 'parser/shared/modules/items/FoodChecker';\r\nimport { ThresholdStyle } from 'parser/core/ParseResults';\r\n\r\nclass PreparationRuleAnalyzer extends Analyzer {\r\n  static dependencies = {\r\n    potionChecker: PotionChecker,\r\n    enchantChecker: EnchantChecker,\r\n    weaponEnhancementChecker: WeaponEnhancementChecker,\r\n    flaskChecker: FlaskChecker,\r\n    foodChecker: FoodChecker,\r\n  };\r\n\r\n  get thresholds() {\r\n    return {\r\n      potionsUsed: {\r\n        actual: this.potionChecker.potionsUsed,\r\n        max: this.potionChecker.maxPotions,\r\n        isLessThan: this.potionChecker.maxPotions,\r\n        style: ThresholdStyle.NUMBER,\r\n      },\r\n      bestPotionUsed: {\r\n        actual: this.potionChecker.strongPotionsUsed,\r\n        max: this.potionChecker.maxPotions,\r\n        isLessThan: this.potionChecker.maxPotions,\r\n        style: ThresholdStyle.NUMBER,\r\n      },\r\n      itemsEnchanted: {\r\n        actual: this.enchantChecker.numEnchantableGear - this.enchantChecker.numSlotsMissingEnchant,\r\n        max: this.enchantChecker.numEnchantableGear,\r\n        isLessThan: this.enchantChecker.numEnchantableGear,\r\n        style: ThresholdStyle.NUMBER,\r\n      },\r\n      itemsBestEnchanted: {\r\n        // numSlotsMissingMaxEnchant doesn't include items without an enchant at all\r\n        actual: this.enchantChecker.numEnchantableGear - this.enchantChecker.numSlotsMissingEnchant - this.enchantChecker.numSlotsMissingMaxEnchant,\r\n        max: this.enchantChecker.numEnchantableGear,\r\n        isLessThan: this.enchantChecker.numEnchantableGear,\r\n        style: ThresholdStyle.NUMBER,\r\n      },\r\n      weaponsEnhanced: {\r\n        actual: this.weaponEnhancementChecker.numWeapons - this.weaponEnhancementChecker.numWeaponsMissingEnhancement,\r\n        max: this.weaponEnhancementChecker.numWeapons,\r\n        isLessThan: this.weaponEnhancementChecker.numWeapons,\r\n        style: ThresholdStyle.NUMBER,\r\n      },\r\n      bestWeaponEnhancements: {\r\n        actual: this.weaponEnhancementChecker.numWeapons - this.weaponEnhancementChecker.numWeaponsMissingEnhancement - this.weaponEnhancementChecker.numWeaponsMissingMaxEnhancement,\r\n        max: this.weaponEnhancementChecker.numWeapons,\r\n        isLessThan: this.weaponEnhancementChecker.numWeapons,\r\n        style: ThresholdStyle.NUMBER,\r\n      },\r\n      higherFlaskPresent: this.flaskChecker.flaskStrengthSuggestion,\r\n      flaskPresent: this.flaskChecker.flaskSuggestionThresholds,\r\n      higherFoodPresent: this.foodChecker.higherFoodSuggestionThresholds,\r\n      foodPresent: this.foodChecker.isPresentFoodSuggestionThresholds,\r\n\r\n    };\r\n  }\r\n\r\n}\r\n\r\nexport default PreparationRuleAnalyzer;\r\n","import React from 'react';\r\nimport { Config } from 'vega-lite';\r\nimport { VegaLite, VisualizationSpec } from 'react-vega';\r\n\r\nexport const defaultConfig = {\r\n  autosize: {\r\n    type: 'fit' as const,\r\n    contains: 'padding' as const,\r\n  },\r\n  background: '#0000',\r\n  padding: 0,\r\n  view: {\r\n    stroke: null,\r\n  },\r\n  axis: {\r\n    domainColor: 'gray',\r\n    labelColor: '#e9e8e7',\r\n    tickColor: 'gray',\r\n  },\r\n};\r\n\r\nexport interface Props {\r\n  spec: VisualizationSpec,\r\n  data: any,\r\n  config?: Config,\r\n  width?: number,\r\n  height?: number,\r\n  renderer?: \"canvas\" | \"svg\",\r\n}\r\n\r\nexport function formatTime(field: string = 'datum.timestamp') {\r\n  return `if(${field} / 1000 >= 60, toString(floor(${field} / 60000)) + 'm ', '') + toString(floor(${field} / 1000) % 60) + 's'`;\r\n}\r\n\r\n\r\nexport default function BaseChart(props: Props) {\r\n  const prp = {\r\n    config: defaultConfig,\r\n    renderer: \"canvas\" as const,\r\n    ...props,\r\n    spec: {\r\n      ...props.spec,\r\n      datasets: props.data,\r\n    },\r\n    data: undefined\r\n  };\r\n\r\n  return (\r\n    <VegaLite\r\n      theme=\"dark\"\r\n      tooltip={{theme: 'dark'}}\r\n      actions={false}\r\n      {...prp}\r\n    />\r\n  );\r\n}\r\n","import React from 'react';\r\n\r\nimport Icon from 'common/Icon';\r\nimport { formatPercentage } from 'common/format';\r\nimport Analyzer, { Options } from 'parser/core/Analyzer';\r\nimport Events, { EndChannelEvent, EventType, GlobalCooldownEvent } from 'parser/core/Events';\r\nimport { When, ThresholdStyle } from 'parser/core/ParseResults';\r\nimport StatisticBox, { STATISTIC_ORDER } from 'interface/others/StatisticBox';\r\nimport Tooltip from 'common/Tooltip';\r\nimport { i18n } from '@lingui/core';\r\nimport { t, Trans } from '@lingui/macro';\r\n\r\nimport Haste from 'parser/shared/modules/Haste';\r\n\r\nimport Abilities from '../../core/modules/Abilities';\r\nimport GlobalCooldown from './GlobalCooldown';\r\nimport Channeling from './Channeling';\r\n\r\nclass AlwaysBeCasting extends Analyzer {\r\n  static dependencies = {\r\n    haste: Haste,\r\n    abilities: Abilities,\r\n    globalCooldown: GlobalCooldown, // triggers the globalcooldown event\r\n    channeling: Channeling, // triggers the channeling-related events\r\n  };\r\n  protected haste!: Haste;\r\n  protected abilities!: Abilities;\r\n  protected globalCooldown!: GlobalCooldown;\r\n  protected channeling!: Channeling;\r\n\r\n  /**\r\n   * The amount of milliseconds not spent casting anything or waiting for the GCD.\r\n   * @type {number}\r\n   */\r\n  get totalTimeWasted() {\r\n    return this.owner.fightDuration - this.activeTime;\r\n  }\r\n\r\n  get downtimePercentage() {\r\n    return 1 - this.activeTimePercentage;\r\n  }\r\n\r\n  get activeTimePercentage() {\r\n    return this.activeTime / this.owner.fightDuration;\r\n  }\r\n\r\n  activeTime = 0;\r\n  _lastGlobalCooldownDuration = 0;\r\n\r\n  constructor(options: Options) {\r\n    super(options);\r\n    this.addEventListener(Events.GlobalCooldown, this.onGCD);\r\n    this.addEventListener(Events.EndChannel, this.onEndChannel);\r\n  }\r\n\r\n  onGCD(event: GlobalCooldownEvent) {\r\n    this._lastGlobalCooldownDuration = event.duration;\r\n    if (event.trigger.prepull) {\r\n      // Ignore prepull casts for active time since active time should only include casts during the\r\n      return false;\r\n    }\r\n    if (event.trigger.type === EventType.BeginChannel) {\r\n      // Only add active time for this channel, we do this when the channel is finished and use the highest of the GCD and channel time\r\n      return false;\r\n    }\r\n    this.activeTime += event.duration;\r\n    return true;\r\n  }\r\n\r\n  onEndChannel(event: EndChannelEvent) {\r\n    // If the channel was shorter than the GCD then use the GCD as active time\r\n    let amount = event.duration;\r\n    if (this.globalCooldown.isOnGlobalCooldown(event.ability.guid)) {\r\n      amount = Math.max(amount, this._lastGlobalCooldownDuration);\r\n    }\r\n    this.activeTime += amount;\r\n    return true;\r\n  }\r\n\r\n  showStatistic = true;\r\n  position = STATISTIC_ORDER.CORE(10);\r\n  static icons = {\r\n    activeTime: '/img/sword.png',\r\n    downtime: '/img/afk.png',\r\n  };\r\n\r\n  statistic() {\r\n    const boss = this.owner.boss;\r\n    if (!this.showStatistic || (boss && boss.fight.disableDowntimeStatistic)) {\r\n      return null;\r\n    }\r\n    if (!this.globalCooldown.isAccurate) {\r\n      return null;\r\n    }\r\n\r\n    const ctor = this.constructor as typeof AlwaysBeCasting;\r\n    return (\r\n      <StatisticBox\r\n        position={this.position}\r\n        icon={<Icon icon=\"spell_mage_altertime\" alt=\"Downtime\" />}\r\n        value={`${formatPercentage(this.downtimePercentage)} %`}\r\n        label={<Trans id=\"shared.alwaysBeCasting.statistic.label\">Downtime</Trans>}\r\n        tooltip={(\r\n          <Trans id=\"shared.alwaysBeCasting.statistic.tooltip\">\r\n            Downtime is available time not used to cast anything (including not having your GCD rolling). This can be caused by delays between casting spells, latency, cast interrupting or just simply not casting anything (e.g. due to movement/stunned).<br />\r\n            <ul>\r\n              <li>You spent <strong>{formatPercentage(this.activeTimePercentage)}%</strong> of your time casting something.</li>\r\n              <li>You spent <strong>{formatPercentage(this.downtimePercentage)}%</strong> of your time casting nothing at all.</li>\r\n            </ul>\r\n          </Trans>\r\n        )}\r\n        footer={(\r\n          <div className=\"statistic-box-bar\">\r\n            <Tooltip content={<Trans id=\"shared.alwaysBeCasting.statistic.footer.activetime.tooltip\">You spent <strong>{formatPercentage(this.activeTimePercentage)}%</strong> of your time casting something.</Trans>}>\r\n              <div\r\n                className=\"stat-health-bg\"\r\n                style={{\r\n                  width: `${this.activeTimePercentage * 100}%`,\r\n                }}\r\n              >\r\n                <img src={ctor.icons.activeTime} alt=\"Active time\" />\r\n              </div>\r\n            </Tooltip>\r\n            <Tooltip content={<Trans id=\"shared.alwaysBeCasting.statistic.footer.downtime.tooltip\">You spent <strong>{formatPercentage(this.downtimePercentage)}%</strong> of your time casting nothing at all.</Trans>}>\r\n              <div className=\"remainder DeathKnight-bg\">\r\n                <img src={ctor.icons.downtime} alt=\"Downtime\" />\r\n              </div>\r\n            </Tooltip>\r\n          </div>\r\n        )}\r\n      />\r\n    );\r\n  }\r\n\r\n  get downtimeSuggestionThresholds() {\r\n    return {\r\n      actual: this.downtimePercentage,\r\n      isGreaterThan: {\r\n        minor: 0.02,\r\n        average: 0.04,\r\n        major: 0.06,\r\n      },\r\n      style: ThresholdStyle.PERCENTAGE,\r\n    };\r\n  }\r\n\r\n  suggestions(when: When) {\r\n    when(this.downtimeSuggestionThresholds.actual).isGreaterThan(this.downtimeSuggestionThresholds.isGreaterThan.minor)\r\n      .addSuggestion((suggest, actual, recommended) => suggest(`${<Trans id=\"shared.suggestions.alwaysBeCasting.suggestion\">Your downtime can be improved. Try to Always Be Casting (ABC), avoid delays between casting spells and cast instant spells when you have to move.</Trans>}`)\r\n        .icon('spell_mage_altertime')\r\n        .actual(`${formatPercentage(actual)}% ${i18n._(t('shared.suggestions.alwaysBeCasting.downtime')`downtime`)}`)\r\n        .recommended(`<${formatPercentage(recommended)}% is recommended`)\r\n        .regular(this.downtimeSuggestionThresholds.isGreaterThan.average).major(this.downtimeSuggestionThresholds.isGreaterThan.major));\r\n  }\r\n}\r\n\r\nexport default AlwaysBeCasting;\r\n","import SPELLS from 'common/SPELLS';\r\n\r\n//region Spells\r\n/** Rapid Fire */\r\n//Rapid Fire ticks 7 times per cast baseline\r\nexport const RAPID_FIRE_TICKS_PER_CAST = 7;\r\n//Rapid Fire generates 1 focus per hit\r\nexport const RAPID_FIRE_FOCUS_PER_TICK = 1;\r\n/** Aimed Shot */\r\n//Aimed Shot has a baseline casttime of 2.5s\r\nexport const AIMED_SHOT_BASELINE_CAST_TIME = 2500;\r\n//Aimed Shot costs 35 focus baseline\r\nexport const AIMED_SHOT_FOCUS_COST = 35;\r\n/** Trueshot */\r\n//Trueshot makes Aimed Shot recharge 225% faster despite what its tooltip says\r\nexport const TRUESHOT_AIMED_SHOT_RECHARGE_INCREASE = 2.25;\r\n//Trueshot makes Rapid Fire recharge 240% faster despite what its tooltip says\r\nexport const TRUESHOT_RAPID_FIRE_RECHARGE_INCREASE = 2.4;\r\n//Trueshot increases the cast rate of Aimed Shot by 50%\r\nexport const TRUESHOT_AIMED_SHOT_CAST_TIME_SPEED_UP = 0.5;\r\n//Trueshot lasts 15 seconds by default\r\nexport const TRUESHOT_DURATION_BASELINE = 15000;\r\n//Trueshot increases focus regen by 50%\r\nexport const TRUESHOT_FOCUS_INCREASE = 0.5;\r\n/** Lone Wolf */\r\n//Lone Wolf increases damage done by up to 10%\r\nexport const MAX_LONE_WOLF_MODIFIER = 0.10;\r\n//Lone Wolf ramps up every 2 seconds if it isn't capped\r\nexport const LONE_WOLF_RAMP_INTERVAL_MS = 2000;\r\n//Lone Wolf increases its damage done by 1% every 2 seconds\r\nexport const LONE_WOLF_INCREASE_PER_RAMP = 0.01;\r\n//Lone Wolf starts at 0% increased damage after dismissing pet\r\nexport const START_LONE_WOLF_MODIFIER = 0;\r\n//Lone Wolf modifies the following abilities\r\nexport const LONE_WOLF_AFFECTED_SPELLS = [\r\n  SPELLS.AUTO_SHOT,\r\n  SPELLS.MULTISHOT_MM,\r\n  SPELLS.AIMED_SHOT,\r\n  SPELLS.STEADY_SHOT,\r\n  SPELLS.BARRAGE_TALENT,\r\n  SPELLS.A_MURDER_OF_CROWS_DEBUFF,\r\n  SPELLS.CHIMAERA_SHOT_MM_FROST_DAMAGE,\r\n  SPELLS.CHIMAERA_SHOT_MM_NATURE_DAMAGE,\r\n  SPELLS.ARCANE_SHOT,\r\n  SPELLS.BURSTING_SHOT,\r\n  SPELLS.EXPLOSIVE_SHOT_DAMAGE,\r\n  SPELLS.SERPENT_STING_TALENT,\r\n  SPELLS.VOLLEY_DAMAGE,\r\n  SPELLS.RAPID_FIRE,\r\n  SPELLS.KILL_SHOT_MM_BM,\r\n];\r\n/** Precise Shots */\r\n//Logs give no indication whether we gain 1 or 2 stacks - we assume 2 and work from there.\r\nexport const PRECISE_SHOTS_ASSUMED_PROCS = 2;\r\n//Precise Shots increase damage of Arcane or Multi-Shot by 75%\r\nexport const PRECISE_SHOTS_MODIFIER = 0.75;\r\n//Because the spells have traveltime we need to take it into account\r\nexport const ARCANE_SHOT_MAX_TRAVEL_TIME = 500;\r\n/** Trick Shots */\r\n//Trick Shots baseline does 50% damage to secondary targets\r\nexport const TRICK_SHOTS_BASELINE_DAMAGE = 0.5;\r\n/** Steady Shot */\r\n//Steady Shot regenerates 10 focus baseline on cast\r\nexport const STEADY_SHOT_FOCUS_REGEN = 10;\r\n//endregion\r\n\r\n//region Talents\r\n/** Streamline */\r\n//Streamline increases the damage of Rapid Fire by 15%\r\nexport const STREAMLINE_RAPID_FIRE_DAMAGE_INCREASE = 0.15;\r\n//Rapid Fire causes the next Aimed Shot to cast 30% faster.\r\nexport const STREAMLINE_AIMED_SHOT_CAST_SPEED_UP = 0.3;\r\n/** Steady Focus */\r\n//Steady Focus increases haste by 7%\r\nexport const STEADY_FOCUS_HASTE_PERCENT = 0.07;\r\n/** Master Marksman */\r\n//Master Marksman makes special shot crits apply a 15% DOT\r\nexport const MASTER_MARKSMAN_CRIT_DOT = 0.15;\r\n//Master Marksman ticks every two seconds\r\nexport const MASTER_MARKSMAN_TICK_RATE = 2000;\r\n/** Dead Eye */\r\n//Dead Eye increases the Aimed Shot recharge rate by 200%, despite tooltip saying it is 50%\r\nexport const DEAD_EYE_AIMED_SHOT_RECHARGE_INCREASE = 2;\r\n/** Calling the Shots */\r\n//Calling the Shots makes Arcane Shot and Multi Shot decrease Trueshot cooldown by 2.5s\r\nexport const CTS_CDR_MS = 2500;\r\n/** Careful Aim */\r\n//Careful Aim is a execution-like talent that triggers off above 70%\r\nexport const CAREFUL_AIM_THRESHOLD = 0.7;\r\n//Careful Aim increases Aimed Shot damage by 50% when active\r\nexport const CA_MODIFIER = .5;\r\n/** Lock and Load */\r\n//Lock and Load has a 8% chance to proc per auto attack\r\nexport const LNL_PROC_CHANCE = 0.08;\r\n//When Lock and Load procs, Aimed Shot costs 0 focus\r\nexport const LNL_COST_MULTIPLIER = 0;\r\n/** Lethal Shots */\r\n//Lethal Shot has a 30% chance per Arcane Shot / Multi Shot / Chimaera Shot hit\r\nexport const LETHAL_SHOTS_CHANCE = 0.3;\r\n//Lethal Shot procs reduce cooldown of Rapid Fire\r\nexport const LETHAL_SHOTS_REDUCTION = 5000;\r\n/** Serpent Sting */\r\n//Serpent Sting has a 18 second duration for Marksmanship\r\nexport const SERPENT_STING_MM_BASE_DURATION = 18000;\r\n//Serpent Sting pandemics at 30%\r\nexport const SERPENT_STING_MM_PANDEMIC = 0.3;\r\n//endregion\r\n\r\n//region Resources\r\n/** Marksmanship specific focus spenders */\r\nexport const LIST_OF_FOCUS_SPENDERS_MM = [\r\n  SPELLS.AIMED_SHOT,\r\n  SPELLS.SERPENT_STING_TALENT,\r\n  SPELLS.MULTISHOT_MM,\r\n  SPELLS.BURSTING_SHOT,\r\n  SPELLS.EXPLOSIVE_SHOT_TALENT,\r\n];\r\n//endregion\r\n\r\n//region Conduits\r\n/** Brutal Projectiles */\r\n//With Brutal Projectiles your auto attacks have a 10%\r\nexport const BRUTAL_PROJECTILES_PROC_CHANCE = 0.1;\r\n//Each Shot of Rapid Fire increases damage more and more over its duration\r\nexport const BRUTAL_PROJECTILES_RAMP_DAMAGE = [0, 0.01, 1.25, 0.015, 0.02, 0.0225, 0.025, 0.0275, 0.0325, 0.035, 0.0375, 0.04, 0.0425, 0.045, 0.0475, 0.05];\r\n/** Deadly Chain */\r\n//With Deadly Chain your trickshots damage is increased\r\nexport const DEADLY_CHAIN_TRICKSHOTS_DAMAGE_INCREASE = [0, 0.10, 0.11, 0.12, 0.13, 0.14, 0.15, 0.16, 0.18, 0.19, 0.20, 0.21, 0.22, 0.23, 0.24, 0.25];\r\n/** Powerful Precision */\r\n//With Powerful Precision Precise Shots further increases the damage of Arcane Shot, Chimaera Shots and Multi-Shot\r\nexport const POWERFUL_PRECISION_DAMAGE_INCREASE = [0, 0.05, 0.06, 0.07, 0.08, 0.10, 0.11, 0.12, 0.13, 0.14, 0.15, 0.16, 0.17, 0.18, 0.19, 0.20];\r\n/** Sharpshooter's Focus */\r\n//With Sharpshooter's Focus, Trueshot lasts x% longer\r\nexport const SHARPSHOOTERS_FOCUS_INCREASE_TRUESHOT_DURATION = [0, 0.20, 0.22, 0.24, 0.27, 0.29, 0.31, 0.33, 0.36, 0.38, 0.40, 0.42, 0.44, 0.46, 0.48, 0.50];\r\n//endregion\r\n\r\n//region Legendaries\r\n/** Surging Shots */\r\n//Surging Shots increases the damage of Rapid Fire by 25%\r\nexport const SURGING_SHOTS_DAMAGE_INCREASE = 0.25;\r\n//Surging Shots gives 15% chance for Aimed Shot to reset the cooldown of Rapid Fire\r\nexport const SURGING_SHOTS_RESET_CHANCE = 0.15;\r\n/** Eagletalon's True Focus */\r\n//Eagletalon's True Focus makes Trueshot reduces focus cost of all abilities by 50%\r\nexport const EAGLETALONS_TRUE_FOCUS_COST_REDUCTION = 0.5;\r\n/** Secrets of the Unblinking Vigil */\r\n//Secrets of the Unblinking Vigil has 50% chance to proc on gaining Trick Shots\r\nexport const SECRETS_UNBLINKING_PROC_CHANCE = 0.5;\r\n//The Secrets of the Unblinking Vigil buff makes Aimed Shot cost 0 focus (100% reduction).\r\nexport const SECRETS_UNBLINKING_FOCUS_COST_REDUCTION = 1;\r\n//endregion\r\n","import React from 'react';\r\nimport { AutoSizer } from 'react-virtualized';\r\n\r\nimport { formatThousands, formatPercentage } from 'common/format';\r\nimport rankingColor from 'common/getRankingColor';\r\nimport makeWclUrl from 'common/makeWclUrl';\r\nimport Tooltip from 'common/Tooltip';\r\nimport StatisticBar from 'interface/statistics/StatisticBar';\r\nimport ThroughputPerformance, { UNAVAILABLE } from 'interface/report/Results/ThroughputPerformance';\r\nimport STATISTIC_ORDER from 'interface/others/STATISTIC_ORDER';\r\nimport Analyzer, { Options, SELECTED_PLAYER, SELECTED_PLAYER_PET } from 'parser/core/Analyzer';\r\nimport FlushLineChart from 'interface/others/FlushLineChart';\r\nimport Events, { AbsorbedEvent, DamageEvent, HealEvent, RemoveBuffEvent } from 'parser/core/Events';\r\n\r\nimport HealingValue from '../HealingValue';\r\n\r\nclass HealingDone extends Analyzer {\r\n  constructor(options: Options) {\r\n    super(options);\r\n\r\n    this.addEventListener(Events.heal.by(SELECTED_PLAYER | SELECTED_PLAYER_PET), this.onHeal);\r\n    this.addEventListener(Events.absorbed.by(SELECTED_PLAYER | SELECTED_PLAYER_PET), this.onAbsorbed);\r\n    this.addEventListener(Events.removebuff.by(SELECTED_PLAYER | SELECTED_PLAYER_PET), this.onRemovebuff);\r\n  }\r\n\r\n  _total = new HealingValue();\r\n  get total() {\r\n    return this._total;\r\n  }\r\n  _healingByAbsorbs = new HealingValue();\r\n  get healingByAbsorbs() {\r\n    return this._healingByAbsorbs;\r\n  }\r\n\r\n  bySecond: { [secondsIntoFight: number]: HealingValue } = {};\r\n\r\n  _byAbility: { [spellId: number]: HealingValue } = {};\r\n  byAbility(spellId: number) {\r\n    if (!this._byAbility[spellId]) {\r\n      return new HealingValue();\r\n    }\r\n    return this._byAbility[spellId];\r\n  }\r\n\r\n  onHeal(event: HealEvent) {\r\n    this._addHealing(event, event.amount, event.absorbed, event.overheal);\r\n  }\r\n  onAbsorbed(event: AbsorbedEvent) {\r\n    this._addHealingByAbsorb(event, event.amount, 0, 0);\r\n  }\r\n  onRemovebuff(event: RemoveBuffEvent) {\r\n    if (event.absorb) {\r\n      this._addHealingByAbsorb(event, 0, 0, event.absorb);\r\n    }\r\n  }\r\n\r\n  _addHealing(event: HealEvent | AbsorbedEvent | RemoveBuffEvent | DamageEvent, amount = 0, absorbed = 0, overheal = 0) {\r\n    this._total = this._total.add(amount, absorbed, overheal);\r\n\r\n    const spellId = event.ability.guid;\r\n    this._byAbility[spellId] = (this._byAbility[spellId] || new HealingValue()).add(amount, absorbed, overheal);\r\n\r\n    const secondsIntoFight = Math.floor((event.timestamp - this.owner.fight.start_time) / 1000);\r\n    this.bySecond[secondsIntoFight] = (this.bySecond[secondsIntoFight] || new HealingValue()).add(amount, absorbed, overheal);\r\n  }\r\n  _addHealingByAbsorb(event: AbsorbedEvent | RemoveBuffEvent, amount = 0, absorbed = 0, overhealing = 0) {\r\n    this._addHealing(event, amount, absorbed, overhealing);\r\n    this._healingByAbsorbs = this._healingByAbsorbs.add(amount, absorbed, overhealing);\r\n  }\r\n  _subtractHealing(event: DamageEvent, amount = 0, absorbed = 0, overheal = 0) {\r\n    return this._addHealing(event, -amount, -absorbed, -overheal);\r\n  }\r\n  _subtractHealingByAbsorb(event: AbsorbedEvent, amount = 0, absorbed = 0, overheal = 0) {\r\n    return this._addHealingByAbsorb(event, -amount, -absorbed, -overheal);\r\n  }\r\n\r\n  showStatistic = true;\r\n  subStatistic() { // rendered by ThroughputStatisticGroup\r\n    if (!this.showStatistic) {\r\n      return null;\r\n    }\r\n\r\n    const data = Object.entries(this.bySecond).map(([sec, val]) => ({ 'time': sec, 'val': val.effective }));\r\n\r\n    const perSecond = this.total.effective / this.owner.fightDuration * 1000;\r\n    const wclUrl = makeWclUrl(this.owner.report.code, {\r\n      fight: this.owner.fightId,\r\n      source: this.owner.playerId,\r\n      type: 'healing',\r\n    });\r\n\r\n    return (\r\n      <StatisticBar\r\n        position={STATISTIC_ORDER.CORE(2)}\r\n        ultrawide\r\n        large={false}\r\n        wide={false}\r\n        style={{ marginBottom: 19, overflow: 'hidden' }} // since this is in a group, reducing margin should be fine\r\n      >\r\n        <div className=\"flex\">\r\n          <div className=\"flex-sub icon\">\r\n            <img\r\n              src=\"/img/healing.png\"\r\n              alt=\"Healing\"\r\n            />\r\n          </div>\r\n          <Tooltip content={<>Total healing done: <strong>{formatThousands(this.total.effective)}</strong></>}>\r\n            <div\r\n              className=\"flex-sub value\"\r\n              style={{ width: 190 }}\r\n            >\r\n              {formatThousands(perSecond)} HPS\r\n            </div>\r\n          </Tooltip>\r\n          <div className=\"flex-sub\" style={{ width: 110, textAlign: 'center', padding: '10px 5px' }}>\r\n            <ThroughputPerformance throughput={perSecond} metric=\"hps\">\r\n              {({ performance, topThroughput }) => performance && performance !== UNAVAILABLE && (\r\n                <Tooltip\r\n                  content={(\r\n                    <>\r\n                      Your HPS compared to the HPS of a top 100 player. To become a top 100 <span className={this.selectedCombatant.spec.className.replace(' ', '')}>{this.selectedCombatant.spec.specName} {this.selectedCombatant.spec.className}</span> on this fight you need to do at least <strong>{formatThousands(topThroughput || 0)} HPS</strong>.\r\n                    </>\r\n                  )}\r\n                >\r\n                  <div\r\n                    className={rankingColor(performance)}\r\n                    style={{ cursor: 'help' }}\r\n                  >\r\n                    {performance >= 1 ? 'TOP 100' : `${formatPercentage(performance, 0)}%`}\r\n                  </div>\r\n                </Tooltip>\r\n              )}\r\n            </ThroughputPerformance>\r\n          </div>\r\n          <div className=\"flex-main chart\" style={{ padding: 0 }}>\r\n            <a href={wclUrl}>\r\n              {perSecond > 0 && (\r\n                <AutoSizer disableWidth>\r\n                  {({ height }) => (\r\n                    <FlushLineChart data={data} duration={this.owner.fightDuration / 1000} height={height} />\r\n                  )}\r\n                </AutoSizer>\r\n              )}\r\n            </a>\r\n          </div>\r\n        </div>\r\n      </StatisticBar>\r\n    );\r\n  }\r\n}\r\n\r\nexport default HealingDone;\r\n","import PropTypes from 'prop-types';\r\n\r\nclass Buff {\r\n  static propTypes = {\r\n    /**\r\n     * REQUIRED The spell id. If an array of spell ids is provided, the first element in the array will be what shows in suggestions / cast timeline. Multiple spell definitions in the same ability can be used to tie multiple cast / buff IDs together as the same ability (with a shared cooldown)\r\n     */\r\n    spellId: PropTypes.oneOfType([\r\n      PropTypes.number,\r\n      PropTypes.arrayOf(PropTypes.number),\r\n    ]).isRequired,\r\n    /**\r\n     * Whether the spell is enabled (available to the player) and should be displayed. This should only be used for hiding spells that are unavailable, for example due to talents. Defaults to true.\r\n     */\r\n    enabled: PropTypes.bool,\r\n    /**\r\n     * The spells that trigger this buff. Defaults to the same spell as the buff (this is most commonly the same spell). Only configure this if it's different.\r\n     */\r\n    triggeredBySpellId: PropTypes.oneOfType([\r\n      PropTypes.number,\r\n      PropTypes.arrayOf(PropTypes.number),\r\n    ]),\r\n    /**\r\n     * Whether the spell should be highlighted on the timeline. You should only highlight important buffs that may affect your cast behavior. Defaults to false.\r\n     */\r\n    timelineHighlight: PropTypes.bool,\r\n  };\r\n\r\n  spellId = null;\r\n  enabled = true;\r\n  triggeredBySpellId = null;\r\n  timelineHighlight = false;\r\n  /**\r\n   * When extending this class you MUST copy-paste this function into the new class. Otherwise your new props will not be set properly.\r\n   * @param options\r\n   */\r\n  constructor(options) {\r\n    this._setProps(options);\r\n  }\r\n\r\n  _setProps(props) {\r\n    if (process.env.NODE_ENV === 'development') {\r\n      /**\r\n       * We verify the sanity of the abilities props to avoid mistakes. First we check the types by reusing React's PropTypes which prints to your console, and next we verify if all the props of the abilities exist in the possible proptypes. If not they're likely mislocated.\r\n       */\r\n      PropTypes.checkPropTypes(this.constructor.propTypes, props, 'prop', 'Ability'); // eslint-disable-line react/forbid-foreign-prop-types\r\n      Object.keys(props).forEach(prop => {\r\n        if (this.constructor.propTypes[prop] === undefined) { // eslint-disable-line react/forbid-foreign-prop-types\r\n          console.log(prop);\r\n          throw new Error(`Property not recognized in Buffs: ${prop} seems misplaced in ${JSON.stringify(props.spell)}`);\r\n        }\r\n      });\r\n    }\r\n    Object.keys(props).forEach(prop => {\r\n      this._setProp(prop, props[prop]);\r\n    });\r\n  }\r\n  _setProp(prop, value) {\r\n    this[prop] = value;\r\n  }\r\n}\r\n\r\nexport default Buff;\r\n","import BLOODLUST_BUFFS from 'game/BLOODLUST_BUFFS';\r\nimport SPELLS from 'common/SPELLS';\r\nimport Module from 'parser/core/Module';\r\nimport Haste from 'parser/shared/modules/Haste';\r\n\r\nimport Buff from './Buff';\r\nimport Abilities from './Abilities';\r\n\r\n// TODO: Make a separate but similar Debuffs module\r\n/**\r\n * @property {Haste} haste\r\n * @property {Abilities} abilities\r\n */\r\nclass Buffs extends Module {\r\n  static dependencies = {\r\n    haste: Haste,\r\n    abilities: Abilities,\r\n  };\r\n  static BUFF_CLASS = Buff;\r\n\r\n  /**\r\n   * This will be called *once* during initialization. This isn't nearly as well worked out as the Abilities modules and was in fact extremely rushed. So I have no clue if you should include all buffs here, or just important ones. We'll figure it out later.\r\n   * @returns {object[]}\r\n   */\r\n  buffs() {\r\n    // This list will NOT be recomputed during the fight. If a cooldown changes based on something like Haste or a Buff you need to put it in a function.\r\n    // While you can put checks for talents/traits outside of the cooldown prop, you generally should aim to keep everything about a single spell together. In general only move a prop up if you're regularly checking for the same talent/trait in multiple spells.\r\n    // I think anyway, this might all change lul.\r\n    return [\r\n      // Convert the legacy buffSpellId prop\r\n      ...this.abilities.activeAbilities.filter(ability => Boolean(ability.buffSpellId)).map(ability => ({\r\n        spellId: ability.buffSpellId,\r\n        triggeredBySpellId: ability.spell.id !== ability.buffSpellId ? ability.primarySpell.id : undefined,\r\n        timelineHighlight: true,\r\n      })),\r\n      {\r\n        spellId: Object.keys(BLOODLUST_BUFFS).map(item => Number(item)),\r\n        timelineHighlight: true,\r\n      },\r\n      {\r\n        spellId: SPELLS.POWER_INFUSION.id,\r\n        timelineHighlight: true,\r\n      },\r\n    ];\r\n  }\r\n\r\n  activeBuffs = [];\r\n  constructor(options) {\r\n    super(options);\r\n    this.loadBuffs(this.buffs());\r\n  }\r\n  loadBuffs(buffs) {\r\n    this.activeBuffs = buffs.map(options => new this.constructor.BUFF_CLASS(options)).filter(ability => ability.enabled);\r\n  }\r\n\r\n  /**\r\n   * Add a buff to the list of active buffs.\r\n   * @param {object} options An object with all the properties and their values that gets passed to the Buff class.\r\n   */\r\n  add(options) {\r\n    const buff = new this.constructor.BUFF_CLASS(options);\r\n    this.activeBuffs.push(buff);\r\n  }\r\n\r\n  /**\r\n   * Returns the first ACTIVE buff with the given spellId (or undefined if there is no such buff)\r\n   */\r\n  getBuff(spellId) {\r\n    return this.activeBuffs.find(buff => {\r\n      if (buff.spellId instanceof Array) {\r\n        return buff.spellId.includes(spellId);\r\n      } else {\r\n        return buff.spellId === spellId;\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nexport default Buffs;\r\n","import SPELLS from 'common/SPELLS/index';\r\nimport { formatMilliseconds, formatPercentage } from 'common/format';\r\nimport Analyzer from 'parser/core/Analyzer';\r\nimport EventEmitter from 'parser/core/modules/EventEmitter';\r\nimport StatTracker from 'parser/shared/modules/StatTracker';\r\nimport BLOODLUST_BUFFS from 'game/BLOODLUST_BUFFS';\r\nimport EventFilter, { SELECTED_PLAYER } from 'parser/core/EventFilter';\r\nimport Events, { EventType } from 'parser/core/Events';\r\nimport { STEADY_FOCUS_HASTE_PERCENT } from 'parser/hunter/marksmanship/constants';\r\nimport { DIRE_BEAST_HASTE_PERCENT } from 'parser/hunter/shared/constants';\r\n\r\nconst debug = false;\r\n\r\nclass Haste extends Analyzer {\r\n  static dependencies = {\r\n    eventEmitter: EventEmitter,\r\n    statTracker: StatTracker,\r\n  };\r\n\r\n  static HASTE_BUFFS = {\r\n\r\n    // HASTE RATING BUFFS ARE HANDLED BY THE STATTRACKER MODULE\r\n\r\n    ...BLOODLUST_BUFFS,\r\n    [SPELLS.HOLY_AVENGER_TALENT.id]: 0.3,\r\n    [SPELLS.BERSERKING.id]: 0.1,\r\n    [SPELLS.ICY_VEINS.id]: 0.3,\r\n    [SPELLS.IN_FOR_THE_KILL_TALENT_BUFF.id]: 0.1,\r\n    [SPELLS.BONE_SHIELD.id]: 0.1, // Blood BK haste buff from maintaining boneshield\r\n    [SPELLS.METAMORPHOSIS_HAVOC_BUFF.id]: 0.25,\r\n    [SPELLS.DARK_SOUL_MISERY_TALENT.id]: 0.3,\r\n    [SPELLS.REVERSE_ENTROPY_BUFF.id]: 0.15,\r\n    [SPELLS.ENRAGE.id]: 0.25, // Fury Warrior\r\n    [SPELLS.FROTHING_BERSERKER.id]: 0.05, // Fury Warrior\r\n    [SPELLS.EMPOWER_RUNE_WEAPON.id]: 0.15, // Frost DK\r\n\r\n    //region Hunter Haste Buffs\r\n    [SPELLS.DIRE_BEAST_BUFF.id]: DIRE_BEAST_HASTE_PERCENT,\r\n    [SPELLS.STEADY_FOCUS_BUFF.id]: STEADY_FOCUS_HASTE_PERCENT,\r\n    //endregion\r\n\r\n    //region Paladin\r\n    [SPELLS.CRUSADE_TALENT.id]: {\r\n      hastePerStack: 0.03,\r\n    },\r\n    //endregion\r\n\r\n    // Boss abilities:\r\n    [SPELLS.OPULENCE_AMETHYST_OF_THE_SHADOW_KING.id]: 0.5, // Amethyst of the Shadow King by Opulence (BoD - BFA)\r\n  };\r\n\r\n  get changehaste() {\r\n    return new EventFilter(EventType.ChangeHaste);\r\n  }\r\n\r\n  current = null;\r\n  constructor(...args) {\r\n    super(...args);\r\n    this.current = this.statTracker.currentHastePercentage;\r\n    debug && console.log(`Haste: Starting haste: ${formatPercentage(this.current)}%`);\r\n    this._triggerChangeHaste(null, null, this.current);\r\n    this.addEventListener(Events.applybuff.to(SELECTED_PLAYER), this.onApplyBuff);\r\n    this.addEventListener(Events.changebuffstack.to(SELECTED_PLAYER), this.onChangeBuffStack);\r\n    this.addEventListener(Events.removebuff.to(SELECTED_PLAYER), this.onRemoveBuff);\r\n    this.addEventListener(Events.applydebuff.to(SELECTED_PLAYER), this.onApplyDebuff);\r\n    this.addEventListener(Events.changedebuffstack.to(SELECTED_PLAYER), this.onChangeDebuffStack);\r\n    this.addEventListener(Events.removedebuff.to(SELECTED_PLAYER), this.onRemoveDebuff);\r\n    this.addEventListener(Events.ChangeStats.to(SELECTED_PLAYER), this.onChangeStats);\r\n  }\r\n  onApplyBuff(event) {\r\n    this._applyActiveBuff(event);\r\n  }\r\n  onChangeBuffStack(event) {\r\n    this._changeBuffStack(event);\r\n  }\r\n  onRemoveBuff(event) {\r\n    this._removeActiveBuff(event);\r\n  }\r\n  onApplyDebuff(event) {\r\n    this._applyActiveBuff(event);\r\n  }\r\n  onChangeDebuffStack(event) {\r\n    this._changeBuffStack(event);\r\n  }\r\n  onRemoveDebuff(event) {\r\n    this._removeActiveBuff(event);\r\n  }\r\n\r\n  onChangeStats(event) { // fabbed event from StatTracker\r\n    if (!event.delta.haste) {\r\n      return;\r\n    }\r\n\r\n    // Calculating the Haste percentage difference form a rating change is hard because all rating (from gear + buffs) is additive while Haste percentage buffs are both multiplicative and additive (see the applyHaste function).\r\n    // 1. Calculate the total Haste percentage without any rating (since the total percentage from the total rating multiplies like any other Haste buff)\r\n    const remainingHasteBuffs = this.constructor.removeHaste(this.current, this.statTracker.hastePercentage(event.before.haste, true));\r\n    // 2. Calculate the new total Haste percentage with the new rating and the old total buff percentage\r\n    const newHastePercentage = this.constructor.addHaste(this.statTracker.hastePercentage(event.after.haste, true), remainingHasteBuffs);\r\n\r\n    this._setHaste(event, newHastePercentage);\r\n\r\n    if (debug) {\r\n      const spellName = event.trigger.ability ? event.trigger.ability.name : 'unknown';\r\n      console.log(`Haste: Current haste: ${formatPercentage(this.current)}% (haste RATING changed by ${event.delta.haste} from ${spellName})`);\r\n    }\r\n  }\r\n\r\n  _applyActiveBuff(event) {\r\n    const spellId = event.ability.guid;\r\n    const hasteGain = this._getBaseHasteGain(spellId);\r\n\r\n    if (hasteGain) {\r\n      this._applyHasteGain(event, hasteGain);\r\n\r\n      debug && console.log(formatMilliseconds(this.owner.fightDuration), 'Haste:', 'Current haste:', `${formatPercentage(this.current)}%`, `(gained ${formatPercentage(hasteGain)}% from ${event.ability.name})`);\r\n    } else {\r\n      debug && console.warn(formatMilliseconds(this.owner.fightDuration), 'Haste: Applied not recognized buff:', event.ability.name);\r\n    }\r\n  }\r\n  _removeActiveBuff(event) {\r\n    const spellId = event.ability.guid;\r\n    const haste = this._getBaseHasteGain(spellId);\r\n\r\n    if (haste) {\r\n      this._applyHasteLoss(event, haste);\r\n\r\n      debug && console.log(`Haste: Current haste: ${formatPercentage(this.current)}% (lost ${formatPercentage(haste)}% from ${SPELLS[spellId] ? SPELLS[spellId].name : spellId})`);\r\n    } else {\r\n      debug && console.warn(formatMilliseconds(this.owner.fightDuration), 'Haste: Removed not recognized buff:', event.ability.name);\r\n    }\r\n  }\r\n  /**\r\n   * Gets the base Haste gain for the provided spell.\r\n   */\r\n  _getBaseHasteGain(spellId) {\r\n    const hasteBuff = this.constructor.HASTE_BUFFS[spellId] || undefined;\r\n\r\n    if (typeof hasteBuff === 'number') {\r\n      // A regular number is a static Haste percentage\r\n      return hasteBuff;\r\n    } else if (typeof hasteBuff === 'object') {\r\n      // An object can provide more info\r\n      if (hasteBuff.haste) {\r\n        return this._getHasteValue(hasteBuff.haste, hasteBuff);\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n\r\n  _changeBuffStack(event) {\r\n    const spellId = event.ability.guid;\r\n    const haste = this._getHastePerStackGain(spellId);\r\n\r\n    if (haste) {\r\n      // Haste stacks are additive, so at 5 stacks with 3% per you'd be at 15%, 6 stacks = 18%. This means the only right way to add a Haste stack is to reset to Haste without the old total and then add the new total Haste again.\r\n      // 1. Calculate the total Haste percentage without the buff\r\n      const baseHaste = this.constructor.removeHaste(this.current, event.oldStacks * haste);\r\n      // 2. Calculate the new total Haste percentage with the Haste from the new amount of stacks\r\n      const newHastePercentage = this.constructor.addHaste(baseHaste, event.newStacks * haste);\r\n\r\n      this._setHaste(event, newHastePercentage);\r\n\r\n      debug && console.log(`Haste: Current haste: ${formatPercentage(this.current)}% (gained ${formatPercentage(haste * event.stacksGained)}% from ${SPELLS[spellId] ? SPELLS[spellId].name : spellId})`);\r\n    }\r\n  }\r\n  _getHastePerStackGain(spellId) {\r\n    const hasteBuff = this.constructor.HASTE_BUFFS[spellId] || undefined;\r\n\r\n    if (typeof hasteBuff === 'number') {\r\n      // hasteBuff being a number is shorthand for static haste only\r\n    } else if (typeof hasteBuff === 'object') {\r\n      if (hasteBuff.hastePerStack) {\r\n        return this._getHasteValue(hasteBuff.hastePerStack, hasteBuff);\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n  /**\r\n   * Get the actual Haste value from a prop allowing various formats.\r\n   */\r\n  _getHasteValue(value, hasteBuff) {\r\n    const { itemId } = hasteBuff;\r\n    if (typeof value === 'function') {\r\n      const selectedCombatant = this.selectedCombatant;\r\n      let itemDetails;\r\n      if (itemId) {\r\n        itemDetails = selectedCombatant.getItem(itemId);\r\n        if (!itemDetails) {\r\n          console.error('Failed to retrieve item information for item with ID:', itemId);\r\n        }\r\n      }\r\n      return value(selectedCombatant, itemDetails);\r\n    }\r\n    return value;\r\n  }\r\n\r\n  _applyHasteGain(event, haste) {\r\n    this._setHaste(event, this.constructor.addHaste(this.current, haste));\r\n  }\r\n  _applyHasteLoss(event, haste) {\r\n    this._setHaste(event, this.constructor.removeHaste(this.current, haste));\r\n  }\r\n  _setHaste(event, haste) {\r\n    if (isNaN(haste)) {\r\n      throw new Error('Attempted to set an invalid Haste value. Something broke.');\r\n    }\r\n    const oldHaste = this.current;\r\n    this.current = haste;\r\n\r\n    this._triggerChangeHaste(event, oldHaste, this.current);\r\n  }\r\n  _triggerChangeHaste(event, oldHaste, newHaste) {\r\n    const fabricatedEvent = {\r\n      type: EventType.ChangeHaste,\r\n      sourceID: event ? event.sourceID : this.owner.playerId,\r\n      targetID: this.owner.playerId,\r\n      oldHaste,\r\n      newHaste,\r\n    };\r\n    debug && console.log(EventType.ChangeHaste, fabricatedEvent);\r\n    this.eventEmitter.fabricateEvent(fabricatedEvent, event);\r\n  }\r\n\r\n  static addHaste(baseHaste, hasteGain) {\r\n    return baseHaste * (1 + hasteGain) + hasteGain;\r\n  }\r\n  static removeHaste(baseHaste, hasteLoss) {\r\n    return (baseHaste - hasteLoss) / (1 + hasteLoss);\r\n  }\r\n}\r\n\r\nexport default Haste;\r\n","import SPELLS from 'common/SPELLS/index';\r\n\r\nconst BLOODLUST_BUFFS: {\r\n  [key: number]: number;\r\n} = {\r\n  [SPELLS.BLOODLUST.id]: 0.3,\r\n  [SPELLS.HEROISM.id]: 0.3, // Alliance Bloodlust\r\n  [SPELLS.TIME_WARP.id]: 0.3, // Mage\r\n  [SPELLS.PRIMAL_RAGE_1.id]: 0.3, // Hunter pet BL\r\n  [SPELLS.PRIMAL_RAGE_2.id]: 0.3, // Hunter pet BL\r\n  [SPELLS.DRUMS_OF_FURY.id]: 0.25, // Legion Leatherworking crafted\r\n  [SPELLS.DRUMS_OF_THE_MOUNTAIN.id]: 0.25, // Legion Leatherworking crafted\r\n  [SPELLS.DRUMS_OF_RAGE.id]: 0.25, // Legion Leatherworking crafted\r\n};\r\nexport default BLOODLUST_BUFFS;\r\n","import { formatMilliseconds } from 'common/format';\r\nimport Analyzer, { SELECTED_PLAYER } from 'parser/core/Analyzer';\r\nimport Events, { EventType } from 'parser/core/Events';\r\nimport EventEmitter from 'parser/core/modules/EventEmitter';\r\nimport CASTS_THAT_ARENT_CASTS from 'parser/core/CASTS_THAT_ARENT_CASTS';\r\n\r\nimport Haste from 'parser/shared/modules/Haste';\r\n\r\nimport Abilities from '../../core/modules/Abilities';\r\nimport Channeling from './Channeling';\r\n\r\nconst INVALID_GCD_CONFIG_LAG_MARGIN = 150; // not sure what this is based around, but <150 seems to catch most false positives\r\nconst MIN_GCD = 750; // Minimum GCD for most abilities is 750ms.\r\n\r\n/**\r\n * This triggers a fabricated `globalcooldown` event when appropriate.\r\n */\r\nclass GlobalCooldown extends Analyzer {\r\n  static dependencies = {\r\n    eventEmitter: EventEmitter,\r\n    abilities: Abilities,\r\n    haste: Haste,\r\n    // For the `beginchannel` event among other things\r\n    channeling: Channeling,\r\n  };\r\n\r\n  constructor(options){\r\n    super(options);\r\n    this.addEventListener(Events.cast.by(SELECTED_PLAYER), this.onCast);\r\n    this.addEventListener(Events.BeginChannel.by(SELECTED_PLAYER), this.onBeginChannel);\r\n    this.addEventListener(Events.GlobalCooldown.to(SELECTED_PLAYER), this.onGlobalcooldown);\r\n  }\r\n\r\n  _errors = 0;\r\n  get errorsPerMinute() {\r\n    const minutesElapsed = (this.owner.fightDuration / 1000) / 60;\r\n    return this._errors / minutesElapsed;\r\n  }\r\n  get isAccurate() {\r\n    return this.errorsPerMinute < 2;\r\n  }\r\n\r\n  /**\r\n   * Returns true if this ability is on the Global Cooldown, false if not.\r\n   * @param {number} spellId\r\n   * @return {boolean} Whether this ability has a GCD.\r\n   */\r\n  isOnGlobalCooldown(spellId) {\r\n    return Boolean(this.getGlobalCooldownDuration(spellId));\r\n  }\r\n\r\n  _currentChannel = null;\r\n  /**\r\n   * Listening to `beginchannel` instead of `begincast` since this also includes *channeled* abilities which don't usually trigger a `begincast` event.\r\n   * If the channel of the cast was cancelled before it was finished (in the case of cast-time abilities, not channels), the GCD event will *not* be fired since it will reset upon cancel. We have no way of knowing *when* the cancel is (regardless if it's 100ms into the channel or 1400ms), but in most cases not triggering the entire GCD is enough.\r\n   * @param event\r\n   */\r\n  onBeginChannel(event) {\r\n    this._currentChannel = event;\r\n\r\n    const spellId = event.ability.guid;\r\n    const isOnGCD = this.isOnGlobalCooldown(spellId);\r\n    // Cancelled casts reset the GCD (only for cast-time spells, \"channels\" always have a GCD but they also can't be *cancelled*, just ended early)\r\n    const isCancelled = event.trigger.isCancelled;\r\n    if (isOnGCD && !isCancelled) {\r\n      event.globalCooldown = this.triggerGlobalCooldown(event);\r\n    }\r\n  }\r\n  /**\r\n   * `cast` events only trigger a GCD if the spell is instant and doesn't have a channeling/casting time.\r\n   * @param event\r\n   */\r\n  onCast(event) {\r\n    const spellId = event.ability.guid;\r\n    const isOnGCD = this.isOnGlobalCooldown(spellId);\r\n    if (!isOnGCD) {\r\n      // This ensures we don't crash when boss abilities are registered as casts which could even happen while channeling. For example on Trilliax: http://i.imgur.com/7QAFy1q.png\r\n      return;\r\n    }\r\n    if (CASTS_THAT_ARENT_CASTS.includes(spellId)) {\r\n      // If it gets registered as a cast, but it's really not an actual cast (See Frenzy being \"cast\" when a BM Hunter casts Barbed Shot this simply returns so we don't trigger a GCD.\r\n      return;\r\n    }\r\n    // We can't rely on `this.channeling` here since it will have been executed first so will already have marked the channel as ended. This is annoying since it will be more reliable and work with changes.\r\n    const isChanneling = Boolean(this._currentChannel);\r\n    const isChannelingSameSpell = isChanneling && this._currentChannel.ability.guid === event.ability.guid;\r\n\r\n    // Reset the current channel prior to returning if `isChannelingSameSpell`, since the player might cast the same ability again and the second `cast` event might be an instant (e.g. channeled Aimed Shot into proc into instant Aimed Shot).\r\n    this._currentChannel = null;\r\n\r\n    if (isChannelingSameSpell) {\r\n      // The GCD occured already at the start of this channel\r\n      return;\r\n    }\r\n    event.globalCooldown = this.triggerGlobalCooldown(event);\r\n  }\r\n\r\n  /**\r\n   * Trigger a `globalcooldown`-event at this timestamp for the `ability` in the provided event.\r\n   * @param event\r\n   */\r\n  triggerGlobalCooldown(event) {\r\n    return this.eventEmitter.fabricateEvent({\r\n      type: EventType.GlobalCooldown,\r\n      ability: event.ability,\r\n      sourceID: event.sourceID,\r\n      targetID: event.sourceID, // no guarantees the original targetID is the player\r\n      timestamp: event.timestamp,\r\n      duration: this.getGlobalCooldownDuration(event.ability.guid),\r\n    }, event);\r\n  }\r\n\r\n  /**\r\n   * Returns the current Global Cooldown duration in milliseconds for the specified spell (some spells have custom GCDs).\r\n   * Typically you should first use isOnGlobalCooldown to check if the spell is on the GCD at all. This function gives\r\n   * a default GCD value if there's no GCD defined for the given spellId.\r\n   * @param {number} spellId\r\n   * @returns {number} The duration in milliseconds.\r\n   */\r\n  getGlobalCooldownDuration(spellId) {\r\n    const ability = this.abilities.getAbility(spellId);\r\n    if (!ability) {\r\n      // Most abilities we don't know (e.g. aren't in the spellbook) also aren't on the GCD\r\n      return 0;\r\n    }\r\n    const gcd = this._resolveAbilityGcdField(ability.gcd);\r\n    if (!gcd) {\r\n      // If gcd isn't set, null, or 0 (falsey), the spell isn't on the GCD. ps. you should set gcd to null to be explicit.\r\n      return 0;\r\n    }\r\n    if (gcd.static !== undefined) {\r\n      return this._resolveAbilityGcdField(gcd.static);\r\n    }\r\n    if (gcd.base) {\r\n      const baseGCD = this._resolveAbilityGcdField(gcd.base);\r\n      const minimumGCD = this._resolveAbilityGcdField(gcd.minimum) || MIN_GCD;\r\n      return this.constructor.calculateGlobalCooldown(this.haste.current, baseGCD, minimumGCD);\r\n    }\r\n    throw new Error(`Ability ${ability.name} (spellId: ${spellId}) defines a GCD property but provides neither a base nor static value.`);\r\n  }\r\n  _resolveAbilityGcdField(value) {\r\n    if (typeof value === 'function') {\r\n      return value.call(this.owner, this.selectedCombatant);\r\n    } else {\r\n      return value;\r\n    }\r\n  }\r\n\r\n  /** @type {object} The last GCD event that occured, can be used to check if the player is affected by the GCD. */\r\n  lastGlobalCooldown = null;\r\n  onGlobalcooldown(event) {\r\n    this._verifyAccuracy(event);\r\n  }\r\n  _verifyAccuracy(event) {\r\n    if (this.lastGlobalCooldown) {\r\n      const timeSince = event.timestamp - this.lastGlobalCooldown.timestamp;\r\n      const remainingDuration = this.lastGlobalCooldown.duration - timeSince;\r\n      if (remainingDuration > INVALID_GCD_CONFIG_LAG_MARGIN) {\r\n        this._errors += 1;\r\n        console.error(\r\n          formatMilliseconds(this.owner.fightDuration),\r\n          'GlobalCooldown',\r\n          event.trigger.ability.name, event.trigger.ability.guid,\r\n          `was cast while the Global Cooldown from`,\r\n          this.lastGlobalCooldown.ability.name, this.lastGlobalCooldown.ability.guid,\r\n          `was already running. There's probably a Haste buff missing from StatTracker or the Haste module, this spell has a GCD different from the default, or the base GCD for this spec is different from default.`,\r\n          'time passed:', timeSince,\r\n          'cooldown remaining:', remainingDuration,\r\n          'expectedDuration:', this.lastGlobalCooldown.duration,\r\n          'errors:', this._errors,\r\n        );\r\n      }\r\n    }\r\n    this.lastGlobalCooldown = event;\r\n  }\r\n\r\n  /**\r\n   * Calculates the GCD based on the current Haste, taking into account the minimum possible GCD.\r\n   * @param haste\r\n   * @param baseGcd\r\n   * @param minGcd\r\n   * @returns {number}\r\n   */\r\n  static calculateGlobalCooldown(haste, baseGcd = 1500, minGcd = 750) {\r\n    const gcd = baseGcd / (1 + haste);\r\n    // Global cooldowns can't normally drop below a certain threshold\r\n    return Math.max(minGcd, gcd);\r\n  }\r\n}\r\n\r\nexport default GlobalCooldown;\r\n","import React from 'react';\r\nimport PropTypes from 'prop-types';\r\n\r\nimport InterfacePanel from 'interface/others/Panel';\r\nimport STATISTIC_CATEGORY from 'interface/others/STATISTIC_CATEGORY';\r\nimport ErrorBoundary from 'interface/common/ErrorBoundary';\r\n\r\nconst Panel = ({ category = STATISTIC_CATEGORY.PANELS, position, ...others }) => (\r\n  <ErrorBoundary>\r\n    <InterfacePanel\r\n      {...others}\r\n    />\r\n  </ErrorBoundary>\r\n);\r\nPanel.propTypes = {\r\n  children: PropTypes.node.isRequired,\r\n  // eslint-disable-next-line react/no-unused-prop-types\r\n  category: PropTypes.oneOf(Object.values(STATISTIC_CATEGORY)),\r\n  // eslint-disable-next-line react/no-unused-prop-types\r\n  position: PropTypes.number,\r\n};\r\nPanel.defaultProps = {\r\n  category: STATISTIC_CATEGORY.PANELS,\r\n};\r\n\r\nexport default Panel;\r\n","import Analyzer, { SELECTED_PLAYER } from 'parser/core/Analyzer';\r\nimport EventEmitter from 'parser/core/modules/EventEmitter';\r\nimport CASTS_THAT_ARENT_CASTS from 'parser/core/CASTS_THAT_ARENT_CASTS';\r\nimport Events, { EventType } from 'parser/core/Events';\r\n\r\nconst debug = false;\r\n\r\n// TODO: KILL THIS MODULE. It hasn't hold well with time, and it should probably be replaced with a normalizer. This normalizer could remove invalid `cast` events and maybe even go so far as to remove the `begincast` event entirely in favor of our own system to be easier to work with. This module also duplicates some logic from the CancelledCasts normalizer.\r\n\r\nclass Channeling extends Analyzer {\r\n  static dependencies = {\r\n    eventEmitter: EventEmitter,\r\n  };\r\n  _currentChannel = null;\r\n\r\n  constructor(options) {\r\n    super(options);\r\n    this.addEventListener(Events.begincast.by(SELECTED_PLAYER), this.onBegincast);\r\n    this.addEventListener(Events.cast.by(SELECTED_PLAYER), this.onCast);\r\n  }\r\n\r\n  beginChannel(event, ability = event.ability) {\r\n    if (this.isChanneling()) {\r\n      // There are no specific events for channel cancels, the only indicator of this are when one starts channeling something else. Whenever we're still channeling and a new channel starts, we need to mark the old channel as canceled.\r\n      this.cancelChannel(event, this._currentChannel.ability);\r\n    }\r\n\r\n    const channelingEvent = {\r\n      type: EventType.BeginChannel,\r\n      timestamp: event.timestamp,\r\n      ability,\r\n      sourceID: event.sourceID,\r\n      isCancelled: event.isCancelled,\r\n    };\r\n    event.channel = channelingEvent;\r\n    this._currentChannel = channelingEvent;\r\n    debug && this.log('Beginning channel of', ability.name);\r\n    this.eventEmitter.fabricateEvent(channelingEvent, event);\r\n  }\r\n\r\n  endChannel(event) {\r\n    const currentChannel = this._currentChannel;\r\n    const start = currentChannel ? currentChannel.timestamp : this.owner.fight.start_time;\r\n    if (!this.isChanneling()) {\r\n      this.warn(event.ability.name, '`endChannel` was called while we weren\\'t channeling, assuming it was a pre-combat channel.');\r\n    }\r\n\r\n    const duration = event.timestamp - start;\r\n    this._currentChannel = null;\r\n    // Since `event` may not always be the spell being ended we default to the start of the casting since that must be the right spell\r\n    const ability = currentChannel ? currentChannel.ability : event.ability;\r\n    debug && this.log('Ending channel of', ability.name);\r\n    return this.eventEmitter.fabricateEvent({\r\n      type: EventType.EndChannel,\r\n      timestamp: event.timestamp,\r\n      ability,\r\n      sourceID: event.sourceID,\r\n      duration: duration,\r\n      start,\r\n      beginChannel: currentChannel,\r\n    }, event); // the trigger may be another spell, sometimes the indicator of 1 channel ending is the start of another\r\n  }\r\n\r\n  cancelChannel(event, ability) {\r\n    this.eventEmitter.fabricateEvent({\r\n      type: EventType.CancelChannel,\r\n      ability,\r\n      sourceID: event.sourceID,\r\n      timestamp: null, // unknown, we can only know when the next cast started so passing the timestamp would be a poor guess\r\n    }, event);\r\n    debug && this.warn('Canceled channel of', ability.name);\r\n  }\r\n\r\n  onBegincast(event) {\r\n    this.beginChannel(event);\r\n  }\r\n\r\n  onCast(event) {\r\n    if (CASTS_THAT_ARENT_CASTS.includes(event.ability.guid)) {\r\n      // Some things such as boss mechanics are marked as cast-events even though they're usually just \"ticks\". This can even occur while channeling. We need to ignore them or it will throw off this module.\r\n      return;\r\n    }\r\n\r\n    // TODO: Account for pre-pull `begincast`\r\n    const isChanneling = Boolean(this._currentChannel);\r\n    if (!isChanneling) {\r\n      return;\r\n    }\r\n    if (!this.isChannelingSpell(event.ability.guid)) {\r\n      this.cancelChannel(event, this._currentChannel.ability);\r\n    } else {\r\n      // Add info to the cast-event related to this channel so it can be used easily\r\n      event.channel = this.endChannel(event);\r\n    }\r\n  }\r\n\r\n  isChanneling() {\r\n    return Boolean(this._currentChannel);\r\n  }\r\n\r\n  isChannelingSpell(spellId) {\r\n    return this._currentChannel && this._currentChannel.ability.guid === spellId;\r\n  }\r\n\r\n  // TODO: Re-implement below\r\n  /**\r\n   * Can be used to determine the accuracy of the Haste tracking. This does not work properly on abilities that can get reduced channel times from other effects such as talents or traits.\r\n   */\r\n  // _verifyChannel(spellId, defaultCastTime, begincast, cast) {\r\n  //   if (cast.ability.guid === spellId) {\r\n  //     if (!begincast) {\r\n  //       console.error('Missing begin cast for channeled ability:', cast);\r\n  //       return;\r\n  //     }\r\n  //\r\n  //     const actualCastTime = cast.timestamp - begincast.timestamp;\r\n  //     const expectedCastTime = Math.round(defaultCastTime / (1 + this.haste.current));\r\n  //     if (!this.constructor.inRange(actualCastTime, expectedCastTime, 50)) { // cast times seem to fluctuate by 50ms, not sure if it depends on player latency, in that case it could be a lot more flexible\r\n  //       console.warn(`ABC: ${SPELLS[spellId].name} channel: Expected actual ${actualCastTime}ms to be expected ${expectedCastTime}ms ± 50ms @ ${formatMilliseconds(cast.timestamp - this.owner.fight.start_time)}`, this.selectedCombatant.activeBuffs());\r\n  //     }\r\n  //   }\r\n  // }\r\n}\r\n\r\nexport default Channeling;\r\n","import SPELLS from 'common/SPELLS';\r\nimport RACES from 'game/RACES';\r\nimport Analyzer, { Options } from 'parser/core/Analyzer';\r\nimport Abilities from 'parser/core/modules/Abilities';\r\n\r\nclass ArcaneTorrent extends Analyzer {\r\n  static dependencies = {\r\n    abilities: Abilities,\r\n  };\r\n\r\n  gcd = 1500;\r\n  castEfficiency = 0.8;\r\n  extraSuggestion = null;\r\n\r\n  constructor(\r\n    options: Options & {\r\n      gcd?: number;\r\n      castEfficiency?: number;\r\n      abilities: Abilities\r\n    },\r\n  ) {\r\n    super(options);\r\n    this.active = this.selectedCombatant.race === RACES.BloodElf;\r\n    if (!this.active) {\r\n      return;\r\n    }\r\n\r\n    this.gcd = options.gcd === undefined ? this.gcd : options.gcd;\r\n    this.castEfficiency =\r\n      options.castEfficiency === undefined ? this.castEfficiency : options.castEfficiency;\r\n\r\n    options.abilities.add({\r\n      spell: [\r\n        SPELLS.ARCANE_TORRENT_MANA1,\r\n        SPELLS.ARCANE_TORRENT_MANA2,\r\n        SPELLS.ARCANE_TORRENT_MANA3,\r\n        SPELLS.ARCANE_TORRENT_RAGE,\r\n        SPELLS.ARCANE_TORRENT_ENERGY,\r\n        SPELLS.ARCANE_TORRENT_RUNIC_POWER,\r\n        SPELLS.ARCANE_TORRENT_MONK,\r\n        SPELLS.ARCANE_TORRENT_FOCUS,\r\n        SPELLS.ARCANE_TORRENT_FURY,\r\n      ],\r\n      category: Abilities.SPELL_CATEGORIES.COOLDOWNS,\r\n      cooldown: 120,\r\n      gcd: {\r\n        base: this.gcd,\r\n      },\r\n      timelineSortIndex: 35,\r\n      castEfficiency: {\r\n        suggestion: this.castEfficiency !== null,\r\n        recommendedEfficiency: this.castEfficiency,\r\n        extraSuggestion: this.extraSuggestion,\r\n      },\r\n    });\r\n  }\r\n}\r\n\r\nexport default ArcaneTorrent;\r\n","import Analyzer, { SELECTED_PLAYER } from 'parser/core/Analyzer';\r\nimport RESOURCE_TYPES from 'game/RESOURCE_TYPES';\r\nimport { formatPercentage, formatNumber } from 'common/format';\r\nimport ROLES from 'game/ROLES';\r\nimport PropTypes from 'prop-types';\r\nimport { i18n } from '@lingui/core';\r\nimport { t } from '@lingui/macro';\r\nimport Events from 'parser/core/Events';\r\n\r\nimport React from 'react';\r\nimport { Trans } from '@lingui/macro';\r\n\r\nclass ManaValues extends Analyzer {\r\n  static propTypes = {\r\n    owner: PropTypes.object.isRequired,\r\n  };\r\n\r\n  lowestMana = null; // start at `null` and fill it with the first value to account for users starting at a non-default amount for whatever reason\r\n  endingMana = 0;\r\n\r\n  maxMana = 50000;\r\n  manaUpdates = [];\r\n\r\n  constructor(...args) {\r\n    super(...args);\r\n    this.addEventListener(Events.cast.by(SELECTED_PLAYER), this.onCast);\r\n    this.active = this.selectedCombatant.spec.role === ROLES.HEALER;\r\n  }\r\n\r\n  onCast(event) {\r\n    if (event.prepull) {\r\n      // These are fabricated by the PrePullCooldowns normalizer which guesses class resources which could introduce issues.\r\n      return;\r\n    }\r\n    if (event.classResources) {\r\n      event.classResources\r\n        .filter(resource => resource.type === RESOURCE_TYPES.MANA.id)\r\n        .forEach(({ amount, cost, max }) => {\r\n          const manaValue = amount;\r\n          const manaCost = cost || 0;\r\n          const currentMana = manaValue - manaCost;\r\n          this.endingMana = currentMana;\r\n\r\n          if (this.lowestMana === null || currentMana < this.lowestMana) {\r\n            this.lowestMana = currentMana;\r\n          }\r\n          this.manaUpdates.push({\r\n            timestamp: event.timestamp,\r\n            current: currentMana,\r\n            max: max,\r\n            used: manaCost,\r\n          });\r\n          // The variable 'max' is constant but can differentiate by racial/items.\r\n          this.maxMana = max;\r\n        });\r\n    }\r\n  }\r\n\r\n  get manaLeftPercentage() {\r\n    return this.endingMana/this.maxMana;\r\n  }\r\n  get suggestionThresholds() {\r\n    return {\r\n      actual: this.manaLeftPercentage,\r\n      isGreaterThan: {\r\n        minor: 0.1,\r\n        average: 0.2,\r\n        major: 0.3,\r\n      },\r\n      style: 'percentage',\r\n    };\r\n  }\r\n  suggestions(when) {\r\n    const fight = this.owner.fight;\r\n    const isWipe = !fight.kill;\r\n    if (isWipe) {\r\n      return;\r\n    }\r\n\r\n    when(this.suggestionThresholds.actual).isGreaterThan(this.suggestionThresholds.isGreaterThan.minor)\r\n      .addSuggestion((suggest, actual, recommended) => suggest(<Trans id=\"shared.manaValues.suggestions.label\">You had mana left at the end of the fight. A good rule of thumb is having the same mana percentage as the bosses health percentage. Mana is indirectly tied with healing throughput and should be optimized.</Trans>)\r\n          .icon('inv_elemental_mote_mana')\r\n          .actual(`${formatPercentage(actual)}% (${formatNumber(this.endingMana)}) ${i18n._(t('shared.suggestions.mana.efficiency')`mana left`)}`)\r\n          .recommended(`<${formatPercentage(recommended)}% is recommended`)\r\n          .regular(this.suggestionThresholds.isGreaterThan.average)\r\n          .major(this.suggestionThresholds.isGreaterThan.major));\r\n  }\r\n}\r\n\r\nexport default ManaValues;\r\n","class HealingValue {\r\n  _regular = 0;\r\n  /** Do not use this without really good reason! `effective` is almost always better; we WANT to include absorbed healing as this is most commonly related to mechanics that need to be removed and therefore significant. */\r\n  get regular() { return this._regular; }\r\n  _absorbed = 0;\r\n  get absorbed() { return this._absorbed; }\r\n  get effective() {\r\n    // `absorbed` is usually a negative debuff you need to remove as part of game mechanics. We should include this as to not punish for doing mechanics.\r\n    return this.regular + this.absorbed;\r\n  }\r\n  _overheal = 0;\r\n  get overheal() { return this._overheal; }\r\n  get raw() {\r\n    return this.effective + this.overheal;\r\n  }\r\n\r\n  constructor(regular = 0, absorbed = 0, overheal = 0) {\r\n    this._regular = regular;\r\n    this._absorbed = absorbed;\r\n    this._overheal = overheal;\r\n  }\r\n\r\n  add(regular = 0, absorbed = 0, overheal = 0) {\r\n    return new this.constructor(this.regular + regular, this.absorbed + absorbed, this.overheal + overheal);\r\n  }\r\n  // TODO: reduceDamage (e.g. LotM self-damage)\r\n}\r\n\r\nexport default HealingValue;\r\n","const MAGIC_SCHOOLS: { \r\n  names: { [id: number]: string }, \r\n  ids: { [name: string]: number } \r\n} = {\r\n  names: {\r\n    1: 'Physical',\r\n    2: 'Holy',\r\n    4: 'Fire',\r\n    8: 'Nature',\r\n    16: 'Frost',\r\n    28: 'Elemental',\r\n    32: 'Shadow',\r\n    33: 'Shadowstrike',\r\n    34: 'Twilight',\r\n    36: 'Shadowflame',\r\n    40: 'Plague',\r\n    48: 'Shadowfrost',\r\n    64: 'Arcane',\r\n    96: 'Spellshadow',\r\n    100: 'Special',\r\n    124: 'Chaos',\r\n  },\r\n  // Multi-school spells are OR'ed together using these base schools\r\n  ids: {\r\n    PHYSICAL: 1,\r\n    HOLY: 2,\r\n    FIRE: 4,\r\n    NATURE: 8,\r\n    FROST: 16,\r\n    SHADOW: 32,\r\n    ARCANE: 64,\r\n  },\r\n};\r\n\r\nexport default MAGIC_SCHOOLS;\r\n","import Module from 'parser/core/Module';\r\nimport { AnyEvent, EventType, MappedEvent } from 'parser/core/Events';\r\nimport EventFilter from 'parser/core/EventFilter';\r\nimport EventEmitter from 'parser/core/modules/EventEmitter';\r\n\r\nclass EventHistory extends Module {\r\n\r\n  /**\r\n   * @param count the maximum number of events to return, or null for no limit\r\n   * @param maxTime the maximum number of milliseconds to look back, or null for no limit\r\n   * @param filterDef an optional EventFilter to apply to all events\r\n   * @returns the last `count` events that match the given filters, with the oldest events first\r\n   */\r\n  public last<ET extends EventType, E extends MappedEvent<ET>>(count?: number, maxTime?: number, filterDef?: EventFilter<ET>): E[] {\r\n    let filter = (event: AnyEvent) => true;\r\n\r\n    if (maxTime) {\r\n      const minTime = this.owner.currentTimestamp - maxTime;\r\n      const prevFilter = filter;\r\n      filter = (event) => {\r\n        if (!event.timestamp || event.timestamp < minTime) {\r\n          return false;\r\n        }\r\n        return prevFilter(event);\r\n      };\r\n    }\r\n\r\n    if (filterDef) {\r\n      const ee: EventEmitter = this.owner.getModule(EventEmitter);\r\n      const prevFilter = filter;\r\n      filter = event => {\r\n        if (event.type !== filterDef.eventType) {\r\n          return false;\r\n        }\r\n        return prevFilter(event);\r\n      };\r\n      const filterTo = filterDef.getTo();\r\n      if (filterTo) {\r\n        const prevFilter = filter;\r\n        const toFilter = ee.createToCheck(filterTo);\r\n        if (toFilter) {\r\n          filter = event => {\r\n            if (!toFilter(event)) {\r\n              return false;\r\n            }\r\n            return prevFilter(event);\r\n          };\r\n        }\r\n      }\r\n      const filterBy = filterDef.getBy();\r\n      if (filterBy) {\r\n        const prevFilter = filter;\r\n        const byFilter = ee.createByCheck(filterBy);\r\n        if (byFilter) {\r\n          filter = event => {\r\n            if (!byFilter(event)) {\r\n              return false;\r\n            }\r\n            return prevFilter(event);\r\n          };\r\n        }\r\n      }\r\n      const filterSpell = filterDef.getSpell();\r\n      if (filterSpell) {\r\n        const prevFilter = filter;\r\n        const spellFilter = ee.createSpellCheck(filterSpell);\r\n        filter = event => {\r\n          if (!spellFilter(event)) {\r\n            return false;\r\n          }\r\n          return prevFilter(event);\r\n        };\r\n      }\r\n    }\r\n\r\n    let history = this.owner.eventHistory.filter(event => filter(event));\r\n    if (count && count < history.length) {\r\n      history = history.slice(-count);\r\n    }\r\n    return history as E[];\r\n  }\r\n\r\n}\r\n\r\nexport default EventHistory;\r\n","import Analyzer from 'parser/core/Analyzer';\r\n\r\nclass CritEffectBonus extends Analyzer {\r\n  static BASE_CRIT_EFFECT_MOD = 2;\r\n\r\n  _hooks = [];\r\n  hook(func) {\r\n    this._hooks.push(func);\r\n  }\r\n\r\n  getBonus(event) {\r\n    return this._hooks.reduce((critEffectModifier, hook) => hook(critEffectModifier, event), this.constructor.BASE_CRIT_EFFECT_MOD);\r\n  }\r\n}\r\n\r\nexport default CritEffectBonus;\r\n","import RESOURCE_TYPES from 'game/RESOURCE_TYPES';\r\nimport Analyzer, { SELECTED_PLAYER } from 'parser/core/Analyzer';\r\nimport Events from 'parser/core/Events';\r\n\r\n/**\r\n * This analyzer adds the cost of a specific resource type to cast events, and allows that cost to\r\n * be adjusted from what's given in the combat log. Typically the combat log doesn't apply resource\r\n * cost reductions so we need to check for conditions and apply it ourselves. Using SpellResourceCost\r\n * allows you to apply that reduction just once and have the information available wherever the cast\r\n * event gets processed.\r\n *\r\n * If you're dealing with mana you should use parser/core/Modules/SpellManaCost instead.\r\n *\r\n * An example implementation can be found at parser/Druid/Feral/Modules/Features/SpellEnergyCost\r\n * Check the \"IMPLEMENTME\" comments for what typically needs to be customised.\r\n */\r\nclass SpellResourceCost extends Analyzer {\r\n  // IMPLEMENTME set to one of game/RESOURCE_TYPES\r\n  static resourceType = null;\r\n\r\n  constructor(...args) {\r\n    super(...args);\r\n    if (!this.constructor.resourceType || !RESOURCE_TYPES[this.constructor.resourceType.id]) {\r\n      throw new Error('Attempting to use SpellResourceCost without providing a valid resourceType.');\r\n    }\r\n    this.addEventListener(Events.cast.by(SELECTED_PLAYER), this.onCast);\r\n  }\r\n\r\n  onCast(event) {\r\n    if (!event.resourceCost) {\r\n      event.resourceCost = {};\r\n    }\r\n    event.resourceCost[this.constructor.resourceType.id] = this.getResourceCost(event);\r\n\r\n    if (!event.rawResourceCost) {\r\n      event.rawResourceCost = {};\r\n    }\r\n    event.rawResourceCost[this.constructor.resourceType.id] = this.getRawResourceCost(event);\r\n  }\r\n\r\n  getCostFromEventObject(event) {\r\n    if (!event.classResources) {\r\n      return 0;\r\n    }\r\n    return event.classResources\r\n      .filter(resource => resource.type === this.constructor.resourceType.id)\r\n      .reduce((totalCost, resource) => totalCost + (resource.cost || 0), 0);\r\n  }\r\n\r\n  /**\r\n   * IMPLEMENTME\r\n   * \"Raw\" resource cost is how much the spell costs before any savings are applied. Typically it'll\r\n   * be equal to the cost given in the spell's tooltip.\r\n   * The majority of resource types don't need anything to be set up here as the log values can be used.\r\n   * If the cast event in the combat log doesn't provide the raw resource cost, you can add it.\r\n   * If the cost is provided in a modified state (e.g. 10x the actual value) you can correct that.\r\n   * @param {object} event cast event which consumes resources\r\n   */\r\n  getRawResourceCost(event) {\r\n    return this.getCostFromEventObject(event);\r\n  }\r\n\r\n  /**\r\n   * IMPLEMENTME\r\n   * Apply any resource cost adjustments here.\r\n   * @param {object} event cast event which consumes resources\r\n   */\r\n  getResourceCost(event) {\r\n    return this.getRawResourceCost(event);\r\n  }\r\n}\r\n\r\nexport default SpellResourceCost;\r\n","import SPELLS from 'common/SPELLS';\r\n\r\nconst spells: number[] = [\r\n  /**\r\n   * This can consist of boss mechanics marked as casts, buff applications marked\r\n   * as separate casts from the normal ability, toy casts that some people macro\r\n   * into their abilities and so forth\r\n   */\r\n  SPELLS.MELEE.id, // Auto attack\r\n  SPELLS.CHI_BURST_HEAL.id, // this is the \"tick\" when you hit a player, the actual cast has a different id\r\n  SPELLS.REFRESHING_JADE_WIND_HEAL.id, // this is the \"tick\" when you hit a player, the actual cast has a different id\r\n  SPELLS.SHADOWY_APPARITION.id,\r\n  SPELLS.SHADOWY_APPARITION_CAST.id, // Shadow priest shadow apparitions passive\r\n  SPELLS.PRIMAL_FURY.id, // Feral Druid \"extra CP on crit\" proc causes a cast event\r\n  SPELLS.BLOW_DARKMOON_WHISTLE.id, //Darkmoon Whistle active that some people macro into abilities\r\n  SPELLS.DARKMOON_FIREWORK.id, //Darkmoon Firework toy\r\n  SPELLS.BIG_RED_RAYS.id, //Big Red Raygun active effect\r\n  SPELLS.FRACTURE_MAIN_HAND.id, // Fracture main hand damage ability\r\n  SPELLS.FRACTURE_OFF_HAND.id, // Fracture off hand damage ability\r\n  SPELLS.SOUL_FRAGMENT_KILLING_BLOW.id, // Soul Fragment that are sometimes generated by killing blows (it does not affect much of a rotation, because it's usually ~1:200, comparing to usual soul fragment generation)\r\n  SPELLS.MUTILATE_OFFHAND.id, // Mutilate off hand\r\n  SPELLS.DIVINE_HYMN_HEAL.id, //The heal component of divine hymn\r\n  SPELLS.CHARGE_2.id, // The damage component of charge\r\n  SPELLS.CLOUDBURST_TOTEM_RECALL.id, // Cloudburst reactivation\r\n  SPELLS.SPIRITWALKERS_GRACE.id,\r\n\r\n  //region Enchants\r\n  SPELLS.CELESTIAL_GUIDANCE_CAST.id, //Celestial Guidance enchant proc\r\n\r\n  //endregion\r\n\r\n  //region Consumables\r\n  SPELLS.SHADOWCORE_OIL_BLAST.id,\r\n  //endregion\r\n\r\n  //region Enchants\r\n  SPELLS.SINFUL_REVELATION_PROC.id,\r\n\r\n  //region Death Knight\r\n  SPELLS.BREATH_OF_SINDRAGOSA_TALENT_DAMAGE_TICK.id,\r\n  SPELLS.RUNE_1.id,\r\n  SPELLS.RUNE_2.id,\r\n  SPELLS.RUNE_3.id,\r\n  //endregion\r\n\r\n  //region Hunter\r\n  SPELLS.BARBED_SHOT_PET_BUFF.id, //The buff applied to BM Hunter pet when casting Barbed Shot\r\n  SPELLS.DIRE_BEAST_SUMMON.id, //A secondary cast event from Dire Beast talent\r\n  SPELLS.WILD_MARK.id, //The debuff applied from enemies inside Wild Spirits\r\n  SPELLS.RESONATING_ARROW_DEBUFF.id, //The debuff applied to mobs inside Kyrian hunter ability resonating arrow area of effect\r\n  SPELLS.RESONATING_ARROW_DAMAGE.id, //The damage event from the Kyrian Hunter Ability also has a cast event tied to it which we shouldn't track\r\n  //endregion\r\n\r\n  //region Mage\r\n  SPELLS.RUNE_OF_POWER_BUFF.id,\r\n\r\n  //region Covenants\r\n  SPELLS.COMBAT_MEDITATION_TRIGGER.id, //The Spell ID when Combat Meditation from Kyrian Soulbind triggers, so that there is now a soul ready to pick up\r\n  SPELLS.COMBAT_MEDITATION_PICK_UP.id, //The Spell ID that is \"cast\" when an orb is picked up\r\n  //endregion\r\n];\r\n\r\nexport default spells;\r\n","import React from 'react';\r\nimport { AutoSizer } from 'react-virtualized';\r\n\r\nimport { formatThousands, formatPercentage } from 'common/format';\r\nimport rankingColor from 'common/getRankingColor';\r\nimport makeWclUrl from 'common/makeWclUrl';\r\nimport StatisticBar from 'interface/statistics/StatisticBar';\r\nimport ThroughputPerformance, { UNAVAILABLE } from 'interface/report/Results/ThroughputPerformance';\r\nimport STATISTIC_ORDER from 'interface/others/STATISTIC_ORDER';\r\nimport Analyzer, { Options, SELECTED_PLAYER, SELECTED_PLAYER_PET } from 'parser/core/Analyzer';\r\nimport Tooltip from 'common/Tooltip';\r\nimport FlushLineChart from 'interface/others/FlushLineChart';\r\nimport Events, { DamageEvent } from 'parser/core/Events';\r\n\r\nimport DamageValue from '../DamageValue';\r\n\r\nclass DamageDone extends Analyzer {\r\n  constructor(options: Options) {\r\n    super(options);\r\n\r\n    this.addEventListener(Events.damage.by(SELECTED_PLAYER), this.onByPlayerDamage);\r\n    this.addEventListener(Events.damage.by(SELECTED_PLAYER_PET), this.onByPlayerPetDamage);\r\n  }\r\n\r\n  _total = new DamageValue();\r\n  get total() {\r\n    return this._total;\r\n  }\r\n  _byPet: { [petId: number]: DamageValue } = {};\r\n  byPet(petId: number) {\r\n    if (!this._byPet[petId]) {\r\n      return new DamageValue();\r\n    }\r\n    return this._byPet[petId];\r\n  }\r\n  get totalByPets() {\r\n    return Object.keys(this._byPet)\r\n      .map(petId => this._byPet[parseInt(petId)])\r\n      .reduce((total, damageValue) => total.add(damageValue.regular, damageValue.absorbed, damageValue.blocked, damageValue.overkill), new DamageValue());\r\n  }\r\n\r\n  bySecond: { [secondsIntoFight: number]: DamageValue } = {};\r\n\r\n  onByPlayerDamage(event: DamageEvent) {\r\n    if (!event.targetIsFriendly) {\r\n      this._total = this._total.add(event.amount, event.absorbed, event.blocked, event.overkill);\r\n\r\n      const secondsIntoFight = Math.floor((event.timestamp - this.owner.fight.start_time) / 1000);\r\n      this.bySecond[secondsIntoFight] = (this.bySecond[secondsIntoFight] || new DamageValue()).add(event.amount, event.absorbed, event.blocked, event.overkill);\r\n    }\r\n  }\r\n  onByPlayerPetDamage(event: DamageEvent) {\r\n    if (!event.targetIsFriendly) {\r\n      this._total = this._total.add(event.amount, event.absorbed, event.blocked, event.overkill);\r\n      const petId = event.sourceID;\r\n      if (petId) {\r\n        this._byPet[petId] = this.byPet(petId).add(event.amount, event.absorbed, event.blocked, event.overkill);\r\n      }\r\n    }\r\n  }\r\n\r\n  showStatistic = true;\r\n  subStatistic() { // rendered by ThroughputStatisticGroup\r\n    if (!this.showStatistic) {\r\n      return null;\r\n    }\r\n\r\n    const data = Object.entries(this.bySecond).map(([sec, val]) => ({ 'time': sec, 'val': val.effective }));\r\n\r\n    const perSecond = this.total.effective / this.owner.fightDuration * 1000;\r\n    const wclUrl = makeWclUrl(this.owner.report.code, {\r\n      fight: this.owner.fightId,\r\n      source: this.owner.playerId,\r\n      type: 'damage-done',\r\n    });\r\n\r\n    return (\r\n      <StatisticBar\r\n        position={STATISTIC_ORDER.CORE(1)}\r\n        ultrawide\r\n        large={false}\r\n        wide={false}\r\n        style={{ marginBottom: 20, overflow: 'hidden' }} // since this is in a group, reducing margin should be fine\r\n      >\r\n        <div className=\"flex\">\r\n          <div className=\"flex-sub icon\">\r\n            <img\r\n              src=\"/img/sword.png\"\r\n              alt=\"Damage\"\r\n            />\r\n          </div>\r\n          <Tooltip content={<>Total damage done: <strong>{formatThousands(this.total.effective)}</strong></>}>\r\n            <div\r\n              className=\"flex-sub value\"\r\n              style={{ width: 190 }}\r\n            >\r\n              {formatThousands(perSecond)} DPS\r\n            </div>\r\n          </Tooltip>\r\n          <div className=\"flex-sub\" style={{ width: 110, textAlign: 'center', padding: '10px 5px' }}>\r\n            <ThroughputPerformance throughput={perSecond} metric=\"dps\">\r\n              {({ performance, topThroughput }) => performance && performance !== UNAVAILABLE && (\r\n                <Tooltip\r\n                  content={(\r\n                    <>\r\n                      Your DPS compared to the DPS of a top 100 player. To become a top 100 <span className={this.selectedCombatant.spec.className.replace(' ', '')}>{this.selectedCombatant.spec.specName} {this.selectedCombatant.spec.className}</span> on this fight you need to do at least <strong>{formatThousands(topThroughput || 0)} DPS</strong>.\r\n                    </>\r\n                  )}\r\n                >\r\n                  <div\r\n                    className={rankingColor(performance)}\r\n                    style={{ cursor: 'help' }}\r\n                  >\r\n                    {performance >= 1 ? 'TOP 100' : `${formatPercentage(performance, 0)}%`}\r\n                  </div>\r\n                </Tooltip>\r\n              )}\r\n            </ThroughputPerformance>\r\n          </div>\r\n          <div className=\"flex-main chart\">\r\n            <a href={wclUrl}>\r\n              {perSecond > 0 && (\r\n                <AutoSizer disableWidth>\r\n                  {({ height }) => (\r\n                    <FlushLineChart data={data} duration={this.owner.fightDuration / 1000} height={height} />\r\n                  )}\r\n                </AutoSizer>\r\n              )}\r\n            </a>\r\n          </div>\r\n        </div>\r\n      </StatisticBar>\r\n    );\r\n  }\r\n}\r\n\r\nexport default DamageDone;\r\n","import React from 'react';\r\nimport PropTypes from 'prop-types';\r\n\r\nimport STATISTIC_CATEGORY from 'interface/others/STATISTIC_CATEGORY';\r\n\r\nimport './Statistic.scss';\r\nimport './StatisticBar.scss';\r\n\r\nconst StatisticBar = ({ children, large, wide, ultrawide, ...others }) => (\r\n  <div className={ultrawide ? 'col-md-12' : (wide ? 'col-md-6 col-sm-12 col-xs-12' : 'col-lg-3 col-md-4 col-sm-6 col-xs-12')}>\r\n    <div className=\"panel statistic bar\" {...others}>\r\n      <div className=\"panel-body\">\r\n        {children}\r\n      </div>\r\n    </div>\r\n  </div>\r\n);\r\nStatisticBar.propTypes = {\r\n  children: PropTypes.node.isRequired,\r\n  large: PropTypes.bool,\r\n  wide: PropTypes.bool,\r\n  ultrawide: PropTypes.bool,\r\n  // eslint-disable-next-line react/no-unused-prop-types\r\n  category: PropTypes.oneOf(Object.values(STATISTIC_CATEGORY)),\r\n  // eslint-disable-next-line react/no-unused-prop-types\r\n  position: PropTypes.number,\r\n};\r\n\r\nexport default StatisticBar;\r\n","import React from 'react';\r\nimport { Link } from 'react-router-dom';\r\nimport { formatNumber, formatPercentage } from 'common/format';\r\nimport Analyzer, { Options, SELECTED_PLAYER } from 'parser/core/Analyzer';\r\nimport { When, ThresholdStyle } from 'parser/core/ParseResults';\r\nimport makeAnalyzerUrl from 'interface/common/makeAnalyzerUrl';\r\nimport { i18n } from '@lingui/core';\r\nimport { t } from '@lingui/macro';\r\n\r\nimport Events, { BeginCastEvent, CastEvent, DamageEvent, DeathEvent, HealEvent, ResurrectEvent } from '../../core/Events';\r\n\r\nconst WIPE_MAX_DEAD_TIME = 15 * 1000; // 15sec\r\n\r\nconst debug = false;\r\n\r\n// Log where someone died: https://wowanalyzer.com/report/RjH6AnYdP8GWzX4h/2-Heroic+Aggramar+-+Kill+(6:23)/Kantasai\r\nclass DeathTracker extends Analyzer {\r\n  deaths: DeathEvent[] = [];\r\n  resurrections: Array<CastEvent | BeginCastEvent | HealEvent | DamageEvent | ResurrectEvent> = [];\r\n\r\n  lastDeathTimestamp: number = 0;\r\n  lastResurrectionTimestamp: number = 0;\r\n  _timeDead: number = 0\r\n  _didCast: boolean = false;\r\n  isAlive: boolean = true;\r\n\r\n  die(event: DeathEvent) {\r\n    this.lastDeathTimestamp = this.owner.currentTimestamp;\r\n    debug && this.log('Player Died');\r\n    this.isAlive = false;\r\n    this.deaths.push(event);\r\n  }\r\n  resurrect(event: CastEvent | BeginCastEvent | HealEvent | DamageEvent | ResurrectEvent) {\r\n    this.lastResurrectionTimestamp = this.owner.currentTimestamp;\r\n    this._timeDead += this.lastResurrectionTimestamp - this.lastDeathTimestamp;\r\n    debug && this.log('Player was Resurrected');\r\n    this.isAlive = true;\r\n    this.resurrections.push(event);\r\n  }\r\n\r\n  constructor(options: Options){\r\n    super(options);\r\n    this.addEventListener(Events.death.to(SELECTED_PLAYER), this.onDeath);\r\n    this.addEventListener(Events.resurrect.to(SELECTED_PLAYER), this.onResurrect);\r\n    this.addEventListener(Events.cast.by(SELECTED_PLAYER), this.onCast);\r\n    this.addEventListener(Events.begincast.by(SELECTED_PLAYER), this.onBeginCast);\r\n    this.addEventListener(Events.heal.to(SELECTED_PLAYER), this.onHealTaken);\r\n    this.addEventListener(Events.damage.to(SELECTED_PLAYER), this.onDamageTaken);\r\n  }\r\n\r\n  onDeath(event: DeathEvent) {\r\n    this.die(event);\r\n  }\r\n  onResurrect(event: ResurrectEvent) {\r\n    this.resurrect(event);\r\n  }\r\n  onCast(event: CastEvent) {\r\n    this._didCast = true;\r\n\r\n    if (!this.isAlive) {\r\n      this.resurrect(event);\r\n    }\r\n  }\r\n  onBeginCast(event: BeginCastEvent) {\r\n    if (!this.isAlive) {\r\n      this.resurrect(event);\r\n    }\r\n  }\r\n  onHealTaken(event: HealEvent) {\r\n    if (!this.isAlive) {\r\n      this.resurrect(event);\r\n    }\r\n  }\r\n  onDamageTaken(event: DamageEvent) {\r\n    if (!this.isAlive) {\r\n      this.resurrect(event);\r\n    }\r\n  }\r\n\r\n  get totalTimeDead() {\r\n    return this._timeDead + (this.isAlive ? 0 : this.owner.currentTimestamp - this.lastDeathTimestamp);\r\n  }\r\n  get timeDeadPercent() {\r\n    return this.totalTimeDead / this.owner.fightDuration;\r\n  }\r\n\r\n  get deathSuggestionThresholds() {\r\n    return {\r\n      actual: this.timeDeadPercent,\r\n      isGreaterThan: {\r\n        major: 0.00,\r\n      },\r\n      style: ThresholdStyle.PERCENTAGE,\r\n    };\r\n  }\r\n\r\n  suggestions(when: When) {\r\n    const boss = this.owner.boss;\r\n    const fight = this.owner.fight;\r\n    const player = this.owner.player;\r\n    const report = this.owner.report;\r\n    const disableDeathSuggestion = boss && boss.fight.disableDeathSuggestion;\r\n    const isWipe = !fight.kill;\r\n    const isWipeDeath = isWipe && this.totalTimeDead < WIPE_MAX_DEAD_TIME;\r\n\r\n    if (!disableDeathSuggestion && !isWipeDeath) {\r\n      when(this.timeDeadPercent).isGreaterThan(0)\r\n        .addSuggestion((suggest, actual) => suggest(<>\r\n            You died during this fight and were dead for {formatPercentage(actual)}% of the fight duration ({formatNumber(this.totalTimeDead / 1000)} seconds). Dying has a significant performance cost. View the <Link to={makeAnalyzerUrl(report, fight.id, player.id, 'death-recap')}>Death Recap</Link> to see the damage taken and what defensives and potions were still available.\r\n          </>)\r\n            .icon('ability_fiegndead')\r\n            .actual(i18n._(t('shared.suggestions.deathTracker.deathTime')`You were dead for ${formatPercentage(actual)}% of the fight`))\r\n            .recommended('0% is recommended')\r\n            .major(this.deathSuggestionThresholds.isGreaterThan.major));\r\n    }\r\n    when(this._didCast).isFalse()\r\n      .addSuggestion((suggest) => suggest('You did not cast a single spell this fight. You were either dead for the entire fight, or were AFK.')\r\n          .icon('ability_fiegndead')\r\n          .major(this.deathSuggestionThresholds.isGreaterThan.major));\r\n  }\r\n}\r\n\r\nexport default DeathTracker;\r\n","import React from 'react';\r\n\r\nimport { Config } from 'vega-lite';\r\n\r\nimport FooterChart from './FooterChart';\r\n\r\nexport interface Props {\r\n  data: any[],\r\n  config?: Config,\r\n  x?: string,\r\n  y?: string,\r\n  duration?: number,\r\n  height?: number,\r\n}\r\n\r\nexport default function FlushLineChart(props: Props) {\r\n  if (props.data.length === 0) {\r\n    return null;\r\n  }\r\n\r\n  const x = props.x || 'time';\r\n  const y = props.y || 'val';\r\n\r\n  const spec = {\r\n    mark: {\r\n      type: 'area' as const,\r\n      line: {\r\n        color: '#fab700',\r\n        strokeWidth: 1,\r\n      },\r\n      color: 'rgba(250, 183, 0, 0.15)',\r\n    },\r\n    transform: [\r\n      {\r\n        calculate: `max(datum.${y}, 0)`,\r\n        as: y,\r\n      },\r\n      {\r\n        impute: y,\r\n        key: x,\r\n        keyvals: {\r\n          start: 0,\r\n          stop: props.duration ? Math.ceil(props.duration) : Math.max.apply(null, props.data.map((obj: any) => obj[x])),\r\n        },\r\n        method: 'value' as const,\r\n        value: 0,\r\n      },\r\n      {\r\n        window: [\r\n          { op: 'mean' as const, field: y, as: 'sum_val' },\r\n        ],\r\n        sort: [\r\n          { field: x, order: 'ascending' as const },\r\n        ],\r\n        frame: [-3, 3],\r\n      },\r\n    ],\r\n    encoding: {\r\n      x: {\r\n        field: x,\r\n        type: 'quantitative' as const,\r\n        axis: null,\r\n        scale: {\r\n          nice: false\r\n        },\r\n      },\r\n      y: {\r\n        field: 'sum_val',\r\n        type: 'quantitative' as const,\r\n        axis: null,\r\n      },\r\n    },\r\n    config: {\r\n      padding: {\r\n        left: 0,\r\n        top: 0,\r\n        right: -5,\r\n        // hide the 0 values w/o leaving disconnected lines\r\n        bottom: -2,\r\n      },\r\n    },\r\n  };\r\n\r\n  return <FooterChart spec={spec} data={props.data} config={props.config} height={props.height} />;\r\n}\r\n","class DamageValue {\r\n  _largestHit = 0;\r\n  _regular = 0;\r\n  /** Do not use this without really good reason! `effective` is almost always better; we WANT to include absorbed damage as this is most commonly related to mechanics that need to be removed and therefore significant. */\r\n  get regular() { return this._regular; }\r\n  _absorbed = 0;\r\n  get absorbed() { return this._absorbed; }\r\n  _blocked = 0;\r\n  get blocked() { return this._blocked; }\r\n  get effective() {\r\n    return this.regular + this.absorbed;\r\n  }\r\n  _overkill = 0;\r\n  get overkill() { return this._overkill; }\r\n  get raw() {\r\n    return this.effective + this.overkill;\r\n  }\r\n\r\n  get largestHit() {\r\n    return this._largestHit;\r\n  }\r\n\r\n  constructor(regular = 0, absorbed = 0, blocked = 0, overkill = 0, largestHit = null) {\r\n    this._regular = regular;\r\n    this._absorbed = absorbed;\r\n    this._blocked = blocked;\r\n    this._overkill = overkill;\r\n    this._largestHit = (largestHit === null) ? regular + absorbed + overkill : largestHit;\r\n  }\r\n\r\n  add(regular = 0, absorbed = 0, blocked = 0, overkill = 0) {\r\n    return new this.constructor(this.regular + regular, this.absorbed + absorbed, this.blocked + blocked, this.overkill + overkill, Math.max(this.largestHit, regular + absorbed + blocked + overkill));\r\n  }\r\n  subtract(regular, absorbed, blocked, overkill) {\r\n    return new this.constructor(this.regular - regular, this.absorbed - absorbed, this.blocked - blocked, this.overkill - overkill, this.largestHit);\r\n  }\r\n}\r\n\r\nexport default DamageValue;\r\n","import React from 'react';\r\nimport { AutoSizer } from 'react-virtualized';\r\n\r\nimport { formatPercentage, formatThousands } from 'common/format';\r\nimport SPELLS from 'common/SPELLS';\r\nimport makeWclUrl from 'common/makeWclUrl';\r\nimport MAGIC_SCHOOLS from 'game/MAGIC_SCHOOLS';\r\nimport rankingColor from 'common/getRankingColor';\r\nimport StatisticBar from 'interface/statistics/StatisticBar';\r\nimport STATISTIC_ORDER from 'interface/others/STATISTIC_ORDER';\r\nimport Analyzer, { Options, SELECTED_PLAYER } from 'parser/core/Analyzer';\r\nimport Tooltip from 'common/Tooltip';\r\nimport FlushLineChart from 'interface/others/FlushLineChart';\r\nimport Events, { AbsorbedEvent, DamageEvent } from 'parser/core/Events';\r\n\r\nimport DamageValue from '../DamageValue';\r\n\r\nconst IGNORED_ABILITIES = [\r\n  SPELLS.SPIRIT_LINK_TOTEM_REDISTRIBUTE.id,\r\n];\r\n\r\nclass DamageTaken extends Analyzer {\r\n  constructor(options: Options) {\r\n    super(options);\r\n\r\n    this.addEventListener(Events.damage.to(SELECTED_PLAYER), this.onToPlayerDamage);\r\n  }\r\n\r\n  _total = new DamageValue(); // consider this \"protected\", so don't change this from other modules. If you want special behavior you must add that code to an extended version of this module.\r\n  get total() {\r\n    return this._total;\r\n  }\r\n\r\n  bySecond: { [secondsIntoFight: number]: DamageValue } = {};\r\n\r\n  _byAbility: { [spellId: number]: DamageValue } = {};\r\n  byAbility(spellId: number) {\r\n    if (!this._byAbility[spellId]) {\r\n      return new DamageValue();\r\n    }\r\n    return this._byAbility[spellId];\r\n  }\r\n\r\n  _byMagicSchool: { [magicSchool: number]: DamageValue } = {};\r\n  byMagicSchool(magicSchool: number) {\r\n    if (!this._byMagicSchool[magicSchool]) {\r\n      return new DamageValue();\r\n    }\r\n    return this._byMagicSchool[magicSchool];\r\n  }\r\n\r\n  onToPlayerDamage(event: DamageEvent) {\r\n    this._addDamage(event, event.amount, event.absorbed, event.blocked, event.overkill);\r\n  }\r\n\r\n  _addDamage(event: DamageEvent | AbsorbedEvent, amount = 0, absorbed = 0, blocked = 0, overkill = 0, ability = event.ability) {\r\n    const spellId = ability.guid;\r\n    if (IGNORED_ABILITIES.includes(spellId)) {\r\n      // Some player abilities (mostly of healers) cause damage as a side-effect, these shouldn't be included in the damage taken.\r\n      return;\r\n    }\r\n    this._total = this._total.add(amount, absorbed, blocked, overkill);\r\n\r\n    if (this._byAbility[spellId]) {\r\n      this._byAbility[spellId] = this._byAbility[spellId].add(amount, absorbed, blocked, overkill);\r\n    } else {\r\n      this._byAbility[spellId] = new DamageValue(amount, absorbed, blocked, overkill);\r\n    }\r\n\r\n    const magicSchool = ability.type;\r\n    if (this._byMagicSchool[magicSchool]) {\r\n      this._byMagicSchool[magicSchool] = this._byMagicSchool[magicSchool].add(amount, absorbed, blocked, overkill);\r\n    } else {\r\n      this._byMagicSchool[magicSchool] = new DamageValue(amount, absorbed, blocked, overkill);\r\n    }\r\n\r\n    const secondsIntoFight = Math.floor((event.timestamp - this.owner.fight.start_time) / 1000);\r\n    this.bySecond[secondsIntoFight] = (this.bySecond[secondsIntoFight] || new DamageValue()).add(amount, absorbed, blocked, overkill);\r\n  }\r\n  _subtractDamage(event: DamageEvent | AbsorbedEvent, amount = 0, absorbed = 0, blocked = 0, overkill = 0, ability = event.ability) {\r\n    return this._addDamage(event, -amount, -absorbed, -blocked, -overkill, ability);\r\n  }\r\n\r\n  get tooltip() {\r\n    const physical = (this._byMagicSchool[MAGIC_SCHOOLS.ids.PHYSICAL]) ? this._byMagicSchool[MAGIC_SCHOOLS.ids.PHYSICAL].effective : 0;\r\n    const magical = this.total.effective - physical;\r\n    return (\r\n      <>\r\n        <strong>Damage taken by type:</strong>\r\n        <ul>\r\n          <li><strong>Physical</strong>: {formatThousands(physical)} ({formatPercentage(physical / this.total.effective)}%)</li>\r\n          <li><strong>Magic</strong>: {formatThousands(magical)} ({formatPercentage(magical / this.total.effective)}%)</li>\r\n        </ul><br />\r\n\r\n        <strong>Damage taken by magic school:</strong>\r\n        <ul>\r\n          {Object.keys(this._byMagicSchool)\r\n            .map(Number)\r\n            .filter(type => this._byMagicSchool[type].effective !== 0)\r\n            .map(type => (\r\n              <li key={type}>\r\n                <strong>{MAGIC_SCHOOLS.names[type] || 'Unknown'}</strong>: {formatThousands(this._byMagicSchool[type].effective)} ({formatPercentage(this._byMagicSchool[type].effective / this.total.effective)}%)\r\n              </li>\r\n            ))\r\n          }\r\n        </ul>\r\n      </>\r\n    );\r\n  }\r\n\r\n  showStatistic = true;\r\n  subStatistic() { // rendered by ThroughputStatisticGroup\r\n    if (!this.showStatistic) {\r\n      return null;\r\n    }\r\n\r\n    const data = Object.entries(this.bySecond).map(([sec, val]) => ({ 'time': sec, 'val': val.effective }));\r\n\r\n    const perSecond = this.total.effective / this.owner.fightDuration * 1000;\r\n    const wclUrl = makeWclUrl(this.owner.report.code, {\r\n      fight: this.owner.fightId,\r\n      source: this.owner.playerId,\r\n      type: 'damage-taken',\r\n    });\r\n\r\n    return (\r\n      <StatisticBar\r\n        position={STATISTIC_ORDER.CORE(3)}\r\n        ultrawide\r\n        wide={false}\r\n        large={false}\r\n        style={{ marginBottom: 0, overflow: 'hidden' }} // since this is in a group, reducing margin should be fine\r\n      >\r\n        <div className=\"flex\">\r\n          <div className=\"flex-sub icon\">\r\n            <img\r\n              src=\"/img/shield.png\"\r\n              alt=\"Damage taken\"\r\n            />\r\n          </div>\r\n          <Tooltip content={this.tooltip}>\r\n            <div\r\n              className=\"flex-sub value\"\r\n              style={{ width: 190 }}\r\n            >\r\n              {formatThousands(perSecond)} DTPS\r\n            </div>\r\n          </Tooltip>\r\n          <div className={`flex-sub ${rankingColor(0)}`} style={{ width: 110, textAlign: 'center' }}>\r\n            -\r\n          </div>\r\n          <div className=\"flex-main chart\">\r\n            <a href={wclUrl}>\r\n              {perSecond > 0 && (\r\n                <AutoSizer disableWidth>\r\n                  {({ height }) => (\r\n                    <FlushLineChart data={data} duration={this.owner.fightDuration / 1000} height={height} />\r\n                  )}\r\n                </AutoSizer>\r\n              )}\r\n            </a>\r\n          </div>\r\n        </div>\r\n      </StatisticBar>\r\n    );\r\n  }\r\n}\r\n\r\nexport default DamageTaken;\r\n","import SPELLS from 'common/SPELLS/index';\r\nimport RESOURCE_TYPES from 'game/RESOURCE_TYPES';\r\nimport SpellResourceCost from 'parser/shared/modules/SpellResourceCost';\r\nimport Events from 'parser/core/Events';\r\n\r\nclass SpellManaCost extends SpellResourceCost {\r\n  static resourceType = RESOURCE_TYPES.MANA;\r\n\r\n  incorrectCosts = {};\r\n\r\n  constructor(options){\r\n    super(options);\r\n    this.addEventListener(Events.fightend, this.onFightend);\r\n  }\r\n\r\n  getHardcodedManaCost(event) {\r\n    const spellId = event.ability.guid;\r\n    const spell = SPELLS[spellId];\r\n    return (spell && spell.manaCost) ? spell.manaCost : null;\r\n  }\r\n\r\n  getRawResourceCost(event) {\r\n    const hardcodedCost = this.getHardcodedManaCost(event);\r\n    const actualCost = this.getCostFromEventObject(event);\r\n\r\n    if (hardcodedCost !== null && actualCost && hardcodedCost !== actualCost) {\r\n      this.incorrectCosts[event.ability.guid] = {\r\n        ...SPELLS[event.ability.guid],\r\n        manaCost: undefined, // delete if it's set in SPELLS\r\n        actualCost: actualCost,\r\n        hardcodedCost: hardcodedCost,\r\n      };\r\n    }\r\n    return hardcodedCost !== null ? hardcodedCost : actualCost;\r\n  }\r\n\r\n  getResourceCost(event) {\r\n    const cost = super.getResourceCost(event);\r\n    if (!cost || cost === 0) {\r\n      return 0;\r\n    }\r\n    if (this.selectedCombatant.hasBuff(SPELLS.INNERVATE.id, event.timestamp)) {\r\n      return 0;\r\n    }\r\n    return cost;\r\n  }\r\n\r\n  onFightend() {\r\n    const incorrectCostCount = Object.keys(this.incorrectCosts).length;\r\n    if (incorrectCostCount === 0) {\r\n      return;\r\n    }\r\n\r\n    console.warn(`There were ${incorrectCostCount} abilities that did not match their expected cost, see below for suggested values.`);\r\n    Object.values(this.incorrectCosts).forEach(ability => console.warn(ability));\r\n  }\r\n}\r\n\r\nexport default SpellManaCost;\r\n","import React from 'react';\r\n\r\n// https://thenounproject.com/search/?q=info&i=367885\r\n// Created by Gregor Cresnar from the Noun Project\r\nconst Icon = ({ ...other }) => (\r\n  <svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 100 100\" className=\"icon\" {...other}>\r\n    <path d=\"M58.9,82.9h7v12.9H34.1V82.9h7.1V45.5h-0.6c-3.6,0-6.4-2.9-6.4-6.4c0-3.6,2.9-6.4,6.4-6.4h0.6h17.4h0.3V82.9z M49,25.8  c6,0,10.8-4.8,10.8-10.8C59.8,9,55,4.2,49,4.2S38.2,9,38.2,15C38.2,21,43,25.8,49,25.8z\" />\r\n  </svg>\r\n);\r\n\r\nexport default Icon;\r\n","//expects a percentile between 0 - 100 and returns the class to color the text accordingly\r\nexport default function rankingColor(percentage: number): string {\r\n  if (percentage < 0.25) {\r\n    return 'parse-grey';\r\n  } else if (percentage < 0.50) {\r\n    return 'parse-green';\r\n  } else if (percentage < 0.75) {\r\n    return 'parse-blue';\r\n  } else if (percentage < 0.95) {\r\n    return 'parse-purple';\r\n  } else if (percentage < 1.00) {\r\n    return 'parse-orange';\r\n  } else if (percentage >= 1.00) {\r\n    return 'parse-artifact';\r\n  } else {\r\n    return 'parse-none';\r\n  }\r\n}\r\n","import SPELLS from 'common/SPELLS';\r\n\r\nconst spells: number[] = [\r\n  /**\r\n   * This consists of spells that are able to be cast while casting. This is\r\n   * primarily used to ignore the below spells when determining whether a\r\n   * spell cast was cancelled since these do not interrupt casting.\r\n   */\r\n  SPELLS.FIRE_BLAST.id,\r\n  SPELLS.SHIMMER_TALENT.id,\r\n  SPELLS.ICE_FLOES_TALENT.id,\r\n  SPELLS.COMBUSTION.id,\r\n  SPELLS.SEARING_NIGHTMARE_TALENT.id,\r\n];\r\n\r\nexport default spells;\r\n","import Analyzer, { SELECTED_PLAYER, Options } from 'parser/core/Analyzer';\r\nimport Abilities from 'parser/core/modules/Abilities';\r\nimport Channeling from 'parser/shared/modules/Channeling';\r\nimport Events, {\r\n  ApplyBuffEvent,\r\n  BeginCastEvent,\r\n  BeginChannelEvent,\r\n  CastEvent,\r\n  EndChannelEvent,\r\n  RemoveBuffEvent,\r\n  UpdateSpellUsableEvent,\r\n} from 'parser/core/Events';\r\n\r\nimport SpellUsable from './SpellUsable';\r\n\r\ntype SpellHistoryEvent =\r\n  | BeginCastEvent\r\n  | CastEvent\r\n  | BeginChannelEvent\r\n  | EndChannelEvent\r\n  | ApplyBuffEvent\r\n  | RemoveBuffEvent\r\n  | UpdateSpellUsableEvent;\r\n\r\nclass SpellHistory extends Analyzer {\r\n  static dependencies = {\r\n    spellUsable: SpellUsable,\r\n    abilities: Abilities,\r\n    channeling: Channeling,\r\n  };\r\n  // necessary for the UpdateSpellUsable event\r\n  protected spellUsable!: SpellUsable;\r\n  protected abilities!: Abilities;\r\n  // necessary for the channeling events\r\n  protected channeling!: Channeling;\r\n\r\n  public historyBySpellId: {\r\n    [spellId: number]: SpellHistoryEvent[];\r\n  } = {\r\n    // This contains the raw event to have all information one might ever need and so that we don't construct additional objects that take their own memory.\r\n    // [spellId]: [\r\n    //   {type: EventType.Cast, timestamp, ...},\r\n    //   {type: EventType.UpdateSpellUsable, trigger: EventType.BeginCooldown', timestamp, ...},\r\n    //   {type: EventType.ApplyBuff, timestamp, ...},\r\n    //   {type: EventType.RemoveBuff, timestamp, ...},\r\n    //   {type: EventType.UpdateSpellUsable, trigger: EventType.EndCooldown', timestamp, ...},\r\n    //   ...\r\n    // ]\r\n  };\r\n\r\n  constructor(options: Options) {\r\n    super(options);\r\n    this.addEventListener(Events.begincast.by(SELECTED_PLAYER), this.append);\r\n    this.addEventListener(Events.cast.by(SELECTED_PLAYER), this.append);\r\n    this.addEventListener(Events.BeginChannel.by(SELECTED_PLAYER), this.append);\r\n    this.addEventListener(Events.EndChannel.by(SELECTED_PLAYER), this.append);\r\n    this.addEventListener(Events.applybuff.by(SELECTED_PLAYER), this.append);\r\n    this.addEventListener(Events.removebuff.by(SELECTED_PLAYER), this.append);\r\n    this.addEventListener(Events.UpdateSpellUsable.by(SELECTED_PLAYER), this.append);\r\n  }\r\n\r\n  private getAbility(spellId: number) {\r\n    const ability = this.abilities.getAbility(spellId);\r\n    if (!ability) {\r\n      // We're only interested in abilities in Abilities since that's the only place we'll show the spell history, besides we only really want to track *casts* and the best source of info for that is Abilities.\r\n      return null;\r\n    }\r\n\r\n    const primarySpellUd = ability.primarySpell.id;\r\n    if (!this.historyBySpellId[primarySpellUd]) {\r\n      this.historyBySpellId[primarySpellUd] = [];\r\n    }\r\n    return this.historyBySpellId[primarySpellUd];\r\n  }\r\n\r\n  private append(event: SpellHistoryEvent) {\r\n    const spellId = event.ability.guid;\r\n    const history = this.getAbility(spellId);\r\n    if (history && event.timestamp > this.owner.fight.start_time) {\r\n      //don't save prephase events in history\r\n      history.push(event);\r\n    }\r\n  }\r\n}\r\n\r\nexport default SpellHistory;\r\n","import Analyzer, { Options } from 'parser/core/Analyzer';\r\nimport EventEmitter from 'parser/core/modules/EventEmitter';\r\nimport Events, { AnyEvent, ApplyBuffEvent, ApplyBuffStackEvent, ApplyDebuffEvent, ApplyDebuffStackEvent, EventType, RemoveBuffEvent, RemoveBuffStackEvent, RemoveDebuffEvent, RemoveDebuffStackEvent } from 'parser/core/Events';\r\nimport Entity, { TrackedBuffEvent } from 'parser/core/Entity';\r\n\r\nconst debug = false;\r\n\r\nconst APPLY = 'apply';\r\nconst REMOVE = 'remove';\r\n\r\nabstract class Entities<T extends Entity> extends Analyzer {\r\n  static dependencies = {\r\n    eventEmitter: EventEmitter,\r\n  };\r\n  readonly eventEmitter!: EventEmitter;\r\n\r\n  constructor(options: Options) {\r\n    super(options);\r\n    this.addEventListener(Events.applybuff, this.applyBuff);\r\n    this.addEventListener(Events.applydebuff, this.applyBuff);\r\n    this.addEventListener(Events.removebuff, this.removeBuff);\r\n    this.addEventListener(Events.removedebuff, this.removeBuff);\r\n    // TODO: Add a sanity check to the `refreshbuff` event that checks if a buff that's being refreshed was applied, if it wasn't it might be a broken pre-combat applied buff not shown in the combatantinfo event\r\n    // We don't store/use durations, so refreshing buff is useless. Removing the buff actually interferes with the `minimalActiveTime` parameter of `getBuff`.\r\n    // on_refreshbuff(event) {\r\n    //   this.removeActiveBuff(event);\r\n    //   this.applyActiveBuff(event);\r\n    // }\r\n    this.addEventListener(Events.applybuffstack, this.updateBuffStack);\r\n    this.addEventListener(Events.applydebuffstack, this.updateBuffStack);\r\n    this.addEventListener(Events.removebuffstack, this.updateBuffStack);\r\n    this.addEventListener(Events.removedebuffstack, this.updateBuffStack);\r\n  }\r\n\r\n  abstract getEntities(): { [entityId: number]: T };\r\n\r\n  abstract getEntity(event: AnyEvent): T | null;\r\n\r\n  applyBuff(event: ApplyBuffEvent | ApplyDebuffEvent) {\r\n    if (!this.owner.byPlayer(event) && !this.owner.toPlayer(event) && !this.owner.byPlayerPet(event) && !this.owner.toPlayerPet(event)) {\r\n      // We don't need to know about debuffs on bosses or buffs on other players not caused by us, but we do want to know about our outgoing buffs, and other people's buffs on us\r\n      return;\r\n    }\r\n    const entity = this.getEntity(event);\r\n    if (!entity) {\r\n      return;\r\n    }\r\n\r\n    debug && this.log(`Apply buff ${event.ability.name} to ${entity.name}`);\r\n    const isDebuff = event.type === EventType.ApplyDebuff;\r\n    const buff = {\r\n      ...event,\r\n      start: event.timestamp,\r\n      end: null,\r\n      isDebuff,\r\n      // The initial buff counts as 1 stack, to make the `changebuffstack` event complete it's fired for all applybuff events, including buffs that aren't actually stackable.\r\n      stacks: 1,\r\n    };\r\n\r\n    this._triggerChangeBuffStack(buff, event.timestamp, 0, 1);\r\n\r\n    if (event.prepull && event.__fromCombatantinfo) {\r\n      // Prepull buffs were already applied in the Combatant constructor\r\n      return;\r\n    }\r\n\r\n    entity.applyBuff(buff);\r\n  }\r\n\r\n  updateBuffStack(event: ApplyBuffStackEvent | ApplyDebuffStackEvent | RemoveBuffStackEvent | RemoveDebuffStackEvent) {\r\n    if (!this.owner.byPlayer(event) && !this.owner.toPlayer(event) && !this.owner.byPlayerPet(event) && !this.owner.toPlayerPet(event)) {\r\n      // We don't need to know about debuffs on bosses or buffs on other players not caused by us, but we do want to know about our outgoing buffs, and other people's buffs on us\r\n      return;\r\n    }\r\n    const entity = this.getEntity(event);\r\n    if (!entity) {\r\n      return;\r\n    }\r\n\r\n    debug && this.log(`Apply buff stack ${event.ability.name} to ${entity.name}`);\r\n\r\n    const existingBuff = entity.buffs.find(item => item.ability.guid === event.ability.guid && item.end === null && event.sourceID === item.sourceID);\r\n    if (existingBuff) {\r\n      const oldStacks = existingBuff.stacks || 1; // the original spell counts as 1 stack\r\n      existingBuff.stacks = event.stack;\r\n      existingBuff.stackHistory.push({ stacks: event.stack, timestamp: event.timestamp });\r\n\r\n      this._triggerChangeBuffStack(existingBuff, event.timestamp, oldStacks, existingBuff.stacks);\r\n    } else {\r\n      console.error('Buff stack updated while active buff wasn\\'t known. Was this buff applied pre-combat? Maybe we should register the buff with start time as fight start when this happens, but it might also be a basic case of erroneous combatlog ordering.');\r\n    }\r\n  }\r\n\r\n  removeBuff(event: RemoveBuffEvent | RemoveDebuffEvent) {\r\n    if (!this.owner.byPlayer(event) && !this.owner.toPlayer(event) && !this.owner.byPlayerPet(event) && !this.owner.toPlayerPet(event)) {\r\n      // We don't need to know about debuffs on bosses or buffs on other players not caused by us, but we do want to know about our outgoing buffs, and other people's buffs on us\r\n      return;\r\n    }\r\n    const entity = this.getEntity(event);\r\n    if (!entity) {\r\n      return;\r\n    }\r\n\r\n    debug && this.log(`Remove buff ${event.ability.name} from ${entity.name}`);\r\n\r\n    const existingBuff = entity.buffs.find(item => item.ability.guid === event.ability.guid && item.end === null && event.sourceID === item.sourceID);\r\n    if (existingBuff) {\r\n      existingBuff.end = event.timestamp;\r\n      existingBuff.stackHistory.push({ stacks: 0, timestamp: event.timestamp });\r\n\r\n      this._triggerChangeBuffStack(existingBuff, event.timestamp, existingBuff.stacks, 0);\r\n    } else {\r\n      // The only possible legit way this could occur that I can imagine is if the log was bugged and had more removebuff events than applybuff events. This might be caused by range or phasing issues.\r\n      // TODO: throw new Error(`Buff ${event.ability.name} wasn't correctly applied in the ApplyBuff normalizer.`);\r\n      // TODO: Remove below and add above. http://localhost:3000/report/YcbxZv1hKX4GVr82/33-Mythic+Grong+-+Wipe+23+(4:26)/45-Teish has issues due to Tricks of the Trade being applied twice at the start by different people. Need to change ApplyBuff to fix this, probably not super complicated but too late to do now.\r\n      const isDebuff = event.type === EventType.RemoveDebuff;\r\n      const buff = {\r\n        ...event,\r\n        start: this.owner.fight.start_time,\r\n        end: event.timestamp,\r\n        stackHistory: [{ stacks: 1, timestamp: this.owner.fight.start_time }, { stacks: 0, timestamp: event.timestamp }],\r\n        isDebuff,\r\n        stacks: 0,\r\n      };\r\n      entity.buffs.push(buff);\r\n\r\n      this._triggerChangeBuffStack(buff, event.timestamp, 1, 0);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Trigger a custom `changebuffstack` event that provides all information available about the buff and its stacks, most notably `oldStacks`, `newStacks` and `stacksGained`.\r\n   * This event is also fired for `applybuff` where `oldStacks` will be 0 and `newStacks` will be 1. NOTE: This event is usually fired before the `applybuff` event!\r\n   * This event is also fired for `removebuff` where `oldStacks` will be either the old stacks (if there were multiple) or 1 and `newStacks` will be 0. NOTE: This event is usually fired before the `removebuff` event!\r\n   */\r\n  _triggerChangeBuffStack(buff: any, timestamp: number, oldStacks: number, newStacks: number) {\r\n    this.eventEmitter.fabricateEvent({\r\n      ...buff,\r\n      type: buff.isDebuff ? EventType.ChangeDebuffStack : EventType.ChangeBuffStack,\r\n      timestamp,\r\n      oldStacks,\r\n      newStacks,\r\n      stacksGained: newStacks - oldStacks,\r\n      stack: undefined,\r\n    }, buff);\r\n  }\r\n\r\n  // Surely this can be done with a couple less loops???\r\n  getBuffUptime(spellId: number, sourceID = this.owner.playerId) {\r\n    const events: Array<{timestamp: number, type: string, buff: TrackedBuffEvent}> = [];\r\n\r\n    const entities = this.getEntities();\r\n    Object.values(entities)\r\n      .forEach(enemy => {\r\n        enemy.getBuffHistory(spellId, sourceID)\r\n          .forEach((buff: TrackedBuffEvent) => {\r\n            events.push({\r\n              timestamp: buff.start,\r\n              type: APPLY,\r\n              buff,\r\n            });\r\n            events.push({\r\n              timestamp: buff.end !== null ? buff.end : this.owner.currentTimestamp, // buff end is null if it's still active, it can also be 0 if buff ended at pull\r\n              type: REMOVE,\r\n              buff,\r\n            });\r\n          });\r\n      });\r\n\r\n    let active = 0;\r\n    let start: number;\r\n    return events\r\n      .sort((a, b) => a.timestamp - b.timestamp)\r\n      .reduce((uptime, event) => {\r\n        if (event.type === APPLY) {\r\n          if (active === 0) {\r\n            start = event.timestamp;\r\n          }\r\n          active += 1;\r\n        }\r\n        if (event.type === REMOVE) {\r\n          active -= 1;\r\n          if (active === 0) {\r\n            uptime += event.timestamp - start;\r\n          }\r\n        }\r\n        return uptime;\r\n      }, 0);\r\n  }\r\n}\r\n\r\nexport default Entities;\r\n","import React from 'react';\r\n\r\nimport { TopLevelSpec, Config } from 'vega-lite';\r\nimport { VisualizationSpec } from 'react-vega';\r\nimport { AutoSizer } from 'react-virtualized';\r\n\r\nimport BaseChart, { defaultConfig, formatTime } from './BaseChart';\r\n\r\nexport { formatTime };\r\n\r\nexport type Spec = Omit<TopLevelSpec, \"data\">;\r\n\r\nexport interface Props {\r\n  spec: Spec;\r\n  data: any;\r\n  config?: Config;\r\n  height?: number;\r\n}\r\n\r\n// A vega-lite chart displayed in the footer of a <StatisticBox />.\r\nexport default function FooterChart(props: Props) {\r\n  const spec = {\r\n    ...props.spec,\r\n    data: { name: 'default_data' },\r\n  };\r\n  const height = props.height || 75;\r\n\r\n  return (\r\n    <div style={{\r\n      width: '100%',\r\n      height,\r\n    }}>\r\n      <AutoSizer disableHeight>\r\n        {({ width }) => {\r\n          if (width > 0) {\r\n            return (\r\n              <BaseChart\r\n                width={width}\r\n                height={height}\r\n                // eslint-disable-next-line @typescript-eslint/camelcase\r\n                data={{default_data: props.data}}\r\n                config={props.config || defaultConfig}\r\n                spec={spec as VisualizationSpec}\r\n              />\r\n            );\r\n          }\r\n          return null;\r\n        }}\r\n      </AutoSizer>\r\n    </div>\r\n  );\r\n}\r\n","import React from 'react';\r\nimport PropTypes from 'prop-types';\r\n\r\nimport STATISTIC_CATEGORY from 'interface/others/STATISTIC_CATEGORY';\r\n\r\nconst StatisticGroup = ({ children, large, wide, style, ...others }) => (\r\n  <div\r\n    className={wide ? 'col-md-6 col-sm-12 col-xs-12' : 'col-lg-3 col-md-4 col-sm-6 col-xs-12'}\r\n    style={{ padding: 0, ...style }}\r\n    {...others}\r\n  >\r\n    {children}\r\n  </div>\r\n);\r\nStatisticGroup.propTypes = {\r\n  children: PropTypes.node.isRequired,\r\n  large: PropTypes.bool,\r\n  wide: PropTypes.bool,\r\n  style: PropTypes.object,\r\n  // eslint-disable-next-line react/no-unused-prop-types\r\n  category: PropTypes.oneOf(Object.values(STATISTIC_CATEGORY)),\r\n  // eslint-disable-next-line react/no-unused-prop-types\r\n  position: PropTypes.number,\r\n};\r\n\r\nexport default StatisticGroup;\r\n","import Analyzer, { SELECTED_PLAYER } from 'parser/core/Analyzer';\r\nimport Events from 'parser/core/Events';\r\n\r\n/**\r\n * Tracks the amount of time (and instances when) the player was dead.\r\n * Example log where this is relevant (Argus M):\r\n * http://localhost:3000/report/J7xvPqaG6WdmnXrV/22-Mythic+Argus+the+Unmaker+-+Kill+(8:10)/132-Mufre\r\n */\r\nclass DeathDowntime extends Analyzer {\r\n  _lastDeathTimestamp = null;\r\n  _isAlive = true;\r\n  _deathHistory = [];\r\n\r\n  get totalDowntime() {\r\n    return this._deathHistory.reduce((total, death) => total + death.duration, 0);\r\n  }\r\n  get downtimeHistory() {\r\n    return this._deathHistory;\r\n  }\r\n\r\n  constructor(options){\r\n    super(options);\r\n    this.addEventListener(Events.fightend, this.onFightend);\r\n    this.addEventListener(Events.death.to(SELECTED_PLAYER), this.onDeath);\r\n    this.addEventListener(Events.resurrect.to(SELECTED_PLAYER), this.onResurrect);\r\n    this.addEventListener(Events.cast.by(SELECTED_PLAYER), this.onCast);\r\n    this.addEventListener(Events.begincast.by(SELECTED_PLAYER), this.onBeginCast);\r\n  }\r\n\r\n  die(event) {\r\n    if (!this._isAlive) {\r\n      // Some boss mechanics trigger death events when already dead (e.g. M Argus where you die on purpose before the mechanic)\r\n      console.warn('Player died while already dead.', event);\r\n      return;\r\n    }\r\n    this._lastDeathTimestamp = event.timestamp;\r\n    this._isAlive = false;\r\n  }\r\n  resurrect(resurrectionTimestamp) {\r\n    this._deathHistory.push({\r\n      from: this._lastDeathTimestamp,\r\n      until: resurrectionTimestamp,\r\n      duration: resurrectionTimestamp - this._lastDeathTimestamp,\r\n    });\r\n    this._lastDeathTimestamp = null;\r\n    this._isAlive = true;\r\n  }\r\n  onFightend() {\r\n    if (!this._isAlive) {\r\n      this.resurrect(this.owner.currentTimestamp);\r\n    }\r\n  }\r\n\r\n  onDeath(event) {\r\n    this.die(event);\r\n  }\r\n  onResurrect(event) {\r\n    this.resurrect(event.timestamp);\r\n  }\r\n  onCast(event) {\r\n    if (!this._isAlive) {\r\n      console.warn('Player magically resurrected', event);\r\n      this.resurrect(event.timestamp);\r\n    }\r\n  }\r\n  onBeginCast(event) {\r\n    if (!this._isAlive) {\r\n      console.warn('Player magically resurrected', event);\r\n      this.resurrect(event.timestamp);\r\n    }\r\n  }\r\n}\r\n\r\nexport default DeathDowntime;\r\n","import React from 'react';\r\n\r\nimport { formatPercentage, formatThousands } from 'common/format';\r\nimport Statistic from 'interface/statistics/Statistic';\r\nimport STATISTIC_ORDER from 'interface/others/STATISTIC_ORDER';\r\nimport Analyzer, { Options, SELECTED_PLAYER } from 'parser/core/Analyzer';\r\nimport Events, { CastEvent, DamageEvent, EnergizeEvent, HealEvent } from 'parser/core/Events';\r\nimport FlushLineChart from 'interface/others/FlushLineChart';\r\nimport { Trans } from '@lingui/macro';\r\n\r\nconst debug = false;\r\n\r\ntype PositionalData = {\r\n  x: number,\r\n  y: number,\r\n  timestamp: number,\r\n}\r\n\r\nclass DistanceMoved extends Analyzer {\r\n  lastPosition: PositionalData | null = null;\r\n  lastPositionChange: PositionalData | null = null;\r\n  totalDistanceMoved = 0;\r\n  timeSpentMoving = 0;\r\n  bySecond = new Map<number, number>();\r\n\r\n  constructor(options: Options) {\r\n    super(options);\r\n    this.addEventListener(Events.cast.by(SELECTED_PLAYER), this.updatePlayerPosition);\r\n    // These coordinates are for the target, so they are only accurate when done TO player\r\n    this.addEventListener(Events.damage.to(SELECTED_PLAYER), this.updatePlayerPosition);\r\n    this.addEventListener(Events.energize.to(SELECTED_PLAYER), this.updatePlayerPosition);\r\n    this.addEventListener(Events.heal.to(SELECTED_PLAYER), this.updatePlayerPosition);\r\n    /* I couldn't find any instances of absorbed events containing location,\r\n     * if it can actually happen we can update the AbsorbedEvent shape and\r\n     * uncomment this binding.\r\n     * this.addEventListener(Events.absorbed.to(SELECTED_PLAYER), this.updatePlayerPosition);\r\n     */\r\n  }\r\n\r\n  timeSinceLastMovement() {\r\n    if (!this.lastPositionChange) {\r\n      return null;\r\n    }\r\n    return this.owner.currentTimestamp - this.lastPositionChange.timestamp;\r\n  }\r\n\r\n  // Data parsing\r\n  calculateDistance(x1: number, y1: number, x2: number, y2: number) {\r\n    return Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)) / 100;\r\n  }\r\n\r\n  updateTotalDistance(newData: PositionalData) {\r\n    if (!this.lastPosition) {\r\n      return;\r\n    }\r\n    const distanceMoved = this.calculateDistance(this.lastPosition.x, this.lastPosition.y, newData.x, newData.y);\r\n    if (distanceMoved !== 0) {\r\n      this.timeSpentMoving += newData.timestamp - this.lastPosition.timestamp;\r\n      this.totalDistanceMoved += distanceMoved;\r\n      const secondsIntoFight = Math.floor((newData.timestamp - this.owner.fight.start_time) / 1000);\r\n      this.bySecond.set(secondsIntoFight, (this.bySecond.get(secondsIntoFight) || 0) + distanceMoved);\r\n    }\r\n  }\r\n\r\n  updatePlayerPosition(event: CastEvent | HealEvent | DamageEvent | EnergizeEvent) {\r\n    if (!event.x || !event.y) {\r\n      return;\r\n    }\r\n    const updatedPosition: PositionalData = {\r\n      x: event.x,\r\n      y: event.y,\r\n      timestamp: event.timestamp,\r\n    }\r\n    this.updateTotalDistance(updatedPosition);\r\n    if (!this.lastPositionChange || this.lastPositionChange.x !== updatedPosition.x || this.lastPositionChange.y !== updatedPosition.y) {\r\n      this.lastPositionChange = updatedPosition;\r\n    }\r\n    this.lastPosition = updatedPosition;\r\n  }\r\n\r\n  statistic() {\r\n    debug && console.log(`Time spent moving: ${this.timeSpentMoving / 1000}s, Total distance moved: ${this.totalDistanceMoved} yds`);\r\n\r\n    const data = Array.from(this.bySecond, ([sec, val]) => ({ 'time': sec, 'val': val }));\r\n\r\n    return (\r\n      <Statistic\r\n        position={STATISTIC_ORDER.UNIMPORTANT()}\r\n        tooltip={(\r\n          <Trans id=\"shared.distanceMoved.statistic.tooltip\">\r\n            Consider this when analyzing the fight, as some fights require more movement than others. Unnecessary movement can result in a DPS/HPS loss.<br /><br />\r\n\r\n            In ≈{formatThousands(this.timeSpentMoving / 1000)} seconds of movement you moved ≈{formatThousands(this.totalDistanceMoved)} yards (≈{formatThousands(this.totalDistanceMoved / (this.owner.fightDuration / 1000) * 60)} yards per minute). This statistic may not be entirely accurate for fights with lots of problems.\r\n          </Trans>\r\n        )}\r\n      >\r\n        <div className=\"pad\">\r\n          <label><Trans id=\"shared.distanceMoved.statistic.label\">Distance moved</Trans></label>\r\n\r\n          <div className=\"value\">\r\n            ≈ {formatThousands(this.totalDistanceMoved)} yards\r\n            <small style={{ marginLeft: 15 }}>\r\n              ≈ {formatPercentage(this.timeSpentMoving / (this.owner.fightDuration))}%\r\n            </small>\r\n          </div>\r\n\r\n          <div style={{ position: 'absolute', bottom: 0, left: 0, right: 0, width: '100%', height: '45%' }}>\r\n            <FlushLineChart data={data} duration={this.owner.fightDuration / 1000} />\r\n          </div>\r\n        </div>\r\n      </Statistic>\r\n    );\r\n  }\r\n}\r\n\r\nexport default DistanceMoved;\r\n"],"sourceRoot":""}