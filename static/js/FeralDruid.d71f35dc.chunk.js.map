{"version":3,"sources":["parser/druid/feral/normalizers/RakeBleed.js","parser/druid/feral/normalizers/ComboPointsFromAoE.js","parser/druid/feral/normalizers/BleedDebuffEvents.js","parser/druid/feral/modules/Abilities.js","parser/druid/feral/modules/Buffs.js","parser/druid/feral/modules/features/AlwaysBeCasting.js","parser/druid/feral/modules/features/CooldownThroughputTracker.js","parser/druid/feral/modules/features/SpellUsable.js","parser/druid/feral/constants.js","parser/druid/feral/modules/features/SpellEnergyCost.js","parser/druid/feral/modules/features/EnergyCapTracker.js","parser/druid/feral/modules/features/EnergyTracker.js","parser/druid/feral/modules/features/EnergyDetails.js","parser/druid/feral/modules/features/checklist/Component.js","parser/druid/feral/modules/bleeds/RakeUptime.js","parser/druid/feral/modules/talents/MoonfireUptime.js","parser/druid/feral/modules/core/HitCountAoE.js","parser/druid/feral/modules/spells/SwipeHitCount.js","parser/druid/feral/modules/combopoints/ComboPointBreakdown.js","parser/druid/feral/modules/combopoints/ComboPointTracker.js","parser/druid/feral/modules/combopoints/ComboPointDetails.js","parser/druid/feral/modules/bleeds/RipUptime.js","parser/druid/feral/modules/spells/FerociousBiteEnergy.js","parser/druid/feral/modules/core/getComboPointsFromEvent.js","parser/druid/feral/modules/core/Snapshot.js","parser/druid/feral/modules/bleeds/RipSnapshot.js","parser/druid/feral/modules/bleeds/RakeSnapshot.js","parser/druid/feral/modules/talents/MoonfireSnapshot.js","parser/druid/feral/modules/spells/PredatorySwiftness.js","parser/druid/feral/modules/talents/Bloodtalons.js","parser/druid/feral/modules/talents/Predator.js","parser/druid/feral/modules/talents/SavageRoar.js","parser/druid/feral/modules/core/getDamageBonus.js","parser/druid/feral/modules/spells/TigersFuryEnergy.js","parser/druid/feral/modules/racials/Shadowmeld.js","parser/druid/feral/modules/combopoints/FinisherUse.js","parser/druid/feral/modules/features/checklist/Module.js","parser/druid/feral/modules/talents/BrutalSlashHitCount.js","parser/druid/feral/modules/spells/ThrashHitCount.js","parser/druid/feral/CombatLogParser.js","parser/core/calculateEffectiveDamage.js","interface/icons/Uptime.js","interface/statistics/components/DonutChart/index.js","interface/others/StatisticsListBox.js","parser/shared/modules/resources/resourcetracker/RegenResourceCapTracker.js"],"names":["RakeBleed","events","fixedEvents","eventIndex","length","castEvent","push","type","EventType","Cast","ability","guid","SPELLS","RAKE","id","previousEventIndex","previousEvent","timestamp","ApplyDebuff","RefreshDebuff","RAKE_BLEED","targetID","targetInstance","sourceID","splice","__modified","EventsNormalizer","INVISIBLE_ENERGIZE_ATTACKS","THRASH_FERAL","SWIPE_CAT","BRUTAL_SLASH_TALENT","HIT_TYPES_THAT_DONT_ENERGIZE","HIT_TYPES","MISS","DODGE","PARRY","IMMUNE","ComboPointsFromAoE","options","playerId","owner","combo","castEventIndex","comboAtCast","fixedEventIndex","forEach","event","eventComboResource","getResource","RESOURCE_TYPES","COMBO_POINTS","Energize","resourceChangeType","Math","min","resourceChange","waste","cost","includes","__fabricated","Damage","tick","hitType","fabricatedEnergize","sourceIsFriendly","targetIsFriendly","classResources","find","resource","CAST_DEBUFF_PAIRS","cast","RIP","debuff","MOONFIRE_FERAL","MOONFIRE_BEAR","multipleDebuffs","PRIMAL_WRATH_TALENT","BleedDebuffEvents","pair","item","debuffEvents","debuffEventIndex","debuffEvent","Abilities","combatant","this","selectedCombatant","spell","SHRED","category","SPELL_CATEGORIES","ROTATIONAL","gcd","static","timelineSortIndex","primaryCoefficient","FEROCIOUS_BITE","SAVAGE_ROAR_TALENT","enabled","hasTalent","LUNAR_INSPIRATION_TALENT","base","ROTATIONAL_AOE","cooldown","haste","charges","castEfficiency","suggestion","SWIPE_BEAR","INCARNATION_KING_OF_THE_JUNGLE_TALENT","COOLDOWNS","recommendedEfficiency","BERSERK","TIGERS_FURY","PREDATOR_TALENT","FERAL_FRENZY_TALENT","REGROWTH","UTILITY","hasBuff","CAT_FORM","ENTANGLING_ROOTS","MAIM","DASH","TIGER_DASH_TALENT","isDefensive","STAMPEDING_ROAR_HUMANOID","STAMPEDING_ROAR_CAT","STAMPEDING_ROAR_BEAR","BEAR_FORM","SKULL_BASH","SKULL_BASH_FERAL","PROWL","PROWL_INCARNATION","SHADOWMELD","isUndetectable","SURVIVAL_INSTINCTS","DEFENSIVE","REBIRTH","MIGHTY_BASH_TALENT","MASS_ENTANGLEMENT_TALENT","TYPHOON","TYPHOON_TALENT","HIBERNATE","SOOTHE","RENEWAL_TALENT","WILD_CHARGE_TALENT","WILD_CHARGE_MOONKIN","WILD_CHARGE_CAT","WILD_CHARGE_BEAR","WILD_CHARGE_TRAVEL","MOONKIN_FORM_AFFINITY","BALANCE_AFFINITY_TALENT_SHARED","TRAVEL_FORM","STAG_FORM","GROWL","MANGLE_BEAR","OTHERS","THRASH_BEAR","MOONFIRE","REMOVE_CORRUPTION","REVIVE","LUNAR_STRIKE_AFFINITY","SOLAR_WRATH_AFFINITY","STARSURGE_AFFINITY","SUNFIRE_AFFINITY","FLAP","IRONFUR","GUARDIAN_AFFINITY_TALENT_FERAL","FRENZIED_REGENERATION","REJUVENATION","RESTORATION_AFFINITY_TALENT","SWIFTMEND","WILD_GROWTH","TREANT_FORM","CHARM_WOODLAND_CREATURE","TELEPORT_MOONGLADE","TELEPORT_DREAMWALK","CoreAbilities","Buffs","spellId","BLOODTALONS_BUFF","BLOODTALONS_TALENT","triggeredBySpellId","timelineHighlight","PREDATORY_SWIFTNESS","Object","keys","BLOODLUST_BUFFS","map","Number","CoreBuffs","AlwaysBeCasting","position","STATISTIC_ORDER","CORE","when","CoreAlwaysBeCasting","CooldownThroughputTracker","CoreCooldownThroughputTracker","cooldownSpells","summary","BUILT_IN_SUMMARY_TYPES","DAMAGE","BLEED_BASE_DURATIONS","BLEED_SPELLS","SpellUsable","args","earlyCastsOfTigersFury","activeBleedsExpire","hasPredator","possibleRecentKill","addEventListener","Events","applydebuff","by","SELECTED_PLAYER","onApplyDebuff","refreshdebuff","onRefreshDebuff","removedebuff","onRemoveDebuff","target","encodeTargetString","duration","existingExpire","remainingOnPrevious","max","durationWithoutPandemic","pandemic","expire","cooldownTriggerEvent","isOnCooldown","resetTime","endCooldown","CoreSpellUsable","SpellEnergyCost","SpellResourceCost","resourceType","ENERGY","EnergyCapTracker","MOMENT_OF_CLARITY_TALENT","combatantHasBuffActive","floor","suggestionThresholds","addSuggestion","suggest","actual","recommended","icon","i18n","_","formatPercentage","Statistic","tooltip","cappedProportion","missedRegen","toFixed","size","BoringResourceValue","value","percentCapped","label","naturalRegen","isLessThan","minor","average","major","style","RegenResourceCapTracker","dependencies","spellResourceCost","baseRegenRate","isRegenHasted","cumulativeEventWindow","buffsChangeMax","resourceRefundOnMiss","exemptFromRefund","EnergyTracker","initBuilderAbility","ResourceTracker","EnergyDetails","title","url","render","Panel","tracker","energyTracker","showSpenders","Analyzer","FeralDruidChecklist","thresholds","UptimeRequirement","props","Requirement","name","SpellLink","CastEfficiencyRequirement","GenericCastEfficiencyRequirement","getCastEfficiencyForSpellId","SnapshotDowngradeRequirement","Rule","description","Tooltip","content","rakeUptime","moonfireUptime","swipeHitOne","comboPointsWaste","SABERTOOTH_TALENT","ripUptime","savageRoarUptime","ferociousBiteEnergy","ripShouldBeBite","ripDurationReduction","badLowComboFinishers","tigersFuryIgnoreEnergy","energyCapped","tigersFuryEnergy","predatorWrongTalent","race","RACES","NightElf","shadowmeld","moonfireDowngrade","rakeDowngrade","ripDowngrade","rakeProwlDowngrade","predatorySwiftnessWasted","bloodtalonsWasted","PreparationRule","RakeUptime","BoringSpellValueText","Uptime","uptime","enemies","getBuffUptime","fightDuration","Enemies","MoonfireUptime","active","OPTIONAL","HitCountAoE","casts","totalHits","castsWithZeroHits","castsWithOneHit","lastCastEvent","lastCastHits","constructor","onCast","damage","onDamage","fightend","onFightend","finalizePreviousCast","statisticPosition","averageTargetsHit","SwipeHitCount","generateStatistic","hitNoneThresholds","hitJustOneThresholds","hitZeroPerMinute","isGreaterThan","hitJustOnePerMinute","ResourceBreakdown","buildersObj","abilityId","generated","wasted","sort","a","b","filter","spendersObj","spent","maxCP","spentByCast","resourceName","prepareGenerated","prepareSpent","totalGenerated","totalWasted","totalSpent","className","colSpan","key","width","paddingRight","textAlign","React","Component","ComboPointTracker","unavoidableWaste","castToMaxCpTimestamp","maxResource","gain","isMaxBefore","current","isMaxAfter","PRIMAL_FURY","currentTimestamp","ComboPointDetails","wastingSuggestionThresholds","pointsWasted","pointsWastedPerMinute","comboPointTracker","RipUptime","HIT_TYPES_TO_IGNORE","FerociousBiteEnergy","biteCount","lostDamageTotal","sumBonusEnergyFraction","lastBiteCast","undefined","energyForFullDamage","energyUsedByCast","energyAvailable","isPaired","_onBiteCast","_onBiteDamage","_averageBonusEnergyFraction","_hasBerserkAtTime","_energyUsedByCast","_energyAvailable","actualDamage","amount","absorbed","lostDamage","_calcPotentialBiteDamage","_bonusEnergyFraction","meta","isInefficientCast","inefficientCastReason","formatNumber","resourceCost","biteCast","berserkOrIncarnationId","_dpsLostFromLowEnergyBites","spellEnergyCost","getComboPointsFromEvent","Snapshot","stateByTarget","castCount","ticks","ticksWithProwl","ticksWithTigersFury","ticksWithBloodtalons","damageFromProwl","damageFromTigersFury","damageFromBloodtalons","Error","_castSnapshotSpell","_damageFromDebuff","lastDoTCastEvent","_debuffApplied","state","expireTime","bonusDamage","calculateEffectiveDamage","calcPowerFromSnapshot","additiveBonus","additivePowerSum","prowl","fractionOfBonus","tigersFury","bloodtalons","targetString","stateOld","stateNew","makeNewState","checkRefreshRule","timeRemainOnOld","durationNew","getDurationOfFresh","expireNew","pandemicTime","isTigersFuryAffected","isProwlAffected","isBloodtalonsAffected","power","startTime","prev","calcPower","feralSnapshotState","PROWL_RAKE_DAMAGE_BONUS","TIGERS_FURY_DAMAGE_BONUS","BLOODTALONS_DAMAGE_BONUS","additive","durationOfFresh","ticksWithBuff","damageIncrease","buffId","buffName","spellName","subStats","buffNames","subStatistic","buffsComment","index","hasComma","hasAnd","isPlural","StatisticsListBox","SpellIcon","noLink","wasStateFreshlyApplied","RipSnapshot","downgradeCount","shouldBeBiteCount","durationReductionCount","comboLastRip","hasSabertooth","_castRip","_castFerociousBite","shouldBeBiteProportion","downgradeProportion","existing","comboPoints","remainingTime","newDuration","strengthComment","remainingOld","remainingNew","isEnhancedCast","downgradeSuggestionThresholds","shouldBeBiteSuggestionThresholds","durationReductionThresholds","RakeSnapshot","prowlLostCastCount","prowlLostTimeSum","downgradeCastCount","timeLost","prowlLostSuggestionThresholds","prowlLostTimePerMinute","MoonfireSnapshot","POTENTIAL_SPENDERS","PredatorySwiftness","hasSwiftness","used","expired","remainAfterFight","overwritten","timeLastGain","applybuff","to","onApplyBuff","refreshbuff","onRefreshBuff","removebuff","onRemoveBuff","wastedFraction","abs","HIT_TYPES_THAT_DONT_CONSUME","CHART_COLOR_SPENDERS","Bloodtalons","spenders","currentStack","lastSpender","spender","chartColor","count","applyDebuff","overwrittenPerMinute","items","color","valueTooltip","DonutChart","isAlreadyAccountedForAoE","addSpender","Boolean","height","combinedChart","Predator","totalCasts","abilities","getAbility","spellUsable","baseCasts","extraCasts","extraCastsPerMinute","earlyCastsComment","earlyCasts","hadExtraCasts","noExtraCasts","positon","AFFECTED_BY_SAVAGE_ROAR","MELEE","SavageRoar","bonusDmg","increase","raw","getDamageBonus","SOUL_OF_THE_FOREST_TALENT_FERAL","getPercentageOfTotalDamageDone","ItemDamageDone","TigersFuryEnergy","shouldIgnoreEnergyWaste","predator","getGeneratedBySpell","getWastedBySpell","Shadowmeld","wastedDuringStealth","correctUses","totalUses","onRake","onShadowmeld","possibleUses","efficiencyThresholds","Fragment","wastedDuringStealthThresholds","FINISHERS","FinisherUse","totalFinishers","notFullComboFinishers","badFinishers","freshRips","upgradingRips","_castSpell","fractionBadFinishers","finisher","element","wasStatePowerUpgrade","badFinishersThresholds","ripSnapshot","Checklist","combatants","selected","preparationRuleAnalyzer","swipeHitCount","comboPointDetails","savageRoar","finisherUse","energyCapTracker","rakeSnapshot","moonfireSnapshot","predatorySwiftness","BaseChecklist","Combatants","CastEfficiency","PreparationRuleAnalyzer","BrutalSlashHitCount","ThrashHitCount","CombatLogParser","CoreCombatLogParser","specModules","rakeBleed","bleedDebuffEvents","comboPointsFromAoE","alwaysBeCasting","buffs","cooldownThroughputTracker","energyDetails","checklist","thrashHitCount","brutalSlashHitCount","Icon","other","xmlns","viewBox","d","total","reduce","sum","background","chartSize","innerRadiusFactor","data","spec","mark","innerRadius","encoding","theta","field","legend","scale","domain","range","view","stroke","renderLegend","renderChart","PureComponent","defaultProps","children","bodyStyle","others","STATISTIC_CATEGORY","GENERAL","HIT_TYPES_THAT_REFUND","atCap","regenState","prevSpender","hasReportedBelowCap","debugErrorSum","debugGreatestError","debugAccuracyCheckCount","currentMaxResourceWithFallback","regen","naturalRegenRate","fight","start_time","energize","onEnergize","drain","onDrain","ChangeHaste","onChangeHaste","predictValue","getBaseRegenRate","isNaN","before","applyEnergize","r","buffHistory","getBuffHistory","buff","start","end","updateState","end_time","applyCumulatively","energizersToApplyCumulatively","time","eventResource","shouldAccumulate","isLastUpdateRecent","getCost","castsToApplyCumulatively","refund","getReducedDrain","buffChangesResourceMax","buffsChangeRegen","buffChangesRegen","oldState","newState","durationCapped","timeCappedBetweenStates","onBelowCap","reachCap","predictReachValue","Infinity","onAtCap","calculated","currentMaxResource","startValue","targetValue","elapsed","predicted","fabricateEndCap","fabricateBeginCap","eventEmitter","fabricateEvent","EventEmitter","Haste","drainsToApplyCumulatively"],"mappings":"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","file":"static/js/FeralDruid.d71f35dc.chunk.js","sourcesContent":["import SPELLS from 'common/SPELLS/index';\r\nimport EventsNormalizer from 'parser/core/EventsNormalizer';\r\nimport { EventType } from 'parser/core/Events';\r\n\r\nconst CAST_WINDOW = 100;\r\n\r\nclass RakeBleed extends EventsNormalizer {\r\n  /**\r\n   * When used from stealth SPELLS.RAKE cast event often appears after the SPELLS.RAKE_BLEED\r\n   * applydebuff event that it causes. (Possibly this misordering has something to do with Rake\r\n   * from stealth also attempting to apply a stun debuff.)\r\n   * This normalizes events so the bleed applydebuff always comes after cast.\r\n   *\r\n   * Example log: https://www.warcraftlogs.com/reports/bt2x7pkqJ6XBjPam#fight=last\r\n   * Player Anatta at times: 0:00.900, 0:33.296, 3:35.127\r\n   *\r\n   * @param {Array} events\r\n   * @returns {Array} Events possibly with some rake debuff events reordered and their timestamp altered.\r\n   */\r\n  normalize(events) {\r\n    const fixedEvents = [];\r\n    for (let eventIndex = 0; eventIndex < events.length; eventIndex += 1) {\r\n      const castEvent = events[eventIndex];\r\n      fixedEvents.push(castEvent);\r\n\r\n      if (castEvent.type !== EventType.Cast || castEvent.ability.guid !== SPELLS.RAKE.id) {\r\n        continue;\r\n      }\r\n\r\n      // look for matching recent applydebuff or refreshdebuff of RAKE_BLEED\r\n      for (let previousEventIndex = eventIndex; previousEventIndex >= 0; previousEventIndex -= 1) {\r\n        const previousEvent = fixedEvents[previousEventIndex];\r\n        if ((castEvent.timestamp - previousEvent.timestamp) > CAST_WINDOW) {\r\n          // looked far enough back that we're outside the cast's time window, so give up\r\n          break;\r\n        }\r\n        if ((previousEvent.type === EventType.ApplyDebuff || previousEvent.type === EventType.RefreshDebuff) &&\r\n          previousEvent.ability.guid === SPELLS.RAKE_BLEED.id &&\r\n          previousEvent.targetID === castEvent.targetID &&\r\n          previousEvent.targetInstance === castEvent.targetInstance &&\r\n          previousEvent.sourceID === castEvent.sourceID) {\r\n          // the \"wrong\" version of this event has already been added to fixedEvents, so remove it and place in new position\r\n          fixedEvents.splice(previousEventIndex, 1);\r\n          fixedEvents.push(previousEvent);\r\n\r\n          // adjust timestamp so the altered event stream doesn't appear to go backwards\r\n          previousEvent.timestamp = castEvent.timestamp;\r\n          previousEvent.__modified = true;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    /*\r\n    events.forEach((event, eventIndex) => {\r\n    fixedEvents.push(event);\r\n\r\n    // find a cast event for rake\r\n    if(event.type === EventType.Cast && event.ability.guid === SPELLS.RAKE.id) {\r\n      const castTimestamp = event.timestamp;\r\n\r\n      // look for matching recent applydebuff or refreshdebuff of RAKE_BLEED\r\n      for (let previousEventIndex = eventIndex; previousEventIndex >= 0; previousEventIndex -= 1) {\r\n        const previousEvent = fixedEvents[previousEventIndex];\r\n        if ((castTimestamp - previousEvent.timestamp) > CAST_WINDOW) {\r\n          break;\r\n        }\r\n        if ((previousEvent.type === EventType.ApplyDebuff || previousEvent.type === EventType.RefreshDebuff) &&\r\n            previousEvent.ability.guid === SPELLS.RAKE_BLEED.id &&\r\n            previousEvent.targetID === event.targetID &&\r\n            previousEvent.targetInstance === event.targetInstance &&\r\n            previousEvent.sourceID === event.sourceID) {\r\n          fixedEvents.splice(previousEventIndex, 1);\r\n          fixedEvents.push(previousEvent);\r\n          // adjust timestamp so the event stream doesn't have\r\n          previousEvent.timestamp = castTimestamp;\r\n          previousEvent.__modified = true;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n    */\r\n\r\n    return fixedEvents;\r\n  }\r\n}\r\n\r\nexport default RakeBleed;\r\n","import SPELLS from 'common/SPELLS/index';\r\nimport RESOURCE_TYPES from 'game/RESOURCE_TYPES';\r\nimport HIT_TYPES from 'game/HIT_TYPES';\r\nimport EventsNormalizer from 'parser/core/EventsNormalizer';\r\nimport { EventType } from 'parser/core/Events';\r\n\r\nconst debug = false;\r\n\r\n// time after a cast event to consider a damage event as possibly belonging to that cast\r\nconst ABILITY_DAMAGE_WINDOW = 250; //ms\r\nconst INVISIBLE_ENERGIZE_ATTACKS = [\r\n  SPELLS.THRASH_FERAL.id,\r\n  SPELLS.SWIPE_CAT.id,\r\n  SPELLS.BRUTAL_SLASH_TALENT.id,\r\n];\r\nconst HIT_TYPES_THAT_DONT_ENERGIZE = [\r\n  HIT_TYPES.MISS,\r\n  HIT_TYPES.DODGE,\r\n  HIT_TYPES.PARRY,\r\n  HIT_TYPES.IMMUNE,\r\n];\r\n\r\n// unlike rogues, feral druids always have a maximum of 5 combo points\r\nconst MAX_COMBO = 5;\r\n\r\n/**\r\n * The Feral AoE abilities Swipe, Thrash, and Brutal Slash generate 1 combo point if they\r\n * hit a target, but that combo point generation is not shown in the combat log.\r\n * Because damage events are often slightly delayed from the cast event, confirmation\r\n * that one of these abilities actually generated a combo point can come too late for\r\n * some work that analyzers need to do. Especially problematic due to Primal Fury generating\r\n * an extra combo point when a generator crits, which usually comes before the damage\r\n * event(s) for that generator. This can lead to wasted energizes being blamed on the\r\n * wrong spell.\r\n *\r\n * This normalizer creates an appropriate energize event when the player uses one of these\r\n * abilities and has it hit at least 1 target. The created event is backdated (by timestamp\r\n * and position in the event stream) to when the ability was cast, so it correctly appears\r\n * before any Primal Fury proc associated with the ability use.\r\n */\r\nclass ComboPointsFromAoE extends EventsNormalizer {\r\n  playerId = null;\r\n\r\n  constructor(options) {\r\n    super(options);\r\n\r\n    // when being tested this.owner may be null (the test will set playerId)\r\n    this.playerId = this.owner ? this.owner.playerId : null;\r\n  }\r\n\r\n  normalize(events) {\r\n    const fixedEvents = [];\r\n\r\n    // Keep track of combo points so an accurate energize event can be fabricated\r\n    let combo = 0;\r\n\r\n    let castEvent = null;\r\n    let castEventIndex = null;\r\n    let comboAtCast = null;\r\n\r\n    // When adding new events the indexing of original events and fixedEvents will become offset\r\n    let fixedEventIndex = 0;\r\n\r\n    events.forEach(event => {\r\n      const eventComboResource = this.getResource(event, RESOURCE_TYPES.COMBO_POINTS.id);\r\n\r\n      if ((event.type === EventType.Energize) && (event.targetID === this.playerId) &&\r\n        (event.resourceChangeType === RESOURCE_TYPES.COMBO_POINTS.id)) {\r\n        // Gained combo points.\r\n        combo = Math.min(MAX_COMBO, combo + (event.resourceChange - event.waste));\r\n      }\r\n      if ((event.type === EventType.Cast) && (event.sourceID === this.playerId) &&\r\n        eventComboResource && eventComboResource.cost) {\r\n        // Spent combo points, which always puts a Feral druid back to 0\r\n        combo = 0;\r\n      }\r\n\r\n      if ((event.type === EventType.Cast) && (event.sourceID === this.playerId) &&\r\n        INVISIBLE_ENERGIZE_ATTACKS.includes(event.ability.guid)) {\r\n        // Cast an ability that may have generated a combo point, but we don't know until it does damage.\r\n        castEvent = event;\r\n        castEventIndex = fixedEventIndex;\r\n        comboAtCast = combo;\r\n        debug && console.log('invisible combo generator cast, awaiting confirmation of it hitting..');\r\n      }\r\n\r\n      if ((event.type === EventType.Energize) && (event.sourceID === this.playerId) &&\r\n        (event.resourceChangeType === RESOURCE_TYPES.COMBO_POINTS.id) &&\r\n        INVISIBLE_ENERGIZE_ATTACKS.includes(event.ability.guid) && !event.__fabricated &&\r\n        castEvent && (castEvent.ability.guid === event.ability.guid) &&\r\n        ((event.timestamp - castEvent.timestamp < 100))) {\r\n        // Detected a combo point energize event from an ability that should never be generating energize events, likely due to a Blizzard or WCL change.\r\n        debug && console.warn(`Detected energize event from an ability that isn't expected to produce energize events. The ComboPointsFromAoE normalizer may no longer be needed for ${event.ability.name} (${event.ability.guid})`);\r\n\r\n        // There's already an energize event for castEvent so prevent generation of another one.\r\n        castEvent = null;\r\n      }\r\n\r\n      if ((event.type === EventType.Damage) && (event.sourceID === this.playerId) &&\r\n        castEvent && (castEvent.ability.guid === event.ability.guid) &&\r\n        ((event.timestamp - castEvent.timestamp) < ABILITY_DAMAGE_WINDOW) &&\r\n        !event.tick && !HIT_TYPES_THAT_DONT_ENERGIZE.includes(event.hitType)) {\r\n        // We now know that the last castEvent hit and so did produce a combo point.\r\n        const fabricatedEnergize = {\r\n          __fabricated: true,\r\n          type: EventType.Energize,\r\n          timestamp: castEvent.timestamp,\r\n          ability: castEvent.ability,\r\n          sourceID: this.playerId,\r\n          sourceIsFriendly: true,\r\n          targetID: this.playerId,\r\n          targetIsFriendly: true,\r\n          resourceChangeType: RESOURCE_TYPES.COMBO_POINTS.id,\r\n          resourceChange: 1,\r\n          waste: (comboAtCast === MAX_COMBO) ? 1 : 0,\r\n        };\r\n        combo = Math.min(MAX_COMBO, combo + (fabricatedEnergize.resourceChange - fabricatedEnergize.waste));\r\n        debug && console.log('confirmed hidden combo generation.');\r\n        debug && console.log(fabricatedEnergize);\r\n\r\n        // Place the energize event immediately after the cast event, so it's before any Primal Fury proc.\r\n        fixedEvents.splice(castEventIndex + 1, 0, fabricatedEnergize);\r\n        fixedEventIndex += 1;\r\n\r\n        // Prevent triggering more than one event fabrication per cast.\r\n        castEvent = null;\r\n      }\r\n\r\n      fixedEvents.push(event);\r\n      fixedEventIndex += 1;\r\n    });\r\n    return fixedEvents;\r\n  }\r\n\r\n  getResource(event, type) {\r\n    if (!event || !event.classResources) {\r\n      return null;\r\n    }\r\n    return event.classResources.find(resource => (resource.type === type));\r\n  }\r\n}\r\n\r\nexport default ComboPointsFromAoE;\r\n","import SPELLS from 'common/SPELLS/index';\r\nimport EventsNormalizer from 'parser/core/EventsNormalizer';\r\nimport { EventType } from 'parser/core/Events';\r\n\r\nconst CAST_WINDOW = 300;\r\nconst CAST_DEBUFF_PAIRS = [\r\n  {\r\n    cast: SPELLS.RIP,\r\n    debuff: SPELLS.RIP,\r\n  },\r\n  {\r\n    cast: SPELLS.RAKE,\r\n    debuff: SPELLS.RAKE_BLEED,\r\n  },\r\n  {\r\n    cast: SPELLS.MOONFIRE_FERAL,\r\n    debuff: SPELLS.MOONFIRE_BEAR,\r\n  },\r\n  {\r\n    cast: SPELLS.THRASH_FERAL,\r\n    debuff: SPELLS.THRASH_FERAL,\r\n    multipleDebuffs: true,\r\n  },\r\n  {\r\n    cast: SPELLS.PRIMAL_WRATH_TALENT,\r\n    debuff: SPELLS.RIP,\r\n    multipleDebuffs: true,\r\n  },\r\n];\r\n\r\nclass BleedDebuffEvents extends EventsNormalizer {\r\n  /**\r\n   * When analyzing the effect of a cast event it's often necessary to know about what debuff application that cast\r\n   * caused. Typically this is handled by listening for both the cast and applydebuff or refreshdebuff\r\n   * events, and combining the information from them to form an analysis. That delays full analysis of a cast event\r\n   * until after the associated debuff event has been processed.\r\n   * Normally this isn't a problem but if another module relies on the result of that cast event analysis it will\r\n   * also have to wait for future events before it can trust the result from the module it relies on. This can lead\r\n   * to some messy coupling between modules.\r\n   *\r\n   * This normalizer attempts to link specified cast events with appropriate debuff apply/refresh events. This way\r\n   * a module that needs to know about the debuff event caused by a cast event can directly access that event through\r\n   * the cast event. It's important that the module design is aware that when doing so the debuff event will have not\r\n   * yet been processed by anything else. e.g. an entity.hasDebuff query will not yet see the debuff.\r\n   *\r\n   * @param {Array} events\r\n   * @returns {Array} Events with some cast events having gained a .debuffEvents property, which is an array of applydebuff and/or refreshdebuff events.\r\n   */\r\n  normalize(events) {\r\n    const fixedEvents = [];\r\n    for (let castEventIndex = 0; castEventIndex < events.length; castEventIndex += 1) {\r\n      const castEvent = events[castEventIndex];\r\n      fixedEvents.push(castEvent);\r\n      if (castEvent.type !== EventType.Cast) {\r\n        continue;\r\n      }\r\n      const pair = CAST_DEBUFF_PAIRS.find(item => item.cast.id === castEvent.ability.guid);\r\n      if (!pair) {\r\n        continue;\r\n      }\r\n      castEvent.__modified = true;\r\n      castEvent.debuffEvents = [];\r\n      // found a suitable cast event so now look forward for debuff events\r\n      // note: debuff events usually appear after associated cast events - make sure this normalizer runs after any that enforce that.\r\n      for (let debuffEventIndex = castEventIndex; debuffEventIndex < events.length; debuffEventIndex += 1) {\r\n        const debuffEvent = events[debuffEventIndex];\r\n        if (debuffEvent.timestamp > castEvent.timestamp + CAST_WINDOW) {\r\n          // if this event is past the time limit then can assume any future events will also be past the time limit, so stop looking.\r\n          break;\r\n        }\r\n        if (debuffEvent.type !== EventType.ApplyDebuff && debuffEvent.type !== EventType.RefreshDebuff) {\r\n          continue;\r\n        }\r\n        if (debuffEvent.ability.guid !== pair.debuff.id) {\r\n          continue;\r\n        }\r\n        castEvent.debuffEvents.push(debuffEvent);\r\n        if (!pair.multipleDebuffs) {\r\n          // the cast is only expected to produce one debuff event, so stop searching for more\r\n          break;\r\n        }\r\n      }\r\n    }\r\n    return fixedEvents;\r\n  }\r\n}\r\n\r\nexport default BleedDebuffEvents;\r\n","import SPELLS from 'common/SPELLS';\r\n\r\nimport CoreAbilities from 'parser/core/modules/Abilities';\r\n\r\nclass Abilities extends CoreAbilities {\r\n  spellbook() {\r\n    const combatant = this.selectedCombatant;\r\n    return [\r\n      {\r\n        spell: SPELLS.SHRED,\r\n        category: Abilities.SPELL_CATEGORIES.ROTATIONAL,\r\n        gcd: {\r\n          static: 1000,\r\n        },\r\n        timelineSortIndex: 1,\r\n        primaryCoefficient: 0.380562,\r\n      },\r\n      {\r\n        spell: SPELLS.RAKE,\r\n        category: Abilities.SPELL_CATEGORIES.ROTATIONAL,\r\n        gcd: {\r\n          static: 1000,\r\n        },\r\n        timelineSortIndex: 2,\r\n        primaryCoefficient: 0.1822, // initial damage, not DoT damage\r\n      },\r\n      {\r\n        spell: SPELLS.RIP,\r\n        category: Abilities.SPELL_CATEGORIES.ROTATIONAL,\r\n        gcd: {\r\n          static: 1000,\r\n        },\r\n        timelineSortIndex: 5,\r\n        primaryCoefficient: 0.125, // damage per tick\r\n      },\r\n      {\r\n        spell: SPELLS.FEROCIOUS_BITE,\r\n        category: Abilities.SPELL_CATEGORIES.ROTATIONAL,\r\n        gcd: {\r\n          static: 1000,\r\n        },\r\n        timelineSortIndex: 6,\r\n      },\r\n      {\r\n        spell: SPELLS.SAVAGE_ROAR_TALENT,\r\n        category: Abilities.SPELL_CATEGORIES.ROTATIONAL,\r\n        enabled: combatant.hasTalent(SPELLS.SAVAGE_ROAR_TALENT.id),\r\n        gcd: {\r\n          static: 1000,\r\n        },\r\n        timelineSortIndex: 7,\r\n      },\r\n      {\r\n        spell: SPELLS.MOONFIRE_FERAL,\r\n        category: Abilities.SPELL_CATEGORIES.ROTATIONAL,\r\n        enabled: combatant.hasTalent(SPELLS.LUNAR_INSPIRATION_TALENT.id),\r\n        gcd: {\r\n          base: 1000,\r\n        },\r\n        timelineSortIndex: 3,\r\n        primaryCoefficient: 0.15, // initial damage, not DoT damage\r\n      },\r\n\r\n      {\r\n        spell: SPELLS.THRASH_FERAL,\r\n        category: Abilities.SPELL_CATEGORIES.ROTATIONAL_AOE,\r\n        gcd: {\r\n          static: 1000,\r\n        },\r\n        timelineSortIndex: 10,\r\n        primaryCoefficient: 0.055, // initial damage, not DoT damage\r\n      },\r\n      {\r\n        spell: SPELLS.PRIMAL_WRATH_TALENT,\r\n        category: Abilities.SPELL_CATEGORIES.ROTATIONAL_AOE,\r\n        enabled: combatant.hasTalent(SPELLS.PRIMAL_WRATH_TALENT.id),\r\n        gcd: {\r\n          static: 1000,\r\n        },\r\n        timelineSortIndex: 5,\r\n      },\r\n      {\r\n        spell: SPELLS.SWIPE_CAT,\r\n        category: Abilities.SPELL_CATEGORIES.ROTATIONAL_AOE,\r\n        enabled: !combatant.hasTalent(SPELLS.BRUTAL_SLASH_TALENT.id),\r\n        gcd: {\r\n          static: 1000,\r\n        },\r\n        timelineSortIndex: 11,\r\n        primaryCoefficient: 0.25,\r\n      },\r\n      {\r\n        spell: SPELLS.BRUTAL_SLASH_TALENT,\r\n        category: Abilities.SPELL_CATEGORIES.ROTATIONAL, // when taken, still used on single target\r\n        enabled: combatant.hasTalent(SPELLS.BRUTAL_SLASH_TALENT.id),\r\n        cooldown: haste => 8 / (1 + haste),\r\n        charges: 3,\r\n        castEfficiency: {\r\n          suggestion: true,\r\n        },\r\n        gcd: {\r\n          static: 1000,\r\n        },\r\n        timelineSortIndex: 11,\r\n        primaryCoefficient: 0.69,\r\n      },\r\n      {\r\n        spell: SPELLS.SWIPE_BEAR,\r\n        category: Abilities.SPELL_CATEGORIES.ROTATIONAL_AOE,\r\n        enabled: !combatant.hasTalent(SPELLS.BRUTAL_SLASH_TALENT.id),\r\n        gcd: {\r\n          base: 1500,\r\n        },\r\n        timelineSortIndex: 11,\r\n        primaryCoefficient: 0.30,\r\n      },\r\n\r\n      {\r\n        spell: SPELLS.INCARNATION_KING_OF_THE_JUNGLE_TALENT,\r\n        category: Abilities.SPELL_CATEGORIES.COOLDOWNS,\r\n        cooldown: 180,\r\n        enabled: combatant.hasTalent(SPELLS.INCARNATION_KING_OF_THE_JUNGLE_TALENT.id),\r\n        castEfficiency: {\r\n          suggestion: true,\r\n          recommendedEfficiency: 0.90,\r\n        },\r\n        // likely a Blizzard bug, probably intended to match Berserk's 1000 fixed\r\n        gcd: {\r\n          base: 1000,\r\n        },\r\n        timelineSortIndex: 22,\r\n      },\r\n      {\r\n        spell: SPELLS.BERSERK,\r\n        category: Abilities.SPELL_CATEGORIES.COOLDOWNS,\r\n        cooldown: 180,\r\n        enabled: !combatant.hasTalent(SPELLS.INCARNATION_KING_OF_THE_JUNGLE_TALENT.id),\r\n        castEfficiency: {\r\n          suggestion: true,\r\n          recommendedEfficiency: 0.90,\r\n        },\r\n        gcd: {\r\n          static: 1000,\r\n        },\r\n        timelineSortIndex: 22,\r\n      },\r\n      {\r\n        spell: SPELLS.TIGERS_FURY,\r\n        category: Abilities.SPELL_CATEGORIES.COOLDOWNS,\r\n        cooldown: 30,\r\n        castEfficiency: {\r\n          suggestion: true,\r\n          // Predator may reset the cooldown very frequently, more often than is useful to use the ability\r\n          recommendedEfficiency: (combatant.hasTalent(SPELLS.PREDATOR_TALENT.id) ? 0.50 : 0.80),\r\n        },\r\n        gcd: null,\r\n        timelineSortIndex: 20,\r\n      },\r\n      {\r\n        spell: SPELLS.FERAL_FRENZY_TALENT,\r\n        category: Abilities.SPELL_CATEGORIES.COOLDOWNS,\r\n        enabled: combatant.hasTalent(SPELLS.FERAL_FRENZY_TALENT.id),\r\n        cooldown: 45,\r\n        castEfficiency: {\r\n          suggestion: true,\r\n        },\r\n        gcd: {\r\n          static: 1000,\r\n        },\r\n        timelineSortIndex: 21,\r\n      },\r\n      {\r\n        spell: SPELLS.REGROWTH,\r\n        category: Abilities.SPELL_CATEGORIES.UTILITY,\r\n        gcd: {\r\n          base: (combatant => (combatant.hasBuff(SPELLS.CAT_FORM.id) ? 1000 : 1500)),\r\n        },\r\n        timelineSortIndex: 30,\r\n      },\r\n      {\r\n        spell: SPELLS.ENTANGLING_ROOTS,\r\n        category: Abilities.SPELL_CATEGORIES.UTILITY,\r\n        gcd: {\r\n          base: (combatant => (combatant.hasBuff(SPELLS.CAT_FORM.id) ? 1000 : 1500)),\r\n        },\r\n        timelineSortIndex: 31,\r\n      },\r\n      {\r\n        spell: SPELLS.MAIM,\r\n        category: Abilities.SPELL_CATEGORIES.UTILITY,\r\n        cooldown: 20,\r\n        gcd: {\r\n          static: 1000,\r\n        },\r\n        timelineSortIndex: 32,\r\n        primaryCoefficient: 0.092, // damage per combo point\r\n      },\r\n      {\r\n        spell: SPELLS.DASH,\r\n        category: Abilities.SPELL_CATEGORIES.UTILITY,\r\n        enabled: !combatant.hasTalent(SPELLS.TIGER_DASH_TALENT.id),\r\n        cooldown: 120,\r\n        gcd: (combatant => {\r\n          if (combatant.hasBuff(SPELLS.CAT_FORM.id)) {\r\n            // off the GCD if player is already in cat form\r\n            return null;\r\n          }\r\n          return {\r\n            static: 1500,\r\n          };\r\n        }),\r\n        isDefensive: true,\r\n        timelineSortIndex: 43,\r\n      },\r\n      {\r\n        spell: SPELLS.TIGER_DASH_TALENT,\r\n        category: Abilities.SPELL_CATEGORIES.UTILITY,\r\n        enabled: combatant.hasTalent(SPELLS.TIGER_DASH_TALENT.id),\r\n        cooldown: 45,\r\n        gcd: (combatant => {\r\n          if (combatant.hasBuff(SPELLS.CAT_FORM.id)) {\r\n            // off the GCD if player is already in cat form\r\n            return null;\r\n          }\r\n          return {\r\n            static: 1500,\r\n          };\r\n        }),\r\n        isDefensive: true,\r\n        timelineSortIndex: 43,\r\n      },\r\n      {\r\n        spell: [SPELLS.STAMPEDING_ROAR_HUMANOID, SPELLS.STAMPEDING_ROAR_CAT, SPELLS.STAMPEDING_ROAR_BEAR],\r\n        category: Abilities.SPELL_CATEGORIES.UTILITY,\r\n        cooldown: 120,\r\n        gcd: (combatant => {\r\n          if (combatant.hasBuff(SPELLS.CAT_FORM.id)) {\r\n            return {\r\n              base: 1000,\r\n            };\r\n          }\r\n          if (combatant.hasBuff(SPELLS.BEAR_FORM.id)) {\r\n            return {\r\n              base: 1500,\r\n            };\r\n          }\r\n          return {\r\n            static: 1500,\r\n          };\r\n        }),\r\n        isDefensive: true,\r\n        timelineSortIndex: 44,\r\n      },\r\n      {\r\n        spell: [SPELLS.SKULL_BASH, SPELLS.SKULL_BASH_FERAL],\r\n        category: Abilities.SPELL_CATEGORIES.UTILITY,\r\n        gcd: null,\r\n        cooldown: 15,\r\n        timelineSortIndex: 33,\r\n      },\r\n      {\r\n        spell: [SPELLS.PROWL, SPELLS.PROWL_INCARNATION],\r\n        category: Abilities.SPELL_CATEGORIES.UTILITY,\r\n        // 6 second cooldown, but triggered by leaving stealth not by using Prowl.\r\n        gcd: null,\r\n        timelineSortIndex: 25,\r\n      },\r\n      {\r\n        spell: SPELLS.SHADOWMELD,\r\n        category: Abilities.SPELL_CATEGORIES.UTILITY,\r\n        cooldown: 120,\r\n        isUndetectable: true,\r\n        gcd: null,\r\n        timelineSortIndex: 24,\r\n      },\r\n      {\r\n        spell: SPELLS.SURVIVAL_INSTINCTS,\r\n        category: Abilities.SPELL_CATEGORIES.DEFENSIVE,\r\n        cooldown: 120,\r\n        charges: 2,\r\n        gcd: null,\r\n        isDefensive: true,\r\n        timelineSortIndex: 40,\r\n      },\r\n      {\r\n        spell: SPELLS.REBIRTH,\r\n        category: Abilities.SPELL_CATEGORIES.UTILITY,\r\n        gcd: {\r\n          base: 1500,\r\n        },\r\n        // 10 minute cooldown usually, but shares the group-wide charge system during raid bosses and M+\r\n        timelineSortIndex: 60,\r\n      },\r\n      {\r\n        spell: SPELLS.MIGHTY_BASH_TALENT,\r\n        category: Abilities.SPELL_CATEGORIES.UTILITY,\r\n        enabled: combatant.hasTalent(SPELLS.MIGHTY_BASH_TALENT.id),\r\n        cooldown: 50,\r\n        gcd: {\r\n          base: 1500,\r\n        },\r\n        timelineSortIndex: 34,\r\n      },\r\n      {\r\n        spell: SPELLS.MASS_ENTANGLEMENT_TALENT,\r\n        category: Abilities.SPELL_CATEGORIES.UTILITY,\r\n        enabled: combatant.hasTalent(SPELLS.MASS_ENTANGLEMENT_TALENT.id),\r\n        cooldown: 30,\r\n        gcd: {\r\n          base: 1500,\r\n        },\r\n        timelineSortIndex: 34,\r\n      },\r\n      {\r\n        spell: SPELLS.TYPHOON,\r\n        category: Abilities.SPELL_CATEGORIES.UTILITY,\r\n        enabled: combatant.hasTalent(SPELLS.TYPHOON_TALENT.id),\r\n        cooldown: 30,\r\n        gcd: {\r\n          base: 1500,\r\n        },\r\n        timelineSortIndex: 35,\r\n      },\r\n      {\r\n        spell: SPELLS.HIBERNATE,\r\n        category: Abilities.SPELL_CATEGORIES.UTILITY,\r\n        gcd: {\r\n          base: 1500,\r\n        },\r\n        timelineSortIndex: 36,\r\n      },\r\n      {\r\n        spell: SPELLS.SOOTHE,\r\n        category: Abilities.SPELL_CATEGORIES.UTILITY,\r\n        cooldown: 10,\r\n        gcd: {\r\n          base: 1500,\r\n        },\r\n        timelineSortIndex: 37,\r\n      },\r\n      {\r\n        spell: SPELLS.RENEWAL_TALENT,\r\n        category: Abilities.SPELL_CATEGORIES.DEFENSIVE,\r\n        enabled: combatant.hasTalent(SPELLS.RENEWAL_TALENT.id),\r\n        cooldown: 90,\r\n        gcd: null,\r\n        isDefensive: true,\r\n        timelineSortIndex: 42,\r\n      },\r\n      {\r\n        spell: [SPELLS.WILD_CHARGE_TALENT, SPELLS.WILD_CHARGE_MOONKIN, SPELLS.WILD_CHARGE_CAT, SPELLS.WILD_CHARGE_BEAR, SPELLS.WILD_CHARGE_TRAVEL],\r\n        category: Abilities.SPELL_CATEGORIES.UTILITY,\r\n        cooldown: 15,\r\n        enabled: combatant.hasTalent(SPELLS.WILD_CHARGE_TALENT.id),\r\n        gcd: null,\r\n        timelineSortIndex: 42,\r\n      },\r\n      {\r\n        spell: SPELLS.BEAR_FORM,\r\n        category: Abilities.SPELL_CATEGORIES.DEFENSIVE,\r\n        gcd: {\r\n          base: 1500,\r\n        },\r\n        isDefensive: true,\r\n        timelineSortIndex: 51,\r\n      },\r\n      {\r\n        spell: SPELLS.CAT_FORM,\r\n        category: Abilities.SPELL_CATEGORIES.UTILITY,\r\n        gcd: {\r\n          base: 1500,\r\n        },\r\n        timelineSortIndex: 50,\r\n      },\r\n      {\r\n        spell: SPELLS.MOONKIN_FORM_AFFINITY,\r\n        category: Abilities.SPELL_CATEGORIES.UTILITY,\r\n        // only has a cooldown for feral spec\r\n        cooldown: 90,\r\n        enabled: combatant.hasTalent(SPELLS.BALANCE_AFFINITY_TALENT_SHARED.id),\r\n        gcd: {\r\n          base: 1500,\r\n        },\r\n        timelineSortIndex: 54,\r\n      },\r\n      {\r\n        spell: SPELLS.TRAVEL_FORM,\r\n        category: Abilities.SPELL_CATEGORIES.UTILITY,\r\n        gcd: {\r\n          base: 1500,\r\n        },\r\n        timelineSortIndex: 52,\r\n      },\r\n      {\r\n        spell: SPELLS.STAG_FORM,\r\n        category: Abilities.SPELL_CATEGORIES.UTILITY,\r\n        gcd: {\r\n          base: 1500,\r\n        },\r\n        timelineSortIndex: 53,\r\n      },\r\n      {\r\n        spell: SPELLS.GROWL,\r\n        category: Abilities.SPELL_CATEGORIES.UTILITY,\r\n        gcd: null,\r\n        cooldown: 8,\r\n      },\r\n      {\r\n        spell: SPELLS.MANGLE_BEAR,\r\n        category: Abilities.SPELL_CATEGORIES.OTHERS,\r\n        gcd: {\r\n          base: 1500,\r\n        },\r\n        cooldown: haste => 6 / (1 + haste),\r\n      },\r\n      {\r\n        spell: SPELLS.THRASH_BEAR,\r\n        category: Abilities.SPELL_CATEGORIES.OTHERS,\r\n        gcd: {\r\n          base: 1500,\r\n        },\r\n        cooldown: haste => 6 / (1 + haste),\r\n      },\r\n      {\r\n        // Moonfire from caster, bear, and moonkin forms. See MOONFIRE_FERAL for cat\r\n        spell: SPELLS.MOONFIRE,\r\n        category: Abilities.SPELL_CATEGORIES.OTHERS,\r\n        gcd: {\r\n          base: 1500,\r\n        },\r\n      },\r\n      {\r\n        spell: SPELLS.REMOVE_CORRUPTION,\r\n        category: Abilities.SPELL_CATEGORIES.UTILITY,\r\n        gcd: {\r\n          base: 1500,\r\n        },\r\n        // 8 second cooldown if it removed something, no cooldown otherwise\r\n      },\r\n      {\r\n        // cannot be cast when player is in combat\r\n        spell: SPELLS.REVIVE,\r\n        category: Abilities.SPELL_CATEGORIES.UTILITY,\r\n        gcd: {\r\n          base: 1500,\r\n        },\r\n      },\r\n      {\r\n        spell: SPELLS.LUNAR_STRIKE_AFFINITY,\r\n        category: Abilities.SPELL_CATEGORIES.OTHERS,\r\n        enabled: combatant.hasTalent(SPELLS.BALANCE_AFFINITY_TALENT_SHARED.id),\r\n        gcd: {\r\n          base: 1500,\r\n        },\r\n      },\r\n      {\r\n        spell: SPELLS.SOLAR_WRATH_AFFINITY,\r\n        category: Abilities.SPELL_CATEGORIES.OTHERS,\r\n        enabled: combatant.hasTalent(SPELLS.BALANCE_AFFINITY_TALENT_SHARED.id),\r\n        gcd: {\r\n          base: 1500,\r\n        },\r\n      },\r\n      {\r\n        spell: SPELLS.STARSURGE_AFFINITY,\r\n        category: Abilities.SPELL_CATEGORIES.OTHERS,\r\n        enabled: combatant.hasTalent(SPELLS.BALANCE_AFFINITY_TALENT_SHARED.id),\r\n        gcd: {\r\n          base: 1500,\r\n        },\r\n        cooldown: 10,\r\n      },\r\n      {\r\n        spell: SPELLS.SUNFIRE_AFFINITY,\r\n        category: Abilities.SPELL_CATEGORIES.OTHERS,\r\n        enabled: combatant.hasTalent(SPELLS.BALANCE_AFFINITY_TALENT_SHARED.id),\r\n        gcd: {\r\n          base: 1500,\r\n        },\r\n      },\r\n      {\r\n        spell: SPELLS.FLAP,\r\n        category: Abilities.SPELL_CATEGORIES.UTILITY,\r\n        // only usable in Moonkin form so need Balance affinity, also need to learn from a tome\r\n        enabled: combatant.hasTalent(SPELLS.BALANCE_AFFINITY_TALENT_SHARED.id),\r\n        gcd: {\r\n          static: 500,\r\n        },\r\n      },\r\n      {\r\n        spell: SPELLS.IRONFUR,\r\n        category: Abilities.SPELL_CATEGORIES.DEFENSIVE,\r\n        enabled: combatant.hasTalent(SPELLS.GUARDIAN_AFFINITY_TALENT_FERAL.id),\r\n        gcd: null,\r\n        cooldown: 0.5,\r\n      },\r\n      {\r\n        spell: SPELLS.FRENZIED_REGENERATION,\r\n        category: Abilities.SPELL_CATEGORIES.DEFENSIVE,\r\n        enabled: combatant.hasTalent(SPELLS.GUARDIAN_AFFINITY_TALENT_FERAL.id),\r\n        gcd: {\r\n          base: 1500,\r\n        },\r\n        // unlike Guardian's version doesn't have charges\r\n        cooldown: haste => 36 / (1 + haste),\r\n      },\r\n      {\r\n        spell: SPELLS.REJUVENATION,\r\n        category: Abilities.SPELL_CATEGORIES.UTILITY,\r\n        enabled: combatant.hasTalent(SPELLS.RESTORATION_AFFINITY_TALENT.id),\r\n        gcd: {\r\n          base: 1500,\r\n        },\r\n      },\r\n      {\r\n        spell: SPELLS.SWIFTMEND,\r\n        category: Abilities.SPELL_CATEGORIES.UTILITY,\r\n        enabled: combatant.hasTalent(SPELLS.RESTORATION_AFFINITY_TALENT.id),\r\n        gcd: {\r\n          base: 1500,\r\n        },\r\n        cooldown: 25,\r\n      },\r\n      {\r\n        spell: SPELLS.WILD_GROWTH,\r\n        category: Abilities.SPELL_CATEGORIES.UTILITY,\r\n        enabled: combatant.hasTalent(SPELLS.RESTORATION_AFFINITY_TALENT.id),\r\n        gcd: {\r\n          base: 1500,\r\n        },\r\n        cooldown: 20,\r\n      },\r\n      {\r\n        // learnt from a tome\r\n        spell: SPELLS.TREANT_FORM,\r\n        category: Abilities.SPELL_CATEGORIES.OTHERS,\r\n        gcd: {\r\n          static: 1500,\r\n        },\r\n      },\r\n      {\r\n        // learnt from a tome\r\n        spell: SPELLS.CHARM_WOODLAND_CREATURE,\r\n        category: Abilities.SPELL_CATEGORIES.OTHERS,\r\n        gcd: null,\r\n      },\r\n      {\r\n        // replaced by Dreamwalk early on in the Legion class hall quest line\r\n        spell: SPELLS.TELEPORT_MOONGLADE,\r\n        category: Abilities.SPELL_CATEGORIES.OTHERS,\r\n        gcd: {\r\n          base: 1500,\r\n        },\r\n      },\r\n      {\r\n        // reward from early in the Legion class hall quest line\r\n        spell: SPELLS.TELEPORT_DREAMWALK,\r\n        category: Abilities.SPELL_CATEGORIES.UTILITY,\r\n        gcd: {\r\n          base: 1500,\r\n        },\r\n        cooldown: 60,\r\n      },\r\n    ];\r\n  }\r\n}\r\n\r\nexport default Abilities;\r\n","import SPELLS from 'common/SPELLS';\r\nimport CoreBuffs from 'parser/core/modules/Buffs';\r\nimport BLOODLUST_BUFFS from 'game/BLOODLUST_BUFFS';\r\n\r\nclass Buffs extends CoreBuffs {\r\n  buffs() {\r\n    const combatant = this.selectedCombatant;\r\n\r\n    // This should include ALL buffs that can be applied by your spec.\r\n    // This data can be used by various kinds of modules to improve their results, and modules added in the future may rely on buffs that aren't used today.\r\n    return [\r\n      // rotational\r\n      {\r\n        spellId: SPELLS.BLOODTALONS_BUFF.id,\r\n        enabled: combatant.hasTalent(SPELLS.BLOODTALONS_TALENT),\r\n        triggeredBySpellId: [SPELLS.REGROWTH.id, SPELLS.ENTANGLING_ROOTS.id],\r\n        timelineHighlight: true,\r\n      },\r\n      {\r\n        spellId: SPELLS.PREDATORY_SWIFTNESS.id,\r\n        // only important for rotation when using Bloodtalons, but always available\r\n        timelineHighlight: combatant.hasTalent(SPELLS.BLOODTALONS_TALENT),\r\n      },\r\n      {\r\n        spellId: SPELLS.SAVAGE_ROAR_TALENT.id,\r\n        triggeredBySpellId: SPELLS.SAVAGE_ROAR_TALENT.id,\r\n        enabled: combatant.hasTalent(SPELLS.SAVAGE_ROAR_TALENT),\r\n        timelineHighlight: true,\r\n      },\r\n\r\n      // defensive\r\n      {\r\n        spellId: SPELLS.SURVIVAL_INSTINCTS.id,\r\n        triggeredBySpellId: SPELLS.SURVIVAL_INSTINCTS.id,\r\n        timelineHighlight: true,\r\n      },\r\n      {\r\n        spellId: SPELLS.BEAR_FORM.id,\r\n        triggeredBySpellId: SPELLS.BEAR_FORM.id,\r\n        timelineHighlight: true,\r\n      },\r\n\r\n      // stealth\r\n      {\r\n        spellId: [SPELLS.PROWL.id, SPELLS.PROWL_INCARNATION.id],\r\n        timelineHighlight: true,\r\n      },\r\n      {\r\n        spellId: SPELLS.SHADOWMELD.id,\r\n        triggeredBySpellId: SPELLS.SHADOWMELD.id,\r\n        timelineHighlight: true,\r\n      },\r\n\r\n      // cooldowns\r\n      {\r\n        spellId: SPELLS.TIGERS_FURY.id,\r\n        triggeredBySpellId: SPELLS.TIGERS_FURY.id,\r\n        timelineHighlight: true,\r\n      },\r\n      {\r\n        spellId: SPELLS.BERSERK.id,\r\n        triggeredBySpellId: SPELLS.BERSERK.id,\r\n        enabled: !combatant.hasTalent(SPELLS.INCARNATION_KING_OF_THE_JUNGLE_TALENT),\r\n        timelineHighlight: true,\r\n      },\r\n      {\r\n        spellId: SPELLS.INCARNATION_KING_OF_THE_JUNGLE_TALENT.id,\r\n        triggeredBySpellId: SPELLS.INCARNATION_KING_OF_THE_JUNGLE_TALENT.id,\r\n        enabled: combatant.hasTalent(SPELLS.INCARNATION_KING_OF_THE_JUNGLE_TALENT),\r\n        timelineHighlight: true,\r\n      },\r\n      {\r\n        spellId: Object.keys(BLOODLUST_BUFFS).map(item => Number(item)),\r\n        timelineHighlight: true,\r\n      },\r\n\r\n      // utility\r\n      {\r\n        // it could be useful to see when the combatant is out of cat form, but filling the timeline with a nearly constant buff would add too much noise\r\n        spellId: SPELLS.CAT_FORM.id,\r\n        triggeredBySpellId: SPELLS.CAT_FORM.id,\r\n      },\r\n      {\r\n        spellId: SPELLS.MOONKIN_FORM_AFFINITY.id,\r\n        enabled: combatant.hasTalent(SPELLS.BALANCE_AFFINITY_TALENT_SHARED),\r\n      },\r\n      {\r\n        spellId: SPELLS.TREANT_FORM.id,\r\n      },\r\n      {\r\n        spellId: SPELLS.TRAVEL_FORM.id,\r\n        triggeredBySpellId: SPELLS.TRAVEL_FORM.id,\r\n        timelineHighlight: true,\r\n      },\r\n      {\r\n        spellId: SPELLS.STAG_FORM.id,\r\n        triggeredBySpellId: SPELLS.STAG_FORM.id,\r\n        timelineHighlight: true,\r\n      },\r\n      {\r\n        spellId: SPELLS.DASH.id,\r\n        triggeredBySpellId: SPELLS.DASH.id,\r\n        enabled: !combatant.hasTalent(SPELLS.TIGER_DASH_TALENT),\r\n      },\r\n      {\r\n        spellId: SPELLS.TIGER_DASH_TALENT.id,\r\n        triggeredBySpellId: SPELLS.TIGER_DASH_TALENT.id,\r\n        enabled: combatant.hasTalent(SPELLS.TIGER_DASH_TALENT),\r\n      },\r\n      {\r\n        spellId: SPELLS.STAMPEDING_ROAR_CAT.id,\r\n        triggeredBySpellId: SPELLS.STAMPEDING_ROAR_CAT.id,\r\n      },\r\n      {\r\n        spellId: SPELLS.STAMPEDING_ROAR_BEAR.id,\r\n        triggeredBySpellId: SPELLS.STAMPEDING_ROAR_BEAR.id,\r\n      },\r\n      {\r\n        spellId: SPELLS.REGROWTH.id,\r\n        //triggeredBySpellId: SPELLS.REGROWTH.id\r\n        // disabled triggeredBySpellId for Regrowth as it causes the PrePullCooldowns normalizer to generate excessive Regrowth casts events before the pull: one for Regrowth and one for the Bloodtalons buff, but in reality a single cast produces both effects.\r\n      },\r\n      {\r\n        spellId: SPELLS.REJUVENATION.id,\r\n        triggeredBySpellId: SPELLS.REJUVENATION.id,\r\n        enabled: combatant.hasTalent(SPELLS.RESTORATION_AFFINITY_TALENT),\r\n      },\r\n      {\r\n        spellId: SPELLS.WILD_GROWTH.id,\r\n        triggeredBySpellId: SPELLS.WILD_GROWTH.id,\r\n        enabled: combatant.hasTalent(SPELLS.RESTORATION_AFFINITY_TALENT),\r\n      },\r\n    ];\r\n  }\r\n}\r\n\r\nexport default Buffs;\r\n","import CoreAlwaysBeCasting from 'parser/shared/modules/AlwaysBeCasting';\r\nimport { STATISTIC_ORDER } from 'interface/others/StatisticBox';\r\n\r\nclass AlwaysBeCasting extends CoreAlwaysBeCasting {\r\n  position = STATISTIC_ORDER.CORE(1);\r\n\r\n  suggestions(when) {\r\n    // override the suggestions from CoreAlwaysBeCasting so there's never any generated, but we still get the statistic.\r\n    return null;\r\n  }\r\n}\r\n\r\nexport default AlwaysBeCasting;\r\n","import SPELLS from 'common/SPELLS';\r\nimport CoreCooldownThroughputTracker, { BUILT_IN_SUMMARY_TYPES } from 'parser/shared/modules/CooldownThroughputTracker';\r\n\r\nclass CooldownThroughputTracker extends CoreCooldownThroughputTracker {\r\n  static cooldownSpells = [\r\n    ...CoreCooldownThroughputTracker.cooldownSpells,\r\n    {\r\n      spell: SPELLS.TIGERS_FURY,\r\n      summary: [\r\n        BUILT_IN_SUMMARY_TYPES.DAMAGE,\r\n      ],\r\n    },\r\n    {\r\n      spell: SPELLS.FERAL_FRENZY_TALENT,\r\n      summary: [\r\n        BUILT_IN_SUMMARY_TYPES.DAMAGE,\r\n      ],\r\n    },\r\n    {\r\n      spell: SPELLS.INCARNATION_KING_OF_THE_JUNGLE_TALENT,\r\n      summary: [\r\n        BUILT_IN_SUMMARY_TYPES.DAMAGE,\r\n      ],\r\n    },\r\n    {\r\n      spell: SPELLS.BERSERK,\r\n      summary: [\r\n        BUILT_IN_SUMMARY_TYPES.DAMAGE,\r\n      ],\r\n    },\r\n  ];\r\n}\r\n\r\nexport default CooldownThroughputTracker;\r\n","import SPELLS from 'common/SPELLS';\r\nimport CoreSpellUsable from 'parser/shared/modules/SpellUsable';\r\nimport { encodeTargetString } from 'parser/shared/modules/EnemyInstances';\r\n\r\nimport Events from 'parser/core/Events';\r\nimport { SELECTED_PLAYER } from 'parser/core/Analyzer';\r\n\r\nimport { RAKE_BASE_DURATION, THRASH_FERAL_BASE_DURATION, PANDEMIC_FRACTION } from '../../constants';\r\n\r\nconst EARLY_BLEED_EXPIRE_TO_COUNT_AS_DEATH = 500;\r\nconst BLEED_BASE_DURATIONS = {\r\n  [SPELLS.RAKE.id]: RAKE_BASE_DURATION,\r\n  //[SPELLS.RIP.id]: RIP_BASE_DURATION,\r\n  [SPELLS.THRASH_FERAL.id]: THRASH_FERAL_BASE_DURATION,\r\n};\r\nconst BLEED_SPELLS = [SPELLS.RAKE, SPELLS.THRASH_FERAL];\r\n\r\n/**\r\n * Predator:\r\n * The cooldown on Tiger's Fury resets when a target dies with one of your Bleed effects active\r\n *\r\n * We cannot directly detect enemy death, but can infer it from a bleed debuff ending early.\r\n * Death is not the only cause of a bleed ending early, for instance a Monk's paralysis ability\r\n * removes DoTs when it's applied to a target.\r\n * We know for certain that an enemy died when Tiger's Fury is used earlier than should be possible.\r\n * When that happens assume the most recent possible enemy death was when the cooldown reset.\r\n *\r\n * TODO: Since 8.1 the duration of Rip is more complex. It can be extended by Sabertooth, its initial\r\n * duration will vary depending on combo points, and it can be applied to multiple targets by Primal Wrath.\r\n * Currently none of this is handled here, so tracking Rip has been disabled.\r\n */\r\nclass SpellUsable extends CoreSpellUsable {\r\n  earlyCastsOfTigersFury = 0;\r\n\r\n  // e.g. activeBleedsExpire[targetString][SPELLS.RAKE.id] = timestamp\r\n  activeBleedsExpire = {};\r\n  hasPredator = null;\r\n\r\n  // timestamp of most recent possible kill event\r\n  possibleRecentKill = null;\r\n\r\n  constructor(...args) {\r\n    super(...args);\r\n    this.hasPredator = this.selectedCombatant.hasTalent(SPELLS.PREDATOR_TALENT.id);\r\n    this.addEventListener(Events.applydebuff.by(SELECTED_PLAYER).spell(BLEED_SPELLS), this.onApplyDebuff);\r\n    this.addEventListener(Events.refreshdebuff.by(SELECTED_PLAYER).spell(BLEED_SPELLS), this.onRefreshDebuff);\r\n    this.addEventListener(Events.removedebuff.by(SELECTED_PLAYER).spell(BLEED_SPELLS), this.onRemoveDebuff);\r\n  }\r\n\r\n  onApplyDebuff(event) {\r\n    const spellId = event.ability.guid;\r\n    if (!this.hasPredator) {\r\n      return;\r\n    }\r\n    const target = encodeTargetString(event.targetID, event.targetInstance);\r\n    if (!this.activeBleedsExpire[target]) {\r\n      this.activeBleedsExpire[target] = {};\r\n    }\r\n    const duration = BLEED_BASE_DURATIONS[spellId];\r\n    this.activeBleedsExpire[target][spellId] = event.timestamp + duration;\r\n  }\r\n\r\n  onRefreshDebuff(event) {\r\n    const spellId = event.ability.guid;\r\n    if (!this.hasPredator) {\r\n      return;\r\n    }\r\n    const target = encodeTargetString(event.targetID, event.targetInstance);\r\n    if (!this.activeBleedsExpire[target]) {\r\n      this.activeBleedsExpire[target] = {};\r\n    }\r\n    // existingExpire may be null if combat log missed the original applydebuff\r\n    const existingExpire = this.activeBleedsExpire[target][spellId];\r\n    const remainingOnPrevious = Math.max(0, existingExpire ? (existingExpire - event.timestamp) : 0);\r\n    const durationWithoutPandemic = BLEED_BASE_DURATIONS[spellId];\r\n    const pandemic = Math.min(durationWithoutPandemic * PANDEMIC_FRACTION, remainingOnPrevious);\r\n    this.activeBleedsExpire[target][spellId] = event.timestamp + durationWithoutPandemic + pandemic;\r\n  }\r\n\r\n  onRemoveDebuff(event) {\r\n    const spellId = event.ability.guid;\r\n    if (!this.hasPredator) {\r\n      return;\r\n    }\r\n    const target = encodeTargetString(event.targetID, event.targetInstance);\r\n    if (!this.activeBleedsExpire[target]) {\r\n      this.activeBleedsExpire[target] = {};\r\n    }\r\n    const expire = this.activeBleedsExpire[target][spellId];\r\n    const beforeExpire = expire ? (expire - event.timestamp) : 0;\r\n    if (beforeExpire > EARLY_BLEED_EXPIRE_TO_COUNT_AS_DEATH) {\r\n      this.possibleRecentKill = event.timestamp;\r\n    }\r\n  }\r\n\r\n  beginCooldown(spellId, cooldownTriggerEvent) {\r\n    if (SPELLS.TIGERS_FURY.id === spellId &&\r\n      this.hasPredator && this.isOnCooldown(spellId)) {\r\n      const resetTime = this.possibleRecentKill ? this.possibleRecentKill : cooldownTriggerEvent.timestamp;\r\n      this.earlyCastsOfTigersFury += 1;\r\n      this.endCooldown(spellId, false, resetTime);\r\n    }\r\n    super.beginCooldown(spellId, cooldownTriggerEvent);\r\n  }\r\n}\r\n\r\nexport default SpellUsable;\r\n","export const RAKE_BASE_DURATION = 15000;\r\nexport const RIP_DURATION_1_CP = 8000;\r\nexport const RIP_DURATION_PER_CP = 4000;\r\nexport const RIP_MAXIMUM_EXTENDED_DURATION = 31200;\r\nexport const SABERTOOTH_EXTEND_PER_CP = 4000;\r\n// cat moonfire lasts for 14 seconds, unlike caster and bear moonfire with a base of 16 seconds.\r\nexport const MOONFIRE_FERAL_BASE_DURATION = 14000;\r\nexport const THRASH_FERAL_BASE_DURATION = 15000;\r\n\r\nexport const SAVAGE_ROAR_DAMAGE_BONUS = 0.15;\r\nexport const TIGERS_FURY_DAMAGE_BONUS = 0.15;\r\nexport const BLOODTALONS_DAMAGE_BONUS = 0.25;\r\nexport const MOMENT_OF_CLARITY_DAMAGE_BONUS = 0.15;\r\nexport const PROWL_RAKE_DAMAGE_BONUS = 1.00;\r\nexport const PANDEMIC_FRACTION = 0.3;\r\n\r\nexport const BERSERK_ENERGY_COST_MULTIPLIER = 0.6;\r\n\r\nexport const ENERGY_FOR_FULL_DAMAGE_BITE = 50;\r\nexport const MAX_BITE_DAMAGE_BONUS_FROM_ENERGY = 1.0;\r\n\r\nexport const SHRED_COEFFICIENT = 0.380562;\r\nexport const SWIPE_CAT_COEFFICIENT = 0.25;\r\nexport const SWIPE_BEAR_COEFFICIENT = 0.30;\r\nexport const BRUTAL_SLASH_COEFFICIENT = 0.60;\r\n\r\nexport const FERAL_DRUID_DAMAGE_AURA = 1.12;\r\nexport const INCARNATION_SHRED_DAMAGE = 1.50;\r\nexport const SHRED_SWIPE_BONUS_ON_BLEEDING = 1.20;\r\n","import SPELLS from 'common/SPELLS';\r\nimport RESOURCE_TYPES from 'game/RESOURCE_TYPES';\r\n\r\nimport SpellResourceCost from 'parser/shared/modules/SpellResourceCost';\r\n\r\nconst debug = false;\r\n\r\nconst BERSERK_COST_MULTIPLIER = 0.6;\r\n\r\nclass SpellEnergyCost extends SpellResourceCost {\r\n  static resourceType = RESOURCE_TYPES.ENERGY;\r\n\r\n  getResourceCost(event) {\r\n    const cost = super.getResourceCost(event);\r\n\r\n    // no need to check for Clearcasting as the zero cost is already applied in the log\r\n\r\n    if (this.selectedCombatant.hasBuff(SPELLS.BERSERK.id) ||\r\n      this.selectedCombatant.hasBuff(SPELLS.INCARNATION_KING_OF_THE_JUNGLE_TALENT.id)) {\r\n      debug && console.log(`Cost of ${this.event.ability.name} reduced to ${cost * BERSERK_COST_MULTIPLIER} by Berserk/Incarnation`);\r\n      return cost * BERSERK_COST_MULTIPLIER;\r\n    }\r\n\r\n    return cost;\r\n  }\r\n}\r\n\r\nexport default SpellEnergyCost;\r\n","import React from 'react';\r\nimport SPELLS from 'common/SPELLS';\r\nimport RESOURCE_TYPES from 'game/RESOURCE_TYPES';\r\nimport { formatPercentage } from 'common/format';\r\nimport STATISTIC_ORDER from 'interface/others/STATISTIC_ORDER';\r\nimport Statistic from 'interface/statistics/Statistic';\r\nimport RegenResourceCapTracker from 'parser/shared/modules/resources/resourcetracker/RegenResourceCapTracker';\r\nimport BoringResourceValue from 'interface/statistics/components/BoringResourceValue';\r\n\r\nimport { i18n } from '@lingui/core';\r\nimport { t } from '@lingui/macro';\r\n\r\nimport SpellEnergyCost from './SpellEnergyCost';\r\n\r\nconst BASE_ENERGY_REGEN = 11;\r\nconst BASE_ENERGY_MAX = 100;\r\nconst MOMENT_OF_CLARITY_MAX_ADDITION = 30;\r\nconst BERSERK_MAX_ADDITION = 50;\r\n\r\nconst RESOURCE_REFUND_ON_MISS = 0.8;\r\n\r\n/**\r\n * Sets up RegenResourceCapTracker to accurately track the regenerating energy of a Feral druid.\r\n * Taking into account the effect of buffs, talents, and items on the energy cost of abilities,\r\n * the maximum energy amount, and the regeneration rate.\r\n * Note that some cost reduction effects are already accounted for in the log.\r\n *\r\n * No need to override getReducedDrain:\r\n * Reduced drain cost from Berserk/Incarnation on Ferocious Bite is already applied in the log.\r\n */\r\nclass EnergyCapTracker extends RegenResourceCapTracker {\r\n  get percentCapped() {\r\n    return (this.naturalRegen - this.missedRegen) / this.naturalRegen;\r\n  }\r\n\r\n  get suggestionThresholds() {\r\n    return {\r\n      actual: this.percentCapped,\r\n      isLessThan: {\r\n        minor: .8,\r\n        average: .70,\r\n        major: .65,\r\n      },\r\n      style: 'percentage',\r\n    };\r\n  }\r\n\r\n  static dependencies = {\r\n    ...RegenResourceCapTracker.dependencies,\r\n    // Needed for the `resourceCost` prop of events\r\n    spellResourceCost: SpellEnergyCost,\r\n  };\r\n  static resourceType = RESOURCE_TYPES.ENERGY;\r\n  static baseRegenRate = BASE_ENERGY_REGEN;\r\n  static isRegenHasted = true;\r\n  static cumulativeEventWindow = 400;\r\n  static buffsChangeMax = [\r\n    SPELLS.BERSERK.id,\r\n    SPELLS.INCARNATION_KING_OF_THE_JUNGLE_TALENT.id,\r\n  ];\r\n  static resourceRefundOnMiss = RESOURCE_REFUND_ON_MISS;\r\n  static exemptFromRefund = [\r\n    SPELLS.THRASH_FERAL.id,\r\n    SPELLS.SWIPE_CAT.id,\r\n    SPELLS.BRUTAL_SLASH_TALENT.id,\r\n  ];\r\n\r\n  currentMaxResource() {\r\n    let max = BASE_ENERGY_MAX;\r\n    if (this.selectedCombatant.hasTalent(SPELLS.MOMENT_OF_CLARITY_TALENT.id)) {\r\n      max += MOMENT_OF_CLARITY_MAX_ADDITION;\r\n    }\r\n    if (this.combatantHasBuffActive(SPELLS.BERSERK.id) || this.combatantHasBuffActive(SPELLS.INCARNATION_KING_OF_THE_JUNGLE_TALENT.id)) {\r\n      // combatantHasBuffActive is used so that if the buff faded at this timestamp it will not count.\r\n      max += BERSERK_MAX_ADDITION;\r\n    }\r\n    // What should be x.5 becomes x in-game.\r\n    return Math.floor(max);\r\n  }\r\n\r\n  suggestions(when) {\r\n    when(this.suggestionThresholds).addSuggestion((suggest, actual, recommended) => suggest(\r\n      <>\r\n        You're allowing your energy to reach its cap. While at its maximum value you miss out on the energy that would have regenerated. Although it can be beneficial to let energy pool ready to be used at the right time, try to spend some before it reaches the cap.\r\n      </>,\r\n    )\r\n      .icon('spell_shadow_shadowworddominate')\r\n      .actual(i18n._(t('druid.feral.suggestions.energy.efficiency')`${formatPercentage(actual)}% regenerated energy lost per minute due to being capped.`))\r\n      .recommended(`<${recommended}% is recommended.`));\r\n  }\r\n\r\n  statistic() {\r\n    return (\r\n      <Statistic\r\n        tooltip={(\r\n          <>\r\n            Although it can be beneficial to wait and let your energy pool ready to be used at the right time, you should still avoid letting it reach the cap.<br />\r\n            You spent <strong>{formatPercentage(this.cappedProportion)}%</strong> of the fight at capped energy, causing you to miss out on a total of <strong>{this.missedRegen.toFixed(0)}</strong> energy from regeneration.\r\n          </>\r\n        )}\r\n        size=\"flexible\"\r\n        position={STATISTIC_ORDER.CORE(1)}\r\n      >\r\n        <BoringResourceValue resource={RESOURCE_TYPES.ENERGY} value={`${formatPercentage(this.percentCapped)}%`} label=\"Wasted energy per minute from being capped\" />\r\n      </Statistic>\r\n    );\r\n  }\r\n}\r\n\r\nexport default EnergyCapTracker;\r\n","import SPELLS from 'common/SPELLS';\r\nimport RESOURCE_TYPES from 'game/RESOURCE_TYPES';\r\nimport ResourceTracker from 'parser/shared/modules/resources/resourcetracker/ResourceTracker';\r\n\r\nclass EnergyTracker extends ResourceTracker {\r\n  constructor(...args) {\r\n    super(...args);\r\n    this.resource = RESOURCE_TYPES.ENERGY;\r\n    this.initBuilderAbility(SPELLS.TIGERS_FURY.id);\r\n  }\r\n}\r\n\r\nexport default EnergyTracker;\r\n","import React from 'react';\r\n\r\nimport Analyzer from 'parser/core/Analyzer';\r\nimport Panel from 'interface/others/Panel';\r\nimport ResourceBreakdown from 'parser/shared/modules/resources/resourcetracker/ResourceBreakdown';\r\n\r\nimport EnergyTracker from './EnergyTracker';\r\n\r\nclass EnergyDetails extends Analyzer {\r\n  static dependencies = {\r\n    energyTracker: EnergyTracker,\r\n  };\r\n\r\n  tab() {\r\n    return {\r\n      title: 'Energy usage',\r\n      url: 'energy-usage',\r\n      render: () => (\r\n        <Panel>\r\n          <ResourceBreakdown\r\n            tracker={this.energyTracker}\r\n            showSpenders\r\n          />\r\n        </Panel>\r\n      ),\r\n    };\r\n  }\r\n}\r\n\r\nexport default EnergyDetails;\r\n","import React from 'react';\r\nimport PropTypes from 'prop-types';\r\n\r\nimport SPELLS from 'common/SPELLS';\r\nimport SpellLink from 'common/SpellLink';\r\nimport RACES from 'game/RACES';\r\nimport { TooltipElement } from 'common/Tooltip';\r\nimport Checklist from 'parser/shared/modules/features/Checklist';\r\nimport Rule from 'parser/shared/modules/features/Checklist/Rule';\r\nimport Requirement from 'parser/shared/modules/features/Checklist/Requirement';\r\nimport PreparationRule from 'parser/shared/modules/features/Checklist/PreparationRule';\r\nimport GenericCastEfficiencyRequirement from 'parser/shared/modules/features/Checklist/GenericCastEfficiencyRequirement';\r\n\r\nconst FeralDruidChecklist = ({ combatant, castEfficiency, thresholds }) => {\r\n  const UptimeRequirement = props => (\r\n    <Requirement\r\n      name={(\r\n        <>\r\n          <SpellLink id={props.spell} /> uptime\r\n        </>\r\n      )}\r\n      thresholds={props.thresholds}\r\n    />\r\n  );\r\n  UptimeRequirement.propTypes = {\r\n    spell: PropTypes.object.isRequired,\r\n  };\r\n  const CastEfficiencyRequirement = props => (\r\n    <GenericCastEfficiencyRequirement\r\n      castEfficiency={castEfficiency.getCastEfficiencyForSpellId(props.spell)}\r\n      {...props}\r\n    />\r\n  );\r\n  CastEfficiencyRequirement.propTypes = {\r\n    spell: PropTypes.object.isRequired,\r\n  };\r\n  const SnapshotDowngradeRequirement = props => (\r\n    <Requirement\r\n      name={(\r\n        <>\r\n          <SpellLink id={props.spell} /> downgraded before the pandemic window\r\n        </>\r\n      )}\r\n      thresholds={props.thresholds}\r\n      tooltip=\"Downgrading a snapshot can be unavoidable, but you should let the upgraded version last as long as possible by avoiding early refreshes.\"\r\n    />\r\n  );\r\n  SnapshotDowngradeRequirement.propTypes = {\r\n    spell: PropTypes.object.isRequired,\r\n  };\r\n\r\n  return (\r\n    <Checklist>\r\n      {/* Builders\r\n         Uptime for Rake DoT\r\n         Uptime for Moonfire DoT (if talented for it)\r\n         Avoid the types of early refresh which aren't already caught by the snapshot analysers. (Can be tricky to determine with certainty if such a refresh is bad, although if the player is just spamming Rake that should be flagged as a mistake.)\r\n         Cast efficiency of Brutal Slash (if talented)\r\n         Cast efficiency of Feral Frenzy (if talented)\r\n         Only use Swipe if it hits multiple enemies\r\n         Don't waste combo points by generating more when full\r\n      */}\r\n      <Rule\r\n        name=\"Generate combo points\"\r\n        description={(\r\n          <>\r\n            Builders use energy and give you combo points. Keep your <TooltipElement content=\"Rake and Moonfire if you have the Lunar Inspiration talent, and Thrash if you the Wild Fleshrending azerite trait.\">DoTs</TooltipElement> active, use <SpellLink id={SPELLS.BRUTAL_SLASH_TALENT.id} /> and <SpellLink id={SPELLS.FERAL_FRENZY_TALENT.id} /> if you have those talents, then fill with <SpellLink id={SPELLS.SHRED.id} />. Don't waste combo points by continuing to use builders when at full combo points.<br /><br />\r\n\r\n            You should adapt your behaviour in AoE situations (the analyzer only accounts for some of this, so use your discretion when looking at AoE-heavy fights.) If you'll hit 2 or more targets replace <SpellLink id={SPELLS.SHRED.id} /> with <SpellLink id={SPELLS.SWIPE_CAT.id} />. When fighting <TooltipElement content=\"The threshold varies slightly depending on your stats and azerite traits.\">5 targets</TooltipElement> or more it's no longer worth using <SpellLink id={SPELLS.RAKE.id} /> and <SpellLink id={SPELLS.MOONFIRE_FERAL.id} />. Unlike in the Legion expansion you should never spam <SpellLink id={SPELLS.THRASH_FERAL.id} />, only keep it active if you would otherwise be using <SpellLink id={SPELLS.SWIPE_CAT.id} /> on targets without any bleeds.\r\n          </>\r\n        )}\r\n      >\r\n        <UptimeRequirement spell={SPELLS.RAKE.id} thresholds={thresholds.rakeUptime} />\r\n        {combatant.hasTalent(SPELLS.LUNAR_INSPIRATION_TALENT.id) && (\r\n          <UptimeRequirement spell={SPELLS.MOONFIRE_FERAL.id} thresholds={thresholds.moonfireUptime} />\r\n        )}\r\n        {combatant.hasTalent(SPELLS.BRUTAL_SLASH_TALENT.id) && (\r\n          <CastEfficiencyRequirement spell={SPELLS.BRUTAL_SLASH_TALENT.id} />\r\n        )}\r\n        {combatant.hasTalent(SPELLS.FERAL_FRENZY_TALENT.id) && (\r\n          <CastEfficiencyRequirement spell={SPELLS.FERAL_FRENZY_TALENT.id} />\r\n        )}\r\n        <Requirement\r\n          name={(\r\n            <>\r\n              Inappropriate <SpellLink id={SPELLS.SWIPE_CAT.id} />\r\n            </>\r\n          )}\r\n          thresholds={thresholds.swipeHitOne}\r\n          tooltip=\"How many times you used Swipe but had it only hit 1 target. Against a single target you should use Shred instead.\"\r\n        />\r\n        <Requirement\r\n          name={(\r\n            <>\r\n              Combo points wasted\r\n            </>\r\n          )}\r\n          thresholds={thresholds.comboPointsWaste}\r\n          tooltip=\"Generating combo points after already reaching the maximum 5 wastes them.\"\r\n        />\r\n      </Rule>\r\n\r\n      {/* Finishers\r\n         Uptime on Rip DoT\r\n         Uptime for Savage Roar buff (if talented)\r\n         Ferocious Bite only at energy >= 50\r\n         Don't cast Rip when Ferocious Bite could have refreshed it, unless you're upgrading the snapshot\r\n         Don't reduce duration of Rip by refreshing early and with low combo points\r\n         Don't use finishers at less than 5 combo points (except for certain exceptions)\r\n      */}\r\n      <Rule\r\n        name=\"Spend combo points\"\r\n        description={(\r\n          <>\r\n            You should generally only use finishers with a full 5 combo points. The exception is the first <SpellLink id={SPELLS.RIP.id} /> of the fight which should be applied as early as possible. <SpellLink id={SPELLS.SABERTOOTH_TALENT.id} /> is a damage gain in many situations and simplifies your finisher use, allowing you to almost always use <SpellLink id={SPELLS.FEROCIOUS_BITE.id} /> as your single target finisher. When casting <SpellLink id={SPELLS.FEROCIOUS_BITE.id} /> make sure you have at least <TooltipElement content=\"Ferocious Bite's tooltip says it needs just 25 energy, but you should always give it an additional 25 to double its damage.\">50 energy.</TooltipElement><br /><br />\r\n\r\n            <SpellLink id={SPELLS.PRIMAL_WRATH_TALENT.id} /> can replace both <SpellLink id={SPELLS.RIP.id} /> and <SpellLink id={SPELLS.FEROCIOUS_BITE.id} /> when against approximately 3 or more enemies.\r\n          </>\r\n        )}\r\n      >\r\n        <UptimeRequirement spell={SPELLS.RIP.id} thresholds={thresholds.ripUptime} />\r\n        {combatant.hasTalent(SPELLS.SAVAGE_ROAR_TALENT.id) && (\r\n          <UptimeRequirement spell={SPELLS.SAVAGE_ROAR_TALENT.id} thresholds={thresholds.savageRoarUptime} />\r\n        )}\r\n        <Requirement\r\n          name={(\r\n            <>\r\n              <SpellLink id={SPELLS.FEROCIOUS_BITE.id} /> damage bonus from energy\r\n            </>\r\n          )}\r\n          thresholds={thresholds.ferociousBiteEnergy}\r\n          tooltip=\"Ferocious Bite consumes up to 50 energy, and should always be given that full 50 energy to significantly increase its damage.\"\r\n        />\r\n        {combatant.hasTalent(SPELLS.SABERTOOTH_TALENT.id) && (\r\n          <Requirement\r\n            name={(\r\n              <>\r\n                <SpellLink id={SPELLS.RIP.id} /> which should have been <SpellLink id={SPELLS.FEROCIOUS_BITE.id} />\r\n              </>\r\n            )}\r\n            thresholds={thresholds.ripShouldBeBite}\r\n            tooltip=\"With the Sabertooth talent you can maintain your Rip by using Ferocious Bite. If you instead cast Rip you are missing out on the Ferocious Bite damage. If the replacement Rip has a better snapshot then it may have been worth using, so those cases are not counted here.\"\r\n          />\r\n        )}\r\n        <Requirement\r\n          name={(\r\n            <>\r\n              <SpellLink id={SPELLS.RIP.id} /> casts which reduced duration\r\n            </>\r\n          )}\r\n          thresholds={thresholds.ripDurationReduction}\r\n          tooltip=\"Because Rip's duration is based on combo points used it is possible to reduce the duration of your existing bleed by reapplying it with low combo points. Not only is this a waste of resources but you're doing less damage than you would if you'd done nothing at all.\"\r\n        />\r\n        <Requirement\r\n          name={(\r\n            <>\r\n              Needless low combo point finishers\r\n            </>\r\n          )}\r\n          thresholds={thresholds.badLowComboFinishers}\r\n          tooltip=\"Your finishers are most efficient when used with full combo points. However it is still worth using a low combo point Rip if it's not yet up on a target (this exception is detected and taken into account when calculating this metric.)\"\r\n        />\r\n      </Rule>\r\n\r\n      {/* Manage your energy\r\n         Don't cap energy\r\n         Don't waste energy from Tiger's Fury\r\n         Some kind of check for good pooling behaviour (having high energy when using a finisher is generally good, but would benefit from some research to quantify that effect.)\r\n\r\n        Switch out the whole rule section if we can detect that the player was in a situation where energy was abundant.\r\n      */}\r\n      {!thresholds.tigersFuryIgnoreEnergy && (\r\n        <Rule\r\n          name=\"Manage your energy\"\r\n          description={(\r\n            <>\r\n              Your actions are <TooltipElement content=\"Notable exceptions are when you have the Predator talent with enemies regularly dying, or large AoE situations with certain builds.\">usually</TooltipElement> limited by available energy so managing it well is important. Don't let it reach the cap and miss out on regeneration, and avoid wasting generated energy from <SpellLink id={SPELLS.TIGERS_FURY.id} />. Allowing your energy to \"pool\" before using a finisher is often <TooltipElement content=\"Using a finisher when at low energy leaves you with little of both your main resources which greatly limits your options. Pooling energy first means you'll have energy left over to react to whatever happens in the fight around you. Although pooling is useful never let your uptime of DoTs and Savage Roar drop because of it.\">beneficial</TooltipElement>.\r\n            </>\r\n          )}\r\n        >\r\n          <Requirement\r\n            name={(\r\n              <>\r\n                Wasted natural regeneration from being capped\r\n              </>\r\n            )}\r\n            thresholds={thresholds.energyCapped}\r\n            tooltip=\"Some waste during Berserk or Incarnation (especially with Bloodlust active) is not a concern. If the fight mechanics force you to not attack for periods of time then capping energy is inevitable. Please use your knowledge of the fight when weighing the importance of this metric.\"\r\n          />\r\n          <Requirement\r\n            name={(\r\n              <>\r\n                Wasted energy from <SpellLink id={SPELLS.TIGERS_FURY.id} />\r\n              </>\r\n            )}\r\n            thresholds={thresholds.tigersFuryEnergy}\r\n            tooltip=\"There are some situations where energy is very abundant and the energy gain from Tiger's Fury becomes unimportant, but that is rare in boss fights. Generally you should aim to use Tiger's Fury both for its energy and damage increase.\"\r\n          />\r\n        </Rule>\r\n      )}\r\n      {thresholds.tigersFuryIgnoreEnergy && combatant.hasTalent(SPELLS.PREDATOR_TALENT.id) && (\r\n        <Rule\r\n          name=\"Manage your energy\"\r\n          description={(\r\n            <>\r\n              Normally your actions are limited by available energy. In this fight you made good use of <SpellLink id={SPELLS.PREDATOR_TALENT.id} /> to allow extra <SpellLink id={SPELLS.TIGERS_FURY.id} /> which makes the usual measures of energy management much less important.\r\n            </>\r\n          )}\r\n        >\r\n          <Requirement\r\n            name={(\r\n              <>\r\n                Additional <SpellLink id={SPELLS.TIGERS_FURY.id} /> from <SpellLink id={SPELLS.PREDATOR_TALENT.id} /> per minute\r\n              </>\r\n            )}\r\n            thresholds={thresholds.predatorWrongTalent}\r\n          />\r\n        </Rule>\r\n      )}\r\n\r\n      {/*Use your cooldowns\r\n         Cast efficiency of Berserk or Incarnation (depending on talent)\r\n         Make the most of Berserk/Incarnation by using as many abilities as possible during the buff (importance of this may be so low that it's not worth checking - run some simulations to find out)\r\n         Cast efficiency of Tiger's Fury\r\n         Shadowmeld for Night Elves: cast efficiency of correctly using it to buff Rake\r\n      */}\r\n      <Rule\r\n        name=\"Use your cooldowns\"\r\n        description={(\r\n          <>\r\n            Aim to use your cooldowns as often as possible, try to get prepared to use the ability when you see it's nearly ready. <SpellLink id={SPELLS.BERSERK.id} /> (or <SpellLink id={SPELLS.INCARNATION_KING_OF_THE_JUNGLE_TALENT.id} />) should be used when you have plenty of energy so that you get the most effect from its cost reduction. Make sure you don't cap energy when using <SpellLink id={SPELLS.TIGERS_FURY.id} />, but still use it as often as possible. Slightly delaying one so it lines up with the other can be beneficial, but avoid delaying so much that you'd miss out on an extra use during the fight.\r\n          </>\r\n        )}\r\n      >\r\n        {!combatant.hasTalent(SPELLS.INCARNATION_KING_OF_THE_JUNGLE_TALENT.id) && (\r\n          <CastEfficiencyRequirement spell={SPELLS.BERSERK.id} />\r\n        )}\r\n        {combatant.hasTalent(SPELLS.INCARNATION_KING_OF_THE_JUNGLE_TALENT.id) && (\r\n          <CastEfficiencyRequirement spell={SPELLS.INCARNATION_KING_OF_THE_JUNGLE_TALENT.id} />\r\n        )}\r\n        <CastEfficiencyRequirement spell={SPELLS.TIGERS_FURY.id} />\r\n        {combatant.race === RACES.NightElf && (\r\n          <Requirement\r\n            name={<SpellLink id={SPELLS.SHADOWMELD.id} />}\r\n            thresholds={thresholds.shadowmeld}\r\n            tooltip=\"This measures how many of the possible uses of Shadowmeld were used to provide the double damage bonus to Rake.\"\r\n          />\r\n        )}\r\n      </Rule>\r\n\r\n      {/*Manage Snapshots\r\n         Only refresh a Moonfire (if talented) before pandemic if the new one is stronger\r\n         Only refresh a Rake before pandemic if the new one is stronger\r\n         Only refresh a Rip before pandemic if the new one is stronger\r\n         Don't end a Prowl-empowered Rake early by refreshing without that empowerment\r\n      */}\r\n      <Rule\r\n        name=\"Make the most of snapshots\"\r\n        description={(\r\n          <>\r\n            <TooltipElement content=\"Tiger's Fury affects all DoTs, Bloodtalons affects all except Moonfire.\">Certain buffs</TooltipElement> will increase the damage of your DoTs for their full duration, even after the buff wears off. Making the most of this mechanic can be the difference between good and great results.<br />\r\n            As a general rule it's beneficial to refresh a DoT early if you would increase the snapshot. It's better to refresh with a weaker version of the DoT during the <TooltipElement content=\"The last 30% of the DoT's duration. If you refresh during this time you don't lose any duration in the process.\">pandemic window</TooltipElement> than to let it wear off. The exception is <SpellLink id={SPELLS.RAKE.id} /> empowered by <TooltipElement content=\"The effect is also provided by Incarnation: King of the Jungle, and Shadowmeld for Night Elves\">Prowl</TooltipElement> which is so much stronger that you should wait until the DoT wears off when replacing it with an unbuffed version.<br />\r\n            <SpellLink id={SPELLS.SABERTOOTH_TALENT.id} /> allows you to use <SpellLink id={SPELLS.FEROCIOUS_BITE.id} /> to maintain the existing snapshot on <SpellLink id={SPELLS.RIP.id} /> and should be used to do so.\r\n          </>\r\n        )}\r\n      >\r\n        {combatant.hasTalent(SPELLS.LUNAR_INSPIRATION_TALENT.id) && (\r\n          <SnapshotDowngradeRequirement spell={SPELLS.MOONFIRE_FERAL.id} thresholds={thresholds.moonfireDowngrade} />\r\n        )}\r\n        <SnapshotDowngradeRequirement spell={SPELLS.RAKE.id} thresholds={thresholds.rakeDowngrade} />\r\n        <SnapshotDowngradeRequirement spell={SPELLS.RIP.id} thresholds={thresholds.ripDowngrade} />\r\n        <Requirement\r\n          name={(\r\n            <>\r\n              Average seconds of Prowl-buffed <SpellLink id={SPELLS.RAKE.id} /> lost by refreshing early\r\n            </>\r\n          )}\r\n          thresholds={thresholds.rakeProwlDowngrade}\r\n        />\r\n      </Rule>\r\n\r\n      {/*Manage Bloodtalons - whole section is only if talent is taken\r\n         Use Predatory Swiftness to generate charges\r\n         Don't waste charges by overwriting\r\n         Prioritize using charges on Rip and Rake\r\n      */}\r\n      {combatant.hasTalent(SPELLS.BLOODTALONS_TALENT.id) && (\r\n        <Rule\r\n          name=\"Weave in Bloodtalons\"\r\n          description={(\r\n            <>\r\n              Taking the <SpellLink id={SPELLS.BLOODTALONS_TALENT.id} /> talent adds an extra set of mechanics to weave into your rotation. You should use every <SpellLink id={SPELLS.PREDATORY_SWIFTNESS.id} /> proc to generate <SpellLink id={SPELLS.BLOODTALONS_TALENT.id} /> charges, which you then spend to buff attacks. Aim to always have the buff active on <SpellLink id={SPELLS.RIP.id} /> and <SpellLink id={SPELLS.RAKE.id} />. Depending on your other talent choices and the number of targets you'll usually have access to more charges than needed to keep those two DoTs buffed, use the rest to buff other high damage attacks such as <SpellLink id={SPELLS.BRUTAL_SLASH_TALENT.id} />. Choose the right time to cast <SpellLink id={SPELLS.REGROWTH.id} /> or <SpellLink id={SPELLS.ENTANGLING_ROOTS.id} /> and generate charges, usually the best time is when you reach 4 or 5 combo points so <SpellLink id={SPELLS.BLOODTALONS_TALENT.id} /> is active for your finisher.\r\n            </>\r\n          )}\r\n        >\r\n          <Requirement\r\n            name={(\r\n              <>\r\n                <SpellLink id={SPELLS.PREDATORY_SWIFTNESS.id} /> wasted\r\n              </>\r\n            )}\r\n            thresholds={thresholds.predatorySwiftnessWasted}\r\n          />\r\n          <Requirement\r\n            name={(\r\n              <>\r\n                <SpellLink id={SPELLS.BLOODTALONS_TALENT.id} /> wasted\r\n              </>\r\n            )}\r\n            thresholds={thresholds.bloodtalonsWasted}\r\n            tooltip=\"Using Bloodtalons to buff any ability counts as it not being wasted. See the statistics results section for details on how those charges were used.\"\r\n          />\r\n        </Rule>\r\n      )}\r\n\r\n      {/*Pick the right talents (if player is using talents that may be unsuitable)\r\n         Only use Predator if it's allowing you to reset Tiger's Fury by killing adds\r\n      */}\r\n      {(combatant.hasTalent(SPELLS.PREDATOR_TALENT.id)) && (\r\n        <Rule\r\n          name=\"Pick the most suitable Talents\"\r\n          description={(\r\n            <>\r\n              The <SpellLink id={SPELLS.PREDATOR_TALENT.id} /> talent is generally only effective on fights with multiple enemies and should be swapped out for single target encounters.\r\n            </>\r\n          )}\r\n        >\r\n          {combatant.hasTalent(SPELLS.PREDATOR_TALENT.id) && (\r\n            <Requirement\r\n              name={(\r\n                <>\r\n                  Additional <SpellLink id={SPELLS.TIGERS_FURY.id} /> from <SpellLink id={SPELLS.PREDATOR_TALENT.id} />\r\n                </>\r\n              )}\r\n              thresholds={thresholds.predatorWrongTalent}\r\n            />\r\n          )}\r\n\r\n        </Rule>\r\n      )}\r\n\r\n      {/*Be prepared\r\n         Universal rules for using potions, enchants, etc.\r\n      */}\r\n      <PreparationRule thresholds={thresholds} />\r\n    </Checklist>\r\n  );\r\n};\r\n\r\nFeralDruidChecklist.propTypes = {\r\n  castEfficiency: PropTypes.object.isRequired,\r\n  combatant: PropTypes.shape({\r\n    hasTalent: PropTypes.func.isRequired,\r\n    race: PropTypes.any,\r\n  }).isRequired,\r\n  thresholds: PropTypes.object.isRequired,\r\n};\r\n\r\nexport default FeralDruidChecklist;\r\n","import React from 'react';\r\nimport Analyzer from 'parser/core/Analyzer';\r\nimport Enemies from 'parser/shared/modules/Enemies';\r\nimport SPELLS from 'common/SPELLS';\r\nimport SpellLink from 'common/SpellLink';\r\nimport { formatPercentage } from 'common/format';\r\nimport STATISTIC_ORDER from 'interface/others/STATISTIC_ORDER';\r\nimport BoringSpellValueText from 'interface/statistics/components/BoringSpellValueText';\r\nimport UptimeIcon from 'interface/icons/Uptime';\r\nimport Statistic from 'interface/statistics/Statistic';\r\nimport { TooltipElement } from 'common/Tooltip';\r\nimport { i18n } from '@lingui/core';\r\nimport { t } from '@lingui/macro';\r\n\r\nclass RakeUptime extends Analyzer {\r\n  get uptime() {\r\n    return this.enemies.getBuffUptime(SPELLS.RAKE_BLEED.id) / this.owner.fightDuration;\r\n  }\r\n\r\n  get suggestionThresholds() {\r\n    return {\r\n      actual: this.uptime,\r\n      isLessThan: {\r\n        minor: 0.95,\r\n        average: 0.90,\r\n        major: 0.80,\r\n      },\r\n      style: 'percentage',\r\n    };\r\n  }\r\n\r\n  static dependencies = {\r\n    enemies: Enemies,\r\n  };\r\n\r\n  suggestions(when) {\r\n    when(this.suggestionThresholds).addSuggestion((suggest, actual, recommended) => suggest(\r\n      <>\r\n        Your <SpellLink id={SPELLS.RAKE.id} /> uptime can be improved. Unless the current application was buffed by Prowl you should refresh the DoT once it has reached its <TooltipElement content=\"The last 30% of the DoT's duration. When you refresh during this time you don't lose any duration in the process.\">pandemic window</TooltipElement>, don't wait for it to wear off.\r\n      </>,\r\n    )\r\n      .icon(SPELLS.RAKE.icon)\r\n      .actual(i18n._(t('druid.feral.suggestions.rake.uptime')`${formatPercentage(actual)}% uptime`))\r\n      .recommended(`>${formatPercentage(recommended)}% is recommended`));\r\n  }\r\n\r\n  statistic() {\r\n    return (\r\n      <Statistic\r\n        position={STATISTIC_ORDER.CORE(3)}\r\n        size=\"flexible\"\r\n      >\r\n        <BoringSpellValueText spell={SPELLS.RAKE}>\r\n          <>\r\n            <UptimeIcon /> {formatPercentage(this.uptime)}% <small>uptime</small>\r\n          </>\r\n        </BoringSpellValueText>\r\n      </Statistic>\r\n    );\r\n  }\r\n}\r\n\r\nexport default RakeUptime;\r\n","import React from 'react';\r\nimport Analyzer from 'parser/core/Analyzer';\r\nimport Enemies from 'parser/shared/modules/Enemies';\r\nimport SPELLS from 'common/SPELLS';\r\nimport SpellLink from 'common/SpellLink';\r\nimport { formatPercentage } from 'common/format';\r\nimport STATISTIC_ORDER from 'interface/others/STATISTIC_ORDER';\r\nimport BoringSpellValueText from 'interface/statistics/components/BoringSpellValueText';\r\nimport UptimeIcon from 'interface/icons/Uptime';\r\nimport Statistic from 'interface/statistics/Statistic';\r\nimport { TooltipElement } from 'common/Tooltip';\r\nimport { i18n } from '@lingui/core';\r\nimport { t } from '@lingui/macro';\r\n\r\nclass MoonfireUptime extends Analyzer {\r\n  get uptime() {\r\n    return this.enemies.getBuffUptime(SPELLS.MOONFIRE_FERAL.id) / this.owner.fightDuration;\r\n  }\r\n\r\n  get suggestionThresholds() {\r\n    return {\r\n      actual: this.uptime,\r\n      isLessThan: {\r\n        minor: 0.95,\r\n        average: 0.90,\r\n        major: 0.80,\r\n      },\r\n      style: 'percentage',\r\n    };\r\n  }\r\n\r\n  static dependencies = {\r\n    enemies: Enemies,\r\n  };\r\n\r\n  constructor(...args) {\r\n    super(...args);\r\n    this.active = this.selectedCombatant.hasTalent(SPELLS.LUNAR_INSPIRATION_TALENT.id);\r\n  }\r\n\r\n  suggestions(when) {\r\n    when(this.suggestionThresholds).addSuggestion((suggest, actual, recommended) => suggest(\r\n      <>\r\n        Your <SpellLink id={SPELLS.MOONFIRE_FERAL.id} /> uptime can be improved. You should refresh the DoT once it has reached its <TooltipElement content=\"The last 30% of the DoT's duration. When you refresh during this time you don't lose any duration in the process.\">pandemic window</TooltipElement>, don't wait for it to wear off. You may wish to consider switching talents to <SpellLink id={SPELLS.SABERTOOTH_TALENT.id} /> which is simpler to use and provides more damage in most situations.\r\n      </>,\r\n    )\r\n      .icon(SPELLS.MOONFIRE_FERAL.icon)\r\n      .actual(i18n._(t('druid.feral.suggestions.moonfire.uptime')`${formatPercentage(actual)}% uptime`))\r\n      .recommended(`>${formatPercentage(recommended)}% is recommended`));\r\n  }\r\n\r\n  statistic() {\r\n    const moonfireUptime = this.enemies.getBuffUptime(SPELLS.MOONFIRE_FERAL.id) / this.owner.fightDuration;\r\n    return (\r\n      <Statistic\r\n        size=\"flexible\"\r\n        position={STATISTIC_ORDER.OPTIONAL(2)}\r\n      >\r\n        <BoringSpellValueText spell={SPELLS.MOONFIRE_BEAR}>\r\n          <>\r\n            <UptimeIcon /> {formatPercentage(moonfireUptime)} % <small>uptime</small>\r\n          </>\r\n        </BoringSpellValueText>\r\n      </Statistic>\r\n    );\r\n  }\r\n}\r\n\r\nexport default MoonfireUptime;\r\n","import React from 'react';\r\nimport Analyzer, { SELECTED_PLAYER } from 'parser/core/Analyzer';\r\nimport BoringSpellValueText from 'interface/statistics/components/BoringSpellValueText';\r\nimport Statistic from 'interface/statistics/Statistic';\r\nimport Events from 'parser/core/Events';\r\n\r\n// time after a cast in which direct damage from the spellId will be associated with the cast\r\nconst DAMAGE_WINDOW = 250; //ms\r\n\r\n/**\r\n * Count how many targets the player's AoE attack hits. Can be a useful measure of how effectively\r\n * an ability is being used.\r\n */\r\nclass HitCountAoE extends Analyzer {\r\n  get averageTargetsHit() {\r\n    if (this.casts === 0) {\r\n      return 0;\r\n    }\r\n    return (this.totalHits / this.casts);\r\n  }\r\n\r\n  get averageTargetsHitNotIncludingZeroCasts() {\r\n    if (this.casts === 0) {\r\n      return 0;\r\n    }\r\n    return (this.totalHits / (this.casts - this.castsWithZeroHits));\r\n  }\r\n\r\n  get hitZeroPerMinute() {\r\n    return (this.castsWithZeroHits / this.owner.fightDuration) * (1000 * 60);\r\n  }\r\n\r\n  get hitJustOnePerMinute() {\r\n    return (this.castsWithOneHit / this.owner.fightDuration) * (1000 * 60);\r\n  }\r\n\r\n  // A spell object from SPELLS\r\n  static spell = null;\r\n  casts = 0;\r\n  totalHits = 0;\r\n  castsWithZeroHits = 0;\r\n  castsWithOneHit = 0;\r\n  lastCastEvent = null;\r\n  lastCastHits = 0;\r\n\r\n  constructor(options) {\r\n    super(options);\r\n    this.addEventListener(Events.cast.by(SELECTED_PLAYER).spell(this.constructor.spell), this.onCast);\r\n    this.addEventListener(Events.damage.by(SELECTED_PLAYER).spell(this.constructor.spell), this.onDamage);\r\n    this.addEventListener(Events.fightend, this.onFightend);\r\n  }\r\n\r\n  onCast(event) {\r\n    this.finalizePreviousCast();\r\n    this.casts += 1;\r\n    this.lastCastEvent = event;\r\n    this.lastCastHits = 0;\r\n  }\r\n\r\n  onDamage(event) {\r\n    if (event.tick ||\r\n      !this.lastCastEvent || ((event.timestamp - this.lastCastEvent.timestamp) > DAMAGE_WINDOW)) {\r\n      // only interested in direct damage from the spellId shortly after cast\r\n      return;\r\n    }\r\n    this.totalHits += 1;\r\n    this.lastCastHits += 1;\r\n  }\r\n\r\n  onFightend() {\r\n    this.finalizePreviousCast();\r\n  }\r\n\r\n  finalizePreviousCast() {\r\n    if (!this.lastCastEvent) {\r\n      return;\r\n    }\r\n    if (this.lastCastHits === 0) {\r\n      this.castsWithZeroHits += 1;\r\n    }\r\n    if (this.lastCastHits === 1) {\r\n      this.castsWithOneHit += 1;\r\n    }\r\n  }\r\n\r\n  generateStatistic(statisticPosition) {\r\n    if (this.casts === 0) {\r\n      // Only show statistic if the ability is used.\r\n      return null;\r\n    }\r\n    return (\r\n      <Statistic\r\n        size=\"flexible\"\r\n        tooltip={(\r\n          <>\r\n            You used {this.constructor.spell.name} <strong>{this.casts}</strong> time{(this.casts === 1) ? '' : 's'}.<br />\r\n            <ul>\r\n              <li><strong>{this.castsWithOneHit}</strong> hit just 1 target.</li>\r\n              <li><strong>{this.castsWithZeroHits}</strong> hit nothing at all</li>\r\n            </ul>\r\n          </>\r\n        )}\r\n        position={statisticPosition}\r\n      >\r\n        <BoringSpellValueText spell={this.constructor.spell}>\r\n          <>\r\n            {this.averageTargetsHit.toFixed(1)} <small>average targets hit</small>\r\n          </>\r\n        </BoringSpellValueText>\r\n      </Statistic>\r\n    );\r\n  }\r\n}\r\n\r\nexport default HitCountAoE;\r\n","import React from 'react';\r\nimport SPELLS from 'common/SPELLS';\r\nimport SpellLink from 'common/SpellLink';\r\nimport { STATISTIC_ORDER } from 'interface/others/StatisticBox';\r\nimport { i18n } from '@lingui/core';\r\nimport { t } from '@lingui/macro';\r\n\r\nimport HitCountAoE from '../core/HitCountAoE';\r\n\r\n/**\r\n * Swipe shouldn't be used against a single target, the player's resources are better spent\r\n * on Shred against a single target.\r\n */\r\nclass SwipeHitCount extends HitCountAoE {\r\n  get hitNoneThresholds() {\r\n    return {\r\n      actual: this.hitZeroPerMinute,\r\n      isGreaterThan: {\r\n        minor: 0,\r\n        average: 0.2,\r\n        major: 0.5,\r\n      },\r\n      style: 'number',\r\n    };\r\n  }\r\n\r\n  get hitJustOneThresholds() {\r\n    return {\r\n      actual: this.hitJustOnePerMinute,\r\n      isGreaterThan: {\r\n        minor: 0,\r\n        average: 0.5,\r\n        major: 3.0,\r\n      },\r\n      style: 'number',\r\n    };\r\n  }\r\n\r\n  static spell = SPELLS.SWIPE_CAT;\r\n\r\n  statistic() {\r\n    return this.generateStatistic(STATISTIC_ORDER.OPTIONAL(10));\r\n  }\r\n\r\n  suggestions(when) {\r\n    when(this.hitNoneThresholds).addSuggestion((suggest, actual, recommended) => suggest(\r\n      <>\r\n        You are using <SpellLink id={SPELLS.SWIPE_CAT.id} /> out of range of any targets. Try to get familiar with the range of your area of effect abilities so you can avoid wasting energy when they'll not hit anything.\r\n      </>,\r\n    )\r\n      .icon(SPELLS.SWIPE_CAT.icon)\r\n      .actual(i18n._(t('druid.feral.suggestions.swipe.hitcount.outOfRange')`${actual.toFixed(1)} uses per minute that hit nothing.`))\r\n      .recommended(`${recommended} is recommended`));\r\n\r\n    when(this.hitJustOneThresholds).addSuggestion((suggest, actual, recommended) => suggest(\r\n      <>\r\n        You are using <SpellLink id={SPELLS.SWIPE_CAT.id} /> against a single target. If there's only one target in range you'll do more damage by using <SpellLink id={SPELLS.SHRED.id} /> instead.\r\n      </>,\r\n    )\r\n      .icon(SPELLS.SWIPE_CAT.icon)\r\n      .actual(i18n._(t('druid.feral.suggestions.swipe.hitcount.efficiency')`${actual.toFixed(1)} uses per minute that hit just one target.`))\r\n      .recommended(`${recommended} is recommended`));\r\n  }\r\n}\r\n\r\nexport default SwipeHitCount;\r\n","import React from 'react';\r\nimport PropTypes from 'prop-types';\r\n\r\nimport SpellLink from 'common/SpellLink';\r\nimport { formatPercentage } from 'common/format';\r\nimport { TooltipElement } from 'common/Tooltip';\r\n\r\n// Copied from core breakdown, but with support for 'max CP casts' in spenders display\r\nclass ResourceBreakdown extends React.Component {\r\n  static propTypes = {\r\n    tracker: PropTypes.object.isRequired,\r\n    showSpenders: PropTypes.bool,\r\n  };\r\n\r\n  prepareGenerated(buildersObj) {\r\n    return Object.keys(buildersObj)\r\n      .map(abilityId => ({\r\n        abilityId: Number(abilityId),\r\n        generated: buildersObj[abilityId].generated,\r\n        wasted: buildersObj[abilityId].wasted,\r\n      }))\r\n      .sort((a, b) => b.generated - a.generated)\r\n      .filter(ability => ability.generated > 0);\r\n  }\r\n\r\n  prepareSpent(spendersObj) {\r\n    return Object.keys(spendersObj)\r\n      .map(abilityId => ({\r\n        abilityId: Number(abilityId),\r\n        spent: spendersObj[abilityId].spent,\r\n        casts: spendersObj[abilityId].casts,\r\n        maxCP: spendersObj[abilityId].spentByCast.filter(spent => spent === 5).length,\r\n      }))\r\n      .sort((a, b) => b.spent - a.spent)\r\n      .filter(ability => ability.spent > 0);\r\n  }\r\n\r\n  render() {\r\n    const { tracker, showSpenders } = this.props;\r\n    const resourceName = tracker.resource.name;\r\n    const generated = this.prepareGenerated(tracker.buildersObj);\r\n    const spent = this.prepareSpent(tracker.spendersObj);\r\n\r\n    let totalGenerated = tracker.generated;\r\n    let totalWasted = tracker.wasted;\r\n\r\n    let totalSpent = tracker.spent;\r\n\r\n    // looks wrong but totals are only for the purpose of percentage, and if nothing was wasted, then 0/1 gives correct result 0% wasted, if it's not 0 it retains its original value\r\n    totalGenerated = (totalGenerated === 0) ? 1 : totalGenerated;\r\n    totalWasted = (totalWasted === 0) ? 1 : totalWasted;\r\n\r\n    totalSpent = (totalSpent === 0) ? 1 : totalSpent;\r\n\r\n    return (\r\n      <div>\r\n        <table className=\"data-table\">\r\n          <thead>\r\n            <tr>\r\n              <th>Ability</th>\r\n              <th colSpan=\"2\">{resourceName} generated</th>\r\n              <th colSpan=\"2\"><TooltipElement content=\"This is the amount of resources that were generated while you were already at cap.\">{resourceName} wasted</TooltipElement></th>\r\n            </tr>\r\n          </thead>\r\n          <tbody>\r\n            {generated && generated\r\n              .map(ability => (\r\n                <tr key={ability.abilityId}>\r\n                  <td style={{ width: '30%' }}>\r\n                    <SpellLink id={ability.abilityId} />\r\n                  </td>\r\n                  <td style={{ width: 50, paddingRight: 5, textAlign: 'right' }}>\r\n                    <TooltipElement content={`${formatPercentage(ability.generated / totalGenerated)} %`}>{ability.generated}</TooltipElement>\r\n                  </td>\r\n                  <td style={{ width: '40%' }}>\r\n                    <div\r\n                      className=\"performance-bar\"\r\n                      style={{ width: `${(ability.generated / totalGenerated) * 100}%` }}\r\n                    />\r\n                  </td>\r\n                  <td style={{ width: 50, paddingRight: 5, textAlign: 'right' }}>\r\n                    <TooltipElement content={`${formatPercentage(ability.wasted / totalWasted)} %`}>{ability.wasted}</TooltipElement>\r\n                  </td>\r\n                  <td style={{ width: '30%' }}>\r\n                    <div\r\n                      className=\"performance-bar\"\r\n                      style={{ width: `${(ability.wasted / totalWasted) * 100}%` }}\r\n                    />\r\n                  </td>\r\n                </tr>\r\n              ))}\r\n          </tbody>\r\n        </table>\r\n        {showSpenders && (\r\n          <table className=\"data-table\">\r\n            <thead>\r\n              <tr>\r\n                <th>Ability</th>\r\n                <th colSpan=\"2\">{resourceName} spent</th>\r\n                <th colSpan=\"2\">Max CP Casts / Total Casts</th>\r\n              </tr>\r\n            </thead>\r\n            <tbody>\r\n              {spent && spent\r\n                .map(ability => (\r\n                  <tr key={ability.abilityId}>\r\n                    <td style={{ width: '30%' }}>\r\n                      <SpellLink id={ability.abilityId} />\r\n                    </td>\r\n                    <td style={{ width: 50, paddingRight: 5, textAlign: 'right' }}>\r\n                      <TooltipElement content={`${formatPercentage(ability.spent / totalSpent)} %`}>{ability.spent}</TooltipElement>\r\n                    </td>\r\n                    <td style={{ width: '40%' }}>\r\n                      <div\r\n                        className=\"performance-bar\"\r\n                        style={{ width: `${(ability.spent / totalSpent) * 100}%` }}\r\n                      />\r\n                    </td>\r\n                    <td style={{ width: 50, paddingRight: 5 }} />\r\n                    <td style={{ width: '30%', textAlign: 'left' }}>{ability.maxCP} / {ability.casts}</td>\r\n                  </tr>\r\n                ))}\r\n            </tbody>\r\n          </table>\r\n        )}\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default ResourceBreakdown;\r\n","import RESOURCE_TYPES from 'game/RESOURCE_TYPES';\r\nimport SPELLS from 'common/SPELLS';\r\nimport ResourceTracker from 'parser/shared/modules/resources/resourcetracker/ResourceTracker';\r\n\r\n// Primal Fury may be slightly delayed.\r\nconst PRIMAL_FURY_WINDOW = 50; //ms\r\n\r\nclass ComboPointTracker extends ResourceTracker {\r\n  /**\r\n   * A critical hit from a generator triggers Primal Fury which gives an extra combo point.\r\n   * A Feral druid should always build up 5 combo points and crits are unpredictable.\r\n   * Generators used at 4 combo points that crit will waste the Primal Fury generation but\r\n   * this is unavoidable, or at least shouldn't be avoided.\r\n   */\r\n  unavoidableWaste = 0;\r\n\r\n  castToMaxCpTimestamp = null;\r\n\r\n  constructor(...args) {\r\n    super(...args);\r\n    this.resource = RESOURCE_TYPES.COMBO_POINTS;\r\n    this.maxResource = 5;\r\n  }\r\n\r\n  _applyBuilder(spellId, resource, gain, waste) {\r\n    const isMaxBefore = (this.current === this.maxResource);\r\n    super._applyBuilder(spellId, resource, gain, waste);\r\n    const isMaxAfter = (this.current === this.maxResource);\r\n\r\n    if (!isMaxBefore && isMaxAfter) {\r\n      this.castToMaxCpTimestamp = this.owner.currentTimestamp;\r\n      return;\r\n    }\r\n\r\n    // primal fury procs that happen right after a cast that brought us to max CP shouldn't count as waste because it was out of the player's control\r\n    if ((spellId === SPELLS.PRIMAL_FURY.id) &&\r\n      ((this.owner.currentTimestamp - this.castToMaxCpTimestamp) < PRIMAL_FURY_WINDOW)) {\r\n      this.unavoidableWaste += 1;\r\n    }\r\n  }\r\n}\r\n\r\nexport default ComboPointTracker;\r\n","import React from 'react';\r\nimport Analyzer from 'parser/core/Analyzer';\r\nimport Panel from 'interface/others/Panel';\r\nimport STATISTIC_ORDER from 'interface/others/STATISTIC_ORDER';\r\nimport Statistic from 'interface/statistics/Statistic';\r\nimport BoringResourceValue from 'interface/statistics/components/BoringResourceValue';\r\nimport RESOURCE_TYPES from 'game/RESOURCE_TYPES';\r\n\r\nimport { i18n } from '@lingui/core';\r\nimport { t } from '@lingui/macro';\r\n\r\nimport ResourceBreakdown from './ComboPointBreakdown';\r\nimport ComboPointTracker from './ComboPointTracker';\r\n\r\nclass ComboPointDetails extends Analyzer {\r\n  get pointsWasted() {\r\n    return this.comboPointTracker.wasted - this.comboPointTracker.unavoidableWaste;\r\n  }\r\n\r\n  get pointsWastedPerMinute() {\r\n    return (this.pointsWasted / this.owner.fightDuration) * 1000 * 60;\r\n  }\r\n\r\n  get wastingSuggestionThresholds() {\r\n    return {\r\n      actual: this.pointsWastedPerMinute,\r\n      isGreaterThan: {\r\n        minor: 0,\r\n        average: 5,\r\n        major: 10,\r\n      },\r\n      style: 'number',\r\n    };\r\n  }\r\n\r\n  static dependencies = {\r\n    comboPointTracker: ComboPointTracker,\r\n  };\r\n\r\n  suggestions(when) {\r\n    when(this.wastingSuggestionThresholds).addSuggestion((suggest, actual, recommended) => suggest(\r\n      <>\r\n        You are wasting combo points. Avoid using generators once you reach the maximum.\r\n      </>,\r\n    )\r\n      .icon('creatureportrait_bubble')\r\n      .actual(i18n._(t('druid.feral.suggestions.comboPoints.wasted')`${actual.toFixed(1)} combo points wasted per minute`))\r\n      .recommended('zero waste is recommended'));\r\n  }\r\n\r\n  statistic() {\r\n    return (\r\n      <Statistic\r\n        size=\"small\"\r\n        tooltip={\r\n          <>\r\n            You wasted a total of <strong>{this.pointsWasted}</strong> combo points. <br />\r\n            This number does NOT include Primal Fury procs that happened on a point builder used at 4 CPs, because this waste can't be controlled.\r\n          </>\r\n        }\r\n        position={STATISTIC_ORDER.CORE(6)}\r\n      >\r\n        <BoringResourceValue\r\n          resource={RESOURCE_TYPES.COMBO_POINTS}\r\n          value={`${this.pointsWastedPerMinute.toFixed(2)}`}\r\n          label=\"Wasted Combo Points per minute\"\r\n        />\r\n      </Statistic>\r\n    );\r\n  }\r\n\r\n  tab() {\r\n    return {\r\n      title: 'Combo Point usage',\r\n      url: 'combo-points',\r\n      render: () => (\r\n        <Panel>\r\n          <ResourceBreakdown\r\n            tracker={this.comboPointTracker}\r\n            showSpenders\r\n          />\r\n        </Panel>\r\n      ),\r\n    };\r\n  }\r\n}\r\n\r\nexport default ComboPointDetails;\r\n","import React from 'react';\r\nimport Analyzer from 'parser/core/Analyzer';\r\nimport Enemies from 'parser/shared/modules/Enemies';\r\nimport SPELLS from 'common/SPELLS';\r\nimport SpellLink from 'common/SpellLink';\r\nimport { formatPercentage } from 'common/format';\r\nimport STATISTIC_ORDER from 'interface/others/STATISTIC_ORDER';\r\nimport BoringSpellValueText from 'interface/statistics/components/BoringSpellValueText';\r\nimport UptimeIcon from 'interface/icons/Uptime';\r\nimport Statistic from 'interface/statistics/Statistic';\r\nimport { TooltipElement } from 'common/Tooltip';\r\nimport { i18n } from '@lingui/core';\r\nimport { t } from '@lingui/macro';\r\n\r\nclass RipUptime extends Analyzer {\r\n  get uptime() {\r\n    return this.enemies.getBuffUptime(SPELLS.RIP.id) / this.owner.fightDuration;\r\n  }\r\n\r\n  get suggestionThresholds() {\r\n    return {\r\n      actual: this.uptime,\r\n      isLessThan: {\r\n        minor: 0.95,\r\n        average: 0.90,\r\n        major: 0.80,\r\n      },\r\n      style: 'percentage',\r\n    };\r\n  }\r\n\r\n  static dependencies = {\r\n    enemies: Enemies,\r\n  };\r\n\r\n  suggestions(when) {\r\n    when(this.suggestionThresholds).addSuggestion((suggest, actual, recommended) => suggest(\r\n      <>\r\n        Your <SpellLink id={SPELLS.RIP.id} /> uptime can be improved. You can refresh the DoT once it has reached its <TooltipElement content=\"The last 30% of the DoT's duration. When you refresh during this time you don't lose any duration in the process.\">pandemic window</TooltipElement>, don't wait for it to wear off.\r\n        {!this.selectedCombatant.hasTalent(SPELLS.SABERTOOTH_TALENT.id) ?\r\n          <> Avoid spending combo points on <SpellLink id={SPELLS.FEROCIOUS_BITE.id} /> if <SpellLink id={SPELLS.RIP.id} /> will need refreshing soon.</> : <></>\r\n        }\r\n      </>,\r\n    )\r\n      .icon(SPELLS.RIP.icon)\r\n      .actual(i18n._(t('druid.feral.suggestions.rip.uptime')`${formatPercentage(actual)}% uptime`))\r\n      .recommended(`>${formatPercentage(recommended)}% is recommended`));\r\n  }\r\n\r\n  statistic() {\r\n    return (\r\n      <Statistic\r\n        position={STATISTIC_ORDER.CORE(4)}\r\n        size=\"flexible\"\r\n      >\r\n        <BoringSpellValueText spell={SPELLS.RIP}>\r\n          <>\r\n            <UptimeIcon /> {formatPercentage(this.uptime)}% <small>uptime</small>\r\n          </>\r\n        </BoringSpellValueText>\r\n      </Statistic>\r\n    );\r\n  }\r\n}\r\n\r\nexport default RipUptime;\r\n","import React from 'react';\r\n\r\nimport { formatNumber } from 'common/format';\r\nimport SPELLS from 'common/SPELLS';\r\nimport SpellLink from 'common/SpellLink';\r\nimport RESOURCE_TYPES from 'game/RESOURCE_TYPES';\r\nimport HIT_TYPES from 'game/HIT_TYPES';\r\nimport Analyzer, { SELECTED_PLAYER } from 'parser/core/Analyzer';\r\nimport Events from 'parser/core/Events';\r\nimport { i18n } from '@lingui/core';\r\nimport { t } from '@lingui/macro';\r\n\r\nimport { BERSERK_ENERGY_COST_MULTIPLIER, ENERGY_FOR_FULL_DAMAGE_BITE, MAX_BITE_DAMAGE_BONUS_FROM_ENERGY } from '../../constants';\r\nimport SpellEnergyCost from '../features/SpellEnergyCost';\r\n\r\nconst debug = false;\r\nconst LEEWAY_BETWEEN_CAST_AND_DAMAGE = 500; // in ms\r\nconst HIT_TYPES_TO_IGNORE = [\r\n  HIT_TYPES.MISS,\r\n  HIT_TYPES.DODGE,\r\n  HIT_TYPES.PARRY,\r\n];\r\n\r\n/**\r\n * Although Ferocious Bite costs 25 energy it does extra damage with more energy available, up to double with a full 25 extra energy. This is among the most efficient uses of energy so it's recommended that feral druids wait for 50+ energy before using Bite.\r\n * Ferocious Bite consumes energy in an unusual way: the cast will consume 25 energy followed by a drain event consuming up to 25 more.\r\n * Berserk or Incarnation reduces energy costs by 40%. It reduces Bite's base cost correctly to 15 but reduces the drain effect to 13 (I expect a bug from when it used to reduce costs by 50%). So a player only needs to have 28 (or 30 if the bug is fixed) energy to get full damage from Ferocious Bite during Berserk rather than the usual 50. This module ignores the bug (the effect is very minor) and calculates everything as if the drain effect is correctly reduced to 15 rather than 13.\r\n */\r\nclass FerociousBiteEnergy extends Analyzer {\r\n  get _dpsLostFromLowEnergyBites() {\r\n    return (this.lostDamageTotal / this.owner.fightDuration) * 1000;\r\n  }\r\n\r\n  get _averageBonusEnergyFraction() {\r\n    return this.biteCount > 0 ? (this.sumBonusEnergyFraction / this.biteCount) : 1.0;\r\n  }\r\n\r\n  get suggestionThresholds() {\r\n    return {\r\n      actual: this._averageBonusEnergyFraction,\r\n      isLessThan: {\r\n        minor: 1.0,\r\n        average: 0.95,\r\n        major: 0.8,\r\n      },\r\n      style: 'percentage',\r\n    };\r\n  }\r\n\r\n  static dependencies = {\r\n    spellEnergyCost: SpellEnergyCost,\r\n  };\r\n  biteCount = 0;\r\n  lostDamageTotal = 0;\r\n  sumBonusEnergyFraction = 0;\r\n  lastBiteCast = { timestamp: 0, event: undefined, energyForFullDamage: 50, energyUsedByCast: 25, energyAvailable: 100, isPaired: true };\r\n\r\n  constructor(...args) {\r\n    super(...args);\r\n    this.addEventListener(Events.cast.by(SELECTED_PLAYER).spell(SPELLS.FEROCIOUS_BITE), this._onBiteCast);\r\n    this.addEventListener(Events.damage.by(SELECTED_PLAYER).spell(SPELLS.FEROCIOUS_BITE), this._onBiteDamage);\r\n  }\r\n\r\n  _onBiteCast(event) {\r\n    this.lastBiteCast = {\r\n      timestamp: event.timestamp,\r\n      event: event,\r\n      energyForFullDamage: ENERGY_FOR_FULL_DAMAGE_BITE * (this._hasBerserkAtTime(event.timestamp) ? BERSERK_ENERGY_COST_MULTIPLIER : 1),\r\n      energyUsedByCast: this._energyUsedByCast(event),\r\n      energyAvailable: this._energyAvailable(event),\r\n      isPaired: false,\r\n    };\r\n  }\r\n\r\n  _onBiteDamage(event) {\r\n    if (this.lastBiteCast.isPaired || event.timestamp > this.lastBiteCast.timestamp + LEEWAY_BETWEEN_CAST_AND_DAMAGE) {\r\n      debug && this.warn(\r\n        `Ferocious Bite damage event couldn't find a matching cast event. Last Ferocious Bite cast event was at ${this.lastBiteCast.timestamp}${this.lastBiteCast.isPaired ? ' but has already been paired' : ''}.`);\r\n      return;\r\n    }\r\n\r\n    if (HIT_TYPES_TO_IGNORE.includes(event.hitType)) {\r\n      // ignore parry/dodge/miss events as they'll refund energy anyway\r\n      return;\r\n    }\r\n\r\n    if (this.lastBiteCast.energyAvailable < this.lastBiteCast.energyForFullDamage) {\r\n      const actualDamage = event.amount + event.absorbed;\r\n      const lostDamage = this._calcPotentialBiteDamage(actualDamage, this.lastBiteCast) - actualDamage;\r\n      this.lostDamageTotal += lostDamage;\r\n      this.sumBonusEnergyFraction += this._bonusEnergyFraction(this.lastBiteCast);\r\n\r\n      const castEvent = this.lastBiteCast.event;\r\n      castEvent.meta = event.meta || {};\r\n      castEvent.meta.isInefficientCast = true;\r\n      castEvent.meta.inefficientCastReason = `Used with low energy only gaining ${(this._bonusEnergyFraction(this.lastBiteCast) * 100).toFixed(1)}% of the potential bonus from extra energy, missing out on ${formatNumber(lostDamage)} damage.`;\r\n    } else {\r\n      this.sumBonusEnergyFraction += 1;\r\n    }\r\n\r\n    this.biteCount += 1;\r\n    this.lastBiteCast.isPaired = true;\r\n  }\r\n\r\n  _hasBerserkAtTime(timestamp) {\r\n    return this.selectedCombatant.hasBuff(SPELLS.BERSERK.id, timestamp) ||\r\n      this.selectedCombatant.hasBuff(SPELLS.INCARNATION_KING_OF_THE_JUNGLE_TALENT.id, timestamp);\r\n  }\r\n\r\n  _energyAvailable(event) {\r\n    const resource = event.classResources && event.classResources.find(classResources => classResources.type === RESOURCE_TYPES.ENERGY.id);\r\n    if (!resource || !resource.amount) {\r\n      debug && this.warn('Unable to get energy available from cast event.');\r\n      return 100;\r\n    }\r\n    return resource.amount;\r\n  }\r\n\r\n  _energyUsedByCast(event) {\r\n    if (!event.resourceCost || event.resourceCost[RESOURCE_TYPES.ENERGY.id] === undefined) {\r\n      debug && this.warn('Unable to get energy cost from cast event.');\r\n      return 0;\r\n    }\r\n    return event.resourceCost[RESOURCE_TYPES.ENERGY.id];\r\n  }\r\n\r\n  _bonusEnergyFraction(biteCast) {\r\n    return Math.min(1, (biteCast.energyAvailable - biteCast.energyUsedByCast) / (biteCast.energyForFullDamage - biteCast.energyUsedByCast));\r\n  }\r\n\r\n  /**\r\n   * Calculate what damage a bite could have done if it'd been given the maximum bonus energy\r\n   * @param {number} actualDamage Observed damage of the Bite\r\n   * @param {number} energy Energy available when Bite was cast\r\n   */\r\n  _calcPotentialBiteDamage(actualDamage, biteCast) {\r\n    if (biteCast.energyAvailable >= biteCast.energyForFullDamage) {\r\n      // Bite was already doing its maximum damage\r\n      return actualDamage;\r\n    }\r\n\r\n    // the ideal multiplier would be 2, but because this bite didn't have enough energy the actual multiplier will be lower\r\n    const actualMultiplier = 1 + (MAX_BITE_DAMAGE_BONUS_FROM_ENERGY * this._bonusEnergyFraction(biteCast));\r\n    const damageBeforeMultiplier = actualDamage / actualMultiplier;\r\n    return damageBeforeMultiplier * (1 + MAX_BITE_DAMAGE_BONUS_FROM_ENERGY);\r\n  }\r\n\r\n  suggestions(when) {\r\n    const berserkOrIncarnationId = this.selectedCombatant.hasTalent(SPELLS.INCARNATION_KING_OF_THE_JUNGLE_TALENT.id) ?\r\n      SPELLS.INCARNATION_KING_OF_THE_JUNGLE_TALENT.id :\r\n      SPELLS.BERSERK.id;\r\n    when(this.suggestionThresholds).addSuggestion((suggest, actual, recommended) => suggest(\r\n      <>\r\n        You didn't always give <SpellLink id={SPELLS.FEROCIOUS_BITE.id} /> enough energy to get the full damage bonus. You should aim to have {ENERGY_FOR_FULL_DAMAGE_BITE} energy before using Ferocious Bite, or {(ENERGY_FOR_FULL_DAMAGE_BITE * BERSERK_ENERGY_COST_MULTIPLIER).toFixed(0)} during <SpellLink id={berserkOrIncarnationId} />. Your Ferocious Bite damage was reduced by {formatNumber(this._dpsLostFromLowEnergyBites)} DPS due to lack of energy.\r\n      </>,\r\n    )\r\n      .icon(SPELLS.FEROCIOUS_BITE.icon)\r\n      .actual(i18n._(t('druid.feral.suggestions.ferociousBite.efficiency')`${(actual * 100).toFixed(1)}% average damage bonus from energy on Ferocious Bite.`))\r\n      .recommended(`${(recommended * 100).toFixed(1)}% is recommended.`));\r\n  }\r\n}\r\n\r\nexport default FerociousBiteEnergy;\r\n","import RESOURCE_TYPES from 'game/RESOURCE_TYPES';\r\n\r\nconst debug = false;\r\n\r\nexport default function getComboPointsFromEvent(castEvent) {\r\n  if (!castEvent || !castEvent.classResources) {\r\n    debug && this.warn('castEvent is null or without a classResources property.');\r\n    return 0;\r\n  }\r\n  const resource = castEvent.classResources.find(item => item.type === RESOURCE_TYPES.COMBO_POINTS.id);\r\n  if (!resource) {\r\n    debug && this.warn('castEvent classResources property doesn\\'t have combo points listed.');\r\n    return 0;\r\n  }\r\n  return resource.amount;\r\n}\r\n","import React from 'react';\r\nimport SPELLS from 'common/SPELLS';\r\nimport SpellLink from 'common/SpellLink';\r\nimport SpellIcon from 'common/SpellIcon';\r\nimport { formatNumber, formatPercentage } from 'common/format';\r\nimport { TooltipElement } from 'common/Tooltip';\r\nimport Analyzer, { SELECTED_PLAYER } from 'parser/core/Analyzer';\r\nimport Events from 'parser/core/Events';\r\nimport { encodeTargetString } from 'parser/shared/modules/EnemyInstances';\r\nimport calculateEffectiveDamage from 'parser/core/calculateEffectiveDamage';\r\nimport StatisticsListBox from 'interface/others/StatisticsListBox';\r\n\r\nimport { PANDEMIC_FRACTION, PROWL_RAKE_DAMAGE_BONUS, TIGERS_FURY_DAMAGE_BONUS, BLOODTALONS_DAMAGE_BONUS } from '../../constants';\r\n\r\nconst debug = false;\r\n\r\n/**\r\n * Feral has a snapshotting mechanic which means the effect of some buffs are maintained over the duration of\r\n * some DoTs even after the buff has worn off.\r\n * Players should follow a number of rules with regards when they refresh a DoT and when they do not, depending\r\n * on what buffs the DoT has snapshot and what buffs are currently active.\r\n *\r\n * The Snapshot class is 'abstract', and shouldn't be directly instantiated. Instead classes should extend\r\n * it to examine how well the combatant is making use of the snapshot mechanic.\r\n */\r\n\r\n/**\r\n * leeway in ms after loss of bloodtalons/prowl buff to count a cast as being buffed.\r\n * Danger of false positives from buffs fading due to causes other than being used to buff a DoT.\r\n */\r\nconst BUFF_WINDOW_TIME = 60;\r\n\r\n// leeway in ms between a cast event and debuff apply/refresh for them to be associated\r\nconst CAST_WINDOW_TIME = 300;\r\n\r\n/**\r\n * Leeway in ms between when a debuff was expected to wear off and when damage events will no longer be counted\r\n * Largest found in logs is 149ms:\r\n * https://www.warcraftlogs.com/reports/8Ddyzh9nRjrxv3JA/#fight=16&source=21\r\n * Moonfire DoT tick at 8:13.300, expected to expire at 8:13.151\r\n */\r\nconst DAMAGE_AFTER_EXPIRE_WINDOW = 200;\r\n\r\nclass Snapshot extends Analyzer {\r\n  // extending class should fill these in:\r\n  static spell = null;\r\n  static debuff = null;\r\n\r\n  static isProwlAffected = false;\r\n  static isTigersFuryAffected = false;\r\n  static isBloodtalonsAffected = false;\r\n  static durationOfFresh = null;\r\n\r\n  stateByTarget = {};\r\n  lastDoTCastEvent;\r\n\r\n  castCount = 0;\r\n  ticks = 0;\r\n  ticksWithProwl = 0;\r\n  ticksWithTigersFury = 0;\r\n  ticksWithBloodtalons = 0;\r\n  damageFromProwl = 0;\r\n  damageFromTigersFury = 0;\r\n  damageFromBloodtalons = 0;\r\n\r\n  constructor(...args) {\r\n    super(...args);\r\n    if (!this.constructor.spell || !this.constructor.debuff) {\r\n      this.active = false;\r\n      throw new Error('Snapshot should be extended and provided with spellCastId and debuffId.');\r\n    }\r\n\r\n    this.addEventListener(Events.cast.by(SELECTED_PLAYER).spell(this.constructor.spell), this._castSnapshotSpell);\r\n    this.addEventListener(Events.damage.by(SELECTED_PLAYER).spell(this.constructor.debuff), this._damageFromDebuff);\r\n  }\r\n\r\n  static wasStateFreshlyApplied(state) {\r\n    if (!state) {\r\n      return false;\r\n    }\r\n    if (!state.prev) {\r\n      // no previous state, so must be fresh\r\n      return true;\r\n    }\r\n    const previous = state.prev;\r\n    if (previous.expireTime < state.startTime) {\r\n      // there was a previous state but it wore off before this was applied\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  static wasStatePowerUpgrade(state) {\r\n    if (!state) {\r\n      return false;\r\n    }\r\n    if (Snapshot.wasStateFreshlyApplied(state)) {\r\n      // a fresh application isn't the same as an upgrade\r\n      return false;\r\n    }\r\n    if (state.power > state.prev.power) {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  _castSnapshotSpell(event) {\r\n    this.castCount += 1;\r\n    this.lastDoTCastEvent = event;\r\n    event.debuffEvents.forEach(event => this._debuffApplied(event));\r\n  }\r\n\r\n  _damageFromDebuff(event) {\r\n    if (event.targetIsFriendly || !event.tick) {\r\n      // ignore damage on friendlies and any non-DoT damage\r\n      return;\r\n    }\r\n    if ((event.amount || 0) + (event.absorbed || 0) === 0) {\r\n      // what buffs a zero-damage tick has doesn't matter, so don't count them (usually means target is currently immune to damage)\r\n      return;\r\n    }\r\n    const state = this.stateByTarget[encodeTargetString(event.targetID, event.targetInstance)];\r\n    if (!state || event.timestamp > state.expireTime + DAMAGE_AFTER_EXPIRE_WINDOW) {\r\n      debug && this.warn(`Damage detected from DoT ${this.constructor.debuff.name} but no active state recorded for the target. Previous state expired: ${state ? this.owner.formatTimestamp(state.expireTime, 3) : 'n/a'}`);\r\n      return;\r\n    }\r\n\r\n    // how much damage is coming from the snapshot buffs combined\r\n    const bonusDamage = calculateEffectiveDamage(event, this.calcPowerFromSnapshot(state) - 1);\r\n    const additiveBonus = this.additivePowerSum(state);\r\n\r\n    this.ticks += 1;\r\n    if (state.prowl) {\r\n      this.ticksWithProwl += 1;\r\n      const fractionOfBonus = PROWL_RAKE_DAMAGE_BONUS / additiveBonus;\r\n      this.damageFromProwl += bonusDamage * fractionOfBonus;\r\n    }\r\n    if (state.tigersFury) {\r\n      this.ticksWithTigersFury += 1;\r\n      const fractionOfBonus = TIGERS_FURY_DAMAGE_BONUS / additiveBonus;\r\n      this.damageFromTigersFury += bonusDamage * fractionOfBonus;\r\n    }\r\n    if (state.bloodtalons) {\r\n      this.ticksWithBloodtalons += 1;\r\n      const fractionOfBonus = BLOODTALONS_DAMAGE_BONUS / additiveBonus;\r\n      this.damageFromBloodtalons += bonusDamage * fractionOfBonus;\r\n    }\r\n  }\r\n\r\n  _debuffApplied(event) {\r\n    const targetString = encodeTargetString(event.targetID, event.targetInstance);\r\n    const stateOld = this.stateByTarget[targetString];\r\n    const stateNew = this.makeNewState(event, stateOld);\r\n    this.stateByTarget[targetString] = stateNew;\r\n\r\n    debug && this.log(`DoT ${this.constructor.debuff.name} applied at ${this.owner.formatTimestamp(event.timestamp, 3)} on ${targetString} Prowl:${stateNew.prowl}, TF: ${stateNew.tigersFury}, BT: ${stateNew.bloodtalons}. Expires at ${this.owner.formatTimestamp(stateNew.expireTime, 3)}`);\r\n\r\n    this.checkRefreshRule(stateNew);\r\n  }\r\n\r\n  makeNewState(debuffEvent, stateOld) {\r\n    const timeRemainOnOld = stateOld ? (stateOld.expireTime - debuffEvent.timestamp) : 0;\r\n    const durationNew = this.getDurationOfFresh(debuffEvent);\r\n    let expireNew = debuffEvent.timestamp + durationNew;\r\n    if (timeRemainOnOld > 0) {\r\n      expireNew += Math.min(durationNew * PANDEMIC_FRACTION, timeRemainOnOld);\r\n    }\r\n\r\n    const combatant = this.selectedCombatant;\r\n    const stateNew = {\r\n      expireTime: expireNew,\r\n      pandemicTime: expireNew - durationNew * PANDEMIC_FRACTION,\r\n      tigersFury: this.constructor.isTigersFuryAffected &&\r\n        combatant.hasBuff(SPELLS.TIGERS_FURY.id),\r\n      prowl: this.constructor.isProwlAffected && (\r\n        combatant.hasBuff(SPELLS.INCARNATION_KING_OF_THE_JUNGLE_TALENT.id) ||\r\n        combatant.hasBuff(SPELLS.PROWL.id, null, BUFF_WINDOW_TIME) ||\r\n        combatant.hasBuff(SPELLS.PROWL_INCARNATION.id, null, BUFF_WINDOW_TIME) ||\r\n        combatant.hasBuff(SPELLS.SHADOWMELD.id, null, BUFF_WINDOW_TIME)\r\n      ),\r\n      bloodtalons: this.constructor.isBloodtalonsAffected &&\r\n        combatant.hasBuff(SPELLS.BLOODTALONS_BUFF.id, null, BUFF_WINDOW_TIME),\r\n      power: 1,\r\n      startTime: debuffEvent.timestamp,\r\n      castEvent: this.lastDoTCastEvent,\r\n\r\n      // undefined if the first application of this debuff on this target\r\n      prev: stateOld,\r\n    };\r\n    stateNew.power = this.calcPower(stateNew);\r\n\r\n    if (!stateNew.castEvent ||\r\n      stateNew.startTime > stateNew.castEvent.timestamp + CAST_WINDOW_TIME) {\r\n      debug && this.warn(`DoT ${this.constructor.debuff.name} applied debuff doesn't have a recent matching cast event.`);\r\n    } else {\r\n      // store a reference to this state on the cast event which we'll be able to display on the timeline (or use elsewhere)\r\n      stateNew.castEvent.feralSnapshotState = stateNew;\r\n    }\r\n\r\n    return stateNew;\r\n  }\r\n\r\n  calcPower(stateNew) {\r\n    return this.calcPowerFromSnapshot(stateNew);\r\n  }\r\n\r\n  calcPowerFromSnapshot(stateNew) {\r\n    let power = 1.0;\r\n    if (stateNew.prowl) {\r\n      power *= (PROWL_RAKE_DAMAGE_BONUS + 1);\r\n    }\r\n    if (stateNew.tigersFury) {\r\n      power *= (TIGERS_FURY_DAMAGE_BONUS + 1);\r\n    }\r\n    if (stateNew.bloodtalons) {\r\n      power *= (BLOODTALONS_DAMAGE_BONUS + 1);\r\n    }\r\n    return power;\r\n  }\r\n\r\n  additivePowerSum(stateNew) {\r\n    let additive = 0;\r\n    if (stateNew.prowl) {\r\n      additive += PROWL_RAKE_DAMAGE_BONUS;\r\n    }\r\n    if (stateNew.tigersFury) {\r\n      additive += TIGERS_FURY_DAMAGE_BONUS;\r\n    }\r\n    if (stateNew.bloodtalons) {\r\n      additive += BLOODTALONS_DAMAGE_BONUS;\r\n    }\r\n    return additive;\r\n  }\r\n\r\n  checkRefreshRule(state) {\r\n    debug && this.warn('Expected checkRefreshRule function to be overridden.');\r\n  }\r\n\r\n  getDurationOfFresh(debuffEvent) {\r\n    return this.constructor.durationOfFresh;\r\n  }\r\n\r\n  // TODO: Bring this statistic and tooltip stuff up to standard\r\n  subStatistic(ticksWithBuff, damageIncrease, buffId, buffName, spellName) {\r\n    const info = (\r\n      // subStatistics for this DoT will be combined, so each should have a unique key\r\n      <div className=\"flex\" key={buffId}>\r\n        <div className=\"flex-main\">\r\n          <SpellLink id={buffId} />\r\n        </div>\r\n        <div className=\"flex-sub text-right\">\r\n          <TooltipElement content={`${formatNumber(damageIncrease / this.owner.fightDuration * 1000)} DPS contributed by ${buffName} on your ${spellName} DoT`}>\r\n            {formatPercentage(this.ticks === 0 ? 0 : ticksWithBuff / this.ticks)}%\r\n          </TooltipElement>\r\n        </div>\r\n      </div>\r\n    );\r\n    return info;\r\n  }\r\n\r\n  generateStatistic(spellName, statisticPosition) {\r\n    const subStats = [];\r\n    const buffNames = [];\r\n    if (this.constructor.isProwlAffected) {\r\n      const buffName = 'Prowl';\r\n      buffNames.push(buffName);\r\n      subStats.push(this.subStatistic(this.ticksWithProwl, this.damageFromProwl, SPELLS.PROWL.id, buffName, spellName));\r\n    }\r\n    if (this.constructor.isTigersFuryAffected) {\r\n      const buffName = 'Tiger\\'s Fury';\r\n      buffNames.push(buffName);\r\n      subStats.push(this.subStatistic(this.ticksWithTigersFury, this.damageFromTigersFury, SPELLS.TIGERS_FURY.id, buffName, spellName));\r\n    }\r\n    if (this.constructor.isBloodtalonsAffected && this.selectedCombatant.hasTalent(SPELLS.BLOODTALONS_TALENT.id)) {\r\n      const buffName = 'Bloodtalons';\r\n      buffNames.push(buffName);\r\n      subStats.push(this.subStatistic(this.ticksWithBloodtalons, this.damageFromBloodtalons, SPELLS.BLOODTALONS_TALENT.id, buffName, spellName));\r\n    }\r\n    let buffsComment = '';\r\n    buffNames.forEach((name, index) => {\r\n      const hasComma = (buffNames.length > 2 && index < buffNames.length - 1);\r\n      const hasAnd = (index === buffNames.length - 2);\r\n      buffsComment = `${buffsComment}${name}${hasComma ? ', ' : ''}${hasAnd ? ' and ' : ''}`;\r\n    });\r\n    const isPlural = buffNames.length > 1;\r\n    return (\r\n      <StatisticsListBox\r\n        title={(\r\n          <>\r\n            <SpellIcon id={this.constructor.spell.id} noLink /> {spellName} Snapshot\r\n          </>\r\n        )}\r\n        tooltip={`${spellName} maintains the damage bonus from ${buffsComment} if ${isPlural ? 'they were' : 'it was'} present when the DoT was applied. This lists how many of your ${spellName} ticks benefited from ${isPlural ? 'each' : 'the'} buff. ${isPlural ? 'As a tick can benefit from multiple buffs at once these percentages can add up to more than 100%.' : ''}`}\r\n        position={statisticPosition}\r\n      >\r\n        {subStats}\r\n      </StatisticsListBox>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Snapshot;\r\n","import React from 'react';\r\nimport SPELLS from 'common/SPELLS';\r\nimport SpellLink from 'common/SpellLink';\r\nimport { encodeTargetString } from 'parser/shared/modules/EnemyInstances';\r\nimport { STATISTIC_ORDER } from 'interface/others/StatisticsListBox';\r\nimport { TooltipElement } from 'common/Tooltip';\r\nimport { SELECTED_PLAYER } from 'parser/core/Analyzer';\r\nimport Events from 'parser/core/Events';\r\nimport { i18n } from '@lingui/core';\r\nimport { t } from '@lingui/macro';\r\n\r\nimport getComboPointsFromEvent from '../core/getComboPointsFromEvent';\r\nimport Snapshot from '../core/Snapshot';\r\nimport ComboPointTracker from '../combopoints/ComboPointTracker';\r\nimport { PANDEMIC_FRACTION, RIP_DURATION_1_CP, RIP_DURATION_PER_CP, RIP_MAXIMUM_EXTENDED_DURATION, SABERTOOTH_EXTEND_PER_CP } from '../../constants';\r\n\r\nconst debug = false;\r\n\r\nconst MAX_ALLOWED_DURATION_REDUCTION = 500; // in ms\r\n\r\n/**\r\n * Rip's damage snapshots the effects of Tiger's Fury and Bloodtalons. It's not affected by prowl.\r\n * Refreshing Rip with a less powerful version before the pandemic window is a damage loss.\r\n *\r\n * Ferocious Bite with the Sabertooth talent will extend a Rip bleed, maintaining the existing snapshot from when Rip was cast.\r\n * Applying a fresh Rip when you could have extended by using Bite is a damage loss, unless the Rip improved the snapshot.\r\n * Bite extending a weak Rip when you could have applied a stronger Rip can sometimes be a damage loss. There's a lot of\r\n * factors in play so this analyzer doesn't attempt to detect Bites that should have been Rips.\r\n *\r\n * When Bite extends the duration of a Rip, it doesn't trigger the refreshdebuff event in the combat log.\r\n */\r\n\r\nclass RipSnapshot extends Snapshot {\r\n  get shouldBeBiteProportion() {\r\n    return this.shouldBeBiteCount / this.castCount;\r\n  }\r\n\r\n  get shouldBeBiteSuggestionThresholds() {\r\n    return {\r\n      actual: this.shouldBeBiteProportion,\r\n      isGreaterThan: {\r\n        minor: 0,\r\n        average: 0.10,\r\n        major: 0.20,\r\n      },\r\n      style: 'percentage',\r\n    };\r\n  }\r\n\r\n  get durationReductionThresholds() {\r\n    return {\r\n      actual: this.durationReductionCount / this.castCount,\r\n      isGreaterThan: {\r\n        minor: 0,\r\n        average: 0.10,\r\n        major: 0.20,\r\n      },\r\n      style: 'percentage',\r\n    };\r\n  }\r\n\r\n  get downgradeProportion() {\r\n    return this.downgradeCount / this.castCount;\r\n  }\r\n\r\n  get downgradeSuggestionThresholds() {\r\n    return {\r\n      actual: this.downgradeProportion,\r\n      isGreaterThan: {\r\n        minor: 0,\r\n        average: 0.15,\r\n        major: 0.60,\r\n      },\r\n      style: 'percentage',\r\n    };\r\n  }\r\n\r\n  static dependencies = {\r\n    comboPointTracker: ComboPointTracker,\r\n  };\r\n  static spell = SPELLS.RIP;\r\n  static debuff = SPELLS.RIP;\r\n  static durationOfFresh = null; // varies, see getDurationOfFresh()\r\n  static isProwlAffected = false;\r\n  static isTigersFuryAffected = true;\r\n  static isBloodtalonsAffected = true;\r\n  static hasSabertooth = false;\r\n  downgradeCount = 0;\r\n  shouldBeBiteCount = 0;\r\n  durationReductionCount = 0;\r\n  /**\r\n   * Order of processed events when player casts rip is always:\r\n   *   cast\r\n   *   debuffapply or debuffrefresh\r\n   * So it's safe to store the comboLastRip on cast then use it to calculate the DoT duration in response to debuff apply/refresh.\r\n   */\r\n  comboLastRip = 0;\r\n\r\n  constructor(...args) {\r\n    super(...args);\r\n    if (this.selectedCombatant.hasTalent(SPELLS.SABERTOOTH_TALENT.id)) {\r\n      this.constructor.hasSabertooth = true;\r\n    }\r\n    this.addEventListener(Events.cast.by(SELECTED_PLAYER).spell(SPELLS.RIP), this._castRip);\r\n    this.addEventListener(Events.cast.by(SELECTED_PLAYER).spell(SPELLS.FEROCIOUS_BITE), this._castFerociousBite);\r\n  }\r\n\r\n  _castRip(event) {\r\n    this.comboLastRip = getComboPointsFromEvent(event);\r\n    debug && this.log(`spend ${this.comboLastRip} combo points on Rip`);\r\n  }\r\n\r\n  _castFerociousBite(event) {\r\n    if (!this.constructor.hasSabertooth) {\r\n      // without sabertooth talent the duration doesn't get extended\r\n      return;\r\n    }\r\n    const target = encodeTargetString(event.targetID, event.targetInstance);\r\n    const existing = this.stateByTarget[target];\r\n    if (!existing || existing.expireTime < event.timestamp) {\r\n      // no existing Rip on the target so nothing to extend\r\n      return;\r\n    }\r\n\r\n    // FIXME: If the ferocious bite is parried (or otherwise fails to hit) it will not extend rip, but that's not accounted for here.\r\n\r\n    // Sabertooth extends duration depending on combo points used on Bite, but there's a limit to how far into the future Rip can be extended\r\n    const comboPoints = getComboPointsFromEvent(event);\r\n    const remainingTime = existing.expireTime - event.timestamp;\r\n    const newDuration = Math.min(RIP_MAXIMUM_EXTENDED_DURATION, remainingTime + comboPoints * SABERTOOTH_EXTEND_PER_CP);\r\n    existing.expireTime = event.timestamp + newDuration;\r\n    existing.pandemicTime = event.timestamp + newDuration * (1.0 - PANDEMIC_FRACTION);\r\n    debug && this.log(`${comboPoints} combo bite extended rip to ${this.owner.formatTimestamp(existing.expireTime)}`);\r\n  }\r\n\r\n  checkRefreshRule(stateNew) {\r\n    const stateOld = stateNew.prev;\r\n    if (!stateOld || stateOld.expireTime < stateNew.startTime) {\r\n      return;\r\n    }\r\n    const event = stateNew.castEvent;\r\n    if (!event) {\r\n      debug && this.warn('RipSnapshot checking refresh rule with a state that was never assigned a cast event.');\r\n      return;\r\n    }\r\n\r\n    if (this.active.constructor.hasSabertooth && stateOld.power >= stateNew.power) {\r\n      // could have extended Rip using Bite and benefited from the Bite's damage instead of this fresh cast of Rip.\r\n      this.shouldBeBiteCount += 1;\r\n      event.meta = event.meta || {};\r\n      event.meta.isInefficientCast = true;\r\n      const strengthComment = (stateOld.power > stateNew.power) ? 'a stronger' : 'the same strength';\r\n      event.meta.inefficientCastReason = `Used Rip when you could have extended using Ferocious Bite and kept ${strengthComment} snapshot.`;\r\n    }\r\n\r\n    if (stateOld.expireTime > (stateNew.expireTime - MAX_ALLOWED_DURATION_REDUCTION)) {\r\n      // existing DoT would have lasted longer than the new one will, so would have been better off doing nothing at all\r\n      const remainingOld = ((stateOld.expireTime - stateNew.startTime) / 1000).toFixed(1);\r\n      const remainingNew = ((stateNew.expireTime - stateNew.startTime) / 1000).toFixed(1);\r\n      this.durationReductionCount += 1;\r\n      event.meta = event.meta || {};\r\n      event.meta.isInefficientCast = true;\r\n      event.meta.inefficientCastReason = `There was already a Rip with ${remainingOld} seconds remaining, but this cast replaced it with one lasting ${remainingNew} seconds.`;\r\n    }\r\n\r\n    if (stateOld.pandemicTime <= stateNew.startTime ||\r\n      stateOld.power <= stateNew.power) {\r\n      return;\r\n    }\r\n    this.downgradeCount += 1;\r\n\r\n    // this downgrade is relatively minor, so don't overwrite cast info from elsewhere\r\n    if (event.meta && (event.meta.isInefficientCast || event.meta.isEnhancedCast)) {\r\n      return;\r\n    }\r\n    event.meta = event.meta || {};\r\n    event.meta.isInefficientCast = true;\r\n    event.meta.inefficientCastReason = 'You refreshed with a weaker version of Rip before the pandemic window.';\r\n  }\r\n\r\n  getDurationOfFresh(debuffEvent) {\r\n    return RIP_DURATION_1_CP + RIP_DURATION_PER_CP * this.comboLastRip;\r\n  }\r\n\r\n  suggestions(when) {\r\n    when(this.downgradeSuggestionThresholds).addSuggestion((suggest, actual, recommended) => suggest(\r\n      <>\r\n        Try not to refresh <SpellLink id={SPELLS.RIP.id} /> before the <TooltipElement content={`The last ${(this.constructor.durationOfFresh * PANDEMIC_FRACTION / 1000).toFixed(1)} seconds of Rip's duration. When you refresh during this time you don't lose any duration in the process.`}>pandemic window</TooltipElement> unless you have more powerful <TooltipElement content=\"Applying Rip with Tiger's Fury or Bloodtalons will boost its damage until you reapply it.\">snapshot buffs</TooltipElement> than were present when it was first cast.\r\n      </>,\r\n    )\r\n      .icon(SPELLS.RIP.icon)\r\n      .actual(i18n._(t('druid.feral.suggestions.ripSnapshot.earlyRefresh')`${this.downgradeCount} Rip refresh${this.downgradeCount === 1 ? '' : 'es'} were early downgrades.`))\r\n      .recommended('None is recommended'));\r\n\r\n    when(this.shouldBeBiteSuggestionThresholds).addSuggestion((suggest, actual, recommended) => suggest(\r\n      <>\r\n        With <SpellLink id={SPELLS.SABERTOOTH_TALENT.id} /> you should use <SpellLink id={SPELLS.FEROCIOUS_BITE.id} /> to extend the duration of <SpellLink id={SPELLS.RIP.id} />. Only use <SpellLink id={SPELLS.RIP.id} /> when the bleed is missing or when you can improve the <TooltipElement content=\"Applying Rip with Tiger's Fury or Bloodtalons will boost its damage until you reapply it. This boost is maintained when Bite extends the bleed.\">snapshot.</TooltipElement>\r\n      </>,\r\n    )\r\n      .icon(SPELLS.RIP.icon)\r\n      .actual(i18n._(t('druid.feral.suggestions.ripSnapshot.shouldBeBite')`${this.shouldBeBiteCount} Rip cast${this.shouldBeBiteCount === 1 ? '' : 's'} could have been replaced with Bite.`))\r\n      .recommended('None is recommended'));\r\n\r\n    when(this.durationReductionThresholds).addSuggestion((suggest, actual, recommended) => suggest(\r\n      <>\r\n        You sometimes replaced your <SpellLink id={SPELLS.RIP.id} /> DoT with a shorter duration version. Avoid using <SpellLink id={SPELLS.RIP.id} /> at low combo points, and especially not when there's already a <SpellLink id={SPELLS.RIP.id} /> active on the target.\r\n      </>,\r\n    )\r\n      .icon(SPELLS.RIP.icon)\r\n      .actual(i18n._(t('druid.feral.suggestions.ripSnapshot.reducedDuration')`Rip's duration reduced ${this.durationReductionCount} time${this.durationReductionCount === 1 ? '' : 's'}.`))\r\n      .recommended('None is recommended'));\r\n  }\r\n\r\n  statistic() {\r\n    return super.generateStatistic(SPELLS.RIP.name, STATISTIC_ORDER.CORE(11));\r\n  }\r\n}\r\n\r\nexport default RipSnapshot;\r\n","import React from 'react';\r\nimport SPELLS from 'common/SPELLS';\r\nimport SpellLink from 'common/SpellLink';\r\nimport { formatPercentage } from 'common/format';\r\nimport { STATISTIC_ORDER } from 'interface/others/StatisticsListBox';\r\nimport { TooltipElement } from 'common/Tooltip';\r\n\r\nimport { i18n } from '@lingui/core';\r\nimport { t } from '@lingui/macro';\r\n\r\nimport { RAKE_BASE_DURATION, PANDEMIC_FRACTION } from '../../constants';\r\nimport Snapshot from '../core/Snapshot';\r\n\r\n/**\r\n * Identify inefficient refreshes of the Rake DoT:\r\n *  Early refresh of a Rake doing double damage due to Prowl with one that will not do double damage.\r\n *  Pre-pandemic refresh of a Rake doing bonus damage from snapshot buffs with one that will do less damage.\r\n */\r\n\r\n/**\r\n * When you cannot refresh a prowl-buffed rake with prowl, ideally you'd let it tick down.\r\n * Then at the moment that it expires you'd apply a fresh DoT.\r\n * But exact timing is unrealistic, so give some leeway.\r\n */\r\nconst FORGIVE_PROWL_LOSS_TIME = 1000;\r\n\r\nclass RakeSnapshot extends Snapshot {\r\n  // seconds of double-damage Rake lost per minute\r\n  get prowlLostTimePerMinute() {\r\n    return (this.prowlLostTimeSum / this.owner.fightDuration) * 60;\r\n  }\r\n\r\n  get downgradeProportion() {\r\n    return this.downgradeCastCount / this.castCount;\r\n  }\r\n\r\n  get prowlLostSuggestionThresholds() {\r\n    return {\r\n      actual: this.prowlLostTimePerMinute,\r\n      isGreaterThan: {\r\n        minor: 0.5,\r\n        average: 2.0,\r\n        major: 8.0,\r\n      },\r\n      style: 'decimal',\r\n    };\r\n  }\r\n\r\n  get downgradeSuggestionThresholds() {\r\n    return {\r\n      actual: this.downgradeProportion,\r\n      isGreaterThan: {\r\n        minor: 0,\r\n        average: 0.15,\r\n        major: 0.60,\r\n      },\r\n      style: 'percentage',\r\n    };\r\n  }\r\n\r\n  static spell = SPELLS.RAKE;\r\n  static debuff = SPELLS.RAKE_BLEED;\r\n  static durationOfFresh = RAKE_BASE_DURATION;\r\n  static isProwlAffected = true;\r\n  static isTigersFuryAffected = true;\r\n  static isBloodtalonsAffected = true;\r\n  // rake buffed with Prowl ending early due to refresh without Prowl buff\r\n  prowlLostCastCount = 0;\r\n  // total time cut out from the end of prowl-buffed rake bleeds by refreshing early (milliseconds)\r\n  prowlLostTimeSum = 0;\r\n  // rake DoTs refreshed with weaker snapshot before pandemic\r\n  downgradeCastCount = 0;\r\n\r\n  checkRefreshRule(stateNew) {\r\n    const stateOld = stateNew.prev;\r\n    const event = stateNew.castEvent;\r\n    if (!stateOld || stateOld.expireTime < stateNew.startTime) {\r\n      // it's not a refresh, so nothing to check\r\n      return;\r\n    }\r\n\r\n    if (stateOld.prowl && !stateNew.prowl) {\r\n      // refresh removed a powerful prowl-buffed bleed\r\n      const timeLost = stateOld.expireTime - stateNew.startTime;\r\n      this.prowlLostTimeSum += timeLost;\r\n\r\n      // only mark significant time loss events. Still add up the \"insignificant\" time lost for possible suggestion.\r\n      if (timeLost > FORGIVE_PROWL_LOSS_TIME) {\r\n        this.prowlLostCastCount += 1;\r\n        event.meta = event.meta || {};\r\n        event.meta.isInefficientCast = true;\r\n        event.meta.inefficientCastReason = `You lost ${(timeLost / 1000).toFixed(1)} seconds of a Rake empowered with Prowl by refreshing early.`;\r\n      }\r\n    } else if (stateOld.pandemicTime > stateNew.startTime &&\r\n      stateOld.power > stateNew.power &&\r\n      !stateNew.prowl) {\r\n      // refreshed with weaker DoT before pandemic window - but ignore this rule if the new Rake has Prowl buff as that's more important.\r\n      this.downgradeCastCount += 1;\r\n\r\n      if (!event.meta || (!event.meta.isInefficientCast && !event.meta.isEnhancedCast)) {\r\n        // this downgrade is relatively minor, so don't overwrite output from elsewhere.\r\n        event.meta = event.meta || {};\r\n        event.meta.isInefficientCast = true;\r\n        event.meta.inefficientCastReason = `You refreshed with a weaker version of Rake before the pandemic window.`;\r\n      }\r\n    }\r\n  }\r\n\r\n  suggestions(when) {\r\n    when(this.prowlLostSuggestionThresholds).addSuggestion((suggest, actual, recommended) => suggest(\r\n      <>\r\n        When <SpellLink id={SPELLS.RAKE.id} /> is empowered by <SpellLink id={SPELLS.PROWL.id} /> avoid refreshing it unless the replacement would also be empowered. You ended {this.prowlLostCastCount} empowered <SpellLink id={SPELLS.RAKE.id} /> bleed{this.prowlLostCastCount !== 1 ? 's' : ''} more than 1 second early.\r\n      </>,\r\n    )\r\n      .icon(SPELLS.RAKE.icon)\r\n      .actual(i18n._(t('druid.feral.suggestions.rakeSnapshot.prowlBuffed')`${actual.toFixed(1)} seconds of Prowl buffed Rake was lost per minute.`))\r\n      .recommended(`<${recommended} is recommended`));\r\n\r\n    when(this.downgradeSuggestionThresholds).addSuggestion((suggest, actual, recommended) => suggest(\r\n      <>\r\n        Try to only refresh <SpellLink id={SPELLS.RAKE.id} /> before the <TooltipElement content={`The last ${(this.constructor.durationOfFresh * PANDEMIC_FRACTION / 1000).toFixed(1)} seconds of Rake's duration. When you refresh during this time you don't lose any duration in the process.`}>pandemic window</TooltipElement> if you have more powerful <TooltipElement content=\"Applying Rake with Prowl, Tiger's Fury or Bloodtalons will boost its damage until you reapply it.\">snapshot buffs</TooltipElement> than were present when it was first cast.\r\n      </>,\r\n    )\r\n      .icon(SPELLS.RAKE.icon)\r\n      .actual(i18n._(t('druid.feral.suggestions.rakeSnapshot.earlyRefresh')`${formatPercentage(actual)}% of Rake refreshes were early downgrades.`))\r\n      .recommended(`${recommended}% is recommended`));\r\n  }\r\n\r\n  statistic() {\r\n    return super.generateStatistic(SPELLS.RAKE.name, STATISTIC_ORDER.CORE(10));\r\n  }\r\n}\r\n\r\nexport default RakeSnapshot;\r\n","import React from 'react';\r\nimport SPELLS from 'common/SPELLS';\r\nimport SpellLink from 'common/SpellLink';\r\nimport { formatPercentage } from 'common/format';\r\nimport { STATISTIC_ORDER } from 'interface/others/StatisticsListBox';\r\nimport { TooltipElement } from 'common/Tooltip';\r\nimport { i18n } from '@lingui/core';\r\nimport { t } from '@lingui/macro';\r\n\r\nimport Snapshot from '../core/Snapshot';\r\nimport { MOONFIRE_FERAL_BASE_DURATION, PANDEMIC_FRACTION } from '../../constants';\r\n\r\n/**\r\n * Moonfire benefits from the damage bonus of Tiger's Fury over its whole duration, even if the\r\n * buff wears off in that time. It's a damage loss to refresh Moonfire before the pandemic window\r\n * if you don't have Tiger's Fury active when the existing DoT does have it active.\r\n */\r\n\r\nclass MoonfireSnapshot extends Snapshot {\r\n  get downgradeProportion() {\r\n    return this.downgradeCastCount / this.castCount;\r\n  }\r\n\r\n  get downgradeSuggestionThresholds() {\r\n    return {\r\n      actual: this.downgradeProportion,\r\n      isGreaterThan: {\r\n        minor: 0,\r\n        average: 0.15,\r\n        major: 0.60,\r\n      },\r\n      style: 'percentage',\r\n    };\r\n  }\r\n\r\n  static spell = SPELLS.MOONFIRE_FERAL;\r\n  static debuff = SPELLS.MOONFIRE_FERAL;\r\n  static durationOfFresh = MOONFIRE_FERAL_BASE_DURATION;\r\n  static isProwlAffected = false;\r\n  static isTigersFuryAffected = true;\r\n  // bloodtalons only affects melee abilities\r\n  static isBloodtalonsAffected = false;\r\n  downgradeCastCount = 0;\r\n\r\n  constructor(...args) {\r\n    super(...args);\r\n    if (!this.selectedCombatant.hasTalent(SPELLS.LUNAR_INSPIRATION_TALENT.id)) {\r\n      this.active = false;\r\n    }\r\n  }\r\n\r\n  checkRefreshRule(stateNew) {\r\n    const stateOld = stateNew.prev;\r\n    if (!stateOld || stateOld.expireTime < stateNew.startTime) {\r\n      // not a refresh, so nothing to check\r\n      return;\r\n    }\r\n\r\n    if (stateNew.startTime >= stateOld.pandemicTime ||\r\n      stateNew.power >= stateOld.power) {\r\n      // good refresh\r\n      return;\r\n    }\r\n\r\n    this.downgradeCastCount += 1;\r\n\r\n    // this downgrade is relatively minor, so don't overwrite cast info from elsewhere\r\n    const event = stateNew.castEvent;\r\n    if (event.meta && (event.meta.isInefficientCast || event.meta.isEnhancedCast)) {\r\n      return;\r\n    }\r\n    event.meta = event.meta || {};\r\n    event.meta.isInefficientCast = true;\r\n    event.meta.inefficientCastReason = 'You refreshed with a weaker version of Moonfire before the pandemic window.';\r\n  }\r\n\r\n  suggestions(when) {\r\n    when(this.downgradeSuggestionThresholds).addSuggestion((suggest, actual, recommended) => suggest(\r\n      <>\r\n        Try not to refresh <SpellLink id={SPELLS.MOONFIRE_FERAL.id} /> before the <TooltipElement content={`The last ${(this.constructor.durationOfFresh * PANDEMIC_FRACTION / 1000).toFixed(1)} seconds of Moonfire's duration. When you refresh during this time you don't lose any duration in the process.`}>pandemic window</TooltipElement> unless you have more powerful <TooltipElement content=\"Applying Moonfire with Tiger's Fury will boost its damage until you reapply it.\">snapshot buffs</TooltipElement> than were present when it was first cast.\r\n      </>,\r\n    )\r\n      .icon(SPELLS.MOONFIRE_FERAL.icon)\r\n      .actual(i18n._(t('druid.feral.suggestions.moonfireSnapshot.downgrades')`${formatPercentage(actual)}% of Moonfire refreshes were early downgrades.`))\r\n      .recommended(`${recommended}% is recommended`));\r\n  }\r\n\r\n  statistic() {\r\n    return super.generateStatistic(SPELLS.MOONFIRE_FERAL.name, STATISTIC_ORDER.OPTIONAL(10));\r\n  }\r\n}\r\n\r\nexport default MoonfireSnapshot;\r\n","import React from 'react';\r\nimport SPELLS from 'common/SPELLS';\r\nimport STATISTIC_ORDER from 'interface/others/STATISTIC_ORDER';\r\nimport BoringSpellValueText from 'interface/statistics/components/BoringSpellValueText';\r\nimport Statistic from 'interface/statistics/Statistic';\r\nimport SpellLink from 'common/SpellLink';\r\nimport { formatPercentage } from 'common/format';\r\nimport Analyzer, { SELECTED_PLAYER } from 'parser/core/Analyzer';\r\nimport Events from 'parser/core/Events';\r\nimport { i18n } from '@lingui/core';\r\nimport { t } from '@lingui/macro';\r\n\r\nconst debug = false;\r\n\r\nconst PREDATORY_SWIFTNESS_BUFF_DURATION = 12000;\r\nconst EXPIRE_WINDOW = 100;\r\nconst IGNORE_DOUBLE_GAIN_WINDOW = 100;\r\nconst POTENTIAL_SPENDERS = [\r\n  SPELLS.REGROWTH,\r\n  SPELLS.ENTANGLING_ROOTS,\r\n];\r\n\r\n/**\r\n * Using a finishing move has a 20% chance per combo point to give the buff \"Predatory Swiftness\"\r\n * which makes the next Regrowth or Entangling Roots instant cast and usable in cat form. Normally\r\n * this provides occasional extra utility. But with the Bloodtalons talent it becomes an important\r\n * part of the damage rotation.\r\n */\r\nclass PredatorySwiftness extends Analyzer {\r\n  get wasted() {\r\n    return this.expired + this.overwritten + this.remainAfterFight;\r\n  }\r\n\r\n  get wastedFraction() {\r\n    return this.wasted / this.generated;\r\n  }\r\n\r\n  get suggestionThresholds() {\r\n    return {\r\n      actual: this.wastedFraction,\r\n      isGreaterThan: {\r\n        minor: 0,\r\n        average: 0.10,\r\n        major: 0.20,\r\n      },\r\n      style: 'percentage',\r\n    };\r\n  }\r\n\r\n  hasSwiftness = false;\r\n  generated = 0;\r\n  used = 0;\r\n  expired = 0;\r\n  remainAfterFight = 0;\r\n  overwritten = 0;\r\n  /**\r\n   * The combat log sometimes reports the player gaining Predatory Swiftness twice from a single finisher.\r\n   * Avoid this by tracking time of last gain event.\r\n   */\r\n  timeLastGain = null;\r\n\r\n  constructor(options) {\r\n    super(options);\r\n    this.addEventListener(Events.fightend, this.onFightend);\r\n    this.addEventListener(Events.applybuff.to(SELECTED_PLAYER).spell(SPELLS.PREDATORY_SWIFTNESS), this.onApplyBuff);\r\n    this.addEventListener(Events.refreshbuff.to(SELECTED_PLAYER).spell(SPELLS.PREDATORY_SWIFTNESS), this.onRefreshBuff);\r\n    this.addEventListener(Events.removebuff.to(SELECTED_PLAYER).spell(SPELLS.PREDATORY_SWIFTNESS), this.onRemoveBuff);\r\n    this.addEventListener(Events.cast.by(SELECTED_PLAYER).spell(POTENTIAL_SPENDERS), this.onCast);\r\n  }\r\n\r\n  onFightend() {\r\n    if (this.hasSwiftness) {\r\n      debug && console.log(`${this.owner.formatTimestamp(this.owner.fight.end_time, 3)} fight ended with a Predatory Swiftness buff unused.`);\r\n      this.remainAfterFight = 1;\r\n    }\r\n\r\n    if (debug && this.generated !== (this.used + this.expired + this.remainAfterFight + this.overwritten)) {\r\n      console.warn(`Not all Predatory Swiftness charges accounted for. Generated: ${this.generated}, used: ${this.used}, expired: ${this.expired}, remainAfterFight: ${this.remainAfterFight}, overwritten: ${this.overwritten}`);\r\n    }\r\n  }\r\n\r\n  onApplyBuff(event) {\r\n    debug && console.log(`${this.owner.formatTimestamp(event.timestamp, 3)} gained Predatory Swiftness`);\r\n    this.hasSwiftness = true;\r\n    this.generated += 1;\r\n    this.timeLastGain = event.timestamp;\r\n    this.expireTime = event.timestamp + PREDATORY_SWIFTNESS_BUFF_DURATION;\r\n  }\r\n\r\n  onRefreshBuff(event) {\r\n    if (Math.abs(event.timestamp - this.timeLastGain) < IGNORE_DOUBLE_GAIN_WINDOW) {\r\n      return;\r\n    }\r\n    debug && console.log(`${this.owner.formatTimestamp(event.timestamp, 3)} gained Predatory Swiftness, overwriting existing`);\r\n    this.hasSwiftness = true;\r\n    this.generated += 1;\r\n    this.overwritten += 1;\r\n    this.timeLastGain = event.timestamp;\r\n    // buff duration not affected by pandemic\r\n    this.expireTime = event.timestamp + PREDATORY_SWIFTNESS_BUFF_DURATION;\r\n  }\r\n\r\n  onRemoveBuff(event) {\r\n    if (!this.hasSwiftness || !this.expireTime ||\r\n      Math.abs(this.expireTime - event.timestamp) > EXPIRE_WINDOW) {\r\n      return;\r\n    }\r\n    debug && console.log(`${this.owner.formatTimestamp(event.timestamp, 3)} Predatory Swiftness expired, unused`);\r\n    this.expired += 1;\r\n    this.hasSwiftness = false;\r\n    this.expireTime = null;\r\n  }\r\n\r\n  onCast(event) {\r\n    if (!this.hasSwiftness) {\r\n      return;\r\n    }\r\n    debug && console.log(`${this.owner.formatTimestamp(event.timestamp, 3)} Predatory Swiftness used`);\r\n    this.used += 1;\r\n    this.hasSwiftness = false;\r\n    this.expireTime = null;\r\n  }\r\n\r\n  suggestions(when) {\r\n    if (!this.selectedCombatant.hasTalent(SPELLS.BLOODTALONS_TALENT.id)) {\r\n      // Predatory Swiftness is only important to damage rotation if the player has Bloodtalons\r\n      return;\r\n    }\r\n    when(this.suggestionThresholds).addSuggestion((suggest, actual, recommended) => suggest(\r\n      <>\r\n        You are not making use of all your chances to trigger <SpellLink id={SPELLS.BLOODTALONS_TALENT.id} /> through <SpellLink id={SPELLS.PREDATORY_SWIFTNESS.id} />. Try to use it to instant-cast <SpellLink id={SPELLS.REGROWTH.id} /> or <SpellLink id={SPELLS.ENTANGLING_ROOTS.id} /> before you generate another charge of the buff, and before it wears off.\r\n      </>,\r\n    )\r\n      .icon(SPELLS.PREDATORY_SWIFTNESS.icon)\r\n      .actual(i18n._(t('druid.feral.suggestions.predatorySwiftness.wasted')`${formatPercentage(actual)}% of Predatory Swiftness buffs wasted.`))\r\n      .recommended(`${recommended}% is recommended`));\r\n  }\r\n\r\n  statistic() {\r\n    return (\r\n      <Statistic\r\n        tooltip={(\r\n          <>\r\n            You used <strong>{this.used}</strong> out of <strong>{this.generated}</strong> Predatory Swiftness buffs to instant-cast Regrowth or Entangling Roots{this.selectedCombatant.hasTalent(SPELLS.BLOODTALONS_TALENT.id) ? ' and trigger the Bloodtalons buff' : ''}. <br />\r\n            <ul>\r\n              <li>The buff was allowed to expire <strong>{this.expired}</strong> time{this.expired !== 1 ? 's' : ''}.</li>\r\n              <li>You used another finisher while the buff was still active and overwrote it <strong>{this.overwritten}</strong> time{this.overwritten !== 1 ? 's' : ''}.</li>\r\n              <li>You had <strong>{this.remainAfterFight}</strong> remaining unused at the end of the fight.</li>\r\n            </ul>\r\n          </>\r\n        )}\r\n        size=\"flexible\"\r\n        position={STATISTIC_ORDER.OPTIONAL(5)}\r\n      >\r\n        <BoringSpellValueText spell={SPELLS.PREDATORY_SWIFTNESS}>\r\n          <>\r\n            {formatPercentage(1 - this.wastedFraction)}% <small>buffs used</small>\r\n          </>\r\n        </BoringSpellValueText>\r\n      </Statistic>\r\n    );\r\n  }\r\n}\r\n\r\nexport default PredatorySwiftness;\r\n","import React from 'react';\r\nimport { STATISTIC_ORDER } from 'interface/others/StatisticsListBox';\r\nimport SPELLS from 'common/SPELLS';\r\nimport SpellLink from 'common/SpellLink';\r\nimport Analyzer, { SELECTED_PLAYER } from 'parser/core/Analyzer';\r\nimport HIT_TYPES from 'game/HIT_TYPES';\r\nimport Statistic from 'interface/statistics/Statistic';\r\nimport DonutChart from 'interface/statistics/components/DonutChart';\r\nimport { i18n } from '@lingui/core';\r\nimport { t } from '@lingui/macro';\r\nimport Events from 'parser/core/Events';\r\n\r\nconst debug = false;\r\n\r\nconst BLOODTALONS_BUFF_DURATION = 30000;\r\nconst EXPIRE_WINDOW = 100;\r\nconst POTENTIAL_SPENDERS = [\r\n  SPELLS.RAKE,\r\n  SPELLS.RIP,\r\n  SPELLS.SHRED,\r\n  SPELLS.FEROCIOUS_BITE,\r\n  SPELLS.BRUTAL_SLASH_TALENT,\r\n  SPELLS.SWIPE_CAT,\r\n  SPELLS.THRASH_FERAL,\r\n  SPELLS.MAIM,\r\n  // Feral Frenzy would be a spender, but it's a talent on the same row as Bloodtalons\r\n];\r\n\r\n// time (in ms) within which to consider direct damage events with same spellId as belonging to the same ability use\r\nconst AOE_DAMAGE_WINDOW = 200;\r\nconst HIT_TYPES_THAT_DONT_CONSUME = [\r\n  HIT_TYPES.MISS,\r\n  HIT_TYPES.DODGE,\r\n  HIT_TYPES.PARRY,\r\n];\r\n\r\nconst CHART_COLOR_WASTED = '#d53805';\r\nconst CHART_COLOR_SPENDERS = [\r\n  '#987284',\r\n  '#9dbf9e',\r\n  '#2e86ab',\r\n  '#40376e',\r\n  '#f39b6d',\r\n  '#f9cb40',\r\n  '#603140',\r\n  '#e0607e',\r\n];\r\n\r\n/**\r\n * Casting Regrowth or Entangling Roots generates 2 stacks of the Bloodtalons buff.\r\n * 1 charge is consumed by each successful use of one of the POTENTIAL_SPENDERS. Successful uses\r\n * are detected in different ways depending on the ability:\r\n * - Single target attacks that do initial damage consume a stack so long as that damage connects.\r\n * - AoE abilities consume a charge if they succeed in hitting at least 1 enemy.\r\n * - Rip (DoT with no initial damage) success is detected by watching for debuff apply or refresh.\r\n */\r\nclass Bloodtalons extends Analyzer {\r\n  get wasted() {\r\n    return this.expired + this.overwritten + this.remainAfterFight;\r\n  }\r\n\r\n  get overwrittenPerMinute() {\r\n    return (this.overwritten / this.owner.fightDuration) * 1000 * 60;\r\n  }\r\n\r\n  get suggestionThresholds() {\r\n    /**\r\n     * Suggestion is based on just overwritten charges rather than all forms of waste.\r\n     * That's because overwriting can always be avoided by the player but the other wastes are\r\n     * often outside the player's control.\r\n     */\r\n    return {\r\n      actual: this.overwrittenPerMinute,\r\n      isGreaterThan: {\r\n        minor: 0,\r\n        average: 0.5,\r\n        major: 2.0,\r\n      },\r\n      style: 'number',\r\n    };\r\n  }\r\n\r\n  get combinedChart() {\r\n    const items = this.spenders\r\n      .filter(spender => spender.count !== 0)\r\n      .map(spender => ({\r\n        color: spender.chartColor,\r\n        label: spender.spell.name,\r\n        spellId: spender.spell.id,\r\n        value: spender.count,\r\n        valueTooltip: <><b>{spender.count}</b> charge{spender.count !== 1 ? 's' : ''} used on {spender.spell.name}.</>,\r\n      }));\r\n\r\n    items.push({\r\n      color: CHART_COLOR_WASTED,\r\n      label: 'Wasted',\r\n      value: this.wasted,\r\n      valueTooltip: (<>\r\n        <b>{this.wasted}</b> Bloodtalons charge{this.wasted !== 1 ? 's were' : ' was'} wasted.<br />\r\n        <ul>\r\n          <li>You lost <b>{this.overwritten}</b> by casting Regrowth or Entangling Roots when you already had charges.</li>\r\n          <li>You lost <b>{this.expired}</b> by allowing {this.expired !== 1 ? 'them' : 'it'} to expire.</li>\r\n          <li>You lost <b>{this.remainAfterFight}</b> by having {this.remainAfterFight !== 1 ? 'them' : 'it'} left over at the fight's end.</li>\r\n        </ul>\r\n      </>),\r\n    });\r\n\r\n    return (\r\n      <DonutChart\r\n        items={items}\r\n      />\r\n    );\r\n  }\r\n\r\n  spenders = null;\r\n  currentStack = 0;\r\n  expireTime = null;\r\n  lastSpender = null;\r\n  generated = 0;\r\n  used = 0;\r\n  expired = 0;\r\n  remainAfterFight = 0;\r\n  overwritten = 0;\r\n\r\n  constructor(...args) {\r\n    super(...args);\r\n\r\n    if (POTENTIAL_SPENDERS.length > CHART_COLOR_SPENDERS.length) {\r\n      throw new Error(`Bloodtalons has ${POTENTIAL_SPENDERS.length} potential spenders but only ${CHART_COLOR_SPENDERS.length} chart colors defined.`);\r\n    }\r\n    this.active = this.selectedCombatant.hasTalent(SPELLS.BLOODTALONS_TALENT.id);\r\n    if (this.active) {\r\n      /**\r\n       * The spenders array could be built during parsing, but doing it at the start means it'll\r\n       * always list the spenders in the same order. That should make comparison between fights\r\n       * or players easier for the user.\r\n       */\r\n      this.spenders = POTENTIAL_SPENDERS.map((spender, index) => ({\r\n        spell: spender,\r\n        chartColor: CHART_COLOR_SPENDERS[index],\r\n        count: 0,\r\n      }));\r\n    }\r\n    this.addEventListener(Events.fightend, this.onFightend);\r\n    this.addEventListener(Events.applybuff.to(SELECTED_PLAYER).spell(SPELLS.BLOODTALONS_BUFF), this.onApplyBuff);\r\n    this.addEventListener(Events.refreshbuff.to(SELECTED_PLAYER).spell(SPELLS.BLOODTALONS_BUFF), this.onRefreshBuff);\r\n    this.addEventListener(Events.removebuff.to(SELECTED_PLAYER).spell(SPELLS.BLOODTALONS_BUFF), this.onRemoveBuff);\r\n    this.addEventListener(Events.damage.by(SELECTED_PLAYER).spell(POTENTIAL_SPENDERS), this.onDamage);\r\n\r\n    this.addEventListener(Events.applydebuff.by(SELECTED_PLAYER).spell(SPELLS.RIP), this.applyDebuff);\r\n    this.addEventListener(Events.refreshdebuff.by(SELECTED_PLAYER).spell(SPELLS.RIP), this.applyDebuff);\r\n  }\r\n\r\n  onFightend() {\r\n    this.remainAfterFight = this.currentStack;\r\n    debug && console.log(`${this.owner.formatTimestamp(this.owner.fight.end_time, 3)} fight ended with ${this.currentStack} Bloodtalons charges remaining`);\r\n\r\n    if (debug && this.generated !== (this.used + this.expired + this.remainAfterFight + this.overwritten)) {\r\n      console.warn(`Not all Bloodtalon charges accounted for. Generated: ${this.generated}, used: ${this.used}, expired: ${this.expired}, remainAfterFight: ${this.remainAfterFight}, overwritten: ${this.overwritten}`);\r\n    }\r\n  }\r\n\r\n  onApplyBuff(event) {\r\n    debug && console.log(`${this.owner.formatTimestamp(event.timestamp, 3)} generated 2 Bloodtalons charges`);\r\n    this.generated += 2;\r\n    this.currentStack = 2;\r\n    this.expireTime = event.timestamp + BLOODTALONS_BUFF_DURATION;\r\n  }\r\n\r\n  onRefreshBuff(event) {\r\n    debug && console.log(`${this.owner.formatTimestamp(event.timestamp, 3)} generated 2 Bloodtalons charges, overwriting ${this.currentStack}`);\r\n    this.overwritten += this.currentStack;\r\n    this.generated += 2;\r\n    this.currentStack = 2;\r\n\r\n    // pandemic doesn't apply\r\n    this.expireTime = event.timestamp + BLOODTALONS_BUFF_DURATION;\r\n  }\r\n\r\n  onRemoveBuff(event) {\r\n    if (this.currentStack === 0 || !this.expireTime ||\r\n      Math.abs(this.expireTime - event.timestamp) > EXPIRE_WINDOW) {\r\n      // only interested in bloodtalons buff wearing off after its full duration\r\n      return;\r\n    }\r\n    debug && console.log(`${this.owner.formatTimestamp(event.timestamp, 3)} Bloodtalons expired, losing ${this.currentStack} charges`);\r\n    this.expired += this.currentStack;\r\n    this.currentStack = 0;\r\n    this.expireTime = null;\r\n  }\r\n\r\n  onDamage(event) {\r\n    const spellId = event.ability.guid;\r\n    if (this.currentStack === 0 ||\r\n      event.tick || HIT_TYPES_THAT_DONT_CONSUME.includes(event.hitType) ||\r\n      this.isAlreadyAccountedForAoE(spellId, event.timestamp)) {\r\n      // only interested in direct damage hits from a spender ability\r\n      return;\r\n    }\r\n    this.lastSpender = {\r\n      spellId,\r\n      timestamp: event.timestamp,\r\n    };\r\n    this.currentStack -= 1;\r\n    this.addSpender(spellId);\r\n  }\r\n\r\n  applyDebuff(event) {\r\n    if (this.currentStack === 0) {\r\n      return;\r\n    }\r\n    this.currentStack -= 1;\r\n    this.addSpender(SPELLS.RIP.id);\r\n  }\r\n\r\n  isSpender(spellId) {\r\n    return Boolean(POTENTIAL_SPENDERS.find(spender => spender.id === spellId));\r\n  }\r\n\r\n  isAlreadyAccountedForAoE(spellId, timestamp) {\r\n    return this.lastSpender && this.lastSpender.spellId === spellId &&\r\n      Math.abs(this.lastSpender.timestamp - timestamp) < AOE_DAMAGE_WINDOW;\r\n  }\r\n\r\n  addSpender(spellId) {\r\n    const spender = this.spenders.find(spender => spender.spell.id === spellId);\r\n    if (!spender) {\r\n      throw new Error(`Tried to add spender ${spellId} which was not listed as a potential spender.`);\r\n    }\r\n    spender.count += 1;\r\n    this.used += 1;\r\n    debug && console.log(`${this.owner.formatTimestamp(this.owner.currentTimestamp, 3)} spend Bloodtalons charge on ${spender.spell.name}`);\r\n  }\r\n\r\n  suggestions(when) {\r\n    when(this.suggestionThresholds).addSuggestion((suggest, actual, recommended) => suggest(\r\n      <>\r\n        You are overwriting charges of <SpellLink id={SPELLS.BLOODTALONS_TALENT.id} />. Try to use both charges before you generate more from casting <SpellLink id={SPELLS.REGROWTH.id} /> or <SpellLink id={SPELLS.ENTANGLING_ROOTS.id} />.\r\n      </>,\r\n    )\r\n      .icon(SPELLS.BLOODTALONS_TALENT.icon)\r\n      .actual(i18n._(t('druid.feral.suggestions.bloodtalons.efficiency')`${actual.toFixed(1)} wasted charges of Bloodtalons per minute.`))\r\n      .recommended(`${recommended} is recommended`));\r\n  }\r\n\r\n  statistic() {\r\n    return (\r\n      <Statistic\r\n        position={STATISTIC_ORDER.OPTIONAL(4)}\r\n        style={{ height: '230px' }}\r\n      >\r\n        <div className=\"pad\">\r\n          <label><SpellLink id={SPELLS.BLOODTALONS_TALENT.id} /> usage</label>\r\n          {this.combinedChart}\r\n        </div>\r\n      </Statistic>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Bloodtalons;\r\n","import React from 'react';\r\nimport Analyzer, { SELECTED_PLAYER } from 'parser/core/Analyzer';\r\nimport SPELLS from 'common/SPELLS';\r\nimport SpellLink from 'common/SpellLink';\r\nimport STATISTIC_ORDER from 'interface/others/STATISTIC_ORDER';\r\nimport BoringSpellValueText from 'interface/statistics/components/BoringSpellValueText';\r\nimport Statistic from 'interface/statistics/Statistic';\r\n\r\nimport { i18n } from '@lingui/core';\r\nimport { t } from '@lingui/macro';\r\n\r\nimport Events from 'parser/core/Events';\r\n\r\nimport SpellUsable from '../features/SpellUsable';\r\nimport Abilities from '../Abilities';\r\n\r\nclass Predator extends Analyzer {\r\n  get baseCasts() {\r\n    const tigersFury = this.abilities.getAbility(SPELLS.TIGERS_FURY.id);\r\n    return 1 + Math.floor(this.owner.fightDuration / (tigersFury.cooldown * 1000));\r\n  }\r\n\r\n  get earlyCasts() {\r\n    return this.spellUsable.earlyCastsOfTigersFury;\r\n  }\r\n\r\n  get extraCasts() {\r\n    return Math.max(0, this.totalCasts - this.baseCasts);\r\n  }\r\n\r\n  get extraCastsPerMinute() {\r\n    return (this.extraCasts / this.owner.fightDuration) * 1000 * 60;\r\n  }\r\n\r\n  get suggestionThresholds() {\r\n    return {\r\n      actual: this.extraCastsPerMinute,\r\n      isLessThan: {\r\n        minor: 1.0,\r\n        average: 0.5,\r\n        major: 0.2,\r\n      },\r\n      style: 'number',\r\n    };\r\n  }\r\n\r\n  static dependencies = {\r\n    spellUsable: SpellUsable,\r\n    abilities: Abilities,\r\n  };\r\n  totalCasts = 0;\r\n\r\n  constructor(...args) {\r\n    super(...args);\r\n    this.active = this.selectedCombatant.hasTalent(SPELLS.PREDATOR_TALENT.id);\r\n    this.addEventListener(Events.cast.by(SELECTED_PLAYER).spell(SPELLS.TIGERS_FURY), this.onCast);\r\n  }\r\n\r\n  onCast(event) {\r\n    this.totalCasts += 1;\r\n  }\r\n\r\n  suggestions(when) {\r\n    when(this.suggestionThresholds).addSuggestion((suggest, actual, recommended) => suggest(\r\n      <>\r\n        You're not gaining much benefit from <SpellLink id={SPELLS.PREDATOR_TALENT.id} />. If the fight has adds make sure they have bleeds on them when they die, and make use of your <SpellLink id={SPELLS.TIGERS_FURY.id} /> cooldown being reset. If the fight doesn't have adds it would be a good idea to switch to another talent.\r\n      </>,\r\n    )\r\n      .icon(SPELLS.PREDATOR_TALENT.icon)\r\n      .actual(i18n._(t('druid.feral.suggestions.predator.efficiency')`${actual.toFixed(1)} extra casts of Tiger's Fury per minute.`))\r\n      .recommended(`>${recommended.toFixed(1)} is recommended`));\r\n  }\r\n\r\n  statistic() {\r\n    // There may be early casts without any extra casts overall\r\n    const earlyCastsComment = <><br />Thanks to Predator <strong>{this.earlyCasts}</strong> of your Tiger's Fury casts {this.earlyCasts !== 1 ? 'were' : 'was'} before when the cooldown would have been ready.</>;\r\n    const hadExtraCasts = <>Your Predator talent allowed you to use Tiger's Fury at least <strong>{this.extraCasts}</strong> extra time{this.extraCasts !== 1 ? 's' : ''}. Without it you would have had time for <strong>{this.baseCasts}</strong> cast{this.baseCasts !== 1 ? 's' : ''} but with it you were able to use Tiger's Fury <strong>{this.totalCasts}</strong> time{this.totalCasts !== 1 ? 's' : ''}.{this.earlyCasts > 0 && earlyCastsComment}</>;\r\n    const noExtraCasts = <>Your Predator talent didn't allow you to cast more Tiger's Fury overall than you would have been able to without it, with the fight lasting long enough for all <strong>{this.totalCasts}</strong> of your cast{this.totalCasts !== 1 ? 's' : ''}. Either there were no enemies dying with your bleeds on them during this fight or you didn't make use of Tiger's Fury when it came off cooldown.{this.earlyCasts > 0 && earlyCastsComment}</>;\r\n    return (\r\n      <Statistic\r\n        size=\"flexible\"\r\n        tooltip={this.extraCasts > 0 ? hadExtraCasts : noExtraCasts}\r\n        positon={STATISTIC_ORDER.OPTIONAL(3)}\r\n      >\r\n        <BoringSpellValueText spell={SPELLS.PREDATOR_TALENT}>\r\n          <>\r\n            {this.extraCastsPerMinute.toFixed(2)} <small>extra casts per minute</small>\r\n          </>\r\n        </BoringSpellValueText>\r\n      </Statistic>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Predator;\r\n","import React from 'react';\r\n\r\nimport Analyzer, { SELECTED_PLAYER } from 'parser/core/Analyzer';\r\nimport Enemies from 'parser/shared/modules/Enemies';\r\n\r\nimport SPELLS from 'common/SPELLS';\r\nimport { formatNumber, formatPercentage } from 'common/format';\r\nimport STATISTIC_ORDER from 'interface/others/STATISTIC_ORDER';\r\nimport BoringSpellValueText from 'interface/statistics/components/BoringSpellValueText';\r\nimport Statistic from 'interface/statistics/Statistic';\r\n\r\nimport Events from 'parser/core/Events';\r\n\r\nimport SpellLink from 'common/SpellLink';\r\nimport { TooltipElement } from 'common/Tooltip';\r\nimport { i18n } from '@lingui/core';\r\nimport { t } from '@lingui/macro';\r\nimport UptimeIcon from 'interface/icons/Uptime';\r\nimport ItemDamageDone from 'interface/ItemDamageDone';\r\n\r\nimport getDamageBonus from '../core/getDamageBonus';\r\nimport { SAVAGE_ROAR_DAMAGE_BONUS } from '../../constants';\r\n\r\n/**\r\n * Since 8.0 only affects \"cat\" abilities.\r\n * Tested and found not to be affected:\r\n *  Damage procs from trinkets\r\n *  DoT from bear's Thrash\r\n *  Sunfire from balance affinity\r\n *\r\n * Presumably would affect Brutal Slash, but they're rival talents.\r\n */\r\nconst AFFECTED_BY_SAVAGE_ROAR = [\r\n  SPELLS.MELEE,\r\n  SPELLS.SHRED,\r\n  SPELLS.RAKE,\r\n  SPELLS.RIP,\r\n  SPELLS.FEROCIOUS_BITE,\r\n  SPELLS.MOONFIRE_FERAL,\r\n  SPELLS.THRASH_FERAL,\r\n  SPELLS.SWIPE_CAT,\r\n  SPELLS.FERAL_FRENZY_TALENT,\r\n  SPELLS.MAIM,\r\n  SPELLS.MOONFIRE, // not really a cat ability, but is affected\r\n];\r\n\r\n/**\r\n * \"Finishing move that increases damage by 15% while in Cat Form.\"\r\n */\r\nclass SavageRoar extends Analyzer {\r\n  get uptime() {\r\n    return this.selectedCombatant.getBuffUptime(SPELLS.SAVAGE_ROAR_TALENT.id) / this.owner.fightDuration;\r\n  }\r\n\r\n  get suggestionThresholds() {\r\n    return {\r\n      actual: this.uptime,\r\n      isLessThan: {\r\n        minor: 0.95,\r\n        average: 0.90,\r\n        major: 0.80,\r\n      },\r\n      style: 'percentage',\r\n    };\r\n  }\r\n\r\n  static dependencies = {\r\n    enemies: Enemies,\r\n  };\r\n  bonusDmg = 0;\r\n\r\n  constructor(...args) {\r\n    super(...args);\r\n    this.active = this.selectedCombatant.hasTalent(SPELLS.SAVAGE_ROAR_TALENT.id);\r\n    this.addEventListener(Events.damage.by(SELECTED_PLAYER).spell(AFFECTED_BY_SAVAGE_ROAR), this.onDamage);\r\n  }\r\n\r\n  onDamage(event) {\r\n    if (!this.selectedCombatant.hasBuff(SPELLS.SAVAGE_ROAR_TALENT.id) ||\r\n      !this.selectedCombatant.hasBuff(SPELLS.CAT_FORM.id)) {\r\n      return;\r\n    }\r\n    this.bonusDmg += getDamageBonus(event, SAVAGE_ROAR_DAMAGE_BONUS);\r\n  }\r\n\r\n  suggestions(when) {\r\n    when(this.suggestionThresholds).addSuggestion((suggest, actual, recommended) => suggest(\r\n      <>\r\n        Your <SpellLink id={SPELLS.SAVAGE_ROAR_TALENT.id} /> uptime can be improved. You should refresh the buff once it has reached its <TooltipElement content=\"The last 30% of the DoT's duration. When you refresh during this time you don't lose any duration in the process.\">pandemic window</TooltipElement>, don't wait for it to wear off. You may also consider switching to <SpellLink id={SPELLS.SOUL_OF_THE_FOREST_TALENT_FERAL.id} /> which is simpler to use and provides more damage in many situations.\r\n      </>,\r\n    )\r\n      .icon(SPELLS.SAVAGE_ROAR_TALENT.icon)\r\n      .actual(i18n._(t('druid.feral.suggestions.savageRoar.uptime')`${formatPercentage(actual)}% uptime`))\r\n      .recommended(`>${formatPercentage(recommended)}% is recommended`));\r\n  }\r\n\r\n  statistic() {\r\n    return (\r\n      <Statistic\r\n        size=\"flexible\"\r\n        tooltip={\r\n          <>\r\n            Your Savage Roar talent contributed <strong>{formatNumber(this.bonusDmg)}</strong> total damage ({formatPercentage(this.owner.getPercentageOfTotalDamageDone(this.bonusDmg))}%).\r\n          </>\r\n        }\r\n        position={STATISTIC_ORDER.OPTIONAL(1)}\r\n      >\r\n        <BoringSpellValueText spell={SPELLS.SAVAGE_ROAR_TALENT}>\r\n          <>\r\n            <UptimeIcon /> {formatPercentage(this.uptime)}% <small>uptime</small> <br />\r\n            <ItemDamageDone amount={this.bonusDmg} />\r\n          </>\r\n        </BoringSpellValueText>\r\n      </Statistic>\r\n    );\r\n  }\r\n}\r\n\r\nexport default SavageRoar;\r\n","export default function getDamageBonus(event, increase) {\r\n  const raw = (event.amount || 0) + (event.absorbed || 0);\r\n  return raw - (raw / (1 + increase));\r\n}\r\n","import React from 'react';\r\nimport SPELLS from 'common/SPELLS';\r\nimport SpellLink from 'common/SpellLink';\r\nimport { formatPercentage } from 'common/format';\r\nimport Analyzer from 'parser/core/Analyzer';\r\n\r\nimport { i18n } from '@lingui/core';\r\nimport { t } from '@lingui/macro';\r\n\r\nimport EnergyTracker from '../features/EnergyTracker';\r\nimport Predator from '../talents/Predator';\r\n\r\nclass TigersFuryEnergy extends Analyzer {\r\n  get shouldIgnoreEnergyWaste() {\r\n    // If Predator is providing plenty of Tigers Fury resets it's no longer important to use them at the perfect time.\r\n    return (this.predator.active && this.predator.extraCastsPerMinute > 1.0);\r\n  }\r\n\r\n  get suggestionThresholds() {\r\n    const generated = this.energyTracker.getGeneratedBySpell(SPELLS.TIGERS_FURY.id);\r\n    const wasted = this.energyTracker.getWastedBySpell(SPELLS.TIGERS_FURY.id);\r\n    const wastedShare = (wasted / (generated + wasted)) || 0;\r\n    return {\r\n      actual: wastedShare,\r\n      isGreaterThan: {\r\n        minor: 0,\r\n        average: 0.10,\r\n        major: 0.25,\r\n      },\r\n      style: 'percentage',\r\n    };\r\n  }\r\n\r\n  static dependencies = {\r\n    energyTracker: EnergyTracker,\r\n    predator: Predator,\r\n  };\r\n\r\n  suggestions(when) {\r\n    if (this.shouldIgnoreEnergyWaste) {\r\n      return;\r\n    }\r\n\r\n    when(this.suggestionThresholds).addSuggestion((suggest, actual, recommended) => suggest(\r\n      <>\r\n        You are wasting energy generated by <SpellLink id={SPELLS.TIGERS_FURY.id} />. Usually your ability use will be limited by energy so it's important to make the most of this energy source. Spend energy before using <SpellLink id={SPELLS.TIGERS_FURY.id} /> so that it's not wasted. The main exception is if <SpellLink id={SPELLS.PREDATOR_TALENT.id} /> provides you with lots of resets in which case you can use it more freely.\r\n      </>,\r\n    )\r\n      .icon(SPELLS.TIGERS_FURY.icon)\r\n      .actual(i18n._(t('druid.feral.suggestions.tigerFuryEnergy.energyWasted')`${formatPercentage(actual)}% of generated energy wasted.`))\r\n      .recommended(`No waste is recommended`));\r\n  }\r\n}\r\n\r\nexport default TigersFuryEnergy;\r\n","import React from 'react';\r\nimport SPELLS from 'common/SPELLS';\r\nimport STATISTIC_ORDER from 'interface/others/STATISTIC_ORDER';\r\nimport BoringSpellValueText from 'interface/statistics/components/BoringSpellValueText';\r\nimport Statistic from 'interface/statistics/Statistic';\r\nimport SpellLink from 'common/SpellLink';\r\nimport { formatPercentage } from 'common/format';\r\nimport RACES from 'game/RACES';\r\nimport Analyzer, { SELECTED_PLAYER } from 'parser/core/Analyzer';\r\nimport Abilities from 'parser/core/modules/Abilities';\r\nimport { i18n } from '@lingui/core';\r\nimport { t } from '@lingui/macro';\r\nimport Events from 'parser/core/Events';\r\n\r\nconst BUFF_WINDOW_TIME = 60;\r\n\r\n/**\r\n * The Night Elf racial ability Shadowmeld can be used by as a DPS cooldown for Feral druids.\r\n * The stealth provided by Shadowmeld doubles the damage of a Rake cast while it's active.\r\n * This analyzer checks how often Shadowmeld is being to buff Rake's damage.\r\n */\r\nclass Shadowmeld extends Analyzer {\r\n  get possibleUses() {\r\n    const cooldown = this.abilities.getAbility(SPELLS.SHADOWMELD.id).cooldown * 1000;\r\n    return Math.floor(this.owner.fightDuration / cooldown) + 1;\r\n  }\r\n\r\n  get efficiencyThresholds() {\r\n    return {\r\n      actual: this.correctUses / this.possibleUses,\r\n      isLessThan: {\r\n        minor: 0.90,\r\n        average: 0.80,\r\n        major: 0.70,\r\n      },\r\n      style: 'percentage',\r\n    };\r\n  }\r\n\r\n  get wastedDuringStealthThresholds() {\r\n    return {\r\n      actual: this.wastedDuringStealth / this.totalUses,\r\n      isGreaterThan: {\r\n        minor: 0.0,\r\n        average: 0.10,\r\n        major: 0.20,\r\n      },\r\n      style: 'percentage',\r\n    };\r\n  }\r\n\r\n  static dependencies = {\r\n    abilities: Abilities,\r\n  };\r\n  wastedDuringStealth = 0;\r\n  correctUses = 0;\r\n  totalUses = 0;\r\n\r\n  constructor(...args) {\r\n    super(...args);\r\n    this.active = this.selectedCombatant.race === RACES.NightElf;\r\n    this.addEventListener(Events.cast.by(SELECTED_PLAYER).spell(SPELLS.RAKE), this.onRake);\r\n    this.addEventListener(Events.cast.by(SELECTED_PLAYER).spell(SPELLS.SHADOWMELD), this.onShadowmeld);\r\n  }\r\n\r\n  onRake(event) {\r\n    if (this.selectedCombatant.hasBuff(SPELLS.SHADOWMELD.id, null, BUFF_WINDOW_TIME)) {\r\n      // using Rake when Shadowmeld is active means Shadowmeld was used correctly\r\n      this.correctUses += 1;\r\n    }\r\n  }\r\n\r\n  onShadowmeld(event) {\r\n    this.totalUses += 1;\r\n\r\n    if (this.selectedCombatant.hasBuff(SPELLS.INCARNATION_KING_OF_THE_JUNGLE_TALENT.id) ||\r\n      this.selectedCombatant.hasBuff(SPELLS.PROWL.id, null, BUFF_WINDOW_TIME) ||\r\n      this.selectedCombatant.hasBuff(SPELLS.PROWL_INCARNATION.id, null, BUFF_WINDOW_TIME)) {\r\n      // using Shadowmeld when the player already has a stealth (or stealth-like) effect active is almost always a mistake\r\n      this.wastedDuringStealth += 1;\r\n    }\r\n  }\r\n\r\n  statistic() {\r\n    return (\r\n      <Statistic\r\n        tooltip={(\r\n          <>\r\n            You used Shadowmeld <strong>{this.correctUses}</strong> times to increase Rake's damage.<br />\r\n            <ul>\r\n              <li>You could have used it <strong>{this.possibleUses}</strong> times.</li>\r\n              <li>You used it <strong>{this.totalUses}</strong> times (<strong>{this.totalUses - this.correctUses}</strong> didn't buff Rake.)</li>\r\n              <li>You used Shadowmeld while already benefiting from a stealth effect <strong>{this.wastedDuringStealth}</strong> times.</li>\r\n            </ul>\r\n          </>\r\n        )}\r\n        position={STATISTIC_ORDER.OPTIONAL()}\r\n        size=\"flexible\"\r\n      >\r\n        <BoringSpellValueText spell={SPELLS.SHADOWMELD}>\r\n          <>\r\n            {formatPercentage(this.correctUses / this.possibleUses)}% <small>Shadowmeld used to buff Rake</small>\r\n          </>\r\n        </BoringSpellValueText>\r\n      </Statistic>\r\n    );\r\n  }\r\n\r\n  suggestions(when) {\r\n    when(this.efficiencyThresholds).addSuggestion((suggest, actual, recommended) => suggest(\r\n      <React.Fragment>\r\n        You could be using <SpellLink id={SPELLS.SHADOWMELD.id} /> to increase your <SpellLink id={SPELLS.RAKE.id} /> damage more often. Activating <SpellLink id={SPELLS.SHADOWMELD.id} /> and immediately using <SpellLink id={SPELLS.RAKE.id} /> will cause it to deal double damage.\r\n      </React.Fragment>,\r\n    )\r\n      .icon(SPELLS.SHADOWMELD.icon)\r\n      .actual(i18n._(t('druid.feral.suggetions.shadowmeld.efficiency')`${(actual * 100).toFixed(0)}% cast efficiency.`))\r\n      .recommended(`>${(recommended * 100).toFixed(0)}% is recommended`));\r\n\r\n    when(this.wastedDuringStealthThresholds).addSuggestion((suggest, actual, recommended) => suggest(\r\n      <React.Fragment>\r\n        You are wasting <SpellLink id={SPELLS.SHADOWMELD.id} /> by using it when you already have a stealth effect active.\r\n      </React.Fragment>,\r\n    )\r\n      .icon(SPELLS.SHADOWMELD.icon)\r\n      .actual(i18n._(t('druid.feral.suggetions.shadowmeld.wasted')`${this.wastedDuringStealth} cast${this.wastedDuringStealth === 1 ? '' : 's'} when already stealthed.`))\r\n      .recommended('0 is recommended'));\r\n  }\r\n}\r\n\r\nexport default Shadowmeld;\r\n","import React from 'react';\r\n\r\nimport SpellLink from 'common/SpellLink';\r\nimport SPELLS from 'common/SPELLS';\r\nimport RESOURCE_TYPES from 'game/RESOURCE_TYPES';\r\nimport Analyzer, { SELECTED_PLAYER } from 'parser/core/Analyzer';\r\nimport Events from 'parser/core/Events';\r\nimport BoringResourceValue from 'interface/statistics/components/BoringResourceValue/index';\r\nimport { STATISTIC_ORDER } from 'interface/others/StatisticBox';\r\nimport Statistic from 'interface/statistics/Statistic';\r\nimport { i18n } from '@lingui/core';\r\nimport { t } from '@lingui/macro';\r\n\r\nimport getComboPointsFromEvent from '../core/getComboPointsFromEvent';\r\nimport RipSnapshot from '../bleeds/RipSnapshot';\r\n\r\nconst debug = false;\r\n\r\nconst FINISHERS = [\r\n  SPELLS.FEROCIOUS_BITE,\r\n  SPELLS.RIP,\r\n  SPELLS.MAIM,\r\n  SPELLS.PRIMAL_WRATH_TALENT,\r\n  SPELLS.SAVAGE_ROAR_TALENT,\r\n];\r\nconst MAX_COMBO = 5;\r\n\r\n/**\r\n * Although all finishers are most efficient at 5 combo points, in some situations use at fewer combo points\r\n * will be a damage increase compared to waiting for the full 5.\r\n *\r\n * Situations where <5 combo point use of an ability is fine:\r\n *  Fresh Rip on a target which doesn't yet have it.\r\n *  Rip on a target that already has Rip if it upgrades the snapshot, so long as player is using Sabertooth.\r\n *  [NYI] Maim on a target where the stun is effective and useful.\r\n *  [NYI] Possibly when using Savage Roar? Will need theorycrafting.\r\n *\r\n */\r\nclass FinisherUse extends Analyzer {\r\n  get fractionBadFinishers() {\r\n    if (this.totalFinishers === 0) {\r\n      return 0;\r\n    }\r\n    return this.badFinishers / this.totalFinishers;\r\n  }\r\n\r\n  get badFinishersThresholds() {\r\n    return {\r\n      actual: this.fractionBadFinishers,\r\n      isGreaterThan: {\r\n        minor: 0,\r\n        average: 0.05,\r\n        major: 0.10,\r\n      },\r\n      style: 'percentage',\r\n    };\r\n  }\r\n\r\n  static dependencies = {\r\n    ripSnapshot: RipSnapshot,\r\n  };\r\n  hasSabertooth = false;\r\n  totalFinishers = 0;\r\n  notFullComboFinishers = 0;\r\n  badFinishers = 0;\r\n  freshRips = 0;\r\n  upgradingRips = 0;\r\n\r\n  constructor(...args) {\r\n    super(...args);\r\n    this.hasSabertooth = this.selectedCombatant.hasTalent(SPELLS.SABERTOOTH_TALENT.id);\r\n    this.addEventListener(Events.cast.by(SELECTED_PLAYER), this._castSpell);\r\n  }\r\n\r\n  _castSpell(event) {\r\n    const finisher = FINISHERS.find(element => element.id === event.ability.guid);\r\n    if (!finisher) {\r\n      return;\r\n    }\r\n    this.totalFinishers += 1;\r\n\r\n    const combo = getComboPointsFromEvent(event);\r\n    if (!combo || combo === MAX_COMBO) {\r\n      // either full combo points (therefore not a problem) used or something went wrong and couldn't get combo information\r\n      return;\r\n    }\r\n    this.notFullComboFinishers += 1;\r\n\r\n    if (finisher !== SPELLS.RIP) {\r\n      this.badFinishers += 1;\r\n      debug && this.log(`cast ${finisher.name} with ${combo} combo points`);\r\n      return;\r\n    }\r\n\r\n    // Rip has been used without full combo points, which is a good thing only in certain situations\r\n    // RipSnapshot will have added the feralSnapshotState prop to the event, because this module has RipSnapshot as a dependency\r\n    // we know that will have been done before this executes.\r\n    if (!event.feralSnapshotState) {\r\n      // ..but when it comes to null references it's worth checking.\r\n      // If for some reason the property doesn't exist just skip checking this cast\r\n      debug && this.warn('Rip cast event doesn\\'t have the expected feralSnapshotState property.');\r\n      return;\r\n    }\r\n    if (RipSnapshot.wasStateFreshlyApplied(event.feralSnapshotState)) {\r\n      debug && this.log(`cast ${finisher.name} with ${combo} combo points but it was a fresh application, so is good`);\r\n      this.freshRips += 1;\r\n      return;\r\n    }\r\n    if (this.hasSabertooth && RipSnapshot.wasStatePowerUpgrade(event.feralSnapshotState)) {\r\n      debug && this.log(`cast ${finisher.name} with ${combo} combo points but it was upgrading ready to be extended with sabertooth, so is good`);\r\n      this.upgradingRips += 1;\r\n      return;\r\n    }\r\n    debug && this.log(`cast ${finisher.name} with ${combo} combo points`);\r\n    this.badFinishers += 1;\r\n  }\r\n\r\n  suggestions(when) {\r\n    when(this.badFinishersThresholds).addSuggestion((suggest, actual, recommended) => suggest(\r\n      <>\r\n        You are unnecessarily using finishers at less than full combo points. Generally the only finisher you should use without full combo points is <SpellLink id={SPELLS.RIP.id} /> when applying it to a target that doesn't have it active yet.\r\n      </>,\r\n    )\r\n      .icon('creatureportrait_bubble')\r\n      .actual(i18n._(t('druid.feral.suggestions.finishers.efficiency')`${(actual * 100).toFixed(0)}% of finishers were incorrectly used without full combo points`))\r\n      .recommended(`${(recommended * 100).toFixed(0)}% is recommended`));\r\n  }\r\n\r\n  statistic() {\r\n    return (\r\n      <Statistic\r\n        position={STATISTIC_ORDER.CORE(6)}\r\n        size=\"small\"\r\n        tooltip={(\r\n          <>\r\n            All finisher abilities are most efficient when used at full combo points, but there are situations where that rule doesn't apply. Of the <b>{this.totalFinishers}</b> finishers you used, <b>{this.notFullComboFinishers}</b> {this.notFullComboFinishers === 1 ? 'was' : 'were'} used without full combo points, and <b>{this.badFinishers}</b> appear not to have had a good reason for their low combo use.<br />\r\n            <ul>\r\n              <li><b>{this.freshRips}</b> {this.freshRips === 1 ? 'was a fresh Rip' : 'were fresh Rips'} applied to a target which didn't already have the DoT, where low combo point use is typically the right thing to do.</li>\r\n              <li><b>{this.upgradingRips}</b> {this.upgradingRips === 1 ? 'was an upgrading Rip' : 'were upgrading Rips'} where thanks to snapshotting the new DoT would do more damage than the existing. When combined with Sabertooth to extend the improved DoT this is a situation where low combo finisher use is of benefit.</li>\r\n            </ul>\r\n          </>\r\n        )}\r\n      >\r\n        <BoringResourceValue\r\n          resource={RESOURCE_TYPES.COMBO_POINTS}\r\n          value={`${(this.fractionBadFinishers * 100).toFixed(0)}%`}\r\n          label=\"Low Combo Finishers\"\r\n        />\r\n      </Statistic>\r\n    );\r\n  }\r\n}\r\n\r\nexport default FinisherUse;\r\n","import React from 'react';\r\n\r\nimport BaseChecklist from 'parser/shared/modules/features/Checklist/Module';\r\nimport CastEfficiency from 'parser/shared/modules/CastEfficiency';\r\nimport Combatants from 'parser/shared/modules/Combatants';\r\nimport PreparationRuleAnalyzer from 'parser/shared/modules/features/Checklist/PreparationRuleAnalyzer';\r\n\r\nimport Component from './Component';\r\nimport RakeUptime from '../../bleeds/RakeUptime';\r\nimport MoonfireUptime from '../../talents/MoonfireUptime';\r\nimport SwipeHitCount from '../../spells/SwipeHitCount';\r\nimport ComboPointDetails from '../../combopoints/ComboPointDetails';\r\nimport RipUptime from '../../bleeds/RipUptime';\r\nimport FerociousBiteEnergy from '../../spells/FerociousBiteEnergy';\r\nimport EnergyCapTracker from '../EnergyCapTracker';\r\nimport RipSnapshot from '../../bleeds/RipSnapshot';\r\nimport RakeSnapshot from '../../bleeds/RakeSnapshot';\r\nimport MoonfireSnapshot from '../../talents/MoonfireSnapshot';\r\nimport PredatorySwiftness from '../../spells/PredatorySwiftness';\r\nimport Bloodtalons from '../../talents/Bloodtalons';\r\nimport Predator from '../../talents/Predator';\r\nimport SavageRoar from '../../talents/SavageRoar';\r\nimport TigersFuryEnergy from '../../spells/TigersFuryEnergy';\r\nimport Shadowmeld from '../../racials/Shadowmeld';\r\nimport FinisherUse from '../../combopoints/FinisherUse';\r\n\r\nclass Checklist extends BaseChecklist {\r\n  static dependencies = {\r\n    combatants: Combatants,\r\n    castEfficiency: CastEfficiency,\r\n    preparationRuleAnalyzer: PreparationRuleAnalyzer,\r\n\r\n    rakeUptime: RakeUptime,\r\n    moonfireUptime: MoonfireUptime,\r\n    swipeHitCount: SwipeHitCount,\r\n    comboPointDetails: ComboPointDetails,\r\n    ripUptime: RipUptime,\r\n    savageRoar: SavageRoar,\r\n    ferociousBiteEnergy: FerociousBiteEnergy,\r\n    energyCapTracker: EnergyCapTracker,\r\n    ripSnapshot: RipSnapshot,\r\n    rakeSnapshot: RakeSnapshot,\r\n    moonfireSnapshot: MoonfireSnapshot,\r\n    predatorySwiftness: PredatorySwiftness,\r\n    bloodtalons: Bloodtalons,\r\n    predator: Predator,\r\n    tigersFuryEnergy: TigersFuryEnergy,\r\n    shadowmeld: Shadowmeld,\r\n    finisherUse: FinisherUse,\r\n  };\r\n\r\n  render() {\r\n    return (\r\n      <Component\r\n        combatant={this.combatants.selected}\r\n        castEfficiency={this.castEfficiency}\r\n        thresholds={{\r\n          // be prepared\r\n          ...this.preparationRuleAnalyzer.thresholds,\r\n\r\n          // builders\r\n          rakeUptime: this.rakeUptime.suggestionThresholds,\r\n          moonfireUptime: this.moonfireUptime.suggestionThresholds,\r\n          swipeHitOne: this.swipeHitCount.hitJustOneThresholds,\r\n          comboPointsWaste: this.comboPointDetails.wastingSuggestionThresholds,\r\n\r\n          // finishers\r\n          ripUptime: this.ripUptime.suggestionThresholds,\r\n          savageRoarUptime: this.savageRoar.suggestionThresholds,\r\n          ferociousBiteEnergy: this.ferociousBiteEnergy.suggestionThresholds,\r\n          ripShouldBeBite: this.ripSnapshot.shouldBeBiteSuggestionThresholds,\r\n          ripDurationReduction: this.ripSnapshot.durationReductionThresholds,\r\n          badLowComboFinishers: this.finisherUse.badFinishersThresholds,\r\n\r\n          // energy\r\n          energyCapped: this.energyCapTracker.suggestionThresholds,\r\n          tigersFuryIgnoreEnergy: this.tigersFuryEnergy.shouldIgnoreEnergyWaste,\r\n          tigersFuryEnergy: this.tigersFuryEnergy.suggestionThresholds,\r\n\r\n          // cooldowns\r\n          shadowmeld: this.shadowmeld.efficiencyThresholds,\r\n\r\n          // snapshot\r\n          rakeDowngrade: this.rakeSnapshot.downgradeSuggestionThresholds,\r\n          rakeProwlDowngrade: this.rakeSnapshot.prowlLostSuggestionThresholds,\r\n          ripDowngrade: this.ripSnapshot.downgradeSuggestionThresholds,\r\n          moonfireDowngrade: this.moonfireSnapshot.downgradeSuggestionThresholds,\r\n\r\n          // bloodtalons\r\n          predatorySwiftnessWasted: this.predatorySwiftness.suggestionThresholds,\r\n          bloodtalonsWasted: this.bloodtalons.suggestionThresholds,\r\n\r\n          // talent selection\r\n          predatorWrongTalent: this.predator.suggestionThresholds,\r\n        }}\r\n      />\r\n    );\r\n  }\r\n}\r\n\r\nexport default Checklist;\r\n","import React from 'react';\r\nimport SPELLS from 'common/SPELLS';\r\nimport SpellLink from 'common/SpellLink';\r\nimport { STATISTIC_ORDER } from 'interface/others/StatisticBox';\r\nimport { i18n } from '@lingui/core';\r\nimport { t } from '@lingui/macro';\r\n\r\nimport HitCountAoE from '../core/HitCountAoE';\r\n\r\n/**\r\n * Despite being an AoE ability Brutal Slash is usually the best talent on its row for single target fights.\r\n * It can be useful to count how many targets it hits, but hitting just one is not a mistake.\r\n */\r\nclass BrutalSlashHitCount extends HitCountAoE {\r\n  get hitNoneThresholds() {\r\n    return {\r\n      actual: this.hitZeroPerMinute,\r\n      isGreaterThan: {\r\n        minor: 0,\r\n        average: 0.2,\r\n        major: 0.5,\r\n      },\r\n      style: 'number',\r\n    };\r\n  }\r\n\r\n  static spell = SPELLS.BRUTAL_SLASH_TALENT;\r\n\r\n  constructor(...args) {\r\n    super(...args);\r\n    this.active = this.selectedCombatant.hasTalent(SPELLS.BRUTAL_SLASH_TALENT.id);\r\n  }\r\n\r\n  statistic() {\r\n    return this.generateStatistic(STATISTIC_ORDER.OPTIONAL(10));\r\n  }\r\n\r\n  suggestions(when) {\r\n    when(this.hitNoneThresholds).addSuggestion((suggest, actual, recommended) => suggest(\r\n      <>\r\n        You are using <SpellLink id={SPELLS.BRUTAL_SLASH_TALENT.id} /> out of range of any targets. Try to get familiar with the range of your area of effect abilities so you can avoid wasting charges and energy when they'll not hit anything.\r\n      </>,\r\n    )\r\n      .icon(SPELLS.BRUTAL_SLASH_TALENT.icon)\r\n      .actual(i18n._(t('druid.feral.suggestions.brutalSlash.hitcount.outOfRange')`${actual.toFixed(1)} uses per minute that hit nothing.`))\r\n      .recommended(`${recommended} is recommended`));\r\n  }\r\n}\r\n\r\nexport default BrutalSlashHitCount;\r\n","import React from 'react';\r\nimport SPELLS from 'common/SPELLS';\r\nimport SpellLink from 'common/SpellLink';\r\nimport { STATISTIC_ORDER } from 'interface/others/StatisticBox';\r\nimport { i18n } from '@lingui/core';\r\nimport { t } from '@lingui/macro';\r\n\r\nimport HitCountAoE from '../core/HitCountAoE';\r\n\r\n/**\r\n * Even with its DoT, thrash shouldn't be used against a single target. It's possible that some\r\n * combination of azerite traits might change this, but for now the player's resources are better\r\n * spent on Shred against a single target.\r\n */\r\nclass ThrashHitCount extends HitCountAoE {\r\n  get hitNoneThresholds() {\r\n    return {\r\n      actual: this.hitZeroPerMinute,\r\n      isGreaterThan: {\r\n        minor: 0,\r\n        average: 0.2,\r\n        major: 0.5,\r\n      },\r\n      style: 'number',\r\n    };\r\n  }\r\n\r\n  get hitJustOneThresholds() {\r\n    return {\r\n      actual: this.hitJustOnePerMinute,\r\n      isGreaterThan: {\r\n        minor: 0,\r\n        average: 0.5,\r\n        major: 3.0,\r\n      },\r\n      style: 'number',\r\n    };\r\n  }\r\n\r\n  static spell = SPELLS.THRASH_FERAL;\r\n\r\n  statistic() {\r\n    return this.generateStatistic(STATISTIC_ORDER.OPTIONAL(11));\r\n  }\r\n\r\n  suggestions(when) {\r\n    when(this.hitNoneThresholds).addSuggestion((suggest, actual, recommended) => suggest(\r\n      <>\r\n        You are using <SpellLink id={SPELLS.THRASH_FERAL.id} /> out of range of any targets. Try to get familiar with the range of your area of effect abilities so you can avoid wasting energy when they'll not hit anything.\r\n      </>,\r\n    )\r\n      .icon(SPELLS.THRASH_FERAL.icon)\r\n      .actual(i18n._(t('druid.feral.suggestions.thrash.hitcount.outOfRange')`${actual.toFixed(1)} uses per minute that hit nothing.`))\r\n      .recommended(`${recommended} is recommended`));\r\n  }\r\n}\r\n\r\nexport default ThrashHitCount;\r\n","import CoreCombatLogParser from 'parser/core/CombatLogParser';\r\n\r\nimport RakeBleed from './normalizers/RakeBleed';\r\nimport ComboPointsFromAoE from './normalizers/ComboPointsFromAoE';\r\nimport BleedDebuffEvents from './normalizers/BleedDebuffEvents';\r\n\r\nimport Abilities from './modules/Abilities';\r\nimport Buffs from './modules/Buffs';\r\nimport AlwaysBeCasting from './modules/features/AlwaysBeCasting';\r\nimport CooldownThroughputTracker from './modules/features/CooldownThroughputTracker';\r\nimport SpellUsable from './modules/features/SpellUsable';\r\nimport SpellEnergyCost from './modules/features/SpellEnergyCost';\r\nimport EnergyCapTracker from './modules/features/EnergyCapTracker';\r\nimport EnergyTracker from './modules/features/EnergyTracker';\r\nimport EnergyDetails from './modules/features/EnergyDetails';\r\nimport Checklist from './modules/features/checklist/Module';\r\n\r\nimport RakeUptime from './modules/bleeds/RakeUptime';\r\nimport RipUptime from './modules/bleeds/RipUptime';\r\nimport FerociousBiteEnergy from './modules/spells/FerociousBiteEnergy';\r\nimport RakeSnapshot from './modules/bleeds/RakeSnapshot';\r\nimport RipSnapshot from './modules/bleeds/RipSnapshot';\r\n\r\nimport ComboPointTracker from './modules/combopoints/ComboPointTracker';\r\nimport ComboPointDetails from './modules/combopoints/ComboPointDetails';\r\nimport FinisherUse from './modules/combopoints/FinisherUse';\r\n\r\nimport MoonfireUptime from './modules/talents/MoonfireUptime';\r\nimport MoonfireSnapshot from './modules/talents/MoonfireSnapshot';\r\nimport Predator from './modules/talents/Predator';\r\nimport Bloodtalons from './modules/talents/Bloodtalons';\r\nimport BrutalSlashHitCount from './modules/talents/BrutalSlashHitCount';\r\nimport SavageRoar from './modules/talents/SavageRoar';\r\n\r\nimport PredatorySwiftness from './modules/spells/PredatorySwiftness';\r\nimport ThrashHitCount from './modules/spells/ThrashHitCount';\r\nimport SwipeHitCount from './modules/spells/SwipeHitCount';\r\nimport TigersFuryEnergy from './modules/spells/TigersFuryEnergy';\r\nimport Shadowmeld from './modules/racials/Shadowmeld';\r\n\r\nclass CombatLogParser extends CoreCombatLogParser {\r\n  static specModules = {\r\n    // Normalizers\r\n    rakeBleed: RakeBleed,\r\n    bleedDebuffEvents: BleedDebuffEvents,\r\n    comboPointsFromAoE: ComboPointsFromAoE,\r\n\r\n    // Features\r\n    alwaysBeCasting: AlwaysBeCasting,\r\n    abilities: Abilities,\r\n    buffs: Buffs,\r\n    cooldownThroughputTracker: CooldownThroughputTracker,\r\n    ferociousBiteEnergy: FerociousBiteEnergy,\r\n    spellUsable: SpellUsable,\r\n    spellEnergyCost: SpellEnergyCost,\r\n    energyCapTracker: EnergyCapTracker,\r\n    energyTracker: EnergyTracker,\r\n    energyDetails: EnergyDetails,\r\n    checklist: Checklist,\r\n\r\n    // bleeds\r\n    rakeUptime: RakeUptime,\r\n    ripUptime: RipUptime,\r\n    rakeSnapshot: RakeSnapshot,\r\n    ripSnapshot: RipSnapshot,\r\n    moonfireSnapshot: MoonfireSnapshot,\r\n\r\n    // spells\r\n    predatorySwiftness: PredatorySwiftness,\r\n    thrashHitCount: ThrashHitCount,\r\n    swipeHitCount: SwipeHitCount,\r\n    tigersFuryEnergy: TigersFuryEnergy,\r\n    shadowmeld: Shadowmeld,\r\n\r\n    // talents\r\n    moonfireUptime: MoonfireUptime,\r\n    savageRoar: SavageRoar,\r\n    predator: Predator,\r\n    bloodtalons: Bloodtalons,\r\n    brutalSlashHitCount: BrutalSlashHitCount,\r\n\r\n    // resources\r\n    comboPointTracker: ComboPointTracker,\r\n    comboPointDetails: ComboPointDetails,\r\n    finisherUse: FinisherUse,\r\n  };\r\n}\r\n\r\nexport default CombatLogParser;\r\n","export default function calculateEffectiveDamage(event, increase) {\r\n  const raw = (event.amount || 0) + (event.absorbed || 0);\r\n  return raw - (raw / (1 + increase));\r\n}\r\n","import React from 'react';\r\n\r\n// https://thenounproject.com/term/duration/370713/\r\n// duration by Bohdan Burmich from the Noun Project\r\nconst Icon = ({ ...other }) => (\r\n  <svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"10 10 80 80\" className=\"icon\" {...other}>\r\n    <path d=\"M50,86.4865c17.4361,0,31.6216-14.1855,31.6216-31.6216c0-16.6168-12.8865-30.2714-29.1892-31.5189v-4.9677h7.2973v-4.8649  H40.2703v4.8649h7.2973v4.9677c-16.3027,1.2475-29.1892,14.902-29.1892,31.5189C18.3784,72.3009,32.5639,86.4865,50,86.4865z M52.4324,28.2236c3.1101,0.2817,6.0664,1.0982,8.7798,2.356l-8.7798,15.2073V28.2236z M47.5676,28.2236v26.6412 c0,1.1008,0.7393,2.0647,1.8029,2.3497c0.209,0.0561,0.4205,0.0827,0.6295,0.0827c0.8533,0,1.6642-0.4504,2.1065-1.2162 l13.3146-23.0616c6.8507,4.8503,11.3357,12.8315,11.3357,21.8454c0,14.7537-12.0031,26.7567-26.7568,26.7567 s-26.7568-12.003-26.7568-26.7567C23.2432,40.9315,33.9501,29.4573,47.5676,28.2236z\" />\r\n  </svg>\r\n);\r\n\r\nexport default Icon;\r\n","import React from 'react';\r\nimport PropTypes from 'prop-types';\r\nimport BaseChart from 'interface/others/BaseChart';\r\n\r\nimport { formatPercentage } from 'common/format';\r\nimport SpellLink from 'common/SpellLink';\r\nimport { TooltipElement } from 'common/Tooltip';\r\n\r\nimport './style.scss';\r\n\r\nclass DonutChart extends React.PureComponent {\r\n  static propTypes = {\r\n    items: PropTypes.arrayOf(PropTypes.shape({\r\n      value: PropTypes.number.isRequired,\r\n      label: PropTypes.node.isRequired,\r\n      color: PropTypes.string.isRequired,\r\n      tooltip: PropTypes.node,\r\n      spellId: PropTypes.number,\r\n      valueTooltip: PropTypes.node,\r\n    })).isRequired,\r\n    // While you could change the chart size, I strongly recommend you do not for consistency and to avoid breaking whenever this component is modified. Do you really need to adjust the size?\r\n    chartSize: PropTypes.number,\r\n    innerRadiusFactor: PropTypes.number,\r\n  };\r\n  static defaultProps = {\r\n    chartSize: 90,\r\n    innerRadiusFactor: 0.28,\r\n  };\r\n\r\n  renderLegend(items) {\r\n    const total = items.reduce((sum, item) => sum + item.value, 0);\r\n\r\n    return (\r\n      <div className=\"legend\">\r\n        {items.map(({ color, label, tooltip, value, spellId, valueTooltip }, index) => {\r\n          label = tooltip ? (\r\n            <TooltipElement content={tooltip}>{label}</TooltipElement>\r\n          ) : label;\r\n          label = spellId ? (\r\n            <SpellLink id={spellId}>{label}</SpellLink>\r\n          ) : label;\r\n          return (\r\n            <div key={index} className=\"flex\">\r\n              <div className=\"flex-sub\">\r\n                <div className=\"circle\" style={{ background: color }} />\r\n              </div>\r\n              <div className=\"flex-main\">\r\n                {label}\r\n              </div>\r\n              <div className=\"flex-sub\">\r\n                <TooltipElement content={valueTooltip ? valueTooltip : value}>\r\n                  {formatPercentage(value / total, 0)}%\r\n                </TooltipElement>\r\n              </div>\r\n            </div>\r\n          );\r\n        })}\r\n      </div>\r\n    );\r\n  }\r\n  renderChart(items, chartSize, innerRadiusFactor) {\r\n    const innerRadius = chartSize * innerRadiusFactor;\r\n\r\n    const data = {\r\n      items,\r\n    };\r\n    const spec = {\r\n      data: {\r\n        name: 'items',\r\n      },\r\n      mark: {\r\n        type: 'arc',\r\n        innerRadius,\r\n      },\r\n      encoding: {\r\n        theta: {\r\n          field: 'value',\r\n          type: 'quantitative',\r\n        },\r\n        color: {\r\n          field: 'label',\r\n          type: 'nominal',\r\n          legend: null,\r\n          scale: {\r\n            domain: items.map(({label}) => label),\r\n            range: items.map(({color}) => color),\r\n          },\r\n        },\r\n      },\r\n      view: {\r\n        stroke: null,\r\n      },\r\n    };\r\n    return (\r\n      <div className=\"chart\">\r\n        <BaseChart\r\n          width={chartSize}\r\n          height={chartSize}\r\n          spec={spec}\r\n          data={data}\r\n        />\r\n      </div>\r\n    );\r\n  }\r\n  render() {\r\n    const { items, chartSize, innerRadiusFactor } = this.props;\r\n\r\n    return (\r\n      <div className=\"donut-chart\">\r\n        {this.renderLegend(items)}\r\n        {this.renderChart(items, chartSize, innerRadiusFactor)}\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default DonutChart;\r\n","import React from 'react';\r\nimport PropTypes from 'prop-types';\r\n\r\nimport { TooltipElement } from 'common/Tooltip';\r\n\r\nimport './StatisticBox.css';\r\nimport STATISTIC_CATEGORY from './STATISTIC_CATEGORY';\r\n\r\nexport { default as STATISTIC_ORDER } from './STATISTIC_ORDER';\r\n\r\n/**\r\n * @deprecated Use `interface/statistic/Statistic` instead.\r\n */\r\nconst StatisticsListBox = ({ title, tooltip, children, bodyStyle, ...others }) => {\r\n  delete others.category;\r\n  delete others.position;\r\n  return (\r\n    <div className=\"col-lg-3 col-md-4 col-sm-6 col-xs-12\">\r\n      <div className=\"panel statistic statistic-box statistic-box-list\" {...others}>\r\n        {title && (\r\n          <div className=\"panel-heading\">\r\n            <h2>{tooltip ? <TooltipElement content={tooltip}>{title}</TooltipElement> : title}</h2>\r\n          </div>\r\n        )}\r\n        <div className=\"panel-body items\" style={bodyStyle}>\r\n          {children}\r\n        </div>\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\nStatisticsListBox.propTypes = {\r\n  title: PropTypes.node,\r\n  children: PropTypes.node.isRequired,\r\n  tooltip: PropTypes.node,\r\n  bodyStyle: PropTypes.object,\r\n  category: PropTypes.string,\r\n  position: PropTypes.number,\r\n};\r\nStatisticsListBox.defaultProps = {\r\n  category: STATISTIC_CATEGORY.GENERAL,\r\n};\r\n\r\nexport default StatisticsListBox;\r\n","import Analyzer, { SELECTED_PLAYER } from 'parser/core/Analyzer';\r\nimport Haste from 'parser/shared/modules/Haste';\r\nimport EventEmitter from 'parser/core/modules/EventEmitter';\r\nimport SpellResourceCost from 'parser/shared/modules/SpellResourceCost';\r\nimport HIT_TYPES from 'game/HIT_TYPES';\r\nimport Events from 'parser/core/Events';\r\n\r\n// turn on debug to find if there's inaccuracies, then verboseDebug to help track the cause.\r\nconst debug = false;\r\nconst verboseDebug = false;\r\n\r\n/**\r\n * Tracks when a regenerating resource reaches its cap. Most useful for specs such as rogues\r\n * and feral druids where their energy resource quickly recharges through natural regeneration\r\n * and may frequently reach its cap during a fight.\r\n *\r\n * It is an 'abstract' class, so should be extended and provided with settings for the resource\r\n * being tracked by your spec. Search for \"IMPLEMENTME\" for what should be set up.\r\n *\r\n * Reductions in spell costs should be handled by implementing parser/core/Modules/SpellResourceCost\r\n * for the relevant resource.\r\n *\r\n * If your derived class shares event handlers remember to call the original, e.g.\r\n * onCast(event) {\r\n *  super.onCast(event);\r\n *  // stuff related to your spec's implementation\r\n * }\r\n *\r\n * Example derived class: parser/Druid/Feral/Modules/Features/EnergyCapTracker\r\n *\r\n * For a more complete picture of how a combatant is using their resources you may want to\r\n * also use parser/core/Modules/ResourceTracker\r\n * ResourceTracker handles how it's energized and spent, RegenResourceCapTracker will tell\r\n * you about natural regeneration and how long it's at cap.\r\n *\r\n * The accuracy of this module's predictions depends heavily on finding the \"quirks\" of how\r\n * abilities and their resource behaviours appear in the combat log. It can never be perfectly\r\n * accurate due to resources being rounded to integer values and latency issues, but an error\r\n * of less than 2 should be possible.\r\n *\r\n * Fabricates events 'beginresourcecap' and 'endresourcecap'. See the functions fabricateBeginCap\r\n * and fabricateEndCap for details on these events and their limitations.\r\n */\r\n\r\n/**\r\n * How far (in ms) damage event can be separated from a cast and still use its information\r\n * to decide there should be a resource refund due to not hiting. 208ms is highest I've seen.\r\n */\r\nconst REFUND_SPENDER_WINDOW = 500;\r\nconst HIT_TYPES_THAT_REFUND = [\r\n  HIT_TYPES.MISS,\r\n  HIT_TYPES.DODGE,\r\n  HIT_TYPES.PARRY,\r\n];\r\n\r\n/**\r\n * @property {EventEmitter} eventEmitter\r\n * @property {Haste} haste\r\n * @property {SpellResourceCost} spellResourceCost\r\n */\r\nclass RegenResourceCapTracker extends Analyzer {\r\n  static dependencies = {\r\n    eventEmitter: EventEmitter,\r\n    haste: Haste,\r\n    // Needed for the `resourceCost` prop of events\r\n    spellResourceCost: SpellResourceCost,\r\n  };\r\n\r\n  // -- Start of IMPLEMENTME statics\r\n\r\n  // One of game/RESOURCE_TYPES\r\n  static resourceType;\r\n\r\n  // Resource's base regeneration rate in points per second (e.g. 10 for Energy)\r\n  static baseRegenRate = 0;\r\n\r\n  /**\r\n   * Is natural regeneration rate increased by haste.\r\n   * If a resource is affected by haste in an unusual way, set false and handle it manually in naturalRegenRate\r\n   */\r\n  static isRegenHasted = false;\r\n\r\n  /**\r\n   * Any buff or debuff IDs that change the max value for this resource. e.g. Berserk for Feral.\r\n   * Remember to check for their presence and apply the effect in currentMaxResource\r\n   */\r\n  static buffsChangeMax = [];\r\n\r\n  /**\r\n   * Any buff or debuff IDs that directly affect natural regeneration rate for this resource. e.g. Adrenaline Rush for Outlaw.\r\n   * Remember to check for their presence and apply the effect in naturalRegenRate\r\n   */\r\n  static buffsChangeRegen = [];\r\n\r\n  // Events for some abilities give inaccurate \"amount\" values, so their change is best applied cumulatively.\r\n  static energizersToApplyCumulatively = [];\r\n  static castsToApplyCumulatively = [];\r\n  static drainsToApplyCumulatively = [];\r\n\r\n  /**\r\n   * How close (in ms) a resource changing event must be to the last one to have the change handled cumulatively.\r\n   *\r\n   * When resource changing events occur in a very short time the values in the combat log can become inaccurate.\r\n   *  What happens in the fight:\r\n   * t: 1  player has 50 energy\r\n   * t: 2  cast spending 20 energy\r\n   * t: 2  energize gaining 30 energy\r\n   * t: 3  player has 60 energy\r\n   *\r\n   *  What the log shows:\r\n   * cast {timestamp: 2, classResources[i]: {amount: 50, cost: 20}}\r\n   * energize {timestamp: 2, resourceChange: 30, classResources[i]: {amount: 80}}\r\n   * ('amount' for cast events is what it was before the event, for energize events it's after.)\r\n   *\r\n   * If we trusted the resource information given by the last parsed event we'd expect energy to\r\n   * be 80 at t = 3.\r\n   */\r\n  static cumulativeEventWindow = 100;\r\n\r\n  /**\r\n   * For some specs (e.g. energy for rogues and feral) a ability that doesn't hit refunds some of the resource.\r\n   * A value of 0 means no refund, 0.8 seems to be the standard refund amount.\r\n   */\r\n  static resourceRefundOnMiss = 0;\r\n\r\n  // Some abilities never get their resources refunded, usually AoEs. List their spellIds here.\r\n  static exemptFromRefund = [];\r\n\r\n  // -- end of IMPLEMENTME statics\r\n\r\n  // Total time spent with resource at maximum (in ms)\r\n  atCap = 0;\r\n\r\n  // Total resources lost from natural regeneration (ONLY natural regeneration) due to being capped\r\n  missedRegen = 0;\r\n\r\n  // Total resources generated from natural regeneration, includes wasted resources.\r\n  naturalRegen = 0;\r\n\r\n  regenState = null;\r\n  prevSpender = null;\r\n  hasReportedBelowCap = false;\r\n\r\n  /**\r\n   * Amount of resource that should be available at current timestamp, accounting for natural regeneration.\r\n   * @returns {number}\r\n   */\r\n  get current() {\r\n    return this.predictValue(this.owner.currentTimestamp);\r\n  }\r\n\r\n  /**\r\n   * Whether the resource is at its cap at the current timestamp.\r\n   * @returns {boolean}\r\n   */\r\n  get isCapped() {\r\n    return this.current >= this.regenState.max;\r\n  }\r\n\r\n  /**\r\n   * What fraction of the fight was spent with this resource at its cap.\r\n   * @returns {number}\r\n   */\r\n  get cappedProportion() {\r\n    return this.atCap / this.owner.fightDuration;\r\n  }\r\n\r\n  /**\r\n   * Resource lost from natural regeneration (only from natural regeneration, not energizers) due\r\n   * to the resource reaching cap, averaged to a per-minute value.\r\n   */\r\n  get missedRegenPerMinute() {\r\n    return (this.missedRegen / this.owner.fightDuration) * 1000 * 60;\r\n  }\r\n\r\n  constructor(...args) {\r\n    super(...args);\r\n    // can't know resource state for certain until the first combat events, but assume a regenerating resource starts full.\r\n    const max = this.currentMaxResourceWithFallback();\r\n    this.regenState = {\r\n      amount: max ? max : 0,\r\n      max,\r\n      regen: this.naturalRegenRate(),\r\n      timestamp: this.owner.fight.start_time,\r\n    };\r\n    this.addEventListener(Events.fightend, this.onFightend);\r\n    this.addEventListener(Events.energize.to(SELECTED_PLAYER), this.onEnergize);\r\n    this.addEventListener(Events.cast.by(SELECTED_PLAYER), this.onCast);\r\n    this.addEventListener(Events.damage.by(SELECTED_PLAYER), this.onDamage);\r\n    this.addEventListener(Events.drain.by(SELECTED_PLAYER), this.onDrain);\r\n    this.addEventListener(Events.applybuff.to(SELECTED_PLAYER), this.onApplyBuff);\r\n    this.addEventListener(Events.removebuff.to(SELECTED_PLAYER), this.onRemoveBuff);\r\n    this.addEventListener(Events.ChangeHaste.to(SELECTED_PLAYER), this.onChangeHaste);\r\n  }\r\n\r\n  /**\r\n   * IMPLEMENTME\r\n   * Some specs have drain reductions that aren't already shown in events, which should be implemented\r\n   * here. Drain events are separate from an ability cast cost.\r\n   * @param   {object}  event A drain event being applied to the player.\r\n   * @returns {number}  Drain amount after any reductions are applied.\r\n   */\r\n  getReducedDrain(event) {\r\n    return event.resourceChange;\r\n  }\r\n\r\n  /**\r\n   * IMPLEMENTME\r\n   * Some specs have modifiers to the base regen rate that apply before haste, which should\r\n   * be implemented here.\r\n   * @returns {number} Base regen rate of the resource.\r\n   */\r\n  getBaseRegenRate(){\r\n    return this.constructor.baseRegenRate;\r\n  }\r\n\r\n  /**\r\n   * IMPLEMENTME\r\n   * Calculate current natural regeneration rate of the resource.\r\n   * When checking combant's buffs/debuffs you may want to use this.combatantHasBuffActive() rather than\r\n   * the .hasBuff of the combatant directly, doing so will exclude buffs which wore off at this timestamp.\r\n   * @returns {number}  Resource expected to be generated per ms.\r\n   */\r\n  naturalRegenRate() {\r\n    let regen = this.getBaseRegenRate() / 1000;\r\n    if (this.constructor.isRegenHasted) {\r\n      regen *= (1 + this.haste.current);\r\n    }\r\n    return regen;\r\n  }\r\n\r\n  /**\r\n   * IMPLEMENTME\r\n   * Calculate current maximum value for the resource. Accounting for items, talents, and active buffs.\r\n   * When checking combant's buffs/debuffs you may want to use this.combatantHasBuffActive() rather than\r\n   * the .hasBuff of the combatant directly, doing so will exclude buffs which wore off at this timestamp.\r\n   * @returns {number}  Maximum resource value, or null to try to use value from resource events.\r\n   */\r\n  currentMaxResource() {\r\n   /**\r\n    * If left unimplemented and no events provide max resource information the Analyzer will never know\r\n    * the resource's max value. It handles that situation without crashing, but without a cap value it\r\n    * is largely useless.\r\n    */\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Applies an energize of the tracked resource type at the current timestamp.\r\n   * Use when a spec has a source of resource which doesn't appear as an energize event in the log.\r\n   * If you have an invisible energize that happens over a duration you should generate an event for\r\n   * each tick, as applying it all at once can lead to inaccuracies. If it doesn't have ticks consider\r\n   * handling it as a buff to the natural regeneration rate instead.\r\n   * @param {number} amount Raw amount of resources to gain. Limiting to max is done within this function\r\n   * so there's no need to check before passing it in.\r\n   */\r\n  processInvisibleEnergize(amount) {\r\n    if (amount == null || isNaN(amount)) {\r\n      throw new Error(`processInvisibleEnergize called without required parameter. amount: ${amount}`);\r\n    }\r\n    if (amount === 0) {\r\n      return;\r\n    }\r\n    const before = this.current;\r\n    const after = Math.min(before + amount, this.currentMaxResourceWithFallback());\r\n    const gain = after - before;\r\n    this.applyEnergize(gain);\r\n  }\r\n\r\n  /**\r\n   * Fetches the appropriate classResources object from an event, or null if there is none available.\r\n   * @param {object} event An event object which may have an appropriate .classResources property.\r\n   */\r\n  getResource(event) {\r\n    if (!event || !event.classResources) {\r\n      return null;\r\n    }\r\n    return event.classResources.find(r => r.type === this.constructor.resourceType.id);\r\n  }\r\n\r\n  /**\r\n   * Fetches the cost of a cast event. Using its resourceCost property (added by SpellResourceCost)\r\n   * if it's available or the resource cost given by the combat log if not.\r\n   * @param {object} event A cast event object with a resource cost associated with it.\r\n   */\r\n  getCost(event) {\r\n    if (event.resourceCost[this.constructor.resourceType.id] !== undefined) {\r\n      return event.resourceCost[this.constructor.resourceType.id];\r\n    }\r\n    return this.getResource(event).cost;\r\n  }\r\n\r\n  /**\r\n   * A variation of this.selectedCombatant.hasBuff that excludes any buffs which were removed on the timestamp.\r\n   * @param {number} buffId ID of buff or debuff to check for on the current combatant.\r\n   * @param {number} timestamp Time to check, or null to use current timestamp. Cannot be a future timestamp.\r\n   */\r\n  combatantHasBuffActive(buffId, timestamp = null) {\r\n    if (!buffId || isNaN(buffId)) {\r\n      throw new Error(`combatantHasBuffActive called without required parameter. buffId: ${buffId}`);\r\n    }\r\n    if (!timestamp) {\r\n      timestamp = this.owner.currentTimestamp;\r\n    }\r\n    const buffHistory = this.selectedCombatant.getBuffHistory(buffId);\r\n    return Boolean(buffHistory.find(buff => (buff.start <= timestamp && (!buff.end || buff.end > timestamp))));\r\n  }\r\n\r\n  onFightend() {\r\n    // updateState one last time to catch any resource capping after the final resource event\r\n    this.updateState(this.predictValue(this.owner.fight.end_time));\r\n    debug && console.log(`mean prediction error magnitude: ${this.debugMeanPredictionError.toFixed(2)}`);\r\n    debug && console.log(`greatest magnitude prediction error: ${this.debugGreatestError.toFixed(2)}`);\r\n  }\r\n\r\n  onEnergize(event) {\r\n    if(event.resourceChangeType !== this.constructor.resourceType.id || !event.resourceChange) {\r\n      return;\r\n    }\r\n    const waste = event.waste ? event.waste : 0;\r\n    const gain = event.resourceChange - waste;\r\n    const applyCumulatively = this.constructor.energizersToApplyCumulatively.includes(event.ability.guid);\r\n    this.applyEnergize(gain, event, applyCumulatively);\r\n  }\r\n\r\n  applyEnergize(gain, event = null, applyCumulatively = false) {\r\n    if (gain == null || isNaN(gain)) {\r\n      // using == null to catch undefined, but still allow 0\r\n      throw new Error(`applyEnergize called without required parameter. gain: ${gain}`);\r\n    }\r\n    const time = event ? event.timestamp : this.owner.currentTimestamp;\r\n    const eventResource = event ? this.getResource(event) : null;\r\n\r\n    const shouldAccumulate = applyCumulatively ||\r\n      this.isLastUpdateRecent(time) ||\r\n      !eventResource || eventResource.amount == null;\r\n\r\n    // eventResource.amount for an energize is the value after the change\r\n    const current = shouldAccumulate ? (this.predictValue(time) + gain) : eventResource.amount;\r\n    if (debug && !shouldAccumulate) {\r\n      this.debugActualVsPredicted(eventResource.amount - gain, time);\r\n    }\r\n    const max = this.currentMaxResourceWithFallback(event);\r\n    this.updateState(current, max);\r\n  }\r\n\r\n  onCast(event) {\r\n    const eventResource = this.getResource(event);\r\n    if (!eventResource) {\r\n      return;\r\n    }\r\n    const cost = this.getCost(event);\r\n    if (!cost) {\r\n      // only interested in cast events that spend resource\r\n      return;\r\n    }\r\n    if (cost < 0) {\r\n      debug && console.warn(`${this.owner.formatTimestamp(event.timestamp, 3)} Unexpected negative cost ${cost} for spell ${event.ability.guid}`);\r\n    }\r\n    if (!this.constructor.exemptFromRefund.includes(event.ability.guid)) {\r\n      this.prevSpender = {\r\n        id: event.ability.guid,\r\n        cost,\r\n        timestamp: event.timestamp,\r\n      };\r\n    }\r\n\r\n    const shouldAccumulate = eventResource.amount == null ||\r\n      this.constructor.castsToApplyCumulatively.includes(event.ability.guid) ||\r\n      this.isLastUpdateRecent(event.timestamp);\r\n    const current = (shouldAccumulate ? this.predictValue(event.timestamp) : eventResource.amount) - cost;\r\n    if (debug && !shouldAccumulate) {\r\n      this.debugActualVsPredicted(eventResource.amount, event.timestamp);\r\n    }\r\n    const max = this.currentMaxResourceWithFallback(event);\r\n    this.updateState(current, max);\r\n  }\r\n\r\n  onDamage(event) {\r\n    // only interested in damage events if they show a spending ability failing to connect (and so triggering a refund)\r\n    if (!this.prevSpender || event.ability.guid !== this.prevSpender.id ||\r\n        (event.timestamp - this.prevSpender.timestamp) > REFUND_SPENDER_WINDOW ||\r\n        event.tick || !HIT_TYPES_THAT_REFUND.includes(event.hitType)) {\r\n      return;\r\n    }\r\n    verboseDebug && console.log(`${this.owner.formatTimestamp(this.owner.currentTimestamp, 3)} attack didn't connect so restoring ${Math.round(this.constructor.resourceRefundOnMiss * 100)}% resource`);\r\n    const refund = Math.floor(this.prevSpender.cost * this.constructor.resourceRefundOnMiss);\r\n    const current = this.predictValue(event.timestamp) + refund;\r\n    this.updateState(current);\r\n  }\r\n\r\n  onDrain(event) {\r\n    if(event.resourceChangeType !== this.constructor.resourceType.id || !event.resourceChange) {\r\n      return;\r\n    }\r\n    const eventResource = this.getResource(event);\r\n    const drain = this.getReducedDrain(event);\r\n\r\n    const shouldAccumulate = !eventResource || eventResource.amount == null ||\r\n      this.constructor.energizersToApplyCumulatively.includes(event.ability.guid) ||\r\n      this.isLastUpdateRecent(event.timestamp);\r\n\r\n    // eventResource.amount for a drain is the value before the change\r\n    const current = (shouldAccumulate ? this.predictValue(event.timestamp) : eventResource.amount) - drain;\r\n    if (debug && !shouldAccumulate) {\r\n      this.debugActualVsPredicted(eventResource.amount, event.timestamp);\r\n    }\r\n    const max = this.currentMaxResourceWithFallback(event);\r\n    this.updateState(current, max);\r\n  }\r\n\r\n  isLastUpdateRecent(timestamp) {\r\n    return this.regenState.timestamp + this.constructor.cumulativeEventWindow >= timestamp;\r\n  }\r\n\r\n  onApplyBuff(event) {\r\n    if (this.constructor.buffsChangeMax.includes(event.ability.guid)) {\r\n      this.buffChangesResourceMax(event);\r\n    }\r\n    if (this.constructor.buffsChangeRegen.includes(event.ability.guid)) {\r\n      this.buffChangesRegen();\r\n    }\r\n  }\r\n\r\n  onRemoveBuff(event) {\r\n    if (this.constructor.buffsChangeMax.includes(event.ability.guid)) {\r\n      this.buffChangesResourceMax(event);\r\n    }\r\n    if (this.constructor.buffsChangeRegen.includes(event.ability.guid)) {\r\n      this.buffChangesRegen();\r\n    }\r\n  }\r\n\r\n  onChangeHaste() {\r\n    const regen = this.naturalRegenRate();\r\n    this.updateState(null, null, regen);\r\n  }\r\n\r\n  buffChangesResourceMax(event) {\r\n    const max = this.currentMaxResourceWithFallback(event);\r\n    this.updateState(null, max);\r\n  }\r\n\r\n  buffChangesRegen() {\r\n    const regen = this.naturalRegenRate();\r\n    this.updateState(null, null, regen);\r\n  }\r\n\r\n  /**\r\n   * Called when current, max, or regen rate for the resource has changed.\r\n   * Builds a new regenState reflecting the current state.\r\n   * Detects if resource capping occurred since the last regenState.\r\n   * @param {number} amount Current amount of resource, or null to use prediction.\r\n   * @param {number} max Current resource maximum, or null to use calculation.\r\n   * @param {number} regen Current resource regeneration rate, or null to use calculation.\r\n   */\r\n  updateState(amount = null, max = null, regen = null) {\r\n    const timestamp = this.owner.currentTimestamp;\r\n    verboseDebug && console.log(`${this.owner.formatTimestamp(timestamp, 3)} amount: ${amount ? amount.toFixed(1) : 'n/a'}, max: ${max ? max.toFixed(1) : 'n/a'} , regen: ${regen ? (regen * 1000).toFixed(3) : 'n/a'}`);\r\n    if (amount == null || isNaN(amount)) {\r\n      amount = this.predictValue(timestamp);\r\n    }\r\n    if (max == null || isNaN(max)) {\r\n      max = this.currentMaxResourceWithFallback();\r\n    }\r\n    if (regen == null || isNaN(regen)) {\r\n      regen = this.naturalRegenRate();\r\n    }\r\n    amount = max ? Math.min(max, amount) : amount;\r\n    const oldState = this.regenState;\r\n    const newState = {\r\n      amount,\r\n      max,\r\n      regen,\r\n      timestamp,\r\n    };\r\n    this.regenState = newState;\r\n    if (oldState) {\r\n      const durationCapped = this.timeCappedBetweenStates(oldState, newState);\r\n      this.atCap += durationCapped;\r\n      this.missedRegen += durationCapped * oldState.regen;\r\n      this.naturalRegen += (newState.timestamp - oldState.timestamp) * oldState.regen;\r\n    }\r\n    if (newState.amount < newState.max) {\r\n      this.onBelowCap(newState.timestamp);\r\n    }\r\n  }\r\n\r\n  timeCappedBetweenStates(oldState, newState) {\r\n    if (!oldState || !newState){\r\n      throw new Error(`timeCappedBetweenStates called without required parameters. oldState: ${oldState}, newState: ${newState}`);\r\n    }\r\n    const reachCap = oldState.max ? this.predictReachValue(oldState.timestamp, oldState.amount, oldState.regen, oldState.max) : Infinity;\r\n    if (reachCap >= newState.timestamp) {\r\n      return 0;\r\n    }\r\n    this.onAtCap(reachCap);\r\n\r\n    return newState.timestamp - reachCap;\r\n  }\r\n\r\n  currentMaxResourceWithFallback(event = null) {\r\n    const calculated = this.currentMaxResource();\r\n    if (calculated) {\r\n      return calculated;\r\n    }\r\n    const eventResource = this.getResource(event);\r\n    if (eventResource && eventResource.max != null && !isNaN(eventResource.max)) {\r\n      return eventResource.max;\r\n    }\r\n    // when neither source provides a value just use the existing\r\n    return this.regenState.max;\r\n  }\r\n\r\n  /**\r\n   * Given a start value and regen rate, calculate when resource will reach a given value.\r\n   * @param {number} startTime Timestamp for known resource value\r\n   * @param {number} startValue Known resource value\r\n   * @param {number} regen Regeneration rate in units per ms\r\n   * @param {number} targetValue Resource value being aimed for\r\n   * @returns {number} Timestamp when targetValue would be reached through natural regen.\r\n   */\r\n  predictReachValue(startTime, startValue, regen, targetValue) {\r\n    if (startValue == null || isNaN(startValue) ||\r\n        regen == null || isNaN(regen) ||\r\n        targetValue == null || isNaN(targetValue) ||\r\n        startTime == null || isNaN(startTime)) {\r\n      throw new Error(`predictReachValue called without required parameters. startValue: ${startValue}, regen: ${regen}, cap: ${targetValue}, startTime: ${startTime}`);\r\n    }\r\n    if (startValue >= targetValue) {\r\n      return startTime;\r\n    }\r\n    if (regen === 0) {\r\n      return Infinity;\r\n    }\r\n    return startTime + ((targetValue - startValue) / regen);\r\n  }\r\n\r\n  /**\r\n   * Calculates available resource accounting for natural regen.\r\n   * @param {number} time Timestamp for which to create a prediction, or null for current timestamp.\r\n   * @returns {number} Predicted resource value at given time.\r\n   */\r\n  predictValue(time = null) {\r\n    if (!time) {\r\n      time = this.owner.currentTimestamp;\r\n    }\r\n    if (time < this.regenState.timestamp) {\r\n      debug && console.warn(`Attempting to predict the past. State's time: ${this.owner.formatTimestamp(this.regenState.timestamp, 3)}, target time: ${this.owner.formatTimestamp(time, 3)}`);\r\n      return this.regenState.amount;\r\n    }\r\n    const elapsed = time - this.regenState.timestamp;\r\n    const predicted = this.regenState.amount + this.regenState.regen * elapsed;\r\n    return this.regenState.max ? Math.min(this.regenState.max, predicted) : predicted;\r\n  }\r\n\r\n  onBelowCap(time) {\r\n    if (this.hasReportedBelowCap) {\r\n      return;\r\n    }\r\n    this.fabricateEndCap(time);\r\n    this.hasReportedBelowCap = true;\r\n  }\r\n\r\n  onAtCap(time) {\r\n    if (!this.hasReportedBelowCap) {\r\n      return;\r\n    }\r\n    this.fabricateBeginCap(time);\r\n    this.hasReportedBelowCap = false;\r\n  }\r\n\r\n  /**\r\n   * Fabricates an event indicating the tracked resource has reached its cap value.\r\n   * May be triggered by an energize or natural regeneration bringing the value to the cap, or\r\n   * by the cap being lowered.\r\n   *\r\n   * Although the timestamp of this event should be accurate, because cap events are sometimes\r\n   * only detected after they happen it may be misplaced within the event stream.\r\n   * So do NOT assume that an event parsed between beginresourcecap and endresourcecap events\r\n   * being parsed happened while the resource was capped. Either look at the timestamps of\r\n   * the events or if you're interested in the current cap state use this analyzer's isCapped\r\n   *\r\n   * Also note that endresourcecap and beginresourcecap events may occur extremely close to\r\n   * one-another, sometimes on the same timestamp if there's a spend and energize event.\r\n   *\r\n   * @param {number} time Timestamp for when the resource reached cap.\r\n   */\r\n  fabricateBeginCap(time) {\r\n    if (time == null || isNaN(time)) {\r\n      throw new Error(`fabricateBeginCap called without required parameter. time: ${time}`);\r\n    }\r\n    verboseDebug && console.log(`${this.owner.formatTimestamp(time, 3)} begin cap`);\r\n    this.eventEmitter.fabricateEvent({\r\n      type: 'beginresourcecap',\r\n      timestamp: time,\r\n      sourceID: this.owner.playerId,\r\n      targetID: this.owner.playerId,\r\n      resourceType: this.constructor.resourceType.id,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Fabricates an event indicating that the tracked resource is no longer at its cap.\r\n   * May be triggered by cast or drain using resource or the cap value being increased.\r\n   * @param {number} time Timestamp for when the resource ceased to be at the cap.\r\n   */\r\n  fabricateEndCap(time) {\r\n    if (time == null || isNaN(time)) {\r\n      throw new Error(`fabricateEndCap called without required parameter. time: ${time}`);\r\n    }\r\n    verboseDebug && console.log(`${this.owner.formatTimestamp(time, 3)} end cap`);\r\n    this.eventEmitter.fabricateEvent({\r\n      type: 'endresourcecap',\r\n      timestamp: time,\r\n      sourceID: this.owner.playerId,\r\n      targetID: this.owner.playerId,\r\n      resourceType: this.constructor.resourceType.id,\r\n    });\r\n  }\r\n\r\n  // -- debug code to check accuracy of predictions against values reported by log\r\n  debugErrorSum = 0;\r\n  debugGreatestError = 0;\r\n  debugAccuracyCheckCount = 0;\r\n  debugActualVsPredicted(actual, timestamp) {\r\n    if (!debug) {\r\n      return;\r\n    }\r\n    const predicted = this.predictValue(timestamp);\r\n    const difference = predicted - actual;\r\n    const errorMagnitude = Math.abs(difference);\r\n    this.debugGreatestError = Math.max(this.debugGreatestError, errorMagnitude);\r\n    this.debugAccuracyCheckCount += 1;\r\n    this.debugErrorSum += errorMagnitude;\r\n    if (errorMagnitude > 3) {\r\n      console.log(`${this.owner.formatTimestamp(timestamp, 3)} actual: ${actual} prediction: ${predicted.toFixed(1)} (error: ${difference > 0 ? '+' : ''}${difference.toFixed(1)})`);\r\n    }\r\n  }\r\n  get debugMeanPredictionError() {\r\n    return this.debugErrorSum / this.debugAccuracyCheckCount;\r\n  }\r\n}\r\n\r\nexport default RegenResourceCapTracker;\r\n"],"sourceRoot":""}