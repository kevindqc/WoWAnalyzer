{"version":3,"sources":["parser/druid/restoration/normalizers/WildGrowth.js","parser/druid/restoration/normalizers/ClearcastingNormalizer.js","parser/druid/restoration/normalizers/HotApplicationNormalizer.js","parser/druid/restoration/normalizers/TreeOfLifeNormalizer.js","parser/druid/restoration/modules/features/AlwaysBeCasting.js","parser/druid/restoration/modules/features/Clearcasting.js","parser/druid/restoration/modules/features/Lifebloom.js","parser/druid/restoration/modules/features/Efflorescence.js","parser/druid/restoration/modules/features/Innervate.js","parser/druid/restoration/modules/features/WildGrowth.js","parser/druid/restoration/SpellInfo.js","parser/druid/restoration/modules/core/Mastery.js","parser/druid/restoration/modules/talents/Cultivation.js","parser/druid/restoration/modules/talents/SpringBlossoms.js","parser/druid/restoration/constants.js","parser/druid/restoration/modules/core/Rejuvenation.js","parser/druid/restoration/modules/talents/TreeOfLife.js","parser/druid/restoration/modules/features/Checklist/Component.js","parser/druid/restoration/modules/features/Checklist/Module.js","parser/druid/restoration/modules/core/hottracking/HotTrackerRestoDruid.tsx","parser/druid/restoration/modules/core/hottracking/RejuvenationAttributor.js","parser/druid/restoration/modules/core/hottracking/RegrowthAttributor.js","parser/druid/restoration/modules/core/SpellManaCost.js","parser/druid/restoration/modules/features/AverageHots.js","parser/druid/restoration/modules/Abilities.js","parser/druid/restoration/modules/features/CooldownThroughputTracker.js","parser/druid/restoration/modules/features/Ironbark.js","parser/druid/restoration/modules/features/PrematureRejuvenations.js","parser/druid/restoration/modules/talents/CenarionWard.js","parser/druid/restoration/modules/talents/Flourish.js","parser/druid/restoration/modules/talents/SoulOfTheForest.js","parser/druid/restoration/modules/talents/Photosynthesis.js","parser/druid/restoration/modules/talents/Abundance.js","parser/druid/restoration/modules/features/StatWeights.js","parser/druid/restoration/modules/features/RestoDruidHealingEfficiencyTracker.js","parser/druid/restoration/modules/shadowlands/conduits/FlashOfClarity.js","parser/druid/restoration/CombatLogParser.js","interface/statistics/components/BoringSpellValueText/index.tsx","interface/icons/Uptime.js","interface/statistics/components/BoringValueText/index.tsx","parser/core/calculateEffectiveHealing.js","parser/shared/modules/resources/resourcetracker/ResourceTracker.ts","../node_modules/react-animate-height/lib/AnimateHeight.js","parser/core/healingEfficiency/ManaTracker.ts","parser/core/healingEfficiency/HealingEfficiencyTracker.ts","interface/PerformanceBar.tsx","parser/shared/modules/features/images/QE-Logo-New-Small.png","parser/core/healingEfficiency/HealingEfficiencyBreakdown.tsx","interface/others/StatisticWrapper.js","parser/shared/modules/features/SpellInfo.js","parser/shared/modules/features/BaseHealerStatValues.js","parser/core/healingEfficiency/HealingEfficiencyDetails.tsx","parser/shared/modules/HotTracker.js"],"names":["WildGrowth","events","_events","_newEvents","forEach","event","idx","push","type","EventType","Cast","ability","guid","SPELLS","WILD_GROWTH","id","_idx","_event","Math","abs","timestamp","reverse","concat","ApplyBuff","targetID","owner","playerId","splice","length","REJUVENATION","REJUVENATION_GERMINATION","includes","FLOURISH_TALENT","EventsNormalizer","ClearcastingNormalizer","fixedEvents","eventIndex","REGROWTH","castTimestamp","previousEventIndex","previousEvent","RemoveBuff","CLEARCASTING_BUFF","sourceID","__modified","HotApplicationNormalizer","instantTickHotIds","spellId","Heal","TreeOfLifeNormalizer","INCARNATION_TREE_OF_LIFE_TALENT","nextEventIndex","nextEvent","pop","INCARNATION_TOL_ALLOWED","AlwaysBeCasting","actual","this","nonHealingTimePercentage","isGreaterThan","minor","average","major","style","downtimePercentage","CoreAlwaysBeCastingHealing","HEALING_ABILITIES_ON_GCD","TRANQUILITY_CAST","CENARION_WARD_TALENT","LIFEBLOOM_HOT_HEAL","SWIFTMEND","EFFLORESCENCE_CAST","NATURES_CURE","Clearcasting","args","totalProcs","expiredProcs","overwrittenProcs","usedProcs","availableProcs","nonCCRegrowths","totalRegrowths","lowHealthRegrowthsNoCC","abundanceRegrowthsNoCC","procsPerCC","addEventListener","Events","applybuff","by","SELECTED_PLAYER","spell","onApplyBuff","refreshbuff","onRefreshBuff","removebuff","onRemoveBuff","cast","onCast","heal","onHeal","selectedCombatant","hasBuff","INNERVATE","abundance","getBuff","ABUNDANCE_BUFF","stacks","tick","effectiveHealing","amount","absorbed","hitPoints","maxHitPoints","when","clearcastingUtilSuggestionThresholds","addSuggestion","suggest","recommended","SpellLink","icon","i18n","_","wastedProcs","formatPercentage","clearcastingUtilPercent","round","nonCCRegrowthsSuggestionThresholds","nonCCRegrowthsPerMinute","toFixed","Statistic","size","position","STATISTIC_ORDER","CORE","tooltip","hadInvisibleRefresh","label","SpellIcon","util","isLessThan","fightDuration","Analyzer","Lifebloom","suggestionThresholds","hasDta","ItemLink","ITEMS","THE_DARK_TITANS_ADVICE","uptimePercent","Uptime","combatants","getBuffUptime","uptime","dependencies","Combatants","Efflorescence","options","precastUptime","castUptime","castTimestamps","EFFLORESCENCE_HEAL","lastCastTimestamp","min","fight","start_time","activeUptime","currentTimestamp","Innervate","manaSaved","wildGrowths","efflorescences","cenarionWards","rejuvenations","regrowths","lifeblooms","swiftmends","tranquilities","freeRegrowths","innervateApplyTimestamp","castsUnderInnervate","innervateCount","secondsManaCapped","lastInnervateTimestamp","depleted","to","fightend","onFightend","averageManaSaved","wholeSecondsCapped","classResources","max","manaCost","averageManaSavedSuggestionThresholds","formatNumber","secondsCappedSuggestionThresholds","wgHistory","wgTracker","wgBuffs","startTimestamp","overheal","firstTicksOverheal","firstTicksRaw","reduce","a","b","wgs","filter","wg","badPrecast","abilityTracker","getAbility","casts","rejuvs","belowRecommendedCasts","belowRecommendedPrecasts","wgsPerRejuv","percentBelowRecommendedCasts","percentBelowRecommendedPrecasts","healVal","HealingValue","effective","raw","suggestionpercentBelowRecommendedPrecastsThresholds","suggestionpercentBelowRecommendedCastsThresholds","RECOMMENDED_HIT_THRESHOLD","averageEffectiveHits","AbilityTracker","DEFAULT_INFO","int","crit","hasteHpm","hasteHpct","mastery","masteryStack","vers","DRUID_HEAL_INFO","CULTIVATION","SPRING_BLOSSOMS","CENARION_WARD_HEAL","FRENZIED_REGENERATION","LIFEBLOOM_BLOOM_HEAL","TRANQUILITY_HEAL","ignored","YSERAS_GIFT_OTHERS","YSERAS_GIFT_SELF","RENEWAL_TALENT","MARK_OF_SHIFTING","getSpellInfo","Mastery","totalNoMasteryHealing","druidSpellNoMasteryHealing","masteryTimesHealing","hotHealingAttrib","masteryBuffs","Object","entries","infoEntry","direct","ASTRAL_HARMONY","JACINS_RUSE","values","entry","attributableHealing","onAbsorbed","target","getEntity","hotsOn","getHotsOn","numHotsOn","decomposedHeal","_decompHeal","noMastery","effectiveStackBenefit","hotOn","_tallyMasteryBenefit","oneStack","calculateEffectiveHealing","relativeBuffBenefit","healId","s","v","healIds","total","Number","sum","buffId","activeBuffs","map","buffObj","hotId","hotMastery","getHotCount","hotCount","masteryBonus","statTracker","currentMasteryPercentage","healMasteryMult","rawNoMasteryHealing","noMasteryHealing","effectiveMasteryHealing","buffRating","ratingNeededForNextPercentage","currentMasteryRating","statBaselineRatingPerPercent","STAT","MASTERY","spec","masteryCoefficient","StatTracker","Cultivation","hasCultivation","hasTalent","CULTIVATION_TALENT","active","getPercentageOfTotalHealingDone","getDirectHealing","getMasteryHealing","directPercent","masteryPercent","totalPercent","OPTIONAL","SpringBlossoms","hasSpringBlossoms","SPRING_BLOSSOMS_TALENT","ABILITIES_AFFECTED_BY_HEALING_INCREASES","LEECH","ABILITIES_AFFECTED_BY_HEALING_INCREASES_SPELL_OBJECTS","HOTS_AFFECTED_BY_ESSENCE_OF_GHANIR","Rejuvenation","totalRejuvsCast","getMultiMasteryHealing","totalRejuvHealing","mana","avgRejuvHealing","healingDone","HealingDone","REJUV_MANA_COST","TreeOfLife","lastTolCast","lastTolApply","completedTolUptime","wgCasts","hardcast","allBoostHealing","rejuvBoostHealing","rejuvManaSaved","extraWgHealing","hardcastUptime","_getTotalHealing","accumulator","_getAccumulator","buffUptime","rejuvenation","_getManaSavedHealing","hardcastUptimePercent","_getManaSaved","RestorationDruidChecklist","combatant","castEfficiency","thresholds","AbilityRequirement","props","GenericCastEfficiencyRequirement","getCastEfficiencyForSpellId","Rule","name","description","SOLAR_WRATH","Requirement","nonHealingTime","downtime","wildGrowthRatio","wildGrowthPercentBelowRecommendedCasts","wildGrowthPercentBelowRecommendedPrecasts","efflorescenceUpTime","innervateAverageManaSaved","clearCastingUtil","manaValues","IRONBARK","BARKSKIN","cultivationPercent","springBlossomsPercent","treeOfLifePercent","PreparationRule","Checklist","Component","selected","preparationRuleAnalyzer","alwaysBeCasting","downtimeSuggestionThresholds","nonHealingTimeSuggestionThresholds","wildGrowth","lifebloomUpTime","lifebloom","efflorescence","innervate","clearCasting","cultivation","springBlossoms","treeOfLife","BaseChecklist","CastEfficiency","PreparationRuleAnalyzer","ManaValues","HotTrackerRestoDruid","duration","tickPeriod","HotTracker","REJUV_SPELLS","RejuvenationAttributor","castRejuvApplied","_getRejuvAttribution","targetId","lastRejuvCastTimestamp","lastRejuvTarget","lastWildGrowthCastTimestamp","hotTracker","hots","prepull","console","warn","formatTimestamp","att","addAttribution","RegrowthAttributor","totalNonCCRegrowthHealing","totalNonCCRegrowthOverhealing","totalNonCCRegrowthAbsorbs","totalNonCCRegrowthHealingTicks","_getRegrowthAttribution","lastRegrowthCastTimestamp","lastRegrowthTarget","SpellManaCost","cost","sourceId","abundanceBuff","CoreSpellManaCost","AverageHots","avgTotalHots","getAverageTotalMasteryStacks","avgDruidHots","getAverageDruidSpellMasteryStacks","MASTERY_HARMONY","Abilities","category","SPELL_CATEGORIES","COOLDOWNS","cooldown","INNER_PEACE_TALENT","gcd","base","suggestion","recommendedEfficiency","averageIssueEfficiency","majorIssueEfficiency","healSpellIds","NATURES_SWIFTNESS","importance","ISSUE_IMPORTANCE","MINOR","buffSpellId","DEFENSIVE","ROTATIONAL","enabled","ROTATIONAL_AOE","OTHERS","REBIRTH","UTILITY","SOOTHE","GROWL","HEALER_DAMAGING_SPELL","MOONFIRE","SUNFIRE_CAST","MANGLE_BEAR","haste","SHRED","static","STAG_FORM","TRAVEL_FORM","BEAR_FORM","CAT_FORM","MOONKIN_FORM","BALANCE_AFFINITY_TALENT_RESTORATION","THRASH_BEAR","GUARDIAN_AFFINITY_TALENT_SHARED","THRASH_FERAL","IRONFUR","SWIPE_CAT","FERAL_AFFINITY_TALENT_RESTORATION","SWIPE_BEAR","RIP","FEROCIOUS_BITE","RAKE","STARSURGE_AFFINITY","LUNAR_STRIKE_AFFINITY","WILD_CHARGE_TALENT","WILD_CHARGE_BEAR","WILD_CHARGE_CAT","WILD_CHARGE_MOONKIN","DASH","TIGER_DASH_TALENT","HIBERNATE","TYPHOON","MIGHTY_BASH_TALENT","URSOLS_VORTEX","ENTANGLING_ROOTS","MASS_ENTANGLEMENT_TALENT","OVERGROWTH_TALENT","CoreAbilities","CooldownThroughputTracker","CoreCooldownThroughputTracker","cooldownSpells","summary","BUILT_IN_SUMMARY_TYPES","HEALING","OVERHEALING","MANA","Ironbark","ironbarkCount","damageTakenDuringIronbark","loadDamageTakenDuringIronbark","fetchWcl","report","code","start","end","end_time","then","json","damageTaken","catch","err","damageReduced","PrematureRejuvenations","totalRejuvsCasts","earlyRefreshments","timeLost","GERMINATION_TALENT","e","oldRejuv","find","pandemicTimestamp","pandemicTime","REJUV_DURATION","o","timeLostThreshold","timeLostInSeconds","CenarionWard","hasCenarionWard","directHealing","masteryHealing","Flourish","flourishCount","flourishes","wgsExtended","cwsExtended","tranqsExtended","rejuvCount","wgCount","lbCount","regrowthCount","sbCount","cultCount","tranqCount","groveTendingCount","increasedRateTotalHealing","increasedRateRejuvenationHealing","increasedRateWildGrowthHealing","increasedRateCenarionWardHealing","increasedRateCultivationHealing","increasedRateLifebloomHealing","increasedRateRegrowthHealing","increasedRateTranqHealing","increasedRateGroveTendingHealing","acc","flourish","healing","totalExtensionHealing","percentWgsExtended","percentCwsExtended","error","newFlourish","procs","foundWg","foundCw","foundTranq","keys","spellIdString","attribution","addExtension","wildGrowthSuggestionThresholds","cenarionWardSuggestionThresholds","extendPercent","increasedRatePercent","cenarionWard","regrowth","traquility","groveTending","dropdown","className","index","key","scope","SoulOfTheForest","proccs","proccConsumed","rejuvenationProccTimestamp","regrowthProccTimestamp","wildGrowthProccTimestamp","regrowthHealing","rejuvenationHealing","wildGrowthHealing","rejuvenationTargets","wildGrowthTargets","rejuvenationDuration","SOUL_OF_THE_FOREST_TALENT_RESTORATION","wgUsagePercent","SOUL_OF_THE_FOREST_BUFF","wgPercent","rejuvPercent","regrowthPercent","Photosynthesis","lifebloomIncrease","lastRealBloomTimestamp","increasedRateSpringBlossomsHealing","increasedRateEffloHealing","randomProccs","naturalProccs","PHOTOSYNTHESIS_TALENT","onLifebloomProc","_combatantInfo","selfUptime","totalUptime","players","player","Abundance","manaSavings","critGains","ABUNDANCE_TALENT","manaCasts","avgManaSavingsPercent","avgCritGains","avgStacks","avgManaSaings","StatWeights","spellInfo","qeLive","done","critChanceBreakdown","baseCritChance","bonusFromOneCrit","currentHasteRating","CRITICAL_STRIKE","critMult","critEffectBonus","getBonus","hitType","HIT_TYPES","CRIT","bonusFromOneMastery","INTELLECT","HASTE_HPCT","HASTE_HPM","VERSATILITY","VERSATILITY_DR","totalOneHasteHpct","totalOneHasteHpm","BaseHealerStatValues","CritEffectBonus","RestoDruidHealingEfficiencyTracker","getRegrowthDetails","regrowthAttributor","overhealingDone","healingAbsorbed","clearcasting","hits","HealingEfficiencyTracker","manaTracker","ManaTracker","damageDone","DamageDone","abilities","FlashOfClarity","healingBoost","targetsWithClearCastingRegrowth","checkIfClearCasting","normalizeBoost","STATISTIC_CATEGORY","COVENANTS","BoringSpellValueText","FLASH_OF_CLARITY","ItemHealingDone","CombatLogParser","CoreCombatLogParser","abilitiesAffectedByHealingIncreases","specModules","wildGrowthNormalizer","WildGrowthNormalizer","clearcastingNormalizer","hotApplicationNormalizer","treeOfLifeNormalizer","spellManaCost","manaLevelChart","ManaLevelChart","manaUsageChart","ManaUsageChart","checklist","rejuvenationAttributor","lowHealthHealing","LowHealthHealing","averageHots","cooldownThroughputTracker","ironbark","prematureRejuvenations","soulOfTheForest","photosynthesis","statWeights","hpmDetails","HealingEfficiencyDetails","hpmTracker","flashOfClarity","children","Icon","other","xmlns","viewBox","d","BoringValue","relativeHealIncrease","ResourceTracker","eventEmitter","current","resourceUpdates","buildersObj","spendersObj","resource","maxResource","energize","onEnergize","generated","wasted","spent","spentByCast","resourceChangeType","waste","gain","resourceChange","_applyBuilder","getResource","maxGain","undefined","initBuilderAbility","used","shouldProcessCastEvent","eventResource","getReducedCost","initSpenderAbility","triggerSpendEvent","resourceCost","r","fabricatedEvent","SpendResource","__fabricated","fabricateEvent","Boolean","EventEmitter","defineProperty","exports","value","_typeof","Symbol","iterator","obj","constructor","prototype","_extends","assign","i","arguments","source","hasOwnProperty","call","_createClass","defineProperties","descriptor","enumerable","configurable","writable","Constructor","protoProps","staticProps","_react2","_interopRequireDefault","require","_propTypes2","_classnames2","__esModule","default","_defineProperty","ANIMATION_STATE_CLASSES","animating","animatingUp","animatingDown","animatingToHeightZero","animatingToHeightAuto","animatingToHeightSpecific","staticHeightZero","staticHeightAuto","staticHeightSpecific","PROPS_TO_OMIT","omit","_len","Array","_key","res","objectKeys","indexOf","cancelAnimationFrames","requestAnimationFrameIDs","cancelAnimationFrame","isNumber","n","isNaN","parseFloat","isFinite","isPercentage","height","search","substr","runCallback","callback","params","AnimateHeight","_React$Component","instance","TypeError","_classCallCheck","_this","self","ReferenceError","_possibleConstructorReturn","__proto__","getPrototypeOf","animationFrameIDs","overflow","animationStateClasses","getStaticStateClasses","state","shouldUseTransitions","subClass","superClass","create","setPrototypeOf","_inherits","contentElement","hideContent","prevProps","prevState","_this2","_props","delay","onAnimationEnd","onAnimationStart","_cx","showContent","contentHeight","offsetHeight","totalDuration","newHeight","timeoutState","isCurrentHeightAuto","timeoutAnimationStateClasses","setState","clearTimeout","timeoutID","animationClassesTimeoutID","requestAnimationFrame","startAnimationHelper","setTimeout","display","_cx2","_cx3","_this3","_props2","animateOpacity","applyInlineTransitions","contentClassName","easing","_state","componentStyle","transition","WebkitTransition","contentStyle","opacity","componentClasses","ariaHidden","createElement","apply","ref","el","propTypes","bool","object","any","isRequired","string","number","propName","componentName","func","defaultProps","RESOURCE_TYPES","healingSpellIds","healingHits","damageHits","damageAbsorbed","manaSpent","manaGained","percentOverhealingDone","percentHealingDone","percentDamageDone","manaPercentSpent","hpm","dpm","timeSpentCasting","percentTimeSpentCasting","hpet","dpet","healingEffective","healingOverheal","healingSpellId","healingAbility","damageEffective","spenders","getCustomSpellStats","regular","getTimeSpentCasting","gcdSpent","includeCooldowns","spells","topHpm","topDpm","topHpet","topDpet","getSpellStats","PerformanceBar","percent","width","backgroundColor","colorForPerformance","module","HealingEfficiencyBreakdown","HealingEfficiencyTable","tracker","getAllSpellStats","showCooldowns","spellArray","sort","showHealing","spellRows","spellDetail","HealingEfficiencySpellRow","detailedView","DetailView","BarView","BarHeader","render","colSpan","content","hasHealing","hasDamage","barWidth","DetailHeader","hasOverhealing","floor","formatDuration","marginRight","defaultChecked","icons","onChange","checked","htmlFor","marginLeft","React","StatisticWrapper","multiplier","HEALTHSTONE","MARK_OF_THE_ANCIENT_PRIESTESS","fallbackSpellInfo","sharedSpellInfo","CORE_SPELL_INFO","mentioned","totalAdjustedHealing","totalOneInt","totalOneCrit","totalOneMastery","totalOneVers","totalOneVersDr","totalOneLeech","playerHealthMissing","scaleWeightsWithHealth","moreInformationLink","SELECTED_PLAYER_PET","onAbsorb","onHealTaken","damage","onDamageTaken","specSpecific","shared","_handleHealEvent","absorb","_getSpellInfo","targetHealthPercentage","_handleHeal","eventForWeights","_adjustGain","_leech","_intellect","_criticalStrike","_hasteHpct","_hasteHpm","_mastery","_versatility","mult","currentLeechPercentage","_leechHasLeech","_leechPrediction","currentLeechRating","toPlayer","healIncreaseFromOneLeech","statMultiplier","leech","healIncreaseFromOneInt","intellect","currentIntellectRating","rating","currentCritRating","baseCritPercentage","ratingCritChance","_isCrit","_getCritChance","totalCritChance","ratingCritChanceContribution","rawBaseHealing","effectiveCritHealing","currHastePerc","currentHastePercentage","healIncreaseFromOneHaste","HASTE","Error","currVersPerc","currentVersatilityPercentage","healIncreaseFromOneVers","versatility","currentVersatilityRating","_updateMissingHealth","damageVal","DamageValue","blocked","overkill","_versatilityDamageReduction","baseStats","itemLevel","hps","primary","calculatePrimaryStat","hpsPerIntellect","criticalStrike","calculateSecondaryStatDefault","hpsPerCriticalStrike","hpsPerHaste","hpsPerMastery","hpsPerVersatility","hpsPerLeech","oneRatingHealing","stat","results","_prepareResults","urlParts","statValue","weight","_getGain","statName","getName","replace","join","href","rel","Tooltip","data-place","Info","padding","margin","minWidth","fontWeight","row","_getTooltip","ratingForOne","_ratingPerOnePercent","getIcon","gainPerSecond","Infinity","informationIconTooltip","getClassNameColor","getNameTranslated","Information","hpsPerHasteHPCT","hpsPerHasteHPM","healingEfficiencyTracker","title","bouncingHots","currentGuid","hotHistory","hotInfo","_generateHotInfo","hotList","_generateHotList","hotApplied","hotHeal","hotReapplied","hotRemoved","_getTarget","_validateHot","bouncy","shift","hotDuration","durationConditions","maxDuration","newHot","originalEnd","ticks","attributions","extensions","boosts","healingAfterOriginalEnd","hot","boost","effectOnCrit","oldEnd","freshDuration","_calculateExtension","clipped","ext","_tallyExtensions","_checkRemovalTime","tickClamps","pandemicClamps","timeOut","timeLeft","timeToAdd","finalAmount","existingExtension","extension","_tallyExtension","now","foundEarlier","latestOutside","scale","rawAmount","currentTimeRemaining","newTimeRemaining","pandemicMax","currentTickPeriod","newTicksRemaining","diff","RefreshBuff","Haste"],"mappings":"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","file":"static/js/RestorationDruid.3b877ff5.chunk.js","sourcesContent":["import SPELLS from 'common/SPELLS';\r\n\r\nimport EventsNormalizer from 'parser/core/EventsNormalizer';\r\nimport { EventType } from 'parser/core/Events';\r\n\r\nconst MS_BUFFER=100;\r\nclass WildGrowth extends EventsNormalizer {\r\n  /**\r\n   * when you cast WG and you yourself are one of the targets the applybuff event will be in the events log before the cast event\r\n   * this can make parsing certain things rather hard, so we need to swap them\r\n   * @param events\r\n   * @returns {Array}\r\n   */\r\n  normalize(events) {\r\n    let _events = [];\r\n    let _newEvents = [];\r\n\r\n    events.forEach((event, idx) => {\r\n      _events.push(event);\r\n\r\n      // for WG cast events we look backwards through the events and any applybuff events we push forward\r\n      if (event.type === EventType.Cast && event.ability.guid === SPELLS.WILD_GROWTH.id) {\r\n        for (let _idx = idx - 1; _idx >= 0; _idx -= 1) {\r\n          const _event = _events[_idx];\r\n\r\n          if (Math.abs(_event.timestamp - event.timestamp) > MS_BUFFER) {\r\n            _newEvents.reverse();\r\n            _events = _events.concat(_newEvents);\r\n            _newEvents = [];\r\n            break;\r\n          }\r\n\r\n          if (_event.type === EventType.ApplyBuff && _event.ability.guid === SPELLS.WILD_GROWTH.id && _event.targetID === this.owner.playerId) {\r\n            _events.splice(_idx, 1);\r\n            _newEvents.push(_event);\r\n          }\r\n        }\r\n\r\n        if (_newEvents.length) {\r\n          _newEvents.reverse();\r\n          _events = _events.concat(_newEvents);\r\n          _newEvents = [];\r\n        }\r\n      }\r\n\r\n      if (event.type === EventType.Cast && event.ability.guid === SPELLS.REJUVENATION.id) {\r\n        for (let _idx = idx - 1; _idx >= 0; _idx -= 1) {\r\n          const _event = _events[_idx];\r\n\r\n          if (_event.timestamp !== event.timestamp) {\r\n            _newEvents.reverse();\r\n            _events = _events.concat(_newEvents);\r\n            _newEvents = [];\r\n            break;\r\n          }\r\n\r\n          if (_event.type === EventType.ApplyBuff\r\n            && [SPELLS.REJUVENATION.id, SPELLS.REJUVENATION_GERMINATION.id].includes(_event.ability.guid)\r\n            && _event.targetID === event.targetID) {\r\n            _events.splice(_idx, 1);\r\n            _newEvents.push(_event);\r\n          }\r\n        }\r\n\r\n        if (_newEvents.length) {\r\n          _newEvents.reverse();\r\n          _events = _events.concat(_newEvents);\r\n          _newEvents = [];\r\n        }\r\n      }\r\n      // for WG apply buff events we look backwards through the events and any events of flourish we push forward\r\n      if (event.type === EventType.ApplyBuff && event.ability.guid === SPELLS.WILD_GROWTH.id) {\r\n        for (let _idx = idx - 1; _idx >= 0; _idx -= 1) {\r\n          const _event = _events[_idx];\r\n\r\n          if (Math.abs(_event.timestamp - event.timestamp) > MS_BUFFER) {\r\n            _newEvents.reverse();\r\n            _events = _events.concat(_newEvents);\r\n            _newEvents = [];\r\n            break;\r\n          }\r\n\r\n          if ((_event.type === EventType.ApplyBuff || _event.type === EventType.Cast) && _event.ability.guid === SPELLS.FLOURISH_TALENT.id) {\r\n            _events.splice(_idx, 1);\r\n            _newEvents.push(_event);\r\n          }\r\n        }\r\n\r\n        if (_newEvents.length) {\r\n          _newEvents.reverse();\r\n          _events = _events.concat(_newEvents);\r\n          _newEvents = [];\r\n        }\r\n      }\r\n    });\r\n\r\n    return _events;\r\n  }\r\n}\r\n\r\nexport default WildGrowth;\r\n","import EventsNormalizer from 'parser/core/EventsNormalizer';\r\n\r\nimport SPELLS from 'common/SPELLS';\r\nimport { EventType } from 'parser/core/Events';\r\n\r\nconst MAX_DELAY = 50;\r\n\r\n// Clearcasting buff fades before the regrowth cast event that consumed it shows up.\r\n// This swaps the order so the buff always fades AFTER the regrowth cast event.\r\nclass ClearcastingNormalizer extends EventsNormalizer {\r\n\r\n  normalize(events) {\r\n    const fixedEvents = [];\r\n    events.forEach((event, eventIndex) => {\r\n      fixedEvents.push(event);\r\n\r\n      if (event.type === EventType.Cast && event.ability.guid === SPELLS.REGROWTH.id) {\r\n        const castTimestamp = event.timestamp;\r\n\r\n        // Loop through the event history in reverse to detect if there was a clearcast remove event that was the result of this cast\r\n        for (let previousEventIndex = eventIndex; previousEventIndex >= 0; previousEventIndex -= 1) {\r\n          const previousEvent = fixedEvents[previousEventIndex];\r\n          if ((castTimestamp - previousEvent.timestamp) > MAX_DELAY) {\r\n            break;\r\n          }\r\n          if (previousEvent.type === EventType.RemoveBuff && previousEvent.ability.guid === SPELLS.CLEARCASTING_BUFF.id && previousEvent.sourceID === event.sourceID) {\r\n            fixedEvents.splice(previousEventIndex, 1);\r\n            fixedEvents.push(previousEvent);\r\n            previousEvent.__modified = true;\r\n            break;\r\n          }\r\n        }\r\n      }\r\n    });\r\n\r\n    return fixedEvents;\r\n  }\r\n\r\n}\r\nexport default ClearcastingNormalizer;\r\n","import EventsNormalizer from 'parser/core/EventsNormalizer';\r\n\r\nimport SPELLS from 'common/SPELLS';\r\nimport { EventType } from 'parser/core/Events';\r\n\r\n// so far I haven't seen any delay, so leaving this at zero so timestamp ordering is preserved,\r\n// and to avoid false positives if HoT falls and then quickly refreshed\r\nconst MAX_DELAY = 0;\r\n\r\n// Occasionally HoT heal has same timestamp but happens before the applybuff event, which causes issues when attempting to attribute the heal.\r\n// This normalizes the heal to always be after the applybuff\r\nclass HotApplicationNormalizer extends EventsNormalizer {\r\n\r\n  // This ordering issue only happens for the HoTs that tick instantly upon application\r\n  instantTickHotIds = [\r\n    SPELLS.REJUVENATION.id,\r\n    SPELLS.REJUVENATION_GERMINATION.id,\r\n    SPELLS.REGROWTH.id,\r\n    SPELLS.WILD_GROWTH.id,\r\n    //TODO - blazyb\r\n  ];\r\n\r\n  normalize(events) {\r\n    const fixedEvents = [];\r\n    events.forEach((event, eventIndex) => {\r\n      fixedEvents.push(event);\r\n\r\n      if (event.type === EventType.ApplyBuff && this.instantTickHotIds.includes(event.ability.guid)) {\r\n        const spellId = event.ability.guid;\r\n        const castTimestamp = event.timestamp;\r\n        if (!event.targetID) {\r\n          return;\r\n        }\r\n\r\n        // Loop through the event history in reverse to detect if there was a heal from same spell on same target\r\n        for (let previousEventIndex = eventIndex; previousEventIndex >= 0; previousEventIndex -= 1) {\r\n          const previousEvent = fixedEvents[previousEventIndex];\r\n          if ((castTimestamp - previousEvent.timestamp) > MAX_DELAY) {\r\n            break;\r\n          }\r\n          if (previousEvent.type === EventType.Heal && previousEvent.ability.guid === spellId && previousEvent.targetID === event.targetID) {\r\n            fixedEvents.splice(previousEventIndex, 1);\r\n            fixedEvents.push(previousEvent);\r\n            previousEvent.__modified = true;\r\n            break;\r\n          }\r\n        }\r\n      }\r\n    });\r\n\r\n    return fixedEvents;\r\n  }\r\n\r\n}\r\nexport default HotApplicationNormalizer;\r\n","import EventsNormalizer from 'parser/core/EventsNormalizer';\r\n\r\nimport SPELLS from 'common/SPELLS';\r\nimport { EventType } from 'parser/core/Events';\r\n\r\nconst MAX_DELAY = 200;\r\n\r\n/*\r\n * The Incarnation: Tree of Life talent can show strangely in events.\r\n * a 'cast' with INCARNATION_TREE_OF_LIFE_TALENT id shows up on activating the talent, BUT ALSO ON REAQUIRING THE FORM DURING THE BUFF.\r\n * This can casue Incarnation cast events to show up in places we don't expect, and can throw off tracking and cast efficiency.\r\n *\r\n * Incarnation produces two buffs. The INCARNATION_TREE_OF_LIFE_TALENT id buff tracks if the player is in Incarnation form (as opposed to the other druid forms)\r\n * The INCARNATION_TOL_ALLOWED id buff tracks if the player is ALLOWED to assume Incarnation form, this is applied both by the talent and the legendary.\r\n * We can discern real casts from form reassumption by checking for proximity to application of INCARNATION_TOL_ALLOWED.\r\n * Casts that happen just before application of INCARNATION_TOL_ALLOWED are real, all others are form reassumption.\r\n *\r\n * This Normalizer deletes all the form reassumption events. Form can still be tracked using the INCARNATION_TREE_OF_LIFE_TALENT buff.\r\n */\r\nclass TreeOfLifeNormalizer extends EventsNormalizer {\r\n\r\n  normalize(events) {\r\n    const fixedEvents = [];\r\n    events.forEach((event, eventIndex) => {\r\n      fixedEvents.push(event);\r\n\r\n      if (event.type === EventType.Cast && event.ability.guid === SPELLS.INCARNATION_TREE_OF_LIFE_TALENT.id) {\r\n        const castTimestamp = event.timestamp;\r\n\r\n        // Look ahead through the events to see if there is an INCARNATION_TOL_ALLOWED application within a brief buffer period\r\n        for (let nextEventIndex = eventIndex; nextEventIndex < events.length-1; nextEventIndex += 1) {\r\n          const nextEvent = events[nextEventIndex];\r\n          if ((nextEvent.timestamp - castTimestamp) > MAX_DELAY) {\r\n            // No INCARNATION_TOL_ALLOWED application found within buffer, meaining this is a form reassumption: delete the event\r\n            fixedEvents.pop();\r\n            break;\r\n          } else if (nextEvent.type === EventType.ApplyBuff && nextEvent.ability.guid === SPELLS.INCARNATION_TOL_ALLOWED.id) {\r\n            // INCARNATION_TOL_ALLOWED application found, this cast event stays\r\n            break;\r\n          }\r\n        }\r\n      }\r\n    });\r\n\r\n    return fixedEvents;\r\n  }\r\n\r\n}\r\nexport default TreeOfLifeNormalizer;\r\n","import SPELLS from 'common/SPELLS';\r\nimport CoreAlwaysBeCastingHealing from 'parser/shared/modules/AlwaysBeCastingHealing';\r\n\r\nclass AlwaysBeCasting extends CoreAlwaysBeCastingHealing {\r\n  static HEALING_ABILITIES_ON_GCD = [\r\n    SPELLS.REJUVENATION.id,\r\n    SPELLS.REGROWTH.id,\r\n    SPELLS.WILD_GROWTH.id,\r\n    SPELLS.TRANQUILITY_CAST.id,\r\n    SPELLS.CENARION_WARD_TALENT.id,\r\n    SPELLS.LIFEBLOOM_HOT_HEAL.id,\r\n    SPELLS.SWIFTMEND.id,\r\n    SPELLS.FLOURISH_TALENT.id,\r\n    SPELLS.EFFLORESCENCE_CAST.id,\r\n    SPELLS.NATURES_CURE.id,\r\n  ];\r\n\r\n  get nonHealingTimeSuggestionThresholds() {\r\n    return {\r\n      actual: this.nonHealingTimePercentage,\r\n      isGreaterThan: {\r\n        minor: 0.3,\r\n        average: 0.4,\r\n        major: 0.8,\r\n      },\r\n      style: 'percentage',\r\n    };\r\n  }\r\n\r\n  get downtimeSuggestionThresholds() {\r\n    return {\r\n      actual: this.downtimePercentage,\r\n      isGreaterThan: {\r\n        minor: 0.2,\r\n        average: 0.3,\r\n        major: 0.5,\r\n      },\r\n      style: 'percentage',\r\n    };\r\n  }\r\n}\r\n\r\nexport default AlwaysBeCasting;\r\n","import React from 'react';\r\nimport { formatPercentage } from 'common/format';\r\nimport STATISTIC_ORDER from 'interface/others/STATISTIC_ORDER';\r\nimport Statistic from 'interface/statistics/Statistic';\r\nimport SpellLink from 'common/SpellLink';\r\nimport SpellIcon from 'common/SpellIcon';\r\nimport BoringValue from 'interface/statistics/components/BoringValueText';\r\n\r\nimport SPELLS from 'common/SPELLS';\r\nimport Analyzer, { SELECTED_PLAYER } from 'parser/core/Analyzer';\r\nimport Events from 'parser/core/Events';\r\nimport { i18n } from '@lingui/core';\r\nimport { t } from '@lingui/macro';\r\n\r\nconst debug = false;\r\nconst LOW_HEALTH_HEALING_THRESHOLD = 0.3;\r\nconst MS_BUFFER = 123;\r\nconst ABUNDANCE_EXCEPTION_STACKS = 4;\r\n\r\nclass Clearcasting extends Analyzer {\r\n\r\n  procsPerCC;\r\n\r\n  totalProcs = 0;\r\n  expiredProcs = 0;\r\n  overwrittenProcs = 0;\r\n  usedProcs = 0;\r\n\r\n  availableProcs = 0;\r\n\r\n  nonCCRegrowths = 0;\r\n  totalRegrowths = 0;\r\n  lowHealthRegrowthsNoCC = 0;\r\n  abundanceRegrowthsNoCC = 0;\r\n\r\n  constructor(...args) {\r\n    super(...args);\r\n    this.procsPerCC = 1;\r\n    this.addEventListener(Events.applybuff.by(SELECTED_PLAYER).spell(SPELLS.CLEARCASTING_BUFF), this.onApplyBuff);\r\n    this.addEventListener(Events.refreshbuff.by(SELECTED_PLAYER).spell(SPELLS.CLEARCASTING_BUFF), this.onRefreshBuff);\r\n    this.addEventListener(Events.removebuff.by(SELECTED_PLAYER).spell(SPELLS.CLEARCASTING_BUFF), this.onRemoveBuff);\r\n    this.addEventListener(Events.cast.by(SELECTED_PLAYER).spell(SPELLS.REGROWTH), this.onCast);\r\n    this.addEventListener(Events.heal.by(SELECTED_PLAYER).spell(SPELLS.REGROWTH), this.onHeal);\r\n  }\r\n\r\n  onApplyBuff(event) {\r\n    debug && console.log(`Clearcasting applied @${this.owner.formatTimestamp(event.timestamp)} - ${this.procsPerCC} procs remaining`);\r\n    this.totalProcs += this.procsPerCC;\r\n    this.availableProcs = this.procsPerCC;\r\n  }\r\n\r\n  onRefreshBuff(event) {\r\n    debug && console.log(`Clearcasting refreshed @${this.owner.formatTimestamp(event.timestamp)} - overwriting ${this.availableProcs} procs - ${this.procsPerCC} procs remaining`);\r\n    this.totalProcs += this.procsPerCC;\r\n    this.overwrittenProcs += this.availableProcs;\r\n    this.availableProcs = this.procsPerCC;\r\n  }\r\n\r\n  onRemoveBuff(event) {\r\n    debug && console.log(`Clearcasting expired @${this.owner.formatTimestamp(event.timestamp)} - ${this.availableProcs} procs expired`);\r\n    if (this.availableProcs < 0) {\r\n      this.availableProcs = 0;\r\n    }\r\n    this.expiredProcs += this.availableProcs;\r\n    this.availableProcs = 0;\r\n  }\r\n\r\n  onCast(event) {\r\n    if (this.selectedCombatant.hasBuff(SPELLS.INNERVATE.id)) {\r\n      return;\r\n    }\r\n\r\n    this.totalRegrowths += 1;\r\n\r\n    if (this.selectedCombatant.hasBuff(SPELLS.CLEARCASTING_BUFF.id)) {\r\n      this.availableProcs -= 1;\r\n      this.usedProcs += 1;\r\n      debug && console.log(`Regrowth w/CC cast @${this.owner.formatTimestamp(event.timestamp)} - ${this.availableProcs} procs remaining`);\r\n    } else {\r\n      this.nonCCRegrowths += 1;\r\n      const abundance = this.selectedCombatant.getBuff(SPELLS.ABUNDANCE_BUFF.id);\r\n      if (abundance) {\r\n        this.abundanceRegrowthsNoCC += abundance.stacks >= ABUNDANCE_EXCEPTION_STACKS;\r\n      }\r\n    }\r\n  }\r\n\r\n  onHeal(event) {\r\n    if (event.tick) {\r\n      return;\r\n    }\r\n    const effectiveHealing = event.amount + (event.absorbed || 0);\r\n    const hitPointsBeforeHeal = event.hitPoints - effectiveHealing;\r\n    const healthPercentage = hitPointsBeforeHeal / event.maxHitPoints;\r\n    if (healthPercentage < LOW_HEALTH_HEALING_THRESHOLD && !this.selectedCombatant.hasBuff(SPELLS.CLEARCASTING_BUFF.id, event.timestamp, MS_BUFFER)) {\r\n      this.lowHealthRegrowthsNoCC += 1;\r\n    }\r\n  }\r\n\r\n  get wastedProcs() {\r\n    return this.expiredProcs + this.overwrittenProcs;\r\n  }\r\n\r\n  get clearcastingUtilPercent() {\r\n    const util = this.usedProcs / this.totalProcs;\r\n    return (util > 1) ? 1 : util;\r\n  }\r\n\r\n  get hadInvisibleRefresh() {\r\n    return this.usedProcs > this.totalProcs;\r\n  }\r\n\r\n  get clearcastingUtilSuggestionThresholds() {\r\n    return {\r\n      actual: this.clearcastingUtilPercent,\r\n      isLessThan: {\r\n        minor: 0.90,\r\n        average: 0.50,\r\n        major: 0.25,\r\n      },\r\n      style: 'percentage',\r\n    };\r\n  }\r\n\r\n  get nonCCRegrowthsPerMinute() {\r\n    return (this.nonCCRegrowths - (this.lowHealthRegrowthsNoCC + this.abundanceRegrowthsNoCC)) / (this.owner.fightDuration / 60000);\r\n  }\r\n\r\n  get nonCCRegrowthsSuggestionThresholds() {\r\n    return {\r\n      actual: this.nonCCRegrowthsPerMinute,\r\n      isGreaterThan: {\r\n        minor: 0,\r\n        average: 1,\r\n        major: 3,\r\n      },\r\n      style: 'number',\r\n    };\r\n  }\r\n\r\n  suggestions(when) {\r\n    when(this.clearcastingUtilSuggestionThresholds)\r\n      .addSuggestion((suggest, actual, recommended) => suggest(<>Your <SpellLink id={SPELLS.CLEARCASTING_BUFF.id} /> procs should be used quickly so they do not get overwritten or expire.</>)\r\n          .icon(SPELLS.CLEARCASTING_BUFF.icon)\r\n          .actual(i18n._(t('druid.restoration.suggestions.clearcasting.wastedProcs')`You missed ${this.wastedProcs} out of ${this.totalProcs} (${formatPercentage(1 - this.clearcastingUtilPercent, 1)}%) of your free regrowth procs`))\r\n          .recommended(`<${Math.round(formatPercentage(1 - recommended, 1))}% is recommended`));\r\n    when(this.nonCCRegrowthsSuggestionThresholds)\r\n      .addSuggestion((suggest, actual, recommended) => suggest(<><SpellLink id={SPELLS.REGROWTH.id} /> is a very inefficient spell to cast without a <SpellLink id={SPELLS.CLEARCASTING_BUFF.id} /> proc. It should only be cast when your target is about to die and you do not have <SpellLink id={SPELLS.SWIFTMEND.id} /> available.</>)\r\n          .icon(SPELLS.REGROWTH.icon)\r\n          .actual(i18n._(t('druid.restoration.suggestions.clearcasting.efficiency')`You cast ${this.nonCCRegrowthsPerMinute.toFixed(1)} Regrowths per minute without a Clearcasting proc.`))\r\n          .recommended(`${recommended.toFixed(1)} CPM is recommended`));\r\n  }\r\n\r\n  statistic() {\r\n    return (\r\n      <Statistic\r\n        size=\"flexible\"\r\n        position={STATISTIC_ORDER.CORE(20)}\r\n        tooltip={(\r\n          <>\r\n            Clearcasting procced <strong>{this.totalProcs} free Regrowths</strong>\r\n            <ul>\r\n              <li>Used: <strong>{this.usedProcs} {this.hadInvisibleRefresh ? '*' : ''}</strong></li>\r\n              {this.hadInvisibleRefresh && <li>Overwritten: <strong>{this.overwrittenProcs}</strong></li>}\r\n              <li>Expired: <strong>{this.expiredProcs}</strong></li>\r\n            </ul>\r\n            <strong>{this.nonCCRegrowths} of your Regrowths were cast without a Clearcasting proc.</strong>\r\n            <strong>{this.lowHealthRegrowthsNoCC}</strong> of these were cast on targets with low health and\r\n            <strong>{this.abundanceRegrowthsNoCC}</strong> of these were cast with more than {ABUNDANCE_EXCEPTION_STACKS} stacks of abundance, so they have been disregarded as bad Regrowth(s).\r\n            Using a clearcasting proc as soon as you get it should be one of your top priorities.\r\n            Even if it overheals you still get that extra mastery stack on a target and the minor HoT.\r\n            Spending your GCD on a free spell also helps with mana management in the long run.<br />\r\n            {this.hadInvisibleRefresh && <em>* Mark of Clarity can sometimes 'invisibly refresh', which can make your total procs show as lower than you actually got. Basically, you invisibly overwrote some number of procs, but we aren't able to see how many.</em>}\r\n          </>\r\n        )}\r\n      >\r\n        <BoringValue label={<><SpellIcon id={SPELLS.CLEARCASTING_BUFF.id} /> Clearcasting Util</>} >\r\n          <>\r\n            {formatPercentage(this.clearcastingUtilPercent, 1)} %\r\n          </>\r\n        </BoringValue>\r\n      </Statistic>\r\n    );\r\n  }\r\n\r\n}\r\n\r\nexport default Clearcasting;\r\n","import React from 'react';\r\nimport { formatPercentage } from 'common/format';\r\nimport STATISTIC_ORDER from 'interface/others/STATISTIC_ORDER';\r\nimport UptimeIcon from 'interface/icons/Uptime';\r\nimport Statistic from 'interface/statistics/Statistic';\r\nimport SpellLink from 'common/SpellLink';\r\nimport ItemLink from 'common/ItemLink';\r\nimport SpellIcon from 'common/SpellIcon';\r\nimport BoringValue from 'interface/statistics/components/BoringValueText';\r\n\r\nimport SPELLS from 'common/SPELLS';\r\nimport ITEMS from 'common/ITEMS';\r\nimport Analyzer from 'parser/core/Analyzer';\r\nimport Combatants from 'parser/shared/modules/Combatants';\r\nimport { i18n } from '@lingui/core';\r\nimport { t } from '@lingui/macro';\r\n\r\nclass Lifebloom extends Analyzer {\r\n  get uptime() {\r\n    return this.combatants.getBuffUptime(SPELLS.LIFEBLOOM_HOT_HEAL.id);\r\n  }\r\n\r\n  get uptimePercent() {\r\n    return this.uptime / this.owner.fightDuration;\r\n  }\r\n\r\n  // \"The Dark Titan's Advice\" legendary buffs Lifebloom, making high uptime more important\r\n  get suggestionThresholds() {\r\n    return {\r\n      actual: this.uptimePercent,\r\n      isLessThan: {\r\n        minor: 0.80,\r\n        average: 0.60,\r\n        major: 0.40,\r\n      },\r\n      style: 'percentage',\r\n    };\r\n  }\r\n\r\n  static dependencies = {\r\n    combatants: Combatants,\r\n  };\r\n\r\n  suggestions(when) {\r\n    when(this.suggestionThresholds)\r\n      .addSuggestion((suggest, actual, recommended) => suggest(<>Your <SpellLink id={SPELLS.LIFEBLOOM_HOT_HEAL.id} /> uptime can be improved. {this.hasDta ? <>High uptime is particularly important for taking advantage of your equipped <ItemLink id={ITEMS.THE_DARK_TITANS_ADVICE.id} /></> : ''}</>)\r\n        .icon(SPELLS.LIFEBLOOM_HOT_HEAL.icon)\r\n        .actual(i18n._(t('druid.restoration.suggestions.lifebloom.uptime')`${formatPercentage(this.uptimePercent)}% uptime`))\r\n        .recommended(`>${Math.round(formatPercentage(recommended))}% is recommended`));\r\n  }\r\n\r\n  statistic() {\r\n    return (\r\n      <Statistic\r\n        size=\"flexible\"\r\n        position={STATISTIC_ORDER.CORE(10)}\r\n      >\r\n        <BoringValue label={<><SpellIcon id={SPELLS.LIFEBLOOM_HOT_HEAL.id} /> Lifebloom Uptime</>}>\r\n          <>\r\n            <UptimeIcon /> {formatPercentage(this.uptimePercent)} %\r\n          </>\r\n        </BoringValue>\r\n      </Statistic>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Lifebloom;\r\n","import React from 'react';\r\nimport { formatPercentage } from 'common/format';\r\nimport STATISTIC_ORDER from 'interface/others/STATISTIC_ORDER';\r\nimport UptimeIcon from 'interface/icons/Uptime';\r\nimport Statistic from 'interface/statistics/Statistic';\r\nimport SpellLink from 'common/SpellLink';\r\nimport SpellIcon from 'common/SpellIcon';\r\nimport BoringValue from 'interface/statistics/components/BoringValueText';\r\n\r\nimport SPELLS from 'common/SPELLS';\r\nimport Analyzer, { SELECTED_PLAYER } from 'parser/core/Analyzer';\r\nimport Events from 'parser/core/Events';\r\nimport { i18n } from '@lingui/core';\r\nimport { t } from '@lingui/macro';\r\n\r\nconst DURATION = 30000;\r\n\r\nclass Efflorescence extends Analyzer {\r\n  precastUptime = 0;\r\n  castUptime = 0;\r\n  castTimestamps = []; // TODO this array not really used yet, but I plan to use it to catch early refreshes\r\n\r\n  constructor(options) {\r\n    super(options);\r\n    this.addEventListener(Events.cast.by(SELECTED_PLAYER).spell(SPELLS.EFFLORESCENCE_CAST), this.onCast);\r\n    this.addEventListener(Events.heal.by(SELECTED_PLAYER).spell(SPELLS.EFFLORESCENCE_HEAL), this.onHeal);\r\n  }\r\n\r\n  onCast(event) {\r\n    if (this.lastCastTimestamp !== null) {\r\n      this.castUptime += Math.min(DURATION, event.timestamp - this.lastCastTimestamp);\r\n    }\r\n    this.castTimestamps.push(event.timestamp);\r\n  }\r\n\r\n  onHeal(event) {\r\n    // if efflo heals before the first cast, we assume it was from a precast\r\n    if (this.castTimestamps.length === 0) {\r\n      this.precastUptime = event.timestamp - this.owner.fight.start_time;\r\n    }\r\n  }\r\n\r\n  get lastCastTimestamp() {\r\n    return this.castTimestamps.length === 0 ? null : this.castTimestamps[this.castTimestamps.length - 1];\r\n  }\r\n\r\n  get uptime() {\r\n    // uptime from a cast is only tallied in 'castUptime' on the *next* cast, so the most recent cast must be handled special\r\n    const activeUptime = this.lastCastTimestamp === null ? 0 : Math.min(DURATION, this.owner.currentTimestamp - this.lastCastTimestamp);\r\n    return this.precastUptime + this.castUptime + activeUptime;\r\n  }\r\n\r\n  get uptimePercent() {\r\n    return this.uptime / this.owner.fightDuration;\r\n  }\r\n\r\n  get suggestionThresholds() {\r\n    return {\r\n      actual: this.uptimePercent,\r\n      isLessThan: {\r\n        minor: 0.90,\r\n        average: 0.50,\r\n        major: 0.25,\r\n      },\r\n      style: 'percentage',\r\n    };\r\n  }\r\n\r\n  suggestions(when) {\r\n    when(this.suggestionThresholds)\r\n      .addSuggestion((suggest, actual, recommended) => suggest(<span>Your <SpellLink id={SPELLS.EFFLORESCENCE_CAST.id} /> uptime can be improved.</span>)\r\n          .icon(SPELLS.EFFLORESCENCE_CAST.icon)\r\n          .actual(i18n._(t('druid.restoration.efflorescence.uptime')`${formatPercentage(this.uptimePercent)}% uptime`))\r\n          .recommended(`>${Math.round(formatPercentage(recommended))}% is recommended`));\r\n\r\n    // TODO suggestion for early refreshes\r\n  }\r\n\r\n  statistic() {\r\n    return (\r\n      <Statistic\r\n        position={STATISTIC_ORDER.CORE(12)}\r\n        size=\"flexible\"\r\n      >\r\n        <BoringValue label={<><SpellIcon id={SPELLS.EFFLORESCENCE_CAST.id} /> Efflorescence uptime</>} >\r\n          <>\r\n            <UptimeIcon /> {formatPercentage(this.uptimePercent)} %\r\n          </>\r\n        </BoringValue>\r\n      </Statistic>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Efflorescence;\r\n","import React from 'react';\r\nimport { formatNumber } from 'common/format';\r\nimport STATISTIC_ORDER from 'interface/others/STATISTIC_ORDER';\r\nimport Statistic from 'interface/statistics/Statistic';\r\nimport SpellLink from 'common/SpellLink';\r\nimport SpellIcon from 'common/SpellIcon';\r\nimport BoringValue from 'interface/statistics/components/BoringValueText';\r\n\r\nimport SPELLS from 'common/SPELLS';\r\nimport Analyzer, { SELECTED_PLAYER } from 'parser/core/Analyzer';\r\nimport Events from 'parser/core/Events';\r\nimport { i18n } from '@lingui/core';\r\nimport { t } from '@lingui/macro';\r\n\r\nconst debug = false;\r\nconst TOL_REJUVENATION_REDUCTION = 0.3;\r\n\r\nclass Innervate extends Analyzer {\r\n  get averageManaSaved() {\r\n    return (this.manaSaved / this.innervateCount) || 0;\r\n  }\r\n\r\n  get averageManaSavedSuggestionThresholds() {\r\n    return {\r\n      actual: this.averageManaSaved,\r\n      isLessThan: {\r\n        minor: 23000,\r\n        average: 19120,\r\n        major: 13200,\r\n      },\r\n      style: 'number',\r\n    };\r\n  }\r\n\r\n  get wholeSecondsCapped() {\r\n    return Math.round(this.secondsManaCapped);\r\n  }\r\n\r\n  get secondsCappedSuggestionThresholds() {\r\n    return {\r\n      actual: this.wholeSecondsCapped,\r\n      isGreaterThan: {\r\n        minor: 0,\r\n        average: 1,\r\n        major: 2,\r\n      },\r\n      style: 'number',\r\n    };\r\n  }\r\n\r\n  manaSaved = 0;\r\n  wildGrowths = 0;\r\n  efflorescences = 0;\r\n  cenarionWards = 0;\r\n  rejuvenations = 0;\r\n  regrowths = 0;\r\n  lifeblooms = 0;\r\n  swiftmends = 0;\r\n  tranquilities = 0;\r\n  freeRegrowths = 0;\r\n  innervateApplyTimestamp = null;\r\n  castsUnderInnervate = 0;\r\n  innervateCount = 0;\r\n  secondsManaCapped = 0;\r\n  lastInnervateTimestamp = 0;\r\n  depleted = false;\r\n\r\n  constructor(options) {\r\n    super(options);\r\n    this.addEventListener(Events.applybuff.to(SELECTED_PLAYER).spell(SPELLS.INNERVATE), this.onApplyBuff);\r\n    this.addEventListener(Events.removebuff.to(SELECTED_PLAYER).spell(SPELLS.INNERVATE), this.onRemoveBuff);\r\n    this.addEventListener(Events.cast.by(SELECTED_PLAYER), this.onCast);\r\n    this.addEventListener(Events.fightend, this.onFightend);\r\n  }\r\n\r\n  onApplyBuff(event) {\r\n    this.innervateCount += 1;\r\n    this.lastInnervateTimestamp = event.timestamp;\r\n  }\r\n\r\n  onRemoveBuff(event) {\r\n    this.depleted = false;\r\n  }\r\n\r\n  onCast(event) {\r\n    const spellId = event.ability.guid;\r\n\r\n    if (this.selectedCombatant.hasBuff(SPELLS.INNERVATE.id)) {\r\n      // Checking if the player is mana capped during an innervate.\r\n      // This is not 100% accuarate because we trigger the calculation on the first heal during an innervate.\r\n      // Realistically the seconds mana capped is higher.\r\n      if (event.classResources && event.classResources[0].amount === event.classResources[0].max && !this.depleted) {\r\n        this.secondsManaCapped = Math.abs(((this.lastInnervateTimestamp + 10000) - event.timestamp)) / 1000;\r\n        this.depleted = true;\r\n      }\r\n      if (SPELLS.REJUVENATION.id === spellId) {\r\n        if (this.selectedCombatant.hasBuff(SPELLS.INCARNATION_TREE_OF_LIFE_TALENT.id)) {\r\n          this.manaSaved += SPELLS.REJUVENATION.manaCost * (1 - TOL_REJUVENATION_REDUCTION);\r\n        } else {\r\n          this.manaSaved += SPELLS.REJUVENATION.manaCost;\r\n        }\r\n        this.castsUnderInnervate += 1;\r\n        this.rejuvenations += 1;\r\n      }\r\n      if (SPELLS.WILD_GROWTH.id === spellId) {\r\n        this.manaSaved += SPELLS.WILD_GROWTH.manaCost;\r\n        this.castsUnderInnervate += 1;\r\n        this.wildGrowths += 1;\r\n      }\r\n      if (SPELLS.EFFLORESCENCE_CAST.id === spellId) {\r\n        this.manaSaved += SPELLS.EFFLORESCENCE_CAST.manaCost;\r\n        this.castsUnderInnervate += 1;\r\n        this.efflorescences += 1;\r\n      }\r\n      if (SPELLS.CENARION_WARD_TALENT.id === spellId) {\r\n        this.manaSaved += SPELLS.CENARION_WARD_TALENT.manaCost;\r\n        this.castsUnderInnervate += 1;\r\n        this.cenarionWards += 1;\r\n      }\r\n      if (SPELLS.REGROWTH.id === spellId) {\r\n        if (this.selectedCombatant.hasBuff(SPELLS.CLEARCASTING_BUFF.id)) {\r\n          this.freeRegrowths += 1;\r\n        } else {\r\n          this.manaSaved += SPELLS.REGROWTH.manaCost;\r\n        }\r\n        this.castsUnderInnervate += 1;\r\n        this.regrowths += 1;\r\n      }\r\n      if (SPELLS.LIFEBLOOM_HOT_HEAL.id === spellId) {\r\n        this.manaSaved += SPELLS.LIFEBLOOM_HOT_HEAL.manaCost;\r\n        this.castsUnderInnervate += 1;\r\n        this.lifeblooms += 1;\r\n      }\r\n      if (SPELLS.SWIFTMEND.id === spellId) {\r\n        this.manaSaved += SPELLS.SWIFTMEND.manaCost;\r\n        this.castsUnderInnervate += 1;\r\n        this.swiftmends += 1;\r\n      }\r\n      if (SPELLS.TRANQUILITY_CAST.id === spellId) {\r\n        this.manaSaved += SPELLS.TRANQUILITY_CAST.manaCost;\r\n        this.castsUnderInnervate += 1;\r\n        this.tranquilities += 1;\r\n      }\r\n    }\r\n  }\r\n\r\n  onFightend() {\r\n    if (debug) {\r\n      console.log(`Innervates gained: ${this.innervateCount}`);\r\n      console.log(`Mana saved: ${this.manaSaved}`);\r\n      console.log(`Avg. Mana saved: ${this.manaSaved / this.innervateCount}`);\r\n      console.log(`Total Casts under innervate: ${this.castsUnderInnervate}`);\r\n      console.log(`Avg Casts under innervate: ${this.castsUnderInnervate / this.innervateCount}`);\r\n      console.log(`Free regrowths cast: ${this.freeRegrowths}`);\r\n      console.log(`WGs: ${this.wildGrowths}`);\r\n      console.log(`Efflos: ${this.efflorescences}`);\r\n      console.log(`CWs: ${this.cenarionWards}`);\r\n      console.log(`Rejvus: ${this.rejuvenations}`);\r\n      console.log(`Regrowth: ${this.regrowths}`);\r\n      console.log(`LBs: ${this.lifeblooms}`);\r\n      console.log(`SM: ${this.swiftmends}`);\r\n      console.log(`Tranq: ${this.tranquilities}`);\r\n      console.log(`Amount of seconds mana capped: ${this.secondsManaCapped}`);\r\n    }\r\n  }\r\n\r\n  suggestions(when) {\r\n    if (this.innervateCount === 0) {\r\n      return;\r\n    }\r\n\r\n    when(this.averageManaSavedSuggestionThresholds)\r\n      .addSuggestion((suggest, actual, recommended) => suggest(<>Your mana spent during an <SpellLink id={SPELLS.INNERVATE.id} /> can be improved.\r\n        Always aim to cast 1 wild growth, 1 efflorescence, and fill the rest with rejuvations for optimal usage.</>)\r\n        .icon(SPELLS.INNERVATE.icon)\r\n        .actual(i18n._(t('druid.restoration.suggestions.innervate.efficiency')`${formatNumber(this.averageManaSaved.toFixed(0))} avg mana spent.`))\r\n        .recommended(`>${formatNumber(recommended)} is recommended`));\r\n\r\n    when(this.secondsCappedSuggestionThresholds)\r\n      .addSuggestion((suggest, actual, recommended) => suggest(<>You were capped on mana during <SpellLink id={SPELLS.INNERVATE.id} />. Try to not use Innervate if you are above 90% mana.</>)\r\n        .icon(SPELLS.INNERVATE.icon)\r\n        .actual(i18n._(t('druid.restoration.suggestions.innervate.secondsCapped')`~${this.wholeSecondsCapped} seconds capped`))\r\n        .recommended(`${recommended} is recommended`));\r\n  }\r\n\r\n  statistic() {\r\n    return (\r\n      <Statistic\r\n        position={STATISTIC_ORDER.CORE(14)}\r\n        size=\"flexible\"\r\n        tooltip={(\r\n          <>\r\n            During your {this.innervateCount} Innervates you cast:\r\n            <ul>\r\n              <li>{this.wildGrowths}/{this.innervateCount} Wild Growths</li>\r\n              <li>{this.efflorescences}/{this.innervateCount} Efflorescences</li>\r\n              {this.cenarionWards > 0 && <li>{this.cenarionWards} Cenarion Wards</li>}\r\n              {this.rejuvenations > 0 && <li>{this.rejuvenations} Rejuvenations</li>}\r\n              {this.regrowths > 0 && <li>{this.regrowths} Regrowths</li>}\r\n              {this.lifeblooms > 0 && <li>{this.lifeblooms} Lifeblooms</li>}\r\n              {this.swiftmends > 0 && <li>{this.swiftmends} Swiftmends</li>}\r\n              {this.tranquilities > 0 && <li>{this.tranquilities} Tranquilities</li>}\r\n            </ul>\r\n          </>\r\n        )}\r\n      >\r\n        <BoringValue label={<><SpellIcon id={SPELLS.INNERVATE.id} /> Mana saved per Innervate</>}>\r\n          <>\r\n            {formatNumber(this.averageManaSaved)}\r\n          </>\r\n        </BoringValue>\r\n      </Statistic>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Innervate;\r\n","import React from 'react';\r\nimport { formatPercentage } from 'common/format';\r\nimport STATISTIC_ORDER from 'interface/others/STATISTIC_ORDER';\r\nimport Statistic from 'interface/statistics/Statistic';\r\nimport SpellLink from 'common/SpellLink';\r\nimport AbilityTracker from 'parser/shared/modules/AbilityTracker';\r\nimport SpellIcon from 'common/SpellIcon';\r\nimport BoringValue from 'interface/statistics/components/BoringValueText';\r\n\r\nimport SPELLS from 'common/SPELLS';\r\nimport Analyzer, { SELECTED_PLAYER } from 'parser/core/Analyzer';\r\nimport HealingValue from 'parser/shared/modules/HealingValue';\r\nimport Events from 'parser/core/Events';\r\nimport { i18n } from '@lingui/core';\r\nimport { t } from '@lingui/macro';\r\n\r\nconst RECOMMENDED_HIT_THRESHOLD = 5;\r\nconst PRECAST_PERIOD = 3000;\r\nconst PRECAST_THRESHOLD = 0.5;\r\n\r\n// TODO - dynamic suggestion threshold based on variables such as Autumn leaves\r\nclass WildGrowth extends Analyzer {\r\n  get averageEffectiveHits() {\r\n    return (this.wgHistory.reduce((a, b) => a + b.wgBuffs.length, 0) / this.wgs) || 0;\r\n  }\r\n\r\n  get belowRecommendedCasts() {\r\n    return this.wgHistory.filter(wg => wg.wgBuffs.length < RECOMMENDED_HIT_THRESHOLD).length;\r\n  }\r\n\r\n  get belowRecommendedPrecasts() {\r\n    return this.wgHistory.filter(wg => wg.badPrecast === true).length;\r\n  }\r\n\r\n  get wgs() {\r\n    return this.abilityTracker.getAbility(SPELLS.WILD_GROWTH.id).casts || 0;\r\n  }\r\n\r\n  get rejuvs() {\r\n    return this.abilityTracker.getAbility(SPELLS.REJUVENATION.id).casts || 0;\r\n  }\r\n\r\n  get wgsPerRejuv() {\r\n    return (this.wgs / this.rejuvs) || 0;\r\n  }\r\n\r\n  get percentBelowRecommendedCasts() {\r\n    return (this.belowRecommendedCasts / this.wgs) || 0;\r\n  }\r\n\r\n  get percentBelowRecommendedPrecasts() {\r\n    return (this.belowRecommendedPrecasts / this.wgs) || 0;\r\n  }\r\n\r\n  get suggestionThresholds() {\r\n    return {\r\n      actual: this.wgsPerRejuv,\r\n      isLessThan: {\r\n        minor: 0.12,\r\n        average: 0.08,\r\n        major: 0.03,\r\n      },\r\n      style: 'percentage',\r\n    };\r\n  }\r\n\r\n  get suggestionpercentBelowRecommendedCastsThresholds() {\r\n    return {\r\n      actual: this.percentBelowRecommendedCasts,\r\n      isGreaterThan: {\r\n        minor: 0.00,\r\n        average: 0.15,\r\n        major: 0.35,\r\n      },\r\n      style: 'percentage',\r\n    };\r\n  }\r\n\r\n  get suggestionpercentBelowRecommendedPrecastsThresholds() {\r\n    return {\r\n      actual: this.percentBelowRecommendedPrecasts,\r\n      isGreaterThan: {\r\n        minor: 0.05,\r\n        average: 0.15,\r\n        major: 0.35,\r\n      },\r\n      style: 'percentage',\r\n    };\r\n  }\r\n\r\n  static dependencies = {\r\n    abilityTracker: AbilityTracker,\r\n  };\r\n  wgHistory = [];\r\n  wgTracker = {\r\n    wgBuffs: [],\r\n    startTimestamp: 0,\r\n    heal: 0,\r\n    overheal: 0,\r\n    firstTicksOverheal: 0,\r\n    firstTicksRaw: 0,\r\n  };\r\n\r\n  constructor(...args) {\r\n    super(...args);\r\n    this.wgTracker.startTimestamp = this.owner.fight.start_time;\r\n    this.addEventListener(Events.cast.by(SELECTED_PLAYER).spell(SPELLS.WILD_GROWTH), this.onCast);\r\n    this.addEventListener(Events.heal.by(SELECTED_PLAYER).spell(SPELLS.WILD_GROWTH), this.onHeal);\r\n    this.addEventListener(Events.applybuff.by(SELECTED_PLAYER).spell(SPELLS.WILD_GROWTH), this.onApplyBuff);\r\n    this.addEventListener(Events.fightend, this.onFightend);\r\n  }\r\n\r\n  onCast(event) {\r\n    if (this.wgTracker.wgBuffs.length > 0) {\r\n      this.wgTracker.badPrecast = (this.wgTracker.firstTicksOverheal / this.wgTracker.firstTicksRaw) > PRECAST_THRESHOLD;\r\n      this.wgHistory.push(this.wgTracker);\r\n    }\r\n\r\n    this.wgTracker = {};\r\n    this.wgTracker.wgBuffs = [];\r\n    this.wgTracker.startTimestamp = event.timestamp;\r\n    this.wgTracker.heal = 0;\r\n    this.wgTracker.overheal = 0;\r\n    this.wgTracker.firstTicksOverheal = 0;\r\n    this.wgTracker.firstTicksRaw = 0;\r\n  }\r\n\r\n  onHeal(event) {\r\n    const healVal = new HealingValue(event.amount, event.absorbed, event.overheal);\r\n    this.wgTracker.heal += healVal.effective;\r\n    this.wgTracker.overheal += healVal.overheal;\r\n\r\n    // Track overhealing first couple ticks to determine if WG was precast before damaging event.\r\n    if (event.timestamp - this.wgTracker.startTimestamp < PRECAST_PERIOD) {\r\n      this.wgTracker.firstTicksRaw += healVal.raw;\r\n      this.wgTracker.firstTicksOverheal += healVal.overheal;\r\n    }\r\n  }\r\n\r\n  onApplyBuff(event) {\r\n    this.wgTracker.wgBuffs.push(event.targetID);\r\n  }\r\n\r\n  onFightend() {\r\n    this.wgHistory.push(this.wgTracker);\r\n  }\r\n\r\n  suggestions(when) {\r\n    when(this.suggestionpercentBelowRecommendedPrecastsThresholds)\r\n      .addSuggestion((suggest, actual, recommended) => suggest(<>Your initial healing from <SpellLink id={SPELLS.WILD_GROWTH.id} /> were doing too much overhealing. <SpellLink id={SPELLS.WILD_GROWTH.id} /> does most of it's healing initially and declines over duration. Make sure you are not precasting it before damaging event but after damage occurs.\r\n      </>)\r\n        .icon(SPELLS.WILD_GROWTH.icon)\r\n        .actual(i18n._(t('druid.restoration.suggestions.wildgrowth.overhealing')`${Math.round(formatPercentage(actual))}% of casts with high overhealing.`))\r\n        .recommended(`<${Math.round(formatPercentage(recommended))}% is recommended`));\r\n    when(this.suggestionpercentBelowRecommendedCastsThresholds)\r\n      .addSuggestion((suggest) => suggest(<>You sometimes cast <SpellLink id={SPELLS.WILD_GROWTH.id} /> on too few targets. <SpellLink id={SPELLS.WILD_GROWTH.id} /> is not mana efficient when hitting few targets, you should only cast it when you can hit at least {RECOMMENDED_HIT_THRESHOLD} wounded targets. Make sure you are not casting on a primary target isolated from the raid. <SpellLink id={SPELLS.WILD_GROWTH.id} /> has a maximum hit radius, the injured raiders could have been out of range. Also, you should never pre-hot with <SpellLink id={SPELLS.WILD_GROWTH.id} />.\r\n      </>)\r\n        .icon(SPELLS.WILD_GROWTH.icon)\r\n        .actual(i18n._(t('druid.restoration.suggestions.wildgrowth.tooFewTargets')`${formatPercentage(this.percentBelowRecommendedCasts, 0)}% of your casts on fewer than ${RECOMMENDED_HIT_THRESHOLD} targets.`))\r\n        .recommended(`never casting on fewer than ${RECOMMENDED_HIT_THRESHOLD} is recommended`));\r\n    when(this.suggestionThresholds)\r\n      .addSuggestion((suggest, actual, recommended) => suggest(<>Your <SpellLink id={SPELLS.WILD_GROWTH.id} /> to rejuv ratio can be improved, try to cast more wild growths if possible as it is usually more efficient.</>)\r\n        .icon(SPELLS.WILD_GROWTH.icon)\r\n        .actual(i18n._(t('druid.restoration.suggestions.wildgrowth.rejuvenationRatio')`${this.wgs} WGs / ${this.rejuvs} rejuvs`))\r\n        .recommended(`>${Math.round(formatPercentage(recommended))}% is recommended`));\r\n  }\r\n\r\n  statistic() {\r\n    return (\r\n      <Statistic\r\n        size=\"flexible\"\r\n        position={STATISTIC_ORDER.CORE(19)}\r\n        tooltip={`Your Wild Growth hit on average ${this.averageEffectiveHits.toFixed(2)} players. ${this.belowRecommendedCasts} of your cast(s) hit fewer than 5 players which is the recommended targets.`}\r\n      >\r\n        <BoringValue label={<><SpellIcon id={SPELLS.WILD_GROWTH.id} /> Average Wild Growth Hits</>}>\r\n          <>\r\n            {this.averageEffectiveHits.toFixed(2)}\r\n          </>\r\n        </BoringValue>\r\n      </Statistic>\r\n    );\r\n  }\r\n}\r\n\r\nexport default WildGrowth;\r\n","import SPELLS from 'common/SPELLS';\r\n\r\n/*\r\n * Fields:\r\n * int: spell scales with Intellect\r\n * crit: spell scales with (is able to or procced from) Critical Strike\r\n * hasteHpm: spell does more healing due to Haste, e.g. HoTs that gain more ticks\r\n * hasteHpct: spell can be cast more frequently due to Haste, basically any spell except for non haste scaling CDs\r\n * mastery: spell is boosted by Mastery\r\n * masteryStack: spell's HoT counts as a Mastery Stack\r\n * vers: spell scales with Versatility\r\n * multiplier: spell scales with whatever procs it, should be ignored for purpose of weights and for 'total healing' number\r\n * ignored: spell should be ignored for purpose of stat weights\r\n */\r\n\r\nconst DEFAULT_INFO = { // we assume unlisted spells scale with vers only (this will mostly be trinkets)\r\n  int: false,\r\n  crit: false,\r\n  hasteHpm: false,\r\n  hasteHpct: false,\r\n  mastery: false,\r\n  masteryStack: false,\r\n  vers: true,\r\n};\r\n\r\nexport const DRUID_HEAL_INFO = {\r\n  [SPELLS.REJUVENATION.id]: {\r\n    int: true,\r\n    crit: true,\r\n    hasteHpm: true,\r\n    hasteHpct: true,\r\n    mastery: true,\r\n    masteryStack: true,\r\n    vers: true,\r\n  },\r\n  [SPELLS.REJUVENATION_GERMINATION.id]: {\r\n    int: true,\r\n    crit: true,\r\n    hasteHpm: true,\r\n    hasteHpct: true,\r\n    mastery: true,\r\n    masteryStack: true,\r\n    vers: true,\r\n  },\r\n  [SPELLS.REGROWTH.id]: {\r\n    int: true,\r\n    crit: true,\r\n    hasteHpm: true,\r\n    hasteHpct: true,\r\n    mastery: true,\r\n    masteryStack: true,\r\n    vers: true,\r\n  },\r\n  [SPELLS.WILD_GROWTH.id]: {\r\n    int: true,\r\n    crit: true,\r\n    hasteHpm: true,\r\n    hasteHpct: false,\r\n    mastery: true,\r\n    masteryStack: true,\r\n    vers: true,\r\n  },\r\n  [SPELLS.CULTIVATION.id]: {\r\n    int: true,\r\n    crit: true,\r\n    hasteHpm: true,\r\n    hasteHpct: true, // an approximation, because this is applied by Rejuv\r\n    mastery: true,\r\n    masteryStack: true,\r\n    vers: true,\r\n  },\r\n  [SPELLS.SPRING_BLOSSOMS.id]: {\r\n    int: true,\r\n    crit: true,\r\n    hasteHpm: true, // an approximation, because faster ticking Efflo will apply more\r\n    hasteHpct: false,\r\n    mastery: true,\r\n    masteryStack: true,\r\n    vers: true,\r\n  },\r\n  [SPELLS.CENARION_WARD_HEAL.id]: {\r\n    int: true,\r\n    crit: true,\r\n    hasteHpm: true,\r\n    hasteHpct: false,\r\n    mastery: true,\r\n    masteryStack: true,\r\n    vers: true,\r\n  },\r\n  [SPELLS.FRENZIED_REGENERATION.id]: { // it's weird this scles with anything, but confirmed on live that it does\r\n    int: false,\r\n    crit: false,\r\n    hasteHpm: false,\r\n    hasteHpct: false,\r\n    mastery: true,\r\n    masteryStack: true,\r\n    vers: true,\r\n  },\r\n  [SPELLS.LIFEBLOOM_HOT_HEAL.id]: {\r\n    int: true,\r\n    crit: true,\r\n    hasteHpm: true,\r\n    hasteHpct: false,\r\n    mastery: true,\r\n    masteryStack: true,\r\n    vers: true,\r\n  },\r\n  [SPELLS.LIFEBLOOM_BLOOM_HEAL.id]: {\r\n    int: true,\r\n    crit: true,\r\n    hasteHpm: false,\r\n    hasteHpct: false,\r\n    mastery: true,\r\n    masteryStack: false,\r\n    vers: true,\r\n  },\r\n  [SPELLS.SWIFTMEND.id]: {\r\n    int: true,\r\n    crit: true,\r\n    hasteHpm: false,\r\n    hasteHpct: false,\r\n    mastery: true,\r\n    masteryStack: false,\r\n    vers: true,\r\n  },\r\n  [SPELLS.TRANQUILITY_HEAL.id]: {\r\n    ignored: false, // Have to enable this again because of the changes to Tranq including a HoT part.\r\n    int: true,\r\n    crit: true,\r\n    hasteHpm: false,\r\n    hasteHpct: false,\r\n    mastery: true,\r\n    masteryStack: true,\r\n    vers: true,\r\n  },\r\n  [SPELLS.EFFLORESCENCE_HEAL.id]: {\r\n    int: true,\r\n    crit: true,\r\n    hasteHpm: true,\r\n    hasteHpct: false,\r\n    mastery: true,\r\n    masteryStack: false,\r\n    vers: true,\r\n  },\r\n  [SPELLS.YSERAS_GIFT_OTHERS.id]: { // TODO does it really scale with nothing (except stam)?\r\n    int: false,\r\n    crit: false,\r\n    hasteHpm: false,\r\n    hasteHpct: false,\r\n    mastery: false,\r\n    masteryStack: false,\r\n    vers: false,\r\n  },\r\n  [SPELLS.YSERAS_GIFT_SELF.id]: { // TODO does it really scale with nothing (except stam)?\r\n    int: false,\r\n    crit: false,\r\n    hasteHpm: false,\r\n    hasteHpct: false,\r\n    mastery: false,\r\n    masteryStack: false,\r\n    vers: false,\r\n  },\r\n  [SPELLS.RENEWAL_TALENT.id]: { // TODO does it really scale with nothing (except stam)?\r\n    int: false,\r\n    crit: false,\r\n    hasteHpm: false,\r\n    hasteHpct: false,\r\n    mastery: false,\r\n    masteryStack: false,\r\n    vers: false,\r\n  },\r\n  [SPELLS.MARK_OF_SHIFTING.id]: { // TODO does it really scale with nothing (except stam)?\r\n    int: false,\r\n    crit: false,\r\n    hasteHpm: false,\r\n    hasteHpct: false,\r\n    mastery: false,\r\n    masteryStack: false,\r\n    vers: false,\r\n  },\r\n};\r\n\r\nexport const getSpellInfo = id => DRUID_HEAL_INFO[id] || DEFAULT_INFO;\r\n","import Analyzer, { SELECTED_PLAYER } from 'parser/core/Analyzer';\r\nimport SPELLS from 'common/SPELLS';\r\nimport Combatants from 'parser/shared/modules/Combatants';\r\nimport HealingValue from 'parser/shared/modules/HealingValue';\r\nimport StatTracker from 'parser/shared/modules/StatTracker';\r\nimport calculateEffectiveHealing from 'parser/core/calculateEffectiveHealing';\r\nimport STAT from 'parser/shared/modules/features/STAT';\r\n\r\nimport Events from 'parser/core/Events';\r\n\r\nimport { DRUID_HEAL_INFO, getSpellInfo } from '../../SpellInfo';\r\n\r\nclass Mastery extends Analyzer {\r\n  static dependencies = {\r\n    combatants: Combatants,\r\n    statTracker: StatTracker,\r\n  };\r\n\r\n  totalNoMasteryHealing = 0;\r\n  druidSpellNoMasteryHealing = 0;\r\n  masteryTimesHealing = 0;\r\n\r\n  /*\r\n   * Keeps track of the attribution of healing done by your hots. Each spellId gets an entry with a 'direct' and 'mastery' field.\r\n   * The 'direct' field just tracks the direct healing from the HoT, should be same as entry in WCL. Includes the benefit from own stack of Mastery.\r\n   * The 'mastery' field tracks which spells were boosted by the presence of this HoT, and by how much.\r\n   * The total healing attributable to the presence of the HoT is the sum of the direct field and all the attributions in the mastery field.\r\n   * While the attribution to any one HoT is correctly counted by simply summing, there are double counts when considering multiple HoTs together.\r\n   */\r\n  hotHealingAttrib = {};\r\n\r\n  /*\r\n   * Tracks healing attributable to mastery buffs\r\n   */\r\n  masteryBuffs = {};\r\n\r\n  constructor(...args) {\r\n    super(...args);\r\n    Object.entries(DRUID_HEAL_INFO)\r\n      .filter(infoEntry => infoEntry[1].masteryStack)\r\n      .forEach(infoEntry => {\r\n        this.hotHealingAttrib[infoEntry[0]] = { direct: 0, mastery: {} };\r\n      });\r\n\r\n    // TODO hook in StatTracker buff list somehow, so new Mastery buffs auto handled?\r\n    this.masteryBuffs = {\r\n      //TODO - blazyb add bfa specific mastery proccs\r\n      [SPELLS.ASTRAL_HARMONY.id]: { amount: 4000 },\r\n      [SPELLS.JACINS_RUSE.id]: { amount: 3000 },\r\n    };\r\n\r\n    Object.values(this.masteryBuffs).forEach(entry => {\r\n      entry.attributableHealing = 0;\r\n    });\r\n\r\n    this.addEventListener(Events.heal.by(SELECTED_PLAYER), this.onHeal);\r\n    this.addEventListener(Events.absorbed.by(SELECTED_PLAYER), this.onAbsorbed);\r\n  }\r\n\r\n  onHeal(event) {\r\n    const spellId = event.ability.guid;\r\n    const target = this.combatants.getEntity(event);\r\n    const healVal = new HealingValue(event.amount, event.absorbed, event.overheal);\r\n\r\n    if (target === null) {\r\n      return;\r\n    }\r\n\r\n    if (this.hotHealingAttrib[spellId]) {\r\n      this.hotHealingAttrib[spellId].direct += healVal.effective;\r\n    }\r\n\r\n    if (getSpellInfo(spellId).mastery) {\r\n      const hotsOn = this.getHotsOn(target);\r\n      const numHotsOn = hotsOn.length;\r\n      const decomposedHeal = this._decompHeal(healVal, numHotsOn);\r\n\r\n      this.totalNoMasteryHealing += decomposedHeal.noMastery;\r\n      this.druidSpellNoMasteryHealing += decomposedHeal.noMastery;\r\n      this.masteryTimesHealing += decomposedHeal.noMastery * decomposedHeal.effectiveStackBenefit;\r\n\r\n      hotsOn\r\n        .filter(hotOn => hotOn !== spellId) // don't double count\r\n        .forEach(hotOn => this._tallyMasteryBenefit(hotOn, spellId, decomposedHeal.oneStack));\r\n\r\n      Object.entries(this.masteryBuffs)\r\n        .filter(entry => this.selectedCombatant.hasBuff(entry[0]))\r\n        .forEach(entry => {\r\n          entry[1].attributableHealing += calculateEffectiveHealing(event, decomposedHeal.relativeBuffBenefit(entry[1].amount));\r\n        });\r\n    } else {\r\n      this.totalNoMasteryHealing += healVal.effective;\r\n    }\r\n  }\r\n\r\n  onAbsorbed(event) {\r\n    this.totalNoMasteryHealing += event.amount;\r\n  }\r\n\r\n  /* accessors for computed values */\r\n\r\n  /*\r\n   * Gets the direct healing attributed to the given resto HoT ID\r\n   */\r\n  getDirectHealing(healId) {\r\n    return this.hotHealingAttrib[healId].direct;\r\n  }\r\n\r\n  /*\r\n   * Gets the total mastery healing attributed to the given resto HoT ID\r\n   */\r\n  getMasteryHealing(healId) {\r\n    return Object.values(this.hotHealingAttrib[healId].mastery)\r\n      .reduce((s, v) => s + v, 0);\r\n  }\r\n\r\n  /*\r\n   * Gets the total healing attributable to the given resto HoT IDs.\r\n   * Counts both direct and by mastery, and avoids the mastery/direct double count issue between the hots.\r\n   */\r\n  getMultiMasteryHealing(healIds) {\r\n    let total = 0;\r\n    healIds.forEach(healId => {\r\n      total += Object.entries(this.hotHealingAttrib[healId].mastery)\r\n        .filter(entry => !healIds.includes(Number(entry[0])))\r\n        .reduce((sum, entry) => sum + entry[1], 0);\r\n      total += this.hotHealingAttrib[healId].direct;\r\n    });\r\n    return total;\r\n  }\r\n\r\n  /*\r\n   * Gets detailed direct / mastery healing attribution info from the given resto HoT ID\r\n   */\r\n  getHealingDetails(healId) {\r\n    return this.hotHealingAttrib[healId];\r\n  }\r\n\r\n  /*\r\n   * Gets the total mastery healing attributed to the given mastery buff ID\r\n   */\r\n  getBuffBenefit(buffId) {\r\n    return this.masteryBuffs[buffId].attributableHealing;\r\n  }\r\n\r\n  /**\r\n   * This is the average number of mastery stacks the player's heals benefitted from, weighted by healing done.\r\n   * Heals and absorbs that don't benefit from mastery are counted as zero mastery stack heals.\r\n   */\r\n  getAverageTotalMasteryStacks() {\r\n    return this.masteryTimesHealing / this.totalNoMasteryHealing;\r\n  }\r\n\r\n  /**\r\n   * This is the average number of mastery stacks the player's heals benefitted from, weighted by healing done.\r\n   * Only heals that benefit from mastery are counted.\r\n   */\r\n  getAverageDruidSpellMasteryStacks() {\r\n    return this.masteryTimesHealing / this.druidSpellNoMasteryHealing;\r\n  }\r\n\r\n  /**\r\n   * Given an Entity object, returns an array of the spell IDs of the Mastery boosting HoTs the Druid currently has on that target.\r\n   */\r\n  getHotsOn(target) {\r\n    return target.activeBuffs()\r\n      .map(buffObj => buffObj.ability.guid)\r\n      .filter(buffId => getSpellInfo(buffId).masteryStack);\r\n  }\r\n\r\n  /**\r\n   * Given an Entity object, returns the number of Mastery boosting HoTs the Druid currently has on that target.\r\n   */\r\n  getHotCount(target) {\r\n    return this.getHotsOn(target).length;\r\n  }\r\n\r\n  _tallyMasteryBenefit(hotId, healId, amount) {\r\n    const hotMastery = this.hotHealingAttrib[hotId].mastery;\r\n    if (hotMastery[healId]) {\r\n      hotMastery[healId] += amount;\r\n    } else {\r\n      hotMastery[healId] = amount;\r\n    }\r\n  }\r\n\r\n  // a version of _decompHeal for call by external modules, takes the heal event\r\n  decomposeHeal(event) {\r\n    const target = this.combatants.getEntity(event);\r\n    if (target === null) {\r\n      return null;\r\n    }\r\n    const healVal = new HealingValue(event.amount, event.absorbed, event.overheal);\r\n    return this._decompHeal(healVal, this.getHotCount(target));\r\n  }\r\n\r\n  _decompHeal(healVal, hotCount) {\r\n    const masteryBonus = this.statTracker.currentMasteryPercentage;\r\n    const healMasteryMult = 1 + (hotCount * masteryBonus);\r\n\r\n    const rawNoMasteryHealing = healVal.raw / healMasteryMult;\r\n    const noMasteryHealing = Math.min(rawNoMasteryHealing, healVal.effective);\r\n\r\n    // because Mastery is a bonus on top of the base healing, all overhealing is counted against Mastery\r\n    const effectiveMasteryHealing = healVal.effective - noMasteryHealing;\r\n    // when Mastery bonus is partially but not completely overhealing, the stacks equally share attribution\r\n    const oneStackMasteryHealingEffective = effectiveMasteryHealing / hotCount;\r\n\r\n    const oneStackMasteryHealingRaw = rawNoMasteryHealing * masteryBonus;\r\n    // the number of mastery stacks that we actually benefitted from once overheal is considered.\r\n    // if this heal didn't overheal at all, will be the same as hotCount\r\n    const effectiveStackBenefit = effectiveMasteryHealing / oneStackMasteryHealingRaw;\r\n\r\n    const relativeBuffBenefit = (buffRating => {\r\n      const buffBonus = hotCount * buffRating / this.statTracker.ratingNeededForNextPercentage(this.statTracker.currentMasteryRating, this.statTracker.statBaselineRatingPerPercent[STAT.MASTERY], this.selectedCombatant.spec.masteryCoefficient);\r\n      return buffBonus / healMasteryMult;\r\n    });\r\n\r\n    return {\r\n      noMastery: noMasteryHealing,\r\n      oneStack: oneStackMasteryHealingEffective,\r\n      effectiveStackBenefit: effectiveStackBenefit,\r\n      relativeBuffBenefit: relativeBuffBenefit,\r\n    };\r\n  }\r\n}\r\n\r\nexport default Mastery;\r\n","import React from 'react';\r\nimport { formatPercentage } from 'common/format';\r\nimport STATISTIC_ORDER from 'interface/others/STATISTIC_ORDER';\r\nimport Statistic from 'interface/statistics/Statistic';\r\nimport SpellLink from 'common/SpellLink';\r\nimport SpellIcon from 'common/SpellIcon';\r\nimport BoringValue from 'interface/statistics/components/BoringValueText';\r\n\r\nimport { i18n } from '@lingui/core';\r\nimport { t } from '@lingui/macro';\r\n\r\nimport SPELLS from 'common/SPELLS';\r\nimport Analyzer from 'parser/core/Analyzer';\r\n\r\nimport Mastery from '../core/Mastery';\r\n\r\nclass Cultivation extends Analyzer {\r\n  get directPercent() {\r\n    return this.owner.getPercentageOfTotalHealingDone(this.mastery.getDirectHealing(SPELLS.CULTIVATION.id));\r\n  }\r\n\r\n  get masteryPercent() {\r\n    return this.owner.getPercentageOfTotalHealingDone(this.mastery.getMasteryHealing(SPELLS.CULTIVATION.id));\r\n  }\r\n\r\n  get totalPercent() {\r\n    return this.directPercent + this.masteryPercent;\r\n  }\r\n\r\n  get suggestionThresholds() {\r\n    return {\r\n      actual: this.totalPercent,\r\n      isLessThan: {\r\n        minor: 0.06,\r\n        average: 0.045,\r\n        major: 0.03,\r\n      },\r\n      style: 'percentage',\r\n    };\r\n  }\r\n\r\n  static dependencies = {\r\n    mastery: Mastery,\r\n  };\r\n\r\n  constructor(...args) {\r\n    super(...args);\r\n    const hasCultivation = this.selectedCombatant.hasTalent(SPELLS.CULTIVATION_TALENT.id);\r\n    this.active = hasCultivation;\r\n  }\r\n\r\n  statistic() {\r\n    return (\r\n      <Statistic\r\n        position={STATISTIC_ORDER.OPTIONAL}\r\n        size=\"flexible\"\r\n        tooltip={(\r\n          <>\r\n            This is the sum of the direct healing from Cultivation and the healing enabled by Cultivation's extra mastery stack.\r\n            <ul>\r\n              <li>Direct: <strong>{formatPercentage(this.directPercent)}%</strong></li>\r\n              <li>Mastery: <strong>{formatPercentage(this.masteryPercent)}%</strong></li>\r\n            </ul>\r\n          </>\r\n        )}\r\n      >\r\n        <BoringValue label={<><SpellIcon id={SPELLS.CULTIVATION.id} /> Cultivation healing </>}>\r\n          <>\r\n            {formatPercentage(this.totalPercent)} %\r\n          </>\r\n        </BoringValue>\r\n      </Statistic>\r\n    );\r\n  }\r\n\r\n  suggestions(when) {\r\n    when(this.suggestionThresholds)\r\n      .addSuggestion((suggest, actual, recommended) => suggest(<>Your healing from <SpellLink id={SPELLS.CULTIVATION.id} /> could be improved. You may have too many healers or doing easy\r\n        content, thus having low cultivation proc rate. You may considering selecting another talent.</>)\r\n        .icon(SPELLS.CULTIVATION.icon)\r\n        .actual(i18n._(t('druid.restoration.suggestions.cultivation.notOptimal')`${formatPercentage(this.totalPercent)}% healing`))\r\n        .recommended(`>${Math.round(formatPercentage(recommended))}% is recommended`));\r\n  }\r\n}\r\n\r\nexport default Cultivation;\r\n","import React from 'react';\r\nimport { formatPercentage } from 'common/format';\r\nimport STATISTIC_ORDER from 'interface/others/STATISTIC_ORDER';\r\nimport Statistic from 'interface/statistics/Statistic';\r\nimport BoringValue from 'interface/statistics/components/BoringValueText';\r\nimport SpellIcon from 'common/SpellIcon';\r\nimport SPELLS from 'common/SPELLS';\r\nimport SpellLink from 'common/SpellLink';\r\nimport Analyzer from 'parser/core/Analyzer';\r\n\r\nimport { i18n } from '@lingui/core';\r\nimport { t } from '@lingui/macro';\r\n\r\nimport Mastery from '../core/Mastery';\r\n\r\nclass SpringBlossoms extends Analyzer {\r\n  get directPercent() {\r\n    return this.owner.getPercentageOfTotalHealingDone(this.mastery.getDirectHealing(SPELLS.SPRING_BLOSSOMS.id));\r\n  }\r\n\r\n  get masteryPercent() {\r\n    return this.owner.getPercentageOfTotalHealingDone(this.mastery.getMasteryHealing(SPELLS.SPRING_BLOSSOMS.id));\r\n  }\r\n\r\n  get totalPercent() {\r\n    return this.directPercent + this.masteryPercent;\r\n  }\r\n\r\n  get suggestionThresholds() {\r\n    return {\r\n      actual: this.totalPercent,\r\n      isLessThan: {\r\n        minor: 0.07,\r\n        average: 0.05,\r\n        major: 0.03,\r\n      },\r\n      style: 'percentage',\r\n    };\r\n  }\r\n\r\n  static dependencies = {\r\n    mastery: Mastery,\r\n  };\r\n\r\n  constructor(...args) {\r\n    super(...args);\r\n    const hasSpringBlossoms = this.selectedCombatant.hasTalent(SPELLS.SPRING_BLOSSOMS_TALENT.id);\r\n    this.active = hasSpringBlossoms;\r\n  }\r\n\r\n  statistic() {\r\n    return (\r\n      <Statistic\r\n        size=\"flexible\"\r\n        position={STATISTIC_ORDER.OPTIONAL(20)}\r\n        tooltip={(\r\n          <>\r\n            This is the sum of the direct healing from Spring Blossoms and the healing enabled by Spring Blossom's extra mastery stack.\r\n            <ul>\r\n              <li>Direct: <strong>{formatPercentage(this.directPercent)}%</strong></li>\r\n              <li>Mastery: <strong>{formatPercentage(this.masteryPercent)}%</strong></li>\r\n            </ul>\r\n          </>\r\n        )}\r\n      >\r\n        <BoringValue label={<><SpellIcon id={SPELLS.SPRING_BLOSSOMS.id} /> Spring Blossoms healing</>}>\r\n          <>\r\n            {formatPercentage(this.totalPercent)} %\r\n          </>\r\n        </BoringValue>\r\n      </Statistic>\r\n    );\r\n  }\r\n\r\n  suggestions(when) {\r\n    when(this.suggestionThresholds)\r\n      .addSuggestion((suggest, actual, recommended) => suggest(<span>Your healing from <SpellLink id={SPELLS.SPRING_BLOSSOMS.id} /> could be improved.\r\n          Either your efflorescence uptime could be improved or the encounter doesn't fit this talent very well.</span>)\r\n        .icon(SPELLS.SPRING_BLOSSOMS.icon)\r\n        .actual(i18n._(t('druid.restoration.suggestions.springBlossoms.efficiency')`${formatPercentage(this.totalPercent)}% healing`))\r\n        .recommended(`>${Math.round(formatPercentage(recommended))}% is recommended`));\r\n  }\r\n}\r\n\r\nexport default SpringBlossoms;\r\n","import SPELLS from 'common/SPELLS';\r\n\r\nexport const ABILITIES_AFFECTED_BY_HEALING_INCREASES = [\r\n  SPELLS.REJUVENATION.id,\r\n  SPELLS.REGROWTH.id,\r\n  SPELLS.WILD_GROWTH.id,\r\n  SPELLS.REJUVENATION_GERMINATION.id,\r\n  SPELLS.CULTIVATION.id,\r\n  SPELLS.TRANQUILITY_HEAL.id,\r\n  SPELLS.EFFLORESCENCE_HEAL.id,\r\n  SPELLS.CENARION_WARD_HEAL.id,\r\n  SPELLS.LIFEBLOOM_HOT_HEAL.id,\r\n  SPELLS.LIFEBLOOM_BLOOM_HEAL.id,\r\n  SPELLS.SWIFTMEND.id,\r\n  SPELLS.RENEWAL_TALENT.id,\r\n  SPELLS.SPRING_BLOSSOMS.id,\r\n  // The following spells don't double dip in healing increases.\r\n  SPELLS.LEECH.id,\r\n  //TODO - blazyb double check if any non resto druid spells scales with healing increases.\r\n];\r\n\r\nexport const ABILITIES_AFFECTED_BY_HEALING_INCREASES_SPELL_OBJECTS = [\r\n  SPELLS.REJUVENATION,\r\n  SPELLS.REGROWTH,\r\n  SPELLS.WILD_GROWTH,\r\n  SPELLS.REJUVENATION_GERMINATION,\r\n  SPELLS.CULTIVATION,\r\n  SPELLS.TRANQUILITY_HEAL,\r\n  SPELLS.EFFLORESCENCE_HEAL,\r\n  SPELLS.CENARION_WARD_HEAL,\r\n  SPELLS.LIFEBLOOM_HOT_HEAL,\r\n  SPELLS.LIFEBLOOM_BLOOM_HEAL,\r\n  SPELLS.SWIFTMEND,\r\n  SPELLS.RENEWAL_TALENT,\r\n  SPELLS.SPRING_BLOSSOMS,\r\n  // The following spells don't double dip in healing increases.\r\n  SPELLS.LEECH,\r\n  //TODO - blazyb double check if any non resto druid spells scales with healing increases.\r\n];\r\n\r\nexport const HOTS_AFFECTED_BY_ESSENCE_OF_GHANIR = [\r\n  SPELLS.REJUVENATION,\r\n  SPELLS.WILD_GROWTH,\r\n  SPELLS.REJUVENATION_GERMINATION,\r\n  SPELLS.CULTIVATION,\r\n  SPELLS.CENARION_WARD_HEAL,\r\n  SPELLS.LIFEBLOOM_HOT_HEAL,\r\n  // Make sure to check that event.tick is true, because regrowth/tranq uses the same id for the heal and the HoT part\r\n  SPELLS.REGROWTH,\r\n  SPELLS.TRANQUILITY_HEAL,\r\n];\r\n","import SPELLS from 'common/SPELLS';\r\nimport Analyzer, { SELECTED_PLAYER } from 'parser/core/Analyzer';\r\nimport HealingDone from 'parser/shared/modules/throughput/HealingDone';\r\n\r\nimport Events from 'parser/core/Events';\r\n\r\nimport Mastery from './Mastery';\r\n\r\nconst BASE_MANA = 20000;\r\nconst REJUV_COST = 0.105; // % of base mana\r\n\r\n/*\r\n * Backend module for calculating things about Rejuvenation, to be used by other modules.\r\n */\r\nclass Rejuvenation extends Analyzer {\r\n  /*\r\n   * The total healing attributable to Rejuvenation\r\n   */\r\n  get totalRejuvHealing() {\r\n    return this.mastery.getMultiMasteryHealing([SPELLS.REJUVENATION.id, SPELLS.REJUVENATION_GERMINATION.id]);\r\n  }\r\n\r\n  /*\r\n   * The average healing caused per cast of Rejuvenation\r\n   */\r\n  get avgRejuvHealing() {\r\n    return this.totalRejuvHealing / this.totalRejuvsCast;\r\n  }\r\n\r\n  static dependencies = {\r\n    healingDone: HealingDone,\r\n    mastery: Mastery,\r\n  };\r\n  totalRejuvsCast = 0;\r\n\r\n  constructor(options) {\r\n    super(options);\r\n    this.addEventListener(Events.heal.by(SELECTED_PLAYER), this.onHeal);\r\n    this.addEventListener(Events.cast.by(SELECTED_PLAYER).spell(SPELLS.REJUVENATION), this.onCast);\r\n    this.addEventListener(Events.applybuff.by(SELECTED_PLAYER), this.onApplyBuff);\r\n    this.addEventListener(Events.fightend, this.onFightend);\r\n  }\r\n\r\n  onHeal(event) {\r\n    // TODO\r\n  }\r\n\r\n  onCast(event) {\r\n    this.totalRejuvsCast += 1;\r\n  }\r\n\r\n  onApplyBuff(event) {\r\n    // TODO check for applications too?\r\n  }\r\n\r\n  onFightend() {\r\n    // TODO debug prints\r\n  }\r\n\r\n  /*\r\n   * The expected healing done by using the given amount of mana to fill with Rejuv casts\r\n   */\r\n  getRejuvFillHealing(mana) {\r\n    return mana / (BASE_MANA / REJUV_COST) * this.avgRejuvHealing;\r\n  }\r\n\r\n}\r\n\r\nexport default Rejuvenation;\r\n","import React from 'react';\r\n\r\nimport { formatNumber, formatPercentage } from 'common/format';\r\nimport SpellLink from 'common/SpellLink';\r\nimport SPELLS from 'common/SPELLS';\r\nimport Analyzer, { SELECTED_PLAYER } from 'parser/core/Analyzer';\r\nimport HealingDone from 'parser/shared/modules/throughput/HealingDone';\r\nimport AbilityTracker from 'parser/shared/modules/AbilityTracker';\r\nimport STATISTIC_ORDER from 'interface/others/STATISTIC_ORDER';\r\nimport Statistic from 'interface/statistics/Statistic';\r\nimport calculateEffectiveHealing from 'parser/core/calculateEffectiveHealing';\r\nimport SpellIcon from 'common/SpellIcon';\r\nimport BoringValue from 'interface/statistics/components/BoringValueText';\r\n\r\nimport { i18n } from '@lingui/core';\r\nimport { t } from '@lingui/macro';\r\n\r\nimport Events from 'parser/core/Events';\r\n\r\nimport { ABILITIES_AFFECTED_BY_HEALING_INCREASES_SPELL_OBJECTS } from '../../constants';\r\nimport Rejuvenation from '../core/Rejuvenation';\r\n\r\nconst ALL_BOOST = 0.15;\r\nconst ALL_MULT = 1.15;\r\nconst REJUV_BOOST = 0.50;\r\nconst REJUV_MANA_SAVED = 0.30;\r\nconst REJUV_MANA_COST = SPELLS.REJUVENATION.manaCost;\r\nconst WG_INCREASE = (8 / 6) - 1;\r\nconst TOL_DURATION = 30000;\r\n\r\n// have to be careful about applying stacking boosts so we don't double count. Arbitrarily considering all boost to be applied \"first\"\r\n// for example, lets say a rejuv tick during ToL heals for 1000 base, but is boosted by 1.15 * 1.5 => 1725... a total of 725 raw boost\r\n// if we count each as a seperate boost, we get 1.15 => 225 boost, 1.5 => 575, total of 800 ... the overlapping boost was double counted\r\n// we correct for this by dividing out the all boost before calcing either the rejuv boost or the wg increase\r\n\r\n/*\r\n * This module handles 'Incarnation: Tree of Life' talent.\r\n *\r\n * Incarnation: Tree of Life -\r\n * Shapeshift into the Tree of Life, increasing healing done by 15%, increasing armor by 120%, and granting protection from Polymorph effects.  Functionality of Rejuvenation, Wild Growth, Regrowth, and Entangling Roots is enhanced.\r\n *\r\n * Tree of Life bonuses:\r\n *  - ALL: +15% healing\r\n *  - Rejuv: +50% healing and -30% mana\r\n *  - Regrowth: instant\r\n *  - Wild Growth: +2 targets\r\n */\r\nclass TreeOfLife extends Analyzer {\r\n  get hardcastUptime() {\r\n    const currentUptime = !(this.lastTolCast) ? 0 : Math.min(TOL_DURATION, this.owner.currentTimestamp - this.lastTolCast);\r\n    return currentUptime + this.completedTolUptime;\r\n  }\r\n\r\n  get hardcastUptimePercent() {\r\n    return this.hardcastUptime / this.owner.fightDuration;\r\n  }\r\n\r\n  get suggestionThresholds() {\r\n    return {\r\n      actual: this.owner.getPercentageOfTotalHealingDone(this._getTotalHealing(this.hardcast)),\r\n      isLessThan: {\r\n        minor: 0.06,\r\n        average: 0.045,\r\n        major: 0.025,\r\n      },\r\n      style: 'percentage',\r\n    };\r\n  }\r\n\r\n  static dependencies = {\r\n    healingDone: HealingDone,\r\n    abilityTracker: AbilityTracker,\r\n    rejuvenation: Rejuvenation,\r\n  };\r\n  lastTolCast = null;\r\n  lastTolApply = null;\r\n  completedTolUptime = 0;\r\n\r\n  // gets the appropriate accumulator for tallying this event\r\n  // if ToL buff isn't active, returns null,\r\n  wgCasts = 0;\r\n  hardcast = {\r\n    allBoostHealing: 0,\r\n    rejuvBoostHealing: 0,\r\n    rejuvManaSaved: 0,\r\n    extraWgHealing: 0,\r\n  };\r\n\r\n  constructor(...args) {\r\n    super(...args);\r\n    this.active = this.selectedCombatant.hasTalent(SPELLS.INCARNATION_TREE_OF_LIFE_TALENT.id);\r\n    this.addEventListener(Events.heal.by(SELECTED_PLAYER).spell(ABILITIES_AFFECTED_BY_HEALING_INCREASES_SPELL_OBJECTS), this.onHeal);\r\n    this.addEventListener(Events.cast.by(SELECTED_PLAYER).spell([SPELLS.INCARNATION_TREE_OF_LIFE_TALENT, SPELLS.REJUVENATION, SPELLS.WILD_GROWTH]), this.onCast);\r\n    this.addEventListener(Events.applybuff.by(SELECTED_PLAYER).spell(SPELLS.INCARNATION_TOL_ALLOWED), this.onApplyBuff);\r\n    this.addEventListener(Events.removebuff.by(SELECTED_PLAYER).spell(SPELLS.INCARNATION_TOL_ALLOWED), this.onRemoveBuff);\r\n  }\r\n\r\n  // if ToL buff is due to hardcast, returns the hardcast accumulator,\r\n  _getAccumulator(event) {\r\n    if (!this.selectedCombatant.hasBuff(SPELLS.INCARNATION_TREE_OF_LIFE_TALENT.id)) {\r\n      return null;\r\n    } else if (this.lastTolCast && this.lastTolCast + TOL_DURATION > event.timestamp) {\r\n      return this.hardcast;\r\n    } else {\r\n      return null;\r\n    }\r\n  }\r\n\r\n  onHeal(event) {\r\n    const spellId = event.ability.guid;\r\n\r\n    const accumulator = this._getAccumulator(event);\r\n    if (!accumulator) {\r\n      return;\r\n    }\r\n\r\n    accumulator.allBoostHealing += calculateEffectiveHealing(event, ALL_BOOST);\r\n\r\n    if (spellId === SPELLS.REJUVENATION.id || spellId === SPELLS.REJUVENATION_GERMINATION.id) {\r\n      accumulator.rejuvBoostHealing += (calculateEffectiveHealing(event, REJUV_BOOST) / ALL_MULT);\r\n    } else if (spellId === SPELLS.WILD_GROWTH.id) {\r\n      accumulator.extraWgHealing += (calculateEffectiveHealing(event, WG_INCREASE) / ALL_MULT);\r\n    }\r\n  }\r\n\r\n  onCast(event) {\r\n    const spellId = event.ability.guid;\r\n    if (spellId === SPELLS.INCARNATION_TREE_OF_LIFE_TALENT.id) {\r\n      this.lastTolCast = event.timestamp;\r\n    } else if (spellId === SPELLS.REJUVENATION.id && !this.selectedCombatant.hasBuff(SPELLS.INNERVATE.id)) {\r\n      const accumulator = this._getAccumulator(event);\r\n      if (!accumulator) {\r\n        return;\r\n      }\r\n      accumulator.rejuvManaSaved += REJUV_MANA_SAVED;\r\n    } else if (spellId === SPELLS.WILD_GROWTH.id) {\r\n      this.wgCasts += 1;\r\n    }\r\n  }\r\n\r\n  onApplyBuff(event) {\r\n    this.lastTolApply = event.timestamp;\r\n  }\r\n\r\n  onRemoveBuff(event) {\r\n    const buffUptime = event.timestamp - this.lastTolApply;\r\n\r\n    if (this.lastTolCast) {\r\n      this.completedTolUptime += Math.min(TOL_DURATION, buffUptime);\r\n    }\r\n\r\n    this.lastTolCast = null;\r\n    this.lastTolApply = null;\r\n  }\r\n\r\n  _getManaSavedHealing(accumulator) {\r\n    return accumulator.rejuvManaSaved * this.rejuvenation.avgRejuvHealing;\r\n  }\r\n\r\n  _getManaSaved(accumulator) {\r\n    return accumulator.rejuvManaSaved * REJUV_MANA_COST;\r\n  }\r\n\r\n  _getTotalHealing(accumulator) {\r\n    return accumulator.allBoostHealing + accumulator.rejuvBoostHealing + accumulator.extraWgHealing + this._getManaSavedHealing(accumulator);\r\n  }\r\n\r\n  suggestions(when) {\r\n    when(this.suggestionThresholds)\r\n      .addSuggestion((suggest, actual, recommended) => suggest(<>Your <SpellLink id={SPELLS.INCARNATION_TREE_OF_LIFE_TALENT.id} /> is not providing you much throughput. You may want to plan your CD usage better or pick another talent.</>)\r\n        .icon(SPELLS.INCARNATION_TREE_OF_LIFE_TALENT.icon)\r\n        .actual(i18n._(t('druid.restoration.suggestions.treeOfLife.efficiency')`${formatPercentage(actual)}% healing`))\r\n        .recommended(`>${formatPercentage(recommended, 0)}% is recommended`));\r\n  }\r\n\r\n  statistic() {\r\n    return (\r\n      <Statistic\r\n        position={STATISTIC_ORDER.OPTIONAL(20)}\r\n        size=\"flexible\"\r\n        tooltip={(\r\n          <>\r\n            The Tree of Life buff was active for <strong>{(this.hardcastUptime / 1000).toFixed(0)}s</strong>, or <strong>{formatPercentage(this.hardcastUptimePercent, 1)}%</strong> of the encounter. The displayed healing number is the sum of several benefits, listed below:\r\n            <ul>\r\n              <li>Overall Increased Healing: <strong>{formatPercentage(this.owner.getPercentageOfTotalHealingDone(this.hardcast.allBoostHealing))}%</strong></li>\r\n              <li>Rejuv Increased Healing: <strong>{formatPercentage(this.owner.getPercentageOfTotalHealingDone(this.hardcast.rejuvBoostHealing))}%</strong></li>\r\n              <li>Rejuv Mana Saved: <strong>{formatNumber(this._getManaSaved(this.hardcast))}</strong> (assuming mana used to fill with Rejuvs: <strong>{formatPercentage(this.owner.getPercentageOfTotalHealingDone(this._getManaSavedHealing(this.hardcast)))}%</strong> healing)</li>\r\n              <li>Increased Wild Growths: <strong>{formatPercentage(this.owner.getPercentageOfTotalHealingDone(this.hardcast.extraWgHealing))}%</strong></li>\r\n            </ul>\r\n          </>\r\n        )}\r\n      >\r\n        <BoringValue label={<><SpellIcon id={SPELLS.INCARNATION_TREE_OF_LIFE_TALENT.id} /> Tree of Life healing</>}>\r\n          <>\r\n            {formatPercentage(this.owner.getPercentageOfTotalHealingDone(this._getTotalHealing(this.hardcast)))} %\r\n          </>\r\n        </BoringValue>\r\n      </Statistic>\r\n    );\r\n  }\r\n}\r\n\r\nexport default TreeOfLife;\r\n","import React from 'react';\r\nimport PropTypes from 'prop-types';\r\n\r\nimport SPELLS from 'common/SPELLS';\r\nimport SpellLink from 'common/SpellLink';\r\nimport { formatPercentage } from 'common/format';\r\n\r\nimport Checklist from 'parser/shared/modules/features/Checklist';\r\nimport Rule from 'parser/shared/modules/features/Checklist/Rule';\r\nimport Requirement from 'parser/shared/modules/features/Checklist/Requirement';\r\nimport PreparationRule from 'parser/shared/modules/features/Checklist/PreparationRule';\r\nimport GenericCastEfficiencyRequirement from 'parser/shared/modules/features/Checklist/GenericCastEfficiencyRequirement';\r\n\r\nconst RestorationDruidChecklist = ({ combatant, castEfficiency, thresholds }) => {\r\n  const AbilityRequirement = props => (\r\n    <GenericCastEfficiencyRequirement\r\n      castEfficiency={castEfficiency.getCastEfficiencyForSpellId(props.spell)}\r\n      {...props}\r\n    />\r\n  );\r\n  AbilityRequirement.propTypes = {\r\n    spell: PropTypes.number.isRequired,\r\n  };\r\n\r\n  return (\r\n    <Checklist>\r\n      <Rule\r\n        name=\"Stay active throughout the fight\"\r\n        description={(\r\n          <>\r\n            While constantly casting heals will quickly run you out of mana, you should still try to always be doing something throughout the fight. You can reduce your downtime while saving mana by spamming <SpellLink id={SPELLS.SOLAR_WRATH.id} /> on the boss when there is nothing serious to heal. If you safely healed through the entire fight and still had high non-healing time, your raid team is probably bringing too many healers.\r\n          </>\r\n        )}\r\n      >\r\n        <Requirement name=\"Non healing time\" thresholds={thresholds.nonHealingTime} />\r\n        <Requirement name=\"Downtime\" thresholds={thresholds.downtime} />\r\n      </Rule>\r\n      <Rule\r\n        name={(<>Use <SpellLink id={SPELLS.WILD_GROWTH.id} /> effectively</>)}\r\n        description={(\r\n          <>\r\n            Effective use of <SpellLink id={SPELLS.WILD_GROWTH.id} /> is incredibly important to your healing performance. When more than 5 raiders are wounded, it is probably the most efficienct and effective spell you can cast. Try to time your <SpellLink id={SPELLS.WILD_GROWTH.id} /> cast to land just after a boss ability in order to keep raiders healthy even through heavy AoE.\r\n          </>\r\n        )}\r\n      >\r\n        <Requirement\r\n          name={(\r\n            <>\r\n              <SpellLink id={SPELLS.WILD_GROWTH.id} /> / <SpellLink id={SPELLS.REJUVENATION.id} /> ratio\r\n            </>\r\n          )}\r\n          tooltip=\"This is your ratio of Wild Growth casts to Rejuvenation casts. If this number is too low, it probably indicates you were missing good opportunities to cast Wild Growth.\"\r\n          thresholds={thresholds.wildGrowthRatio}\r\n        />\r\n        <Requirement\r\n          name={(\r\n            <>\r\n              Low target <SpellLink id={SPELLS.WILD_GROWTH.id} /> casts\r\n            </>\r\n          )}\r\n          tooltip=\"This is your percent of Wild Growth casts that hit too few wounded targets. Low target casts happen either by casting it when almost all the raid was full health, or casting it on an isolated target. Remember that Wild Growth can only apply to players within 30 yds of the primary target, so if you use it on a target far away from the rest of the raid your cast will not be effective.\"\r\n          thresholds={thresholds.wildGrowthPercentBelowRecommendedCasts}\r\n        />\r\n        <Requirement\r\n          name={(\r\n            <>\r\n              High initial overhealing <SpellLink id={SPELLS.WILD_GROWTH.id} />\r\n            </>\r\n          )}\r\n          tooltip=\"This is your percent of Wild Growth casts that has high initial overhealing. Wild Growth does most of it's healing initially and declines over duration. Make sure you are not precasting it before damaging event but after damage occurs.\"\r\n          thresholds={thresholds.wildGrowthPercentBelowRecommendedPrecasts}\r\n        />\r\n      </Rule>\r\n      <Rule\r\n        name=\"Use your healing cooldowns\"\r\n        description={(\r\n          <>\r\n            Your cooldowns can be a big contributor to healing throughput when used frequently throughout the fight. When used early and often they can contribute a lot of healing for very little mana. Try to plan your major cooldowns like (<SpellLink id={SPELLS.TRANQUILITY_CAST.id} /> around big damage boss abilities, like the Transition Phase on Imonar or Fusillade on Antoran High Command. The below percentages represent the percentage of time you kept each spell on cooldown.\r\n          </>\r\n        )}\r\n      >\r\n        {combatant.hasTalent(SPELLS.CENARION_WARD_TALENT.id) && (\r\n          <AbilityRequirement spell={SPELLS.CENARION_WARD_TALENT.id} />\r\n        )}\r\n        {combatant.hasTalent(SPELLS.FLOURISH_TALENT.id) && (\r\n          <AbilityRequirement spell={SPELLS.FLOURISH_TALENT.id} />\r\n        )}\r\n        {combatant.hasTalent(SPELLS.INCARNATION_TREE_OF_LIFE_TALENT.id) && (\r\n          <AbilityRequirement spell={SPELLS.INCARNATION_TREE_OF_LIFE_TALENT.id} />\r\n        )}\r\n        <AbilityRequirement spell={SPELLS.TRANQUILITY_CAST.id} />\r\n        <AbilityRequirement spell={SPELLS.INNERVATE.id} />\r\n      </Rule>\r\n      <Rule\r\n        name={(\r\n          <>\r\n            Keep <SpellLink id={SPELLS.LIFEBLOOM_HOT_HEAL.id} /> and <SpellLink id={SPELLS.EFFLORESCENCE_CAST.id} /> active\r\n          </>\r\n        )}\r\n        description={(\r\n          <>\r\n            Maintaining uptime on these two important spells will improve your mana efficiency and overall throughput. It is good to keep <SpellLink id={SPELLS.LIFEBLOOM_HOT_HEAL.id} /> constantly active on a tank. While its throughput is comparable to a <SpellLink id={SPELLS.REJUVENATION.id} />, it also provides a constant chance to proc <SpellLink id={SPELLS.CLEARCASTING_BUFF.id} />. <SpellLink id={SPELLS.EFFLORESCENCE_CAST.id} /> is very mana efficient when it can tick over its full duration. Place it where raiders are liable to be and refresh it as soon as it expires.\r\n          </>\r\n        )}\r\n      >\r\n        <Requirement\r\n          name={(<><SpellLink id={SPELLS.EFFLORESCENCE_CAST.id} /> uptime</>)}\r\n          thresholds={thresholds.efflorescenceUpTime}\r\n        />\r\n      </Rule>\r\n      <Rule\r\n        name=\"Manage your mana\"\r\n        description={(\r\n          <>\r\n            Casting on targets who don't need healing or recklessly using inefficienct heals can result in running out of mana well before an encounter ends. Adapt your spell use to the situation, and as a rule of thumb try and keep your current mana percentage just above the bosses health percentage.\r\n          </>\r\n        )}\r\n      >\r\n        <Requirement\r\n          name={(\r\n            <>\r\n              Mana saved during <SpellLink id={SPELLS.INNERVATE.id} />\r\n            </>\r\n          )}\r\n          thresholds={thresholds.innervateAverageManaSaved}\r\n          tooltip=\"All spells cost no mana during Innervate, so take care to chain cast for its duration. Typically this means casting a Wild Growth, refreshing Efflorescence, and spamming Rejuvenation. It's also fine to Regrowth a target that is in immediate danger of dying.\"\r\n        />\r\n        <Requirement\r\n          name={(\r\n            <>Use your <SpellLink id={SPELLS.CLEARCASTING_BUFF.id} /> procs</>\r\n          )}\r\n          thresholds={thresholds.clearCastingUtil}\r\n          tooltip=\"This is the percentage of Clearcasting procs that you used. Regrowth is normally very expensive, but it's completely free with a Clearcasting proc. Use your procs in a timely fashion for a lot of free healing.\"\r\n        />\r\n        <Requirement\r\n          name={(\r\n            <>\r\n              Don't overuse <SpellLink id={SPELLS.REGROWTH.id} />\r\n            </>\r\n          )}\r\n          thresholds={thresholds.nonCCRegrowths}\r\n          tooltip=\"This is the number of no-clearcasting Regrowths you cast per minute. Regrowth is very mana inefficient, and should only be used in emergency situations (and when you've already expended Swiftmend). Usually, you should rely on other healers in your raid to triage.\"\r\n        />\r\n        <Requirement\r\n          name=\"Mana remaining at fight end\"\r\n          thresholds={thresholds.manaValues}\r\n          tooltip=\"Try to spend your mana at roughly the same rate the boss is dying. Having too much mana left at fight end could mean you were too conservative with your spell casts. If your mana is in good shape but there isn't much to heal, consider mixing Moonfire and Sunfire into your DPS rotation, which will burn some mana for extra DPS contribution.\"\r\n        />\r\n      </Rule>\r\n      <Rule\r\n        name=\"Use your defensive / emergency spells\"\r\n        description={(\r\n          <>Restoration Druids unfortunately do not have many tools to deal with burst damage, but you should take care to use the ones you have. Swiftmend is a fairly inefficient spell, and should only be used in an emergency. The below percentages represent the percentage of time you kept each spell on cooldown.</>\r\n        )}\r\n      >\r\n        <AbilityRequirement spell={SPELLS.SWIFTMEND.id} />\r\n        <AbilityRequirement spell={SPELLS.IRONBARK.id} />\r\n        <AbilityRequirement spell={SPELLS.BARKSKIN.id} />\r\n      </Rule>\r\n      <Rule\r\n        name=\"Pick the right tools for the fight\"\r\n        description={(\r\n          <>\r\n            Different talent choices can be more or less effective depending on the fight. Listed below you will see how much throughput some talents were providing.\r\n          </>\r\n        )}\r\n      >\r\n        {combatant.hasTalent(SPELLS.CULTIVATION.id) && (\r\n          <Requirement\r\n            name={(<><SpellLink id={SPELLS.CULTIVATION.id} /> throughput</>)}\r\n            thresholds={thresholds.cultivationPercent}\r\n            tooltip={`This is the percent of your total healing that Cultivation contributed. Below around ${formatPercentage(thresholds.cultivationPercent.isLessThan.average, 0)}%, you either had too many healers in this fight, or the fight is better for Tree of Life`}\r\n          />\r\n        )}\r\n        {combatant.hasTalent(SPELLS.SPRING_BLOSSOMS.id) && (\r\n          <Requirement\r\n            name={(<><SpellLink id={SPELLS.SPRING_BLOSSOMS.id} /> throughput</>)}\r\n            thresholds={thresholds.springBlossomsPercent}\r\n            tooltip={`This is the percent of your total healing that Spring Blossoms contributed. Below around ${formatPercentage(thresholds.springBlossomsPercent.isLessThan.average, 0)}%, you either weren't doing a good job with Efflorescence placement or you would have been better off picking Germination`}\r\n          />\r\n        )}\r\n        {combatant.hasTalent(SPELLS.INCARNATION_TREE_OF_LIFE_TALENT.id) && (\r\n          <Requirement\r\n            name={(<><SpellLink id={SPELLS.INCARNATION_TREE_OF_LIFE_TALENT.id} /> throughput</>)}\r\n            thresholds={thresholds.treeOfLifePercent}\r\n            tooltip={`This is the percent of your total healing that Tree of Life contributed. Below around ${formatPercentage(thresholds.treeOfLifePercent.isLessThan.average, 0)}%, you either didn't pick good times to use ToL or you would have been better off picking Cultivation`}\r\n          />\r\n        )}\r\n      </Rule>\r\n      <PreparationRule thresholds={thresholds} />\r\n    </Checklist>\r\n  );\r\n};\r\n\r\nRestorationDruidChecklist.propTypes = {\r\n  castEfficiency: PropTypes.object.isRequired,\r\n  combatant: PropTypes.shape({\r\n    hasTalent: PropTypes.func.isRequired,\r\n  }).isRequired,\r\n  thresholds: PropTypes.object.isRequired,\r\n};\r\n\r\nexport default RestorationDruidChecklist;\r\n","import React from 'react';\r\n\r\nimport BaseChecklist from 'parser/shared/modules/features/Checklist/Module';\r\nimport CastEfficiency from 'parser/shared/modules/CastEfficiency';\r\nimport Combatants from 'parser/shared/modules/Combatants';\r\nimport PreparationRuleAnalyzer from 'parser/shared/modules/features/Checklist/PreparationRuleAnalyzer';\r\nimport ManaValues from 'parser/shared/modules/ManaValues';\r\n\r\nimport AlwaysBeCasting from '../AlwaysBeCasting';\r\nimport Clearcasting from '../Clearcasting';\r\nimport Lifebloom from '../Lifebloom';\r\nimport Efflorescence from '../Efflorescence';\r\nimport Innervate from '../Innervate';\r\nimport WildGrowth from '../WildGrowth';\r\n\r\nimport Cultivation from '../../talents/Cultivation';\r\nimport SpringBlossoms from '../../talents/SpringBlossoms';\r\nimport TreeOfLife from '../../talents/TreeOfLife';\r\n\r\nimport Component from './Component';\r\n\r\nclass Checklist extends BaseChecklist {\r\n  static dependencies = {\r\n    combatants: Combatants,\r\n    castEfficiency: CastEfficiency,\r\n    preparationRuleAnalyzer: PreparationRuleAnalyzer,\r\n    alwaysBeCasting: AlwaysBeCasting,\r\n    wildGrowth: WildGrowth,\r\n    lifebloom: Lifebloom,\r\n    efflorescence: Efflorescence,\r\n    innervate: Innervate,\r\n    clearCasting: Clearcasting,\r\n    manaValues: ManaValues,\r\n    cultivation: Cultivation,\r\n    springBlossoms: SpringBlossoms,\r\n    treeOfLife: TreeOfLife,\r\n  };\r\n\r\n  render() {\r\n    return (\r\n      <Component\r\n        combatant={this.combatants.selected}\r\n        castEfficiency={this.castEfficiency}\r\n        thresholds={{\r\n          ...this.preparationRuleAnalyzer.thresholds,\r\n\r\n          downtime: this.alwaysBeCasting.downtimeSuggestionThresholds,\r\n          nonHealingTime: this.alwaysBeCasting.nonHealingTimeSuggestionThresholds,\r\n          wildGrowthRatio: this.wildGrowth.suggestionThresholds,\r\n          wildGrowthPercentBelowRecommendedCasts: this.wildGrowth.suggestionpercentBelowRecommendedCastsThresholds,\r\n          wildGrowthPercentBelowRecommendedPrecasts: this.wildGrowth.suggestionpercentBelowRecommendedPrecastsThresholds,\r\n          lifebloomUpTime: this.lifebloom.suggestionThresholds,\r\n          efflorescenceUpTime: this.efflorescence.suggestionThresholds,\r\n          innervateAverageManaSaved: this.innervate.averageManaSavedSuggestionThresholds,\r\n          clearCastingUtil: this.clearCasting.clearcastingUtilSuggestionThresholds,\r\n          nonCCRegrowths: this.clearCasting.nonCCRegrowthsSuggestionThresholds,\r\n          manaValues: this.manaValues.suggestionThresholds,\r\n          cultivationPercent: this.cultivation.suggestionThresholds,\r\n          springBlossomsPercent: this.springBlossoms.suggestionThresholds,\r\n          treeOfLifePercent: this.treeOfLife.suggestionThresholds,\r\n        }}\r\n      />\r\n    );\r\n  }\r\n}\r\n\r\nexport default Checklist;\r\n","import SPELLS from 'common/SPELLS';\r\nimport HotTracker from 'parser/shared/modules/HotTracker';\r\n\r\nclass HotTrackerRestoDruid extends HotTracker {\r\n\r\n  _generateHotInfo() { // must be generated dynamically because it reads from traits\r\n    return {\r\n      [SPELLS.REJUVENATION.id]: {\r\n        duration: 15000,\r\n        tickPeriod: 3000,\r\n      },\r\n      [SPELLS.REJUVENATION_GERMINATION.id]: {\r\n        duration: 15000,\r\n        tickPeriod: 3000,\r\n      },\r\n      [SPELLS.REGROWTH.id]: {\r\n        duration: 12000,\r\n        tickPeriod: 2000,\r\n      },\r\n      [SPELLS.WILD_GROWTH.id]: {\r\n        duration: 7000,\r\n        tickPeriod: 1000,\r\n      },\r\n      [SPELLS.LIFEBLOOM_HOT_HEAL.id]: {\r\n        duration: 15000,\r\n        tickPeriod: 1000,\r\n      },\r\n      [SPELLS.CENARION_WARD_HEAL.id]: {\r\n        duration: 8000,\r\n        tickPeriod: 2000,\r\n      },\r\n      [SPELLS.CULTIVATION.id]: {\r\n        duration: 6000,\r\n        tickPeriod: 2000,\r\n      },\r\n      [SPELLS.SPRING_BLOSSOMS.id]: {\r\n        duration: 6000,\r\n        tickPeriod: 2000,\r\n      },\r\n      [SPELLS.TRANQUILITY_HEAL.id]: {\r\n        duration: 8000,\r\n        tickPeriod: 2000,\r\n      },\r\n    };\r\n  }\r\n\r\n  _generateHotList() {\r\n    return [SPELLS.REJUVENATION, SPELLS.REJUVENATION_GERMINATION, SPELLS.REGROWTH, SPELLS.WILD_GROWTH, SPELLS.LIFEBLOOM_HOT_HEAL, SPELLS.CENARION_WARD_HEAL, SPELLS.CULTIVATION, SPELLS.SPRING_BLOSSOMS, SPELLS.TRANQUILITY_HEAL];\r\n  }\r\n}\r\n\r\nexport default HotTrackerRestoDruid;\r\n","import SPELLS from 'common/SPELLS';\r\nimport Analyzer, { SELECTED_PLAYER } from 'parser/core/Analyzer';\r\n\r\nimport Events from 'parser/core/Events';\r\n\r\nimport HotTrackerRestoDruid from './HotTrackerRestoDruid';\r\n\r\nconst REJUV_SPELLS = [\r\n  SPELLS.REJUVENATION,\r\n  SPELLS.REJUVENATION_GERMINATION,\r\n];\r\n\r\nconst BUFFER_MS = 150; // saw a few cases of taking close to 150ms from cast -> applybuff\r\n\r\n/*\r\n * Backend module tracks attribution of Rejuvenations\r\n * TODO - Dead module?\r\n */\r\nclass RejuvenationAttributor extends Analyzer {\r\n  static dependencies = {\r\n    hotTracker: HotTrackerRestoDruid,\r\n  };\r\n\r\n  // cast tracking stuff\r\n  lastRejuvCastTimestamp;\r\n  lastRejuvTarget;\r\n  castRejuvApplied; // occasionally procs happen on target that was just cast on, assures that no more than 1 apply/refreshbuff is attributed per cast\r\n  lastWildGrowthCastTimestamp;\r\n\r\n  constructor(...args) {\r\n    super(...args);\r\n    this.castRejuvApplied = true;\r\n    this.addEventListener(Events.cast.by(SELECTED_PLAYER).spell([SPELLS.REJUVENATION, SPELLS.WILD_GROWTH]), this.onCast);\r\n    this.addEventListener(Events.applybuff.by(SELECTED_PLAYER).spell(REJUV_SPELLS), this._getRejuvAttribution);\r\n    this.addEventListener(Events.refreshbuff.by(SELECTED_PLAYER).spell(REJUV_SPELLS), this._getRejuvAttribution);\r\n  }\r\n\r\n  onCast(event) {\r\n    const spellId = event.ability.guid;\r\n    const targetId = event.targetID;\r\n\r\n    // set last cast timestamps, used for attribution of HoT applications later\r\n    if (spellId === SPELLS.REJUVENATION.id) {\r\n      this.lastRejuvCastTimestamp = event.timestamp;\r\n      this.lastRejuvTarget = targetId;\r\n      this.castRejuvApplied = false;\r\n    } else if (spellId === SPELLS.WILD_GROWTH.id) {\r\n      this.lastWildGrowthCastTimestamp = event.timestamp;\r\n    }\r\n  }\r\n\r\n  // gets attribution for a given applybuff/refreshbuff of Rejuvenation or Germination\r\n  _getRejuvAttribution(event) {\r\n    const spellId = event.ability.guid;\r\n    const targetId = event.targetID;\r\n    if (!this.hotTracker.hots[targetId] || !this.hotTracker.hots[targetId][spellId]) {\r\n      return;\r\n    }\r\n\r\n    const timestamp = event.timestamp;\r\n    const attributions = [];\r\n\r\n    if (event.prepull || (this.lastRejuvCastTimestamp + BUFFER_MS > timestamp && this.lastRejuvTarget === targetId && !this.castRejuvApplied)) {\r\n      // regular cast (assume prepull applications are hardcast)\r\n      // standard hardcast gets no special attribution\r\n      this.castRejuvApplied = true;\r\n    } else {\r\n      console.warn(`Unable to attribute Rejuv @${this.owner.formatTimestamp(timestamp)} on ${targetId}`);\r\n    }\r\n\r\n    attributions.forEach(att => {\r\n      this.hotTracker.addAttribution(att, targetId, spellId);\r\n    });\r\n  }\r\n\r\n}\r\n\r\nexport default RejuvenationAttributor;\r\n","import SPELLS from 'common/SPELLS';\r\nimport Analyzer, { SELECTED_PLAYER } from 'parser/core/Analyzer';\r\n\r\nimport Events from 'parser/core/Events';\r\n\r\nimport HotTrackerRestoDruid from './HotTrackerRestoDruid';\r\n\r\nconst BUFFER_MS = 150; // saw a few cases of taking close to 150ms from cast -> applybuff\r\n/*\r\n * Backend module tracks attribution of Regrowth\r\n * TODO - Dead module?\r\n */\r\nclass RegrowthAttributor extends Analyzer {\r\n  static dependencies = {\r\n    hotTracker: HotTrackerRestoDruid,\r\n  };\r\n\r\n  // cast tracking stuff\r\n  lastRegrowthCastTimestamp;\r\n  lastRegrowthTarget;\r\n\r\n  totalNonCCRegrowthHealing = 0;\r\n  totalNonCCRegrowthOverhealing = 0;\r\n  totalNonCCRegrowthAbsorbs = 0;\r\n  totalNonCCRegrowthHealingTicks = 0;\r\n\r\n  constructor(options) {\r\n    super(options);\r\n    this.addEventListener(Events.cast.by(SELECTED_PLAYER).spell(SPELLS.REGROWTH), this.onCast);\r\n    this.addEventListener(Events.heal.by(SELECTED_PLAYER).spell(SPELLS.REGROWTH), this.onHeal);\r\n    this.addEventListener(Events.applybuff.by(SELECTED_PLAYER).spell(SPELLS.REGROWTH), this._getRegrowthAttribution);\r\n    this.addEventListener(Events.refreshbuff.by(SELECTED_PLAYER).spell(SPELLS.REGROWTH), this._getRegrowthAttribution);\r\n  }\r\n\r\n  onCast(event) {\r\n    const targetId = event.targetID;\r\n\r\n    // set last cast timestamps, used for attribution of HoT applications later\r\n    this.lastRegrowthCastTimestamp = event.timestamp;\r\n    this.lastRegrowthTarget = targetId;\r\n  }\r\n\r\n  onHeal(event) {\r\n    if (!this.selectedCombatant.hasBuff(SPELLS.CLEARCASTING_BUFF.id, event.timestamp, BUFFER_MS)) {\r\n      this.totalNonCCRegrowthHealing += event.amount;\r\n      this.totalNonCCRegrowthOverhealing += event.overheal || 0;\r\n      this.totalNonCCRegrowthAbsorbs += event.absorbed || 0;\r\n      if (event.tick) {\r\n        this.totalNonCCRegrowthHealingTicks += 1;\r\n      }\r\n    }\r\n  }\r\n\r\n  // gets attribution for a given applybuff/refreshbuff of Regrowth\r\n  _getRegrowthAttribution(event) {\r\n    const spellId = event.ability.guid;\r\n    const targetId = event.targetID;\r\n    if (!this.hotTracker.hots[targetId] || !this.hotTracker.hots[targetId][spellId]) {\r\n      return;\r\n    }\r\n\r\n    const timestamp = event.timestamp;\r\n    const attributions = [];\r\n\r\n    if (event.prepull || (this.lastRegrowthCastTimestamp + BUFFER_MS > timestamp && this.lastRegrowthTarget === targetId)) { // regular cast (assume prepull applications are hardcast)\r\n      // standard hardcast gets no special attribution\r\n    } else {\r\n      console.warn(`Unable to attribute Regrowth @${this.owner.formatTimestamp(timestamp)} on ${targetId}`);\r\n    }\r\n\r\n    attributions.forEach(att => {\r\n      this.hotTracker.addAttribution(att, targetId, spellId);\r\n    });\r\n  }\r\n\r\n}\r\n\r\nexport default RegrowthAttributor;\r\n","import CoreSpellManaCost from 'parser/shared/modules/SpellManaCost';\r\nimport SPELLS from 'common/SPELLS/index';\r\n\r\nconst MS_BUFFER = 200;\r\nconst ABUNDANCE_MANA_REDUCTION = 0.06;\r\nconst TOL_REJUVENATION_REDUCTION = 0.3;\r\n\r\nclass SpellManaCost extends CoreSpellManaCost {\r\n  getResourceCost(event) {\r\n    const spellId = event.ability.guid;\r\n    let cost = super.getResourceCost(event);\r\n    if (cost === 0) {\r\n      return cost;\r\n    }\r\n\r\n    if (this.selectedCombatant.hasBuff(SPELLS.CLEARCASTING_BUFF.id, event.timestamp, MS_BUFFER, 0, event.sourceId) && spellId === SPELLS.REGROWTH.id) {\r\n      return 0;\r\n    }\r\n\r\n    // Mana is not adjusted for ToL\r\n    if (this.selectedCombatant.hasBuff(SPELLS.INCARNATION_TREE_OF_LIFE_TALENT.id, event.timestamp, 0, 0, event.sourceId) && (spellId === SPELLS.REJUVENATION.id || spellId === SPELLS.REJUVENATION_GERMINATION)) {\r\n      cost = cost - (cost * TOL_REJUVENATION_REDUCTION);\r\n    }\r\n\r\n    // Mana is not adjusted for Regrowth + abundance\r\n    if (spellId === SPELLS.REGROWTH.id) {\r\n      const abundanceBuff = this.selectedCombatant.getBuff(SPELLS.ABUNDANCE_BUFF.id, event.timestamp, MS_BUFFER);\r\n      if (abundanceBuff != null) {\r\n        return cost - (cost * abundanceBuff.stacks * ABUNDANCE_MANA_REDUCTION);\r\n      }\r\n    }\r\n\r\n    return cost;\r\n  }\r\n}\r\n\r\nexport default SpellManaCost;\r\n","import React from 'react';\r\nimport STATISTIC_ORDER from 'interface/others/STATISTIC_ORDER';\r\nimport Statistic from 'interface/statistics/Statistic';\r\nimport SpellIcon from 'common/SpellIcon';\r\nimport BoringValue from 'interface/statistics/components/BoringValueText';\r\n\r\nimport SPELLS from 'common/SPELLS';\r\nimport Analyzer from 'parser/core/Analyzer';\r\n\r\nimport Mastery from '../core/Mastery';\r\n\r\nclass AverageHots extends Analyzer {\r\n  static dependencies = {\r\n    mastery: Mastery,\r\n  };\r\n\r\n  statistic() {\r\n    const avgTotalHots = (this.mastery.getAverageTotalMasteryStacks()).toFixed(2);\r\n    const avgDruidHots = (this.mastery.getAverageDruidSpellMasteryStacks()).toFixed(2);\r\n\r\n    return (\r\n      <Statistic\r\n        position={STATISTIC_ORDER.CORE(11)}\r\n        size=\"flexible\"\r\n        tooltip={(\r\n          <>\r\n            This is the average number of mastery stacks your heals benefitted from, weighted by healing done. It can help show how much mileage you're getting out of your mastery.<br /><br />\r\n\r\n            Not all of this number is within your control. Having to do a lot of tank healing or speccing for Cultivation and/or Spring Blossoms tends to produce higher average mastery stacks, while playing in larger raid groups tends to produce lower average mastery stacks.<br /><br />\r\n\r\n            This number counts all your healing, even heals that don't benefit from your mastery (like most trinkets). Your average mastery stacks counting only heals that benefit from mastery is <strong>{avgDruidHots}</strong>.\r\n          </>\r\n        )}\r\n      >\r\n        <BoringValue label={<><SpellIcon id={SPELLS.MASTERY_HARMONY.id} /> Average Mastery stacks</>}>\r\n          <>\r\n            {avgTotalHots}\r\n          </>\r\n        </BoringValue>\r\n      </Statistic>\r\n    );\r\n  }\r\n\r\n}\r\n\r\nexport default AverageHots;\r\n","import SPELLS from 'common/SPELLS';\r\nimport ISSUE_IMPORTANCE from 'parser/core/ISSUE_IMPORTANCE';\r\nimport CoreAbilities from 'parser/core/modules/Abilities';\r\n\r\nclass Abilities extends CoreAbilities {\r\n  spellbook() {\r\n    const combatant = this.selectedCombatant;\r\n    return [\r\n      {\r\n        spell: SPELLS.TRANQUILITY_CAST,\r\n        category: Abilities.SPELL_CATEGORIES.COOLDOWNS,\r\n        cooldown: combatant.hasTalent(SPELLS.INNER_PEACE_TALENT.id) ? 120 : 180,\r\n        gcd: {\r\n          base: 1500,\r\n        },\r\n        castEfficiency: {\r\n          suggestion: true,\r\n          recommendedEfficiency: 0.75,\r\n          averageIssueEfficiency: 0.55,\r\n          majorIssueEfficiency: 0.30,\r\n        },\r\n        healSpellIds: [\r\n          SPELLS.TRANQUILITY_HEAL.id,\r\n        ],\r\n      },\r\n      {\r\n        spell: SPELLS.NATURES_SWIFTNESS,\r\n        category: Abilities.SPELL_CATEGORIES.COOLDOWNS,\r\n        cooldown: 60,//TODO include conduit reduction\r\n        gcd: {\r\n          base: 1500,\r\n        },\r\n        castEfficiency: {\r\n          suggestion: true,\r\n        },\r\n      },\r\n      {\r\n        spell: SPELLS.INNERVATE,\r\n        category: Abilities.SPELL_CATEGORIES.COOLDOWNS,\r\n        cooldown: 180,\r\n        gcd: {\r\n          base: 1500,\r\n        },\r\n        castEfficiency: {\r\n          suggestion: true,\r\n        },\r\n      },\r\n      {\r\n        spell: SPELLS.IRONBARK,\r\n        category: Abilities.SPELL_CATEGORIES.COOLDOWNS,\r\n        cooldown: 60,\r\n        castEfficiency: {\r\n          suggestion: true,\r\n          importance: ISSUE_IMPORTANCE.MINOR,\r\n          recommendedEfficiency: 0.60,\r\n        },\r\n      },\r\n      {\r\n        spell: SPELLS.BARKSKIN,\r\n        buffSpellId: SPELLS.BARKSKIN.id,\r\n        category: Abilities.SPELL_CATEGORIES.DEFENSIVE,\r\n        cooldown: 60,\r\n        castEfficiency: {\r\n          suggestion: true,\r\n          importance: ISSUE_IMPORTANCE.MINOR,\r\n          recommendedEfficiency: 0.60,\r\n        },\r\n      },\r\n      {\r\n        spell: SPELLS.CENARION_WARD_TALENT,\r\n        category: Abilities.SPELL_CATEGORIES.ROTATIONAL,\r\n        cooldown: 30,\r\n        gcd: {\r\n          base: 1500,\r\n        },\r\n        enabled: combatant.hasTalent(SPELLS.CENARION_WARD_TALENT.id),\r\n        castEfficiency: {\r\n          suggestion: true,\r\n        },\r\n        healSpellIds: [\r\n          SPELLS.CENARION_WARD_HEAL.id,\r\n        ],\r\n      },\r\n      {\r\n        spell: SPELLS.FLOURISH_TALENT,\r\n        category: Abilities.SPELL_CATEGORIES.COOLDOWNS,\r\n        cooldown: 90,\r\n        gcd: {\r\n          base: 1500,\r\n        },\r\n        enabled: combatant.hasTalent(SPELLS.FLOURISH_TALENT.id),\r\n        castEfficiency: {\r\n          suggestion: true,\r\n          recommendedEfficiency: 0.75,\r\n          averageIssueEfficiency: 0.55,\r\n          majorIssueEfficiency: 0.30,\r\n        },\r\n      },\r\n      {\r\n        spell: SPELLS.WILD_GROWTH,\r\n        category: Abilities.SPELL_CATEGORIES.ROTATIONAL_AOE,\r\n        cooldown: 10,\r\n        gcd: {\r\n          base: 1500,\r\n        },\r\n      },\r\n      {\r\n        spell: SPELLS.EFFLORESCENCE_CAST,\r\n        category: Abilities.SPELL_CATEGORIES.ROTATIONAL_AOE,\r\n        gcd: {\r\n          base: 1500,\r\n        },\r\n        healSpellIds: [\r\n          SPELLS.EFFLORESCENCE_HEAL.id,\r\n          SPELLS.SPRING_BLOSSOMS.id,\r\n        ],\r\n      },\r\n      {\r\n        spell: SPELLS.REJUVENATION,\r\n        category: Abilities.SPELL_CATEGORIES.ROTATIONAL,\r\n        gcd: {\r\n          base: 1500,\r\n        },\r\n        healSpellIds: [\r\n          SPELLS.REJUVENATION_GERMINATION.id,\r\n          SPELLS.CULTIVATION.id,\r\n          // TODO - Add part of ysera's gift to be included if you have azerite trait waking dream\r\n        ],\r\n      },\r\n      {\r\n        spell: SPELLS.INCARNATION_TREE_OF_LIFE_TALENT,\r\n        category: Abilities.SPELL_CATEGORIES.COOLDOWNS,\r\n        enabled: combatant.hasTalent(SPELLS.INCARNATION_TREE_OF_LIFE_TALENT.id),\r\n        cooldown: 180,\r\n        gcd: {\r\n          base: 1500,\r\n        },\r\n        castEfficiency: {\r\n          suggestion: true,\r\n          recommendedEfficiency: 0.80,\r\n          averageIssueEfficiency: 0.60,\r\n          majorIssueEfficiency: 0.40,\r\n        },\r\n      },\r\n      {\r\n        spell: SPELLS.REGROWTH,\r\n        category: Abilities.SPELL_CATEGORIES.ROTATIONAL,\r\n        gcd: {\r\n          base: 1500,\r\n        },\r\n      },\r\n      {\r\n        spell: SPELLS.SWIFTMEND,\r\n        category: Abilities.SPELL_CATEGORIES.ROTATIONAL,\r\n        cooldown: 15,\r\n        gcd: {\r\n          base: 1500,\r\n        },\r\n        castEfficiency: {\r\n          suggestion: true,\r\n          recommendedEfficiency: 0.40,\r\n          averageIssueEfficiency: 0.00, // average and \"negative\" major included for checklist bar scaling in line with a \"minor\" issue\r\n          majorIssueEfficiency: -1,\r\n          importance: ISSUE_IMPORTANCE.MINOR,\r\n        },\r\n      },\r\n      {\r\n        spell: SPELLS.RENEWAL_TALENT,\r\n        category: Abilities.SPELL_CATEGORIES.COOLDOWNS,\r\n        enabled: combatant.hasTalent(SPELLS.RENEWAL_TALENT.id),\r\n        cooldown: 90,\r\n        castEfficiency: {\r\n          suggestion: true,\r\n        },\r\n      },\r\n      {\r\n        spell: SPELLS.LIFEBLOOM_HOT_HEAL,\r\n        category: Abilities.SPELL_CATEGORIES.ROTATIONAL,\r\n        gcd: {\r\n          base: 1500,\r\n        },\r\n        healSpellIds: [\r\n          SPELLS.LIFEBLOOM_BLOOM_HEAL.id,\r\n        ],\r\n      },\r\n      {\r\n        spell: SPELLS.NATURES_CURE,\r\n        category: Abilities.SPELL_CATEGORIES.OTHERS,\r\n        cooldown: 8,\r\n        gcd: {\r\n          base: 1500,\r\n        },\r\n      },\r\n      {\r\n        spell: SPELLS.REBIRTH,\r\n        category: Abilities.SPELL_CATEGORIES.UTILITY,\r\n        gcd: {\r\n          base: 1500,\r\n        },\r\n      },\r\n      {\r\n        spell: SPELLS.SOOTHE,\r\n        category: Abilities.SPELL_CATEGORIES.UTILITY,\r\n        cooldown: 10,\r\n        gcd: {\r\n          base: 1500,\r\n        },\r\n      },\r\n      {\r\n        spell: SPELLS.GROWL,\r\n        category: Abilities.SPELL_CATEGORIES.UTILITY,\r\n        cooldown: 8,\r\n      },\r\n      //Damage Dealing\r\n      {\r\n        spell: SPELLS.SOLAR_WRATH,\r\n        category: Abilities.SPELL_CATEGORIES.HEALER_DAMAGING_SPELL,\r\n        gcd: {\r\n          base: 1500,\r\n        },\r\n      },\r\n      {\r\n        spell: SPELLS.MOONFIRE,\r\n        category: Abilities.SPELL_CATEGORIES.HEALER_DAMAGING_SPELL,\r\n        gcd: {\r\n          base: 1500,\r\n        },\r\n      },\r\n      {\r\n        spell: SPELLS.SUNFIRE_CAST,\r\n        category: Abilities.SPELL_CATEGORIES.HEALER_DAMAGING_SPELL,\r\n        gcd: {\r\n          base: 1500,\r\n        },\r\n      },\r\n      {\r\n        spell: SPELLS.MANGLE_BEAR,\r\n        category: Abilities.SPELL_CATEGORIES.OTHERS,\r\n        cooldown: haste => 6 / (1 + haste),\r\n        gcd: {\r\n          base: 1500,\r\n        },\r\n      },\r\n      {\r\n        spell: SPELLS.SHRED,\r\n        category: Abilities.SPELL_CATEGORIES.OTHERS,\r\n        gcd: {\r\n          static: 1000,\r\n        },\r\n      },\r\n      //Forms\r\n      {\r\n        spell: SPELLS.STAG_FORM,\r\n        category: Abilities.SPELL_CATEGORIES.OTHERS,\r\n        gcd: {\r\n          base: 1500,\r\n        },\r\n      },\r\n      {\r\n        spell: SPELLS.TRAVEL_FORM,\r\n        category: Abilities.SPELL_CATEGORIES.OTHERS,\r\n        gcd: {\r\n          base: 1500,\r\n        },\r\n      },\r\n      {\r\n        spell: SPELLS.BEAR_FORM,\r\n        buffSpellId: SPELLS.BEAR_FORM.id,\r\n        category: Abilities.SPELL_CATEGORIES.DEFENSIVE,\r\n        gcd: {\r\n          base: 1500,\r\n        },\r\n      },\r\n      {\r\n        spell: SPELLS.CAT_FORM,\r\n        category: Abilities.SPELL_CATEGORIES.OTHERS,\r\n        gcd: {\r\n          base: 1500,\r\n        },\r\n      },\r\n      {\r\n        spell: SPELLS.MOONKIN_FORM,\r\n        category: Abilities.SPELL_CATEGORIES.OTHERS,\r\n        enabled: combatant.hasTalent(SPELLS.BALANCE_AFFINITY_TALENT_RESTORATION.id),\r\n        gcd: {\r\n          base: 1500,\r\n        },\r\n      },\r\n      //Guardian Affinity\r\n      {\r\n        spell: SPELLS.THRASH_BEAR,\r\n        category: Abilities.SPELL_CATEGORIES.OTHERS,\r\n        enabled: combatant.hasTalent(SPELLS.GUARDIAN_AFFINITY_TALENT_SHARED.id),\r\n        cooldown: 30,\r\n        gcd: {\r\n          base: 1500,\r\n        },\r\n      },\r\n      {\r\n        spell: SPELLS.THRASH_FERAL,\r\n        category: Abilities.SPELL_CATEGORIES.OTHERS,\r\n        enabled: combatant.hasTalent(SPELLS.GUARDIAN_AFFINITY_TALENT_SHARED.id),\r\n        gcd: {\r\n          static: 1000,\r\n        },\r\n      },\r\n      {\r\n        spell: SPELLS.FRENZIED_REGENERATION,\r\n        category: Abilities.SPELL_CATEGORIES.OTHERS,\r\n        enabled: combatant.hasTalent(SPELLS.GUARDIAN_AFFINITY_TALENT_SHARED.id),\r\n        cooldown: 30,\r\n        gcd: {\r\n          base: 1500,\r\n        },\r\n      },\r\n      {\r\n        spell: SPELLS.IRONFUR,\r\n        category: Abilities.SPELL_CATEGORIES.OTHERS,\r\n        enabled: combatant.hasTalent(SPELLS.GUARDIAN_AFFINITY_TALENT_SHARED.id),\r\n        cooldown: 0.5,\r\n      },\r\n\r\n      //Feral Affinity\r\n      {\r\n        spell: SPELLS.SWIPE_CAT,\r\n        category: Abilities.SPELL_CATEGORIES.OTHERS,\r\n        enabled: combatant.hasTalent(SPELLS.FERAL_AFFINITY_TALENT_RESTORATION.id),\r\n        gcd: {\r\n          static: 1000,\r\n        },\r\n      },\r\n      {\r\n        spell: SPELLS.SWIPE_BEAR,\r\n        category: Abilities.SPELL_CATEGORIES.OTHERS,\r\n        enabled: combatant.hasTalent(SPELLS.FERAL_AFFINITY_TALENT_RESTORATION.id),\r\n        gcd: {\r\n          base: 1500,\r\n        },\r\n      },\r\n      {\r\n        spell: SPELLS.RIP,\r\n        category: Abilities.SPELL_CATEGORIES.OTHERS,\r\n        enabled: combatant.hasTalent(SPELLS.FERAL_AFFINITY_TALENT_RESTORATION.id),\r\n        gcd: {\r\n          static: 1000,\r\n        },\r\n      },\r\n      {\r\n        spell: SPELLS.FEROCIOUS_BITE,\r\n        category: Abilities.SPELL_CATEGORIES.OTHERS,\r\n        enabled: combatant.hasTalent(SPELLS.FERAL_AFFINITY_TALENT_RESTORATION.id),\r\n        gcd: {\r\n          static: 1000,\r\n        },\r\n      },\r\n      {\r\n        spell: SPELLS.RAKE,\r\n        category: Abilities.SPELL_CATEGORIES.OTHERS,\r\n        enabled: combatant.hasTalent(SPELLS.FERAL_AFFINITY_TALENT_RESTORATION.id),\r\n        gcd: {\r\n          static: 1000,\r\n        },\r\n      },\r\n\r\n      //Balance Affinity\r\n      {\r\n        spell: SPELLS.STARSURGE_AFFINITY,\r\n        category: Abilities.SPELL_CATEGORIES.OTHERS,\r\n        enabled: combatant.hasTalent(SPELLS.BALANCE_AFFINITY_TALENT_RESTORATION.id),\r\n        cooldown: 10,\r\n        gcd: {\r\n          base: 1500,\r\n        },\r\n      },\r\n      {\r\n        spell: SPELLS.LUNAR_STRIKE_AFFINITY,\r\n        category: Abilities.SPELL_CATEGORIES.OTHERS,\r\n        enabled: combatant.hasTalent(SPELLS.BALANCE_AFFINITY_TALENT_RESTORATION.id),\r\n        gcd: {\r\n          base: 1500,\r\n        },\r\n      },\r\n\r\n      //Movement\r\n      {\r\n        spell: SPELLS.WILD_CHARGE_TALENT,\r\n        category: Abilities.SPELL_CATEGORIES.UTILITY,\r\n        enabled: combatant.hasTalent(SPELLS.WILD_CHARGE_TALENT.id),\r\n        cooldown: 15,\r\n        gcd: null,\r\n      },\r\n      {\r\n        spell: SPELLS.WILD_CHARGE_BEAR,\r\n        category: Abilities.SPELL_CATEGORIES.UTILITY,\r\n        enabled: combatant.hasTalent(SPELLS.WILD_CHARGE_TALENT.id),\r\n        cooldown: 15,\r\n        gcd: null,\r\n      },\r\n      {\r\n        spell: SPELLS.WILD_CHARGE_CAT,\r\n        category: Abilities.SPELL_CATEGORIES.UTILITY,\r\n        enabled: combatant.hasTalent(SPELLS.WILD_CHARGE_TALENT.id),\r\n        cooldown: 15,\r\n        gcd: null,\r\n      },\r\n      {\r\n        spell: SPELLS.WILD_CHARGE_MOONKIN,\r\n        category: Abilities.SPELL_CATEGORIES.UTILITY,\r\n        enabled: combatant.hasTalent(SPELLS.WILD_CHARGE_TALENT.id),\r\n        cooldown: 15,\r\n        gcd: null,\r\n      },\r\n      {\r\n        spell: SPELLS.DASH,\r\n        category: Abilities.SPELL_CATEGORIES.UTILITY,\r\n        cooldown: 120,\r\n        gcd: (combatant => {\r\n          if (combatant.hasBuff(SPELLS.CAT_FORM.id)) {\r\n            // off the GCD if player is already in cat form\r\n            return null;\r\n          }\r\n          return {\r\n            static: 1500,\r\n          };\r\n        }),\r\n      },\r\n      {\r\n        spell: SPELLS.TIGER_DASH_TALENT,\r\n        category: Abilities.SPELL_CATEGORIES.UTILITY,\r\n        enabled: combatant.hasTalent(SPELLS.TIGER_DASH_TALENT.id),\r\n        cooldown: 45,\r\n        gcd: (combatant => {\r\n          if (combatant.hasBuff(SPELLS.CAT_FORM.id)) {\r\n            // off the GCD if player is already in cat form\r\n            return null;\r\n          }\r\n          return {\r\n            static: 1500,\r\n          };\r\n        }),\r\n      },\r\n\r\n      //CC\r\n      {\r\n        spell: SPELLS.HIBERNATE,\r\n        category: Abilities.SPELL_CATEGORIES.UTILITY,\r\n        gcd: {\r\n          base: 1500,\r\n        },\r\n      },\r\n      {\r\n        spell: SPELLS.TYPHOON,\r\n        category: Abilities.SPELL_CATEGORIES.UTILITY,\r\n        cooldown: 30,\r\n        gcd: {\r\n          base: 1500,\r\n        },\r\n        enabled: combatant.hasTalent(SPELLS.TYPHOON.id),\r\n      },\r\n      {\r\n        spell: SPELLS.MIGHTY_BASH_TALENT,\r\n        category: Abilities.SPELL_CATEGORIES.UTILITY,\r\n        cooldown: 50,\r\n        gcd: {\r\n          base: 1500,\r\n        },\r\n        enabled: combatant.hasTalent(SPELLS.MIGHTY_BASH_TALENT.id),\r\n      },\r\n      {\r\n        spell: SPELLS.URSOLS_VORTEX,\r\n        category: Abilities.SPELL_CATEGORIES.OTHERS,\r\n        cooldown: 60,\r\n        gcd: {\r\n          base: 1500,\r\n        },\r\n      },\r\n      {\r\n        spell: SPELLS.ENTANGLING_ROOTS,\r\n        category: Abilities.SPELL_CATEGORIES.UTILITY,\r\n        gcd: {\r\n          base: 1500,\r\n        },\r\n        enabled: combatant.hasTalent(SPELLS.MASS_ENTANGLEMENT_TALENT.id),\r\n      },\r\n      {\r\n        spell: SPELLS.MASS_ENTANGLEMENT_TALENT,\r\n        category: Abilities.SPELL_CATEGORIES.UTILITY,\r\n        cooldown: 30,\r\n        gcd: {\r\n          base: 1500,\r\n        },\r\n        enabled: combatant.hasTalent(SPELLS.MASS_ENTANGLEMENT_TALENT.id),\r\n      },\r\n      {\r\n        spell: SPELLS.OVERGROWTH_TALENT,\r\n        category: Abilities.SPELL_CATEGORIES.ROTATIONAL,\r\n        cooldown: 60,\r\n        gcd: {\r\n          base: 1500,\r\n        },\r\n        enabled: combatant.hasTalent(SPELLS.OVERGROWTH_TALENT.id),\r\n      },\r\n    ];\r\n  }\r\n}\r\n\r\nexport default Abilities;\r\n","import SPELLS from 'common/SPELLS';\r\nimport CoreCooldownThroughputTracker, { BUILT_IN_SUMMARY_TYPES } from 'parser/shared/modules/CooldownThroughputTracker';\r\n\r\nclass CooldownThroughputTracker extends CoreCooldownThroughputTracker {\r\n  static cooldownSpells = [\r\n    ...CoreCooldownThroughputTracker.cooldownSpells,\r\n    {\r\n      spell: SPELLS.INCARNATION_TREE_OF_LIFE_TALENT,\r\n      summary: [\r\n        BUILT_IN_SUMMARY_TYPES.HEALING,\r\n        BUILT_IN_SUMMARY_TYPES.OVERHEALING,\r\n        BUILT_IN_SUMMARY_TYPES.MANA,\r\n      ],\r\n    },\r\n  ];\r\n}\r\n\r\nexport default CooldownThroughputTracker;\r\n","import React from 'react';\r\nimport { formatNumber, formatPercentage } from 'common/format';\r\nimport STATISTIC_ORDER from 'interface/others/STATISTIC_ORDER';\r\nimport Statistic from 'interface/statistics/Statistic';\r\nimport SpellIcon from 'common/SpellIcon';\r\nimport BoringValue from 'interface/statistics/components/BoringValueText';\r\n\r\nimport SPELLS from 'common/SPELLS';\r\nimport fetchWcl from 'common/fetchWclApi';\r\nimport Analyzer, { SELECTED_PLAYER } from 'parser/core/Analyzer';\r\nimport Events, { EventType } from 'parser/core/Events';\r\n\r\nconst IRONBARK_BASE_DR = 0.20;\r\n\r\nclass Ironbark extends Analyzer {\r\n  get damageReduced() {\r\n    return this.damageTakenDuringIronbark / (1 - IRONBARK_BASE_DR) * IRONBARK_BASE_DR;\r\n  }\r\n\r\n  ironbarkCount = 0;\r\n  damageTakenDuringIronbark = 0;\r\n\r\n  constructor(options) {\r\n    super(options);\r\n    this.addEventListener(Events.cast.by(SELECTED_PLAYER).spell(SPELLS.IRONBARK), this.onCast);\r\n    this.loadDamageTakenDuringIronbark();\r\n  }\r\n\r\n  onCast(event) {\r\n    this.ironbarkCount += 1;\r\n  }\r\n\r\n  loadDamageTakenDuringIronbark() {\r\n    fetchWcl(`report/tables/damage-taken/${this.owner.report.code}`, {\r\n      start: this.owner.fight.start_time,\r\n      end: this.owner.fight.end_time,\r\n      filter: `(IN RANGE FROM type='${EventType.ApplyBuff}' AND ability.id=${SPELLS.IRONBARK.id} AND source.name='${this.selectedCombatant.name}' TO type='${EventType.RemoveBuff}' AND ability.id=${SPELLS.IRONBARK.id} AND source.name='${this.selectedCombatant.name}' GROUP BY target ON target END)`,\r\n    })\r\n      .then((json) => {\r\n        this.damageTakenDuringIronbark = json.entries.reduce((damageTaken, entry) => damageTaken + entry.total, 0);\r\n      })\r\n      .catch(err => {\r\n        throw err;\r\n      });\r\n  }\r\n\r\n  statistic() {\r\n    if (this.damageTakenDuringIronbark) {\r\n      return (\r\n        <Statistic\r\n          position={STATISTIC_ORDER.CORE(20)}\r\n          size=\"flexible\"\r\n          tooltip={(\r\n            <>\r\n              This is the average amount of damage you prevented per Ironbark cast. The total damage prevented over your <strong>{this.ironbarkCount} casts</strong> was <strong>{formatNumber(this.damageReduced)}</strong>.\r\n              While this amount is not counted in your healing done, this is equivalent to <strong>{formatPercentage(this.owner.getPercentageOfTotalHealingDone(this.damageReduced))}%</strong> of your total healing.\r\n            </>\r\n          )}\r\n        >\r\n          <BoringValue label={<><SpellIcon id={SPELLS.IRONBARK.id} /> Average Ironbark mitigation</>}>\r\n            <>\r\n              {formatNumber(this.damageReduced / this.ironbarkCount)}\r\n            </>\r\n          </BoringValue>\r\n        </Statistic>\r\n      );\r\n    } else {\r\n      return '';\r\n    }\r\n  }\r\n}\r\n\r\nexport default Ironbark;\r\n","import React from 'react';\r\nimport SPELLS from 'common/SPELLS/index';\r\nimport Analyzer, { SELECTED_PLAYER } from 'parser/core/Analyzer';\r\nimport HealingDone from 'parser/shared/modules/throughput/HealingDone';\r\nimport STATISTIC_ORDER from 'interface/others/STATISTIC_ORDER';\r\nimport BoringValue from 'interface/statistics/components/BoringValueText';\r\nimport SpellIcon from 'common/SpellIcon';\r\nimport Statistic from 'interface/statistics/Statistic';\r\nimport SpellLink from 'common/SpellLink';\r\nimport Combatants from 'parser/shared/modules/Combatants';\r\nimport Events from 'parser/core/Events';\r\nimport { i18n } from '@lingui/core';\r\nimport { t } from '@lingui/macro';\r\n\r\nconst debug = false;\r\n\r\nconst REJUV_DURATION = 15000;\r\nconst MS_BUFFER = 200;\r\nconst PANDEMIC_THRESHOLD = 0.7;\r\nconst FLOURISH_EXTENSION = 8000;\r\n\r\n/*\r\n * This module tracks early refreshments of rejuvenation.\r\n * TODO: Extend/refactor this module to include other HoTs/Spells as well such as lifebloom/efflorescence\r\n * TODO: Add this module to checklist\r\n */\r\nclass PrematureRejuvenations extends Analyzer {\r\n  static dependencies = {\r\n    healingDone: HealingDone,\r\n    combatants: Combatants,\r\n  };\r\n\r\n  totalRejuvsCasts = 0;\r\n  rejuvenations = [];\r\n  earlyRefreshments = 0;\r\n  timeLost = 0;\r\n\r\n  constructor(...args) {\r\n    super(...args);\r\n    // TODO - Extend this module to also support when using Germination.\r\n    this.active = !this.selectedCombatant.hasTalent(SPELLS.GERMINATION_TALENT.id);\r\n    this.addEventListener(Events.removebuff.by(SELECTED_PLAYER).spell(SPELLS.REJUVENATION), this.onRemoveBuff);\r\n    this.addEventListener(Events.cast.by(SELECTED_PLAYER).spell([SPELLS.REJUVENATION, SPELLS.FLOURISH_TALENT]), this.onCast);\r\n    this.addEventListener(Events.fightend, this.onFightend);\r\n  }\r\n\r\n  onRemoveBuff(event) {\r\n    const target = this.combatants.getEntity(event);\r\n    if (!target) {\r\n      return; // target wasn't important (a pet probably)\r\n    }\r\n\r\n    // Sanity check - Remove rejuvenation from array if it was removed from target player.\r\n    this.rejuvenations = this.rejuvenations.filter(e => e.targetId !== event.targetID);\r\n  }\r\n\r\n  onCast(event) {\r\n    if (event.ability.guid === SPELLS.REJUVENATION.id) {\r\n      this.totalRejuvsCasts += 1;\r\n\r\n      const oldRejuv = this.rejuvenations.find(e => e.targetId === event.targetID);\r\n      if (oldRejuv == null) {\r\n        this.rejuvenations.push({ 'targetId': event.targetID, 'timestamp': event.timestamp });\r\n        return;\r\n      }\r\n\r\n      const pandemicTimestamp = oldRejuv.timestamp + ((REJUV_DURATION * PANDEMIC_THRESHOLD) + MS_BUFFER);\r\n      if (pandemicTimestamp > event.timestamp) {\r\n        this.earlyRefreshments += 1;\r\n        this.timeLost += pandemicTimestamp - event.timestamp;\r\n      }\r\n\r\n      // Account for pandemic time if hot was applied within the pandemic timeframe.\r\n      let pandemicTime = 0;\r\n      if (event.timestamp >= pandemicTimestamp && event.timestamp <= oldRejuv.timestamp + REJUV_DURATION) {\r\n        pandemicTime = (oldRejuv.timestamp + REJUV_DURATION) - event.timestamp;\r\n      } else if (event.timestamp <= pandemicTime) {\r\n        pandemicTime = REJUV_DURATION - (REJUV_DURATION * PANDEMIC_THRESHOLD);\r\n      }\r\n      debug && console.log('Extended within pandemic time frame: ' + pandemicTime);\r\n\r\n      // Set the new timestamp\r\n      oldRejuv.timestamp = event.timestamp + pandemicTime;\r\n    } else if (event.ability.guid === SPELLS.FLOURISH_TALENT.id) {\r\n      // TODO - Flourish extends all active rejuvenations within 60 yards by 8 seconds. Add range check possible?\r\n      this.rejuvenations = this.rejuvenations.map(o => ({ ...o, timestamp: o.timestamp + FLOURISH_EXTENSION }));\r\n    }\r\n  }\r\n\r\n  onFightend() {\r\n    debug && console.log('Finished: %o', this.rejuvenations);\r\n    debug && console.log('Early refreshments: ' + this.earlyRefreshments);\r\n    debug && console.log('Time lost: ' + this.timeLost);\r\n  }\r\n\r\n  get timeLostInSeconds() {\r\n    return (this.timeLost / 1000).toFixed(2);\r\n  }\r\n\r\n  get timeLostThreshold() {\r\n    return {\r\n      actual: this.timeLostInSeconds,\r\n      isGreaterThan: {\r\n        minor: 0,\r\n        average: 20,\r\n        major: 45,\r\n      },\r\n      style: 'number',\r\n    };\r\n  }\r\n\r\n  suggestions(when) {\r\n    when(this.timeLostThreshold)\r\n      .addSuggestion((suggest) => suggest(<>Don't refresh <SpellLink id={SPELLS.REJUVENATION.id} /> if it's not within pandemic time frame (4.5s left on buff).</>)\r\n          .icon(SPELLS.REJUVENATION.icon)\r\n          .actual(i18n._(t('druid.restoration.suggestions.rejuvenation.wastedSeconds')`You refreshed early ${this.earlyRefreshments} times which made you waste ${this.timeLostInSeconds} seconds of rejuvenation.`))\r\n          .recommended(`0 seconds lost is recommended`));\r\n  }\r\n\r\n  statistic() {\r\n    return (\r\n      <Statistic\r\n        position={STATISTIC_ORDER.CORE(18)}\r\n        size=\"flexible\"\r\n        tooltip={`The total time lost from your early refreshments was ${this.timeLostInSeconds} seconds.`}\r\n      >\r\n        <BoringValue label={<><SpellIcon id={SPELLS.REJUVENATION.id} /> Early Rejuvenation refreshes</>} >\r\n          <>\r\n            {this.earlyRefreshments}\r\n          </>\r\n        </BoringValue>\r\n      </Statistic>\r\n    );\r\n  }\r\n}\r\n\r\nexport default PrematureRejuvenations;\r\n\r\n","import React from 'react';\r\nimport { formatPercentage } from 'common/format';\r\nimport STATISTIC_ORDER from 'interface/others/STATISTIC_ORDER';\r\nimport Statistic from 'interface/statistics/Statistic';\r\nimport SpellIcon from 'common/SpellIcon';\r\nimport BoringValue from 'interface/statistics/components/BoringValueText';\r\n\r\nimport SPELLS from 'common/SPELLS';\r\nimport Analyzer from 'parser/core/Analyzer';\r\n\r\nimport Mastery from '../core/Mastery';\r\n\r\nclass CenarionWard extends Analyzer {\r\n  static dependencies = {\r\n    mastery: Mastery,\r\n  };\r\n\r\n  constructor(...args) {\r\n    super(...args);\r\n    const hasCenarionWard = this.selectedCombatant.hasTalent(SPELLS.CENARION_WARD_TALENT.id);\r\n    this.active = hasCenarionWard;\r\n  }\r\n\r\n  statistic() {\r\n    const directHealing = this.mastery.getDirectHealing(SPELLS.CENARION_WARD_HEAL.id);\r\n    const directPercent = this.owner.getPercentageOfTotalHealingDone(directHealing);\r\n\r\n    const masteryHealing = this.mastery.getMasteryHealing(SPELLS.CENARION_WARD_HEAL.id);\r\n    const masteryPercent = this.owner.getPercentageOfTotalHealingDone(masteryHealing);\r\n\r\n    const totalPercent = directPercent + masteryPercent;\r\n\r\n    return (\r\n      <Statistic\r\n        position={STATISTIC_ORDER.OPTIONAL}\r\n        size=\"flexible\"\r\n        tooltip={(\r\n          <>\r\n            This is the sum of the direct healing from Cenarion Ward and the healing enabled by Cenarion Ward's extra mastery stack.\r\n            <ul>\r\n              <li>Direct: <strong>{formatPercentage(directPercent)}%</strong></li>\r\n              <li>Mastery: <strong>{formatPercentage(masteryPercent)}%</strong></li>\r\n            </ul>\r\n          </>\r\n        )}\r\n      >\r\n        <BoringValue label={<><SpellIcon id={SPELLS.CENARION_WARD_HEAL.id} /> Cenarion Ward healing</>}>\r\n          <>\r\n            {formatPercentage(totalPercent)} %\r\n          </>\r\n        </BoringValue>\r\n      </Statistic>\r\n    );\r\n  }\r\n}\r\n\r\nexport default CenarionWard;\r\n","import React from 'react';\r\nimport { formatPercentage, formatNumber } from 'common/format';\r\nimport STATISTIC_ORDER from 'interface/others/STATISTIC_ORDER';\r\nimport Statistic from 'interface/statistics/Statistic';\r\nimport calculateEffectiveHealing from 'parser/core/calculateEffectiveHealing';\r\nimport SpellLink from 'common/SpellLink';\r\nimport SpellIcon from 'common/SpellIcon';\r\nimport BoringValue from 'interface/statistics/components/BoringValueText';\r\n\r\nimport { i18n } from '@lingui/core';\r\nimport { t } from '@lingui/macro';\r\n\r\nimport SPELLS from 'common/SPELLS';\r\nimport Analyzer, { SELECTED_PLAYER } from 'parser/core/Analyzer';\r\n\r\nimport Events from 'parser/core/Events';\r\n\r\nimport HotTrackerRestoDruid from '../core/hottracking/HotTrackerRestoDruid';\r\n\r\nimport { HOTS_AFFECTED_BY_ESSENCE_OF_GHANIR } from '../../constants';\r\n\r\nconst debug = false;\r\n\r\nconst FLOURISH_EXTENSION = 8000;\r\nconst FLOURISH_HEALING_INCREASE = 1;\r\n/*\r\n  Extends the duration of all of your heal over time effects on friendly targets within 60 yards by 8 sec,\r\n  and increases the rate of your heal over time effects by 100% for 8 sec.\r\n */\r\n\r\n// TODO: Idea - Give suggestions on low amount/duration extended with flourish on other HoTs\r\nclass Flourish extends Analyzer {\r\n  get totalExtensionHealing() {\r\n    return this.flourishes.reduce((acc, flourish) => acc + flourish.healing + flourish.masteryHealing, 0);\r\n  }\r\n\r\n  get averageHealing() {\r\n    return this.flourishCount === 0 ? 0 : this.totalExtensionHealing / this.flourishCount;\r\n  }\r\n\r\n  get percentWgsExtended() {\r\n    return this.flourishCount === 0 ? 0 : this.wgsExtended / this.flourishCount;\r\n  }\r\n\r\n  get wildGrowthSuggestionThresholds() {\r\n    return {\r\n      actual: this.percentWgsExtended,\r\n      isLessThan: {\r\n        minor: 1.00,\r\n        average: 0.75,\r\n        major: 0.50,\r\n      },\r\n      style: 'percentage',\r\n    };\r\n  }\r\n\r\n  get percentCwsExtended() {\r\n    return (this.cwsExtended / this.flourishCount) || 0;\r\n  }\r\n\r\n  get cenarionWardSuggestionThresholds() {\r\n    return {\r\n      actual: this.percentCwsExtended,\r\n      isLessThan: {\r\n        minor: 1.00,\r\n        average: 0.00,\r\n        major: 0.00,\r\n      },\r\n      style: 'percentage',\r\n    };\r\n  }\r\n\r\n  static dependencies = {\r\n    hotTracker: HotTrackerRestoDruid,\r\n  };\r\n  // Counters for hot extension\r\n  flourishCount = 0;\r\n  flourishes = [];\r\n  wgsExtended = 0; // tracks how many flourishes extended Wild Growth\r\n  cwsExtended = 0; // tracks how many flourishes extended Cenarion Ward\r\n  tranqsExtended = 0;\r\n  hasCenarionWard = false;\r\n  rejuvCount = 0;\r\n  wgCount = 0;\r\n  lbCount = 0;\r\n  regrowthCount = 0;\r\n  sbCount = 0;\r\n  cultCount = 0;\r\n  tranqCount = 0;\r\n  groveTendingCount = 0;\r\n  // Counters for increased ticking rate of hots\r\n  increasedRateTotalHealing = 0;\r\n  increasedRateRejuvenationHealing = 0;\r\n  increasedRateWildGrowthHealing = 0;\r\n  increasedRateCenarionWardHealing = 0;\r\n  increasedRateCultivationHealing = 0;\r\n  increasedRateLifebloomHealing = 0;\r\n  increasedRateRegrowthHealing = 0;\r\n  increasedRateTranqHealing = 0;\r\n  increasedRateGroveTendingHealing = 0;\r\n\r\n  constructor(...args) {\r\n    super(...args);\r\n    this.active = this.selectedCombatant.hasTalent(SPELLS.FLOURISH_TALENT.id);\r\n    this.hasCenarionWard = this.selectedCombatant.hasTalent(SPELLS.CENARION_WARD_TALENT.id);\r\n    this.addEventListener(Events.heal.by(SELECTED_PLAYER).spell(HOTS_AFFECTED_BY_ESSENCE_OF_GHANIR), this.onHeal);\r\n    this.addEventListener(Events.cast.by(SELECTED_PLAYER).spell(SPELLS.FLOURISH_TALENT), this.onCast);\r\n  }\r\n\r\n  onHeal(event) {\r\n    const spellId = event.ability.guid;\r\n\r\n    if (this.selectedCombatant.hasBuff(SPELLS.FLOURISH_TALENT.id)) {\r\n      switch (spellId) {\r\n        case SPELLS.REJUVENATION.id:\r\n          this.increasedRateRejuvenationHealing += calculateEffectiveHealing(event, FLOURISH_HEALING_INCREASE);\r\n          break;\r\n        case SPELLS.REJUVENATION_GERMINATION.id:\r\n          this.increasedRateRejuvenationHealing += calculateEffectiveHealing(event, FLOURISH_HEALING_INCREASE);\r\n          break;\r\n        case SPELLS.WILD_GROWTH.id:\r\n          this.increasedRateWildGrowthHealing += calculateEffectiveHealing(event, FLOURISH_HEALING_INCREASE);\r\n          break;\r\n        case SPELLS.CENARION_WARD_HEAL.id:\r\n          this.increasedRateCenarionWardHealing += calculateEffectiveHealing(event, FLOURISH_HEALING_INCREASE);\r\n          break;\r\n        case SPELLS.CULTIVATION.id:\r\n          this.increasedRateCultivationHealing += calculateEffectiveHealing(event, FLOURISH_HEALING_INCREASE);\r\n          break;\r\n        case SPELLS.LIFEBLOOM_HOT_HEAL.id:\r\n          this.increasedRateLifebloomHealing += calculateEffectiveHealing(event, FLOURISH_HEALING_INCREASE);\r\n          break;\r\n        case SPELLS.REGROWTH.id:\r\n          if (event.tick === true) {\r\n            this.increasedRateRegrowthHealing += calculateEffectiveHealing(event, FLOURISH_HEALING_INCREASE);\r\n          }\r\n          break;\r\n        case SPELLS.TRANQUILITY_HEAL.id:\r\n          if (event.tick === true) {\r\n            this.increasedRateTranqHealing += calculateEffectiveHealing(event, FLOURISH_HEALING_INCREASE);\r\n          }\r\n          break;\r\n        default:\r\n          console.error('EssenceOfGhanir: Error, could not identify this object as a HoT: %o', event);\r\n      }\r\n\r\n      if ((SPELLS.REGROWTH.id === spellId || SPELLS.TRANQUILITY_HEAL.id) && event.tick !== true) {\r\n        return;\r\n      }\r\n      this.increasedRateTotalHealing += calculateEffectiveHealing(event, FLOURISH_HEALING_INCREASE);\r\n    }\r\n  }\r\n\r\n  onCast(event) {\r\n    this.flourishCount += 1;\r\n    debug && console.log(`Flourish cast #: ${this.flourishCount}`);\r\n\r\n    const newFlourish = {\r\n      name: `Flourish #${this.flourishCount}`,\r\n      healing: 0,\r\n      masteryHealing: 0,\r\n      procs: 0,\r\n      duration: 0,\r\n    };\r\n    this.flourishes.push(newFlourish);\r\n\r\n    let foundWg = false;\r\n    let foundCw = false;\r\n    let foundTranq = false;\r\n\r\n    Object.keys(this.hotTracker.hots).forEach(playerId => {\r\n      Object.keys(this.hotTracker.hots[playerId]).forEach(spellIdString => {\r\n        const spellId = Number(spellIdString);\r\n        // due to flourish's refresh mechanc, we don't include it in Flourish numbers\r\n        const attribution = spellId === SPELLS.CULTIVATION.id ? null : newFlourish;\r\n        this.hotTracker.addExtension(attribution, FLOURISH_EXTENSION, playerId, spellId);\r\n\r\n        if (spellId === SPELLS.WILD_GROWTH.id) {\r\n          foundWg = true;\r\n          this.wgCount += 1;\r\n        } else if (spellId === SPELLS.CENARION_WARD_HEAL.id) {\r\n          foundCw = true;\r\n        } else if (spellId === SPELLS.REJUVENATION.id || spellId === SPELLS.REJUVENATION_GERMINATION.id) {\r\n          this.rejuvCount += 1;\r\n        } else if (spellId === SPELLS.REGROWTH.id) {\r\n          this.regrowthCount += 1;\r\n        } else if (spellId === SPELLS.LIFEBLOOM_HOT_HEAL.id) {\r\n          this.lbCount += 1;\r\n        } else if (spellId === SPELLS.SPRING_BLOSSOMS.id) {\r\n          this.sbCount += 1;\r\n        } else if (spellId === SPELLS.CULTIVATION.id) {\r\n          this.cultCount += 1;\r\n        } else if (spellId === SPELLS.TRANQUILITY_HEAL.id) {\r\n          foundTranq = true;\r\n          this.tranqCount += 1;\r\n        }\r\n      });\r\n    });\r\n\r\n    if (foundWg) {\r\n      this.wgsExtended += 1;\r\n    }\r\n    if (foundCw) {\r\n      this.cwsExtended += 1;\r\n    }\r\n    if (foundTranq) {\r\n      this.tranqsExtended += 1;\r\n    }\r\n  }\r\n\r\n  suggestions(when) {\r\n    if (this.flourishCount === 0) {\r\n      return;\r\n    }\r\n\r\n    when(this.wildGrowthSuggestionThresholds)\r\n      .addSuggestion((suggest, actual, recommended) => suggest(<>Your <SpellLink id={SPELLS.FLOURISH_TALENT.id} /> should always aim to extend a <SpellLink id={SPELLS.WILD_GROWTH.id} /></>)\r\n        .icon(SPELLS.FLOURISH_TALENT.icon)\r\n        .actual(i18n._(t('druid.restoration.suggestions.flourish.wildGrowthExtended')`${formatPercentage(this.wgsExtended / this.flourishCount, 0)}% WGs extended.`))\r\n        .recommended(`${formatPercentage(recommended)}% is recommended`));\r\n\r\n    if (this.hasCenarionWard) {\r\n      when(this.cenarionWardSuggestionThresholds)\r\n        .addSuggestion((suggest, actual, recommended) => suggest(<>Your <SpellLink id={SPELLS.FLOURISH_TALENT.id} /> should always aim to extend a <SpellLink id={SPELLS.CENARION_WARD_HEAL.id} /></>)\r\n          .icon(SPELLS.FLOURISH_TALENT.icon)\r\n          .actual(i18n._(t('druid.restoration.suggestions.flourish.cenarionWardExtended')`${this.cwsExtended}/${this.flourishCount} CWs extended.`))\r\n          .recommended(`${formatPercentage(recommended)}% is recommended`));\r\n    }\r\n  }\r\n\r\n  statistic() {\r\n    const extendPercent = this.owner.getPercentageOfTotalHealingDone(this.totalExtensionHealing);\r\n    const increasedRatePercent = this.owner.getPercentageOfTotalHealingDone(this.increasedRateTotalHealing);\r\n    const totalPercent = this.owner.getPercentageOfTotalHealingDone(this.totalExtensionHealing + this.increasedRateTotalHealing);\r\n    return (\r\n      <Statistic\r\n        size=\"flexible\"\r\n        position={STATISTIC_ORDER.OPTIONAL(15)}\r\n        tooltip={(\r\n          <>\r\n            The HoT extension contributed: <strong>{formatPercentage(extendPercent)} %</strong><br />\r\n            The HoT increased tick rate contributed: <strong>{formatPercentage(increasedRatePercent)} %</strong><br />\r\n            <ul>\r\n              {this.wildGrowth !== 0 && <li>{formatPercentage(this.owner.getPercentageOfTotalHealingDone(this.increasedRateWildGrowthHealing))}% from Wild Growth</li>}\r\n              {this.rejuvenation !== 0 && <li>{formatPercentage(this.owner.getPercentageOfTotalHealingDone(this.increasedRateRejuvenationHealing))}% from Rejuvenation</li>}\r\n              {this.cenarionWard !== 0 && <li>{formatPercentage(this.owner.getPercentageOfTotalHealingDone(this.increasedRateCenarionWardHealing))}% from Cenarion Ward</li>}\r\n              {this.lifebloom !== 0 && <li>{formatPercentage(this.owner.getPercentageOfTotalHealingDone(this.increasedRateLifebloomHealing))}% from Lifebloom</li>}\r\n              {this.regrowth !== 0 && <li>{formatPercentage(this.owner.getPercentageOfTotalHealingDone(this.increasedRateRegrowthHealing))}% from Regrowth</li>}\r\n              {this.cultivation !== 0 && <li>{formatPercentage(this.owner.getPercentageOfTotalHealingDone(this.increasedRateCultivationHealing))}% from Cultivation</li>}\r\n              {this.traquility !== 0 && <li>{formatPercentage(this.owner.getPercentageOfTotalHealingDone(this.increasedRateTranqHealing))}% from Tranquillity</li>}\r\n              {this.groveTending !== 0 && <li>{formatPercentage(this.owner.getPercentageOfTotalHealingDone(this.increasedRateGroveTendingHealing))}% from Grove Tending</li>}\r\n            </ul>\r\n\r\n            The per Flourish amounts do <em>not</em> include Cultivation due to its refresh mechanic.<br />\r\n            Your {this.flourishCount} Flourish casts extended:\r\n            <ul>\r\n              <li>{this.wgsExtended}/{this.flourishCount} Wild Growth casts ({this.wgCount} HoTs)</li>\r\n              {this.hasCenarionWard && <li>{this.cwsExtended}/{this.flourishCount} Cenarion Wards</li>}\r\n              {this.rejuvCount > 0 && <li>{this.rejuvCount} Rejuvenations</li>}\r\n              {this.regrowthCount > 0 && <li>{this.regrowthCount} Regrowths</li>}\r\n              {this.lbCount > 0 && <li>{this.lbCount} Lifeblooms</li>}\r\n              {this.sbCount > 0 && <li>{this.sbCount} Spring Blossoms</li>}\r\n              {this.cultCount > 0 && <li>{this.cultCount} Cultivations (not counted in HoT count and HoT healing totals)</li>}\r\n              {this.tranqCount > 0 && <li>{this.tranqsExtended}/{this.flourishCount} Tranquillities casts ({this.tranqCount} HoTs)</li>}\r\n              {this.groveTendingCount > 0 && <li>{this.groveTendingCount}/{this.flourishCount} Grove tendings</li>}\r\n            </ul>\r\n            <br />\r\n            The Healing column shows how much additional healing was done by the 8 extra seconds of HoT time. Note that if you Flourished near the end of a fight, numbers might be lower than you expect because extension healing isn't tallied until a HoT falls.\r\n          </>\r\n        )}\r\n        dropdown={(\r\n          <>\r\n            <table className=\"table table-condensed\">\r\n              <thead>\r\n                <tr>\r\n                  <th>Cast</th>\r\n                  <th># of HoTs</th>\r\n                  <th>Healing</th>\r\n                </tr>\r\n              </thead>\r\n              <tbody>\r\n                {\r\n                  this.flourishes.map((flourish, index) => (\r\n                    <tr key={index}>\r\n                      <th scope=\"row\">{index + 1}</th>\r\n                      <td>{flourish.procs}</td>\r\n                      <td>{formatNumber(flourish.healing + flourish.masteryHealing)}</td>\r\n                    </tr>\r\n                  ))\r\n                }\r\n              </tbody>\r\n            </table>\r\n          </>\r\n        )}\r\n      >\r\n        <BoringValue label={<><SpellIcon id={SPELLS.FLOURISH_TALENT.id} /> Flourish healing</>}>\r\n          <>\r\n            {formatPercentage(totalPercent)} %\r\n          </>\r\n        </BoringValue>\r\n      </Statistic>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Flourish;\r\n","import React from 'react';\r\nimport { formatPercentage } from 'common/format';\r\nimport STATISTIC_ORDER from 'interface/others/STATISTIC_ORDER';\r\nimport Statistic from 'interface/statistics/Statistic';\r\nimport Analyzer, { SELECTED_PLAYER } from 'parser/core/Analyzer';\r\nimport SPELLS from 'common/SPELLS';\r\nimport SpellLink from 'common/SpellLink';\r\nimport SpellIcon from 'common/SpellIcon';\r\nimport BoringValue from 'interface/statistics/components/BoringValueText';\r\n\r\nimport { i18n } from '@lingui/core';\r\nimport { t } from '@lingui/macro';\r\n\r\nimport calculateEffectiveHealing from 'parser/core/calculateEffectiveHealing';\r\nimport Events from 'parser/core/Events';\r\n\r\nconst REGROWTH_HEALING_INCREASE = 2;\r\nconst REJUVENATION_HEALING_INCREASE = 2;\r\nconst WILD_GROWTH_HEALING_INCREASE = 0.75;\r\nconst WILD_GROWTH_DURATION = 7000;\r\nconst REJUVENATION_BASE_DURATION = 12000;\r\n\r\nclass SoulOfTheForest extends Analyzer {\r\n  get wgUsagePercent() {\r\n    return this.wildGrowths / this.proccs;\r\n  }\r\n\r\n  get suggestionThresholds() {\r\n    return {\r\n      actual: this.wgUsagePercent,\r\n      isLessThan: {\r\n        minor: 1.00,\r\n        average: 0.80,\r\n        major: 0.60,\r\n      },\r\n      style: 'percentage',\r\n    };\r\n  }\r\n\r\n  regrowths = 0;\r\n  wildGrowths = 0;\r\n  rejuvenations = 0;\r\n  proccs = 0;\r\n  proccConsumed = true;\r\n  rejuvenationProccTimestamp = null;\r\n  regrowthProccTimestamp = null;\r\n  wildGrowthProccTimestamp = null;\r\n  regrowthHealing = 0;\r\n  rejuvenationHealing = 0;\r\n  wildGrowthHealing = 0;\r\n  rejuvenationTargets = [];\r\n  wildGrowthTargets = [];\r\n  rejuvenationDuration = REJUVENATION_BASE_DURATION;\r\n\r\n  constructor(...args) {\r\n    super(...args);\r\n    this.active = this.selectedCombatant.hasTalent(SPELLS.SOUL_OF_THE_FOREST_TALENT_RESTORATION.id);\r\n    this.addEventListener(Events.applybuff.by(SELECTED_PLAYER), this.onApplyBuff);\r\n    this.addEventListener(Events.cast.by(SELECTED_PLAYER), this.onCast);\r\n    this.addEventListener(Events.heal.by(SELECTED_PLAYER), this.onHeal);\r\n  }\r\n\r\n  onApplyBuff(event) {\r\n    const spellId = event.ability.guid;\r\n\r\n    if (SPELLS.SOUL_OF_THE_FOREST_BUFF.id === spellId) {\r\n      this.proccs += 1;\r\n      this.proccConsumed = false;\r\n    }\r\n\r\n    // Saving the \"valid\" targets to track the healing done on. I.e. get the targets that had an \"empowered\" WG/Rejuv applied on them.\r\n    if (this.wildGrowthProccTimestamp !== null && SPELLS.WILD_GROWTH.id === spellId && (event.timestamp - this.wildGrowthProccTimestamp) < 100) {\r\n      this.wildGrowthTargets.push(event.targetID);\r\n    } else if (this.rejuvenationProccTimestamp !== null && (SPELLS.REJUVENATION.id === spellId || SPELLS.REJUVENATION_GERMINATION.id === spellId) && (event.timestamp - this.rejuvenationProccTimestamp) < 100) {\r\n      this.rejuvenationTargets.push(event.targetID);\r\n    }\r\n  }\r\n\r\n  onCast(event) {\r\n    const spellId = event.ability.guid;\r\n\r\n    // proccConsumsed it used because WG and RG has a cast time. So whenever you queue cast WG + rejuv they will happen at the exact same timestamp.\r\n    if (this.selectedCombatant.hasBuff(SPELLS.SOUL_OF_THE_FOREST_BUFF.id) && this.proccConsumed === false) {\r\n      if (SPELLS.REJUVENATION.id === spellId || SPELLS.REJUVENATION_GERMINATION === spellId) {\r\n        this.rejuvenations += 1;\r\n        this.rejuvenationProccTimestamp = event.timestamp;\r\n      } else if (SPELLS.REGROWTH.id === spellId) {\r\n        this.regrowths += 1;\r\n        this.proccConsumed = true;\r\n        this.regrowthProccTimestamp = event.timestamp;\r\n      } else if (SPELLS.WILD_GROWTH.id === spellId) {\r\n        this.wildGrowths += 1;\r\n        this.proccConsumed = true;\r\n        this.wildGrowthProccTimestamp = event.timestamp;\r\n      }\r\n    }\r\n  }\r\n\r\n  onHeal(event) {\r\n    const spellId = event.ability.guid;\r\n\r\n    // Reset procc variables\r\n    if ((event.timestamp + 200) > (this.rejuvenationProccTimestamp + this.rejuvenationDuration)) {\r\n      this.rejuvenationProccTimestamp = null;\r\n      this.rejuvenationTargets = [];\r\n    } else if ((event.timestamp + 200) > (this.wildGrowthProccTimestamp + WILD_GROWTH_DURATION)) {\r\n      this.wildGrowthProccTimestamp = null;\r\n      this.wildGrowthTargets = [];\r\n    }\r\n\r\n    if (SPELLS.REGROWTH.id === spellId && this.regrowthProccTimestamp === event.timestamp) {\r\n      this.regrowthHealing += calculateEffectiveHealing(event, REGROWTH_HEALING_INCREASE);\r\n      this.regrowthProccTimestamp = null;\r\n    } else if (this.rejuvenationProccTimestamp !== null\r\n      && (SPELLS.REJUVENATION.id === spellId || SPELLS.REJUVENATION_GERMINATION === spellId)\r\n      && (event.timestamp - (this.rejuvenationProccTimestamp + this.rejuvenationDuration)) <= 0) {\r\n      if (this.rejuvenationTargets.includes(event.targetID)) {\r\n        this.rejuvenationHealing += calculateEffectiveHealing(event, REJUVENATION_HEALING_INCREASE);\r\n      }\r\n    } else if (this.wildGrowthProccTimestamp !== null\r\n      && SPELLS.WILD_GROWTH.id === spellId\r\n      && (event.timestamp - (this.wildGrowthProccTimestamp + WILD_GROWTH_DURATION)) <= 0) {\r\n      if (this.wildGrowthTargets.includes(event.targetID)) {\r\n        this.wildGrowthHealing += calculateEffectiveHealing(event, WILD_GROWTH_HEALING_INCREASE);\r\n      }\r\n    }\r\n  }\r\n\r\n  suggestions(when) {\r\n    when(this.suggestionThresholds)\r\n      .addSuggestion((suggest, actual, recommended) => suggest(<span>You did not consume all your <SpellLink id={SPELLS.SOUL_OF_THE_FOREST_TALENT_RESTORATION.id} /> buffs with <SpellLink id={SPELLS.WILD_GROWTH.id} />.\r\n          Try to use <SpellLink id={SPELLS.WILD_GROWTH.id} /> every time you get a <SpellLink id={SPELLS.SOUL_OF_THE_FOREST_TALENT_RESTORATION.id} /> buff.</span>)\r\n        .icon(SPELLS.SOUL_OF_THE_FOREST_TALENT_RESTORATION.icon)\r\n        .actual(i18n._(t('druid.restoration.suggestions.soulOfTheForest.efficiency')`Wild growth consumed ${formatPercentage(this.wgUsagePercent)}% of all the buffs.`))\r\n        .recommended(`${Math.round(formatPercentage(recommended))}% is recommended`));\r\n  }\r\n\r\n  statistic() {\r\n    const total = this.wildGrowthHealing + this.rejuvenationHealing + this.regrowthHealing;\r\n    const totalPercent = this.owner.getPercentageOfTotalHealingDone(total);\r\n\r\n    const wgPercent = this.owner.getPercentageOfTotalHealingDone(this.wildGrowthHealing);\r\n    const rejuvPercent = this.owner.getPercentageOfTotalHealingDone(this.rejuvenationHealing);\r\n    const regrowthPercent = this.owner.getPercentageOfTotalHealingDone(this.regrowthHealing);\r\n\r\n    return (\r\n      <Statistic\r\n        size=\"flexible\"\r\n        position={STATISTIC_ORDER.OPTIONAL(20)}\r\n        tooltip={(\r\n          <>\r\n            You gained {this.proccs} total Soul of the Forest procs.\r\n            <ul>\r\n              <li>Consumed {this.wildGrowths} procs with Wild Growth for {formatPercentage(wgPercent)}% healing</li>\r\n              <li>Consumed {this.rejuvenations} procs with Rejuvenation for {formatPercentage(rejuvPercent)}% healing</li>\r\n              <li>Consumed {this.regrowths} procs with Regrowth for {formatPercentage(regrowthPercent)}% healing</li>\r\n            </ul>\r\n          </>\r\n        )}\r\n      >\r\n        <BoringValue label={<><SpellIcon id={SPELLS.SOUL_OF_THE_FOREST_TALENT_RESTORATION.id} /> Soul of the Forest healing</>}>\r\n          <>\r\n            {formatPercentage(totalPercent)} %\r\n          </>\r\n        </BoringValue>\r\n      </Statistic>\r\n    );\r\n  }\r\n}\r\n\r\nexport default SoulOfTheForest;\r\n","import React from 'react';\r\n\r\nimport STATISTIC_ORDER from 'interface/others/STATISTIC_ORDER';\r\nimport Statistic from 'interface/statistics/Statistic';\r\nimport SPELLS from 'common/SPELLS';\r\nimport { formatPercentage } from 'common/format';\r\nimport SpellIcon from 'common/SpellIcon';\r\nimport BoringValue from 'interface/statistics/components/BoringValueText';\r\nimport Analyzer, { SELECTED_PLAYER } from 'parser/core/Analyzer';\r\nimport Combatants from 'parser/shared/modules/Combatants';\r\nimport calculateEffectiveHealing from 'parser/core/calculateEffectiveHealing';\r\n\r\nimport Events from 'parser/core/Events';\r\n\r\nimport { HOTS_AFFECTED_BY_ESSENCE_OF_GHANIR } from '../../constants';\r\n\r\nconst PHOTOSYNTHESIS_HOT_INCREASE = 0.2;\r\n// Spring blossoms double dips, confirmed by Bastas\r\nconst PHOTOSYNTHESIS_SB_INCREASE = 0.44;\r\nconst BLOOM_BUFFER_MS = 100;\r\n\r\n/*\r\nWhile your Lifebloom is on yourself, your periodic heals heal 20% faster.\r\n\r\nWhile your Lifebloom is on an ally, your periodic heals on them have a 5% chance to cause it to bloom.\r\n */\r\nclass Photosynthesis extends Analyzer {\r\n  static dependencies = {\r\n    combatants: Combatants,\r\n  };\r\n\r\n  lifebloomIncrease = 0;\r\n\r\n  lastRealBloomTimestamp = null;\r\n\r\n  // Counters for increased ticking rate of hots\r\n  increasedRateRejuvenationHealing = 0;\r\n  increasedRateWildGrowthHealing = 0;\r\n  increasedRateCenarionWardHealing = 0;\r\n  increasedRateCultivationHealing = 0;\r\n  increasedRateLifebloomHealing = 0;\r\n  increasedRateRegrowthHealing = 0;\r\n  increasedRateTranqHealing = 0;\r\n  increasedRateSpringBlossomsHealing = 0;\r\n  increasedRateEffloHealing = 0;\r\n  increasedRateGroveTendingHealing = 0;\r\n  randomProccs = 0;\r\n  naturalProccs = 0;\r\n\r\n  constructor(...args) {\r\n    super(...args);\r\n    this.active = this.selectedCombatant.hasTalent(SPELLS.PHOTOSYNTHESIS_TALENT.id);\r\n    this.addEventListener(Events.cast.by(SELECTED_PLAYER).spell(SPELLS.LIFEBLOOM_HOT_HEAL), this.onCast);\r\n    this.addEventListener(Events.removebuff.by(SELECTED_PLAYER).spell(SPELLS.LIFEBLOOM_HOT_HEAL), this.onRemoveBuff);\r\n    this.addEventListener(Events.heal.by(SELECTED_PLAYER).spell([SPELLS.EFFLORESCENCE_HEAL, SPELLS.SPRING_BLOSSOMS, ...HOTS_AFFECTED_BY_ESSENCE_OF_GHANIR]), this.onHeal);\r\n    this.addEventListener(Events.heal.by(SELECTED_PLAYER).spell(SPELLS.LIFEBLOOM_BLOOM_HEAL), this.onLifebloomProc);\r\n  }\r\n\r\n  onCast(event) {\r\n    this.lastRealBloomTimestamp = event.timestamp;\r\n  }\r\n\r\n  onRemoveBuff(event) {\r\n    this.lastRealBloomTimestamp = event.timestamp;\r\n  }\r\n\r\n  onLifebloomProc(event) {\r\n    // Lifebloom random bloom procc\r\n    if (this.lastRealBloomTimestamp === null || (event.timestamp - this.lastRealBloomTimestamp) > BLOOM_BUFFER_MS) {\r\n      this.lifebloomIncrease += event.amount;\r\n      this.randomProccs += 1;\r\n    } else {\r\n      this.naturalProccs += 1;\r\n    }\r\n  }\r\n\r\n  onHeal(event) {\r\n    const spellId = event.ability.guid;\r\n\r\n    // Yes it actually buffs efflorescence, confirmed by Voulk and Bastas\r\n    if (this.selectedCombatant.hasBuff(SPELLS.LIFEBLOOM_HOT_HEAL.id, null, 0, 0, this.selectedCombatant.sourceID)) {\r\n      switch (spellId) {\r\n        case SPELLS.REJUVENATION.id:\r\n          this.increasedRateRejuvenationHealing += calculateEffectiveHealing(event, PHOTOSYNTHESIS_HOT_INCREASE);\r\n          break;\r\n        case SPELLS.REJUVENATION_GERMINATION.id:\r\n          this.increasedRateRejuvenationHealing += calculateEffectiveHealing(event, PHOTOSYNTHESIS_HOT_INCREASE);\r\n          break;\r\n        case SPELLS.WILD_GROWTH.id:\r\n          this.increasedRateWildGrowthHealing += calculateEffectiveHealing(event, PHOTOSYNTHESIS_HOT_INCREASE);\r\n          break;\r\n        case SPELLS.CENARION_WARD_HEAL.id:\r\n          this.increasedRateCenarionWardHealing += calculateEffectiveHealing(event, PHOTOSYNTHESIS_HOT_INCREASE);\r\n          break;\r\n        case SPELLS.CULTIVATION.id:\r\n          this.increasedRateCultivationHealing += calculateEffectiveHealing(event, PHOTOSYNTHESIS_HOT_INCREASE);\r\n          break;\r\n        case SPELLS.LIFEBLOOM_HOT_HEAL.id:\r\n          this.increasedRateLifebloomHealing += calculateEffectiveHealing(event, PHOTOSYNTHESIS_HOT_INCREASE);\r\n          break;\r\n        case SPELLS.SPRING_BLOSSOMS.id:\r\n          this.increasedRateSpringBlossomsHealing += calculateEffectiveHealing(event, PHOTOSYNTHESIS_SB_INCREASE);\r\n          break;\r\n        case SPELLS.EFFLORESCENCE_HEAL.id:\r\n          this.increasedRateEffloHealing += calculateEffectiveHealing(event, PHOTOSYNTHESIS_HOT_INCREASE);\r\n          break;\r\n        case SPELLS.REGROWTH.id:\r\n          if (event.tick === true) {\r\n            this.increasedRateRegrowthHealing += calculateEffectiveHealing(event, PHOTOSYNTHESIS_HOT_INCREASE);\r\n          }\r\n          break;\r\n        case SPELLS.TRANQUILITY_HEAL.id:\r\n          if (event.tick === true) {\r\n            this.increasedRateTranqHealing += calculateEffectiveHealing(event, PHOTOSYNTHESIS_HOT_INCREASE);\r\n          }\r\n          break;\r\n        default:\r\n          console.error('Photosynthesis: Error, could not identify this object as a HoT: %o', event);\r\n      }\r\n    }\r\n  }\r\n\r\n  statistic() {\r\n    const totalPercent = this.owner.getPercentageOfTotalHealingDone(\r\n      this.increasedRateRejuvenationHealing\r\n      + this.increasedRateWildGrowthHealing\r\n      + this.increasedRateCenarionWardHealing\r\n      + this.increasedRateCultivationHealing\r\n      + this.increasedRateLifebloomHealing\r\n      + this.increasedRateRegrowthHealing\r\n      + this.increasedRateTranqHealing\r\n      + this.increasedRateSpringBlossomsHealing\r\n      + this.increasedRateEffloHealing\r\n      + this.increasedRateGroveTendingHealing\r\n      + this.lifebloomIncrease);\r\n    const sourceID = this.selectedCombatant._combatantInfo.sourceID;\r\n    const selfUptime = this.selectedCombatant.getBuffUptime(SPELLS.LIFEBLOOM_HOT_HEAL.id, sourceID);\r\n    const totalUptime =\r\n      Object.keys(this.combatants.players)\r\n        .map(key => this.combatants.players[key])\r\n        .reduce((uptime, player) => uptime + player.getBuffUptime(SPELLS.LIFEBLOOM_HOT_HEAL.id), sourceID);\r\n\r\n    return (\r\n      <Statistic\r\n        position={STATISTIC_ORDER.OPTIONAL(20)}\r\n        size=\"flexible\"\r\n        tooltip={(\r\n          <>\r\n            Healing contribution\r\n            <ul>\r\n              <li>Rejuvenation: <strong>{formatPercentage(this.owner.getPercentageOfTotalHealingDone(this.increasedRateRejuvenationHealing))} %</strong></li>\r\n              <li>Wild Growth: <strong>{formatPercentage(this.owner.getPercentageOfTotalHealingDone(this.increasedRateWildGrowthHealing))} %</strong></li>\r\n              <li>Cenarion Ward: <strong>{formatPercentage(this.owner.getPercentageOfTotalHealingDone(this.increasedRateCenarionWardHealing))} %</strong></li>\r\n              <li>Cultivation: <strong>{formatPercentage(this.owner.getPercentageOfTotalHealingDone(this.increasedRateCultivationHealing))} %</strong></li>\r\n              <li>Lifebloom HoT: <strong>{formatPercentage(this.owner.getPercentageOfTotalHealingDone(this.increasedRateLifebloomHealing))} %</strong></li>\r\n              <li>Regrowth HoT: <strong>{formatPercentage(this.owner.getPercentageOfTotalHealingDone(this.increasedRateRegrowthHealing))} %</strong></li>\r\n              <li>Tranquility HoT: <strong>{formatPercentage(this.owner.getPercentageOfTotalHealingDone(this.increasedRateTranqHealing))} %</strong></li>\r\n              <li>Spring Blossoms: <strong>{formatPercentage(this.owner.getPercentageOfTotalHealingDone(this.increasedRateSpringBlossomsHealing))} %</strong></li>\r\n              <li>Efflorescence: <strong>{formatPercentage(this.owner.getPercentageOfTotalHealingDone(this.increasedRateEffloHealing))} %</strong></li>\r\n              <li>Grove Tending: <strong>{formatPercentage(this.owner.getPercentageOfTotalHealingDone(this.increasedRateGroveTendingHealing))} %</strong></li>\r\n              <hr />\r\n              <li>Total HoT increase part: <strong>{formatPercentage(totalPercent - this.owner.getPercentageOfTotalHealingDone(this.lifebloomIncrease))} %</strong></li>\r\n              <li>Lifebloom random bloom: <strong>{formatPercentage(this.owner.getPercentageOfTotalHealingDone(this.lifebloomIncrease))} %</strong> (Random proccs: {this.randomProccs}, Natural proccs: {this.naturalProccs})</li>\r\n            </ul>\r\n            Lifebloom uptime\r\n            <ul>\r\n              <li>On Self: <strong>{formatPercentage(selfUptime / this.owner.fightDuration)} %</strong></li>\r\n              <li>On Others: <strong>{formatPercentage((totalUptime - selfUptime) / this.owner.fightDuration)} %</strong></li>\r\n            </ul>\r\n          </>\r\n        )}\r\n      >\r\n        <BoringValue label={<><SpellIcon id={SPELLS.PHOTOSYNTHESIS_TALENT.id} /> Photosynthesis healing</>}>\r\n          <>\r\n            {formatPercentage(totalPercent)} %\r\n          </>\r\n        </BoringValue>\r\n      </Statistic>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Photosynthesis;\r\n","import React from 'react';\r\nimport { formatNumber, formatPercentage } from 'common/format';\r\nimport STATISTIC_ORDER from 'interface/others/STATISTIC_ORDER';\r\nimport Statistic from 'interface/statistics/Statistic';\r\n\r\nimport SPELLS from 'common/SPELLS';\r\nimport Analyzer, { SELECTED_PLAYER } from 'parser/core/Analyzer';\r\nimport Events from 'parser/core/Events';\r\nimport SpellIcon from 'common/SpellIcon';\r\nimport BoringValue from 'interface/statistics/components/BoringValueText';\r\n\r\nconst MS_BUFFER = 200;\r\nconst ABUNDANCE_MANA_REDUCTION = 0.06;\r\nconst ABUNDANCE_INCREASED_CRIT = 0.06;\r\n\r\n/*\r\n  For each Rejuvenation you have active, Regrowth's cost is reduced by 6% and critical effect chance is increased by 6%.\r\n */\r\nclass Abundance extends Analyzer {\r\n  manaSavings = [];\r\n  critGains = [];\r\n  stacks = [];\r\n\r\n  constructor(...args) {\r\n    super(...args);\r\n    this.active = this.selectedCombatant.hasTalent(SPELLS.ABUNDANCE_TALENT.id);\r\n    this.addEventListener(Events.cast.by(SELECTED_PLAYER).spell(SPELLS.REGROWTH), this.onCast);\r\n  }\r\n\r\n  onCast(event) {\r\n    const abundanceBuff = this.selectedCombatant.getBuff(SPELLS.ABUNDANCE_BUFF.id, event.timestamp, MS_BUFFER);\r\n    if (abundanceBuff == null) {\r\n      return;\r\n    }\r\n\r\n    if (!this.selectedCombatant.hasBuff(SPELLS.CLEARCASTING_BUFF.id) && !this.selectedCombatant.hasBuff(SPELLS.INNERVATE.id)) {\r\n      this.manaSavings.push(abundanceBuff.stacks * ABUNDANCE_MANA_REDUCTION > 1 ? 1 : abundanceBuff.stacks * ABUNDANCE_MANA_REDUCTION);\r\n      this.manaCasts += 1;\r\n    }\r\n\r\n    this.critGains.push((abundanceBuff.stacks * ABUNDANCE_INCREASED_CRIT) > 1 ? 1 : abundanceBuff.stacks * ABUNDANCE_INCREASED_CRIT);\r\n    this.stacks.push(abundanceBuff.stacks);\r\n  }\r\n\r\n  statistic() {\r\n    const avgManaSavingsPercent = (this.manaSavings.reduce(function(a, b) {\r\n      return a + b;\r\n    }, 0) / this.manaSavings.length) || 0;\r\n    const avgCritGains = (this.critGains.reduce(function(a, b) {\r\n      return a + b;\r\n    }, 0) / this.critGains.length) || 0;\r\n    const avgStacks = (this.stacks.reduce(function(a, b) {\r\n      return a + b;\r\n    }, 0) / this.stacks.length) || 0;\r\n    const avgManaSaings = SPELLS.REGROWTH.manaCost * avgManaSavingsPercent;\r\n\r\n    // TODO translate these values into healing/throughput.\r\n    return (\r\n      <Statistic\r\n        position={STATISTIC_ORDER.CORE(20)}\r\n        size=\"flexible\"\r\n        tooltip={(\r\n          <>\r\n            Average mana reductions gained was {formatPercentage(avgManaSavingsPercent)}% or {formatNumber(avgManaSaings)} mana per cast.<br />\r\n            Maximum mana saved was {avgManaSaings * this.manaSavings.length} <br />\r\n            Average crit gain was {formatPercentage(avgCritGains)}%.\r\n          </>\r\n        )}\r\n      >\r\n        <BoringValue label={<><SpellIcon id={SPELLS.ABUNDANCE_TALENT.id} /> Average Abundance stacks</>}>\r\n          <>\r\n            {avgStacks.toFixed(2)}\r\n          </>\r\n        </BoringValue>\r\n      </Statistic>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Abundance;\r\n","import SPELLS from 'common/SPELLS';\r\nimport STAT from 'parser/shared/modules/features/STAT';\r\nimport HIT_TYPES from 'game/HIT_TYPES';\r\n\r\nimport BaseHealerStatValues from 'parser/shared/modules/features/BaseHealerStatValues';\r\nimport Combatants from 'parser/shared/modules/Combatants';\r\nimport CritEffectBonus from 'parser/shared/modules/helpers/CritEffectBonus';\r\nimport StatTracker from 'parser/shared/modules/StatTracker';\r\n\r\nimport Mastery from '../core/Mastery';\r\n\r\nimport { DRUID_HEAL_INFO } from '../../SpellInfo';\r\n\r\n/*\r\n * Resto Druid Stat Weights Methodology\r\n *\r\n * Approach -\r\n * This module generates the players stat weights using the actual logged events. We keep a listing of all the player's healing spells\r\n * along with which stats those spells scales with, and for each stat a heal scales with we do some simple math to find out\r\n * how much more it would have healed if the player had one more of that stat. We compare the total healing increases\r\n * caused by seperately increasing each stat by one in order to generate weights.\r\n *\r\n * Overheal -\r\n * The toughest problem to face when generating healing stat weights is what to do about overhealing. Unfortunately, there is\r\n * no one correct answer. A main issue is what I call The \"Would've\" Problem. We can say \"an extra bit of healing here doesn't\r\n * matter because it *would've* just caused the next heal to overheal\", but how far can we take this logic? My approach is that\r\n * it doesn't only matter how much is healed, but also how quickly. We'll count all healing that doesn't overheal even if we\r\n * theorize that it might lead to overhealing. We're more strict on heals that overheal: they're disregarded entirely even\r\n * if they're only partial overhealing. This is because a spell that partially overheals will do the same amount of effective\r\n * healing regardless of the raw strength of the heal. This approach can cause some possible weirdness. For example, consider\r\n * a situation where there is a heal for 500 (0 overheal) followed immediately by a heal for 400 (+ 100 overheal). 500 of this\r\n * healing would be counted towards stat weights. Now consider a situation where one heal does 900 (+ 100 overheal). Functionally,\r\n * this situation is identical, but in this case none of the healing is counted towards stat weights. Counting all effective\r\n * healing, even heals that partially overheal, fixes this issue and is overall a valid approach, but still not one I will be taking.\r\n * I think an advantage of disregarding all partial overheals is that it gives \"top off\" heals an effective lower weight than\r\n * \"life saver\" heals. Still, this is a decision I will revisit.\r\n *\r\n * Stat Tracking -\r\n * These calculations work best when they use the players actual stats at the moment of a heal. As such, accuracy will be\r\n * improved when a StatTracker module is implemented, rather than being forced to use the player's stats at the moment of pull.\r\n * For now, I'm handling the most common big Druid stat buffs manually.\r\n *\r\n * Intellect -\r\n * Math here is straightforward, as spells that scale with int scale directly and linearly with total int. Due to the 'all leather'\r\n * bonus, each point of int gained is multiplied by 1.05, which has to be taken into account. The increase in power from\r\n * one int is simply 1.05 / totalInt.\r\n *\r\n * Crit -\r\n * The general formula is critChanceFromOneRating * healAmount, but we have to make sure to account for anything that makes a\r\n * crit stronger than 2x (e.g. Drape of Shame), and we also have to account for if healAmount is already a crit. If the heal\r\n * is already a crit then we double count the weight, so we first have to normalize it to the amount it would have done\r\n * had it not crit. Special handling is needed for Living Seed obviously. We assume that higher crit will result in proportionally\r\n * more Living Seeds, and so get the bonus to Living Seed as critChangeFromOneRating / critChance.\r\n *\r\n * Haste -\r\n * Calculating the benefit to healing from being able to cast faster is a huge pain in the ass, particularly for Resto Druids\r\n * who aren't very dependant on cast times. However, HoTs tick faster and effectively do increased healing per cast due to Haste.\r\n * We make the decision to only calculate this benefit, which is fairly simple math:\r\n * healAmount / (1 + hastePercentage) * hastePercentageFromOneRating\r\n *\r\n * Mastery -\r\n * The mastery calculation is almost the same as Haste's, in that you normalize the heal amount to be the amount it would\r\n * have been without any of the stat, and then multiply by the percentage gain from one rating. The one wrinkle is that mastery's\r\n * strength is multiplied by the number of hots on target. Fortunately, we can easily calculate the number of HoTs on the target\r\n * of each heal.\r\n *\r\n * Versatility -\r\n * This is the same calculation as for haste, healAmount / (1 + versPercentage) * versPercentageFromOneRating.\r\n * We don't currently consider the damage reduction bonus from vers, and it's probably not a good thing to add directly to\r\n * the weight as damage reduction isn't quite the same thing as healing. It's easy enough to calculate just by skimming the\r\n * appropriate percentage of each toPlayer_damage. I will probably add it to the tooltip in the future.\r\n *\r\n * Leech -\r\n * Calculating this is different depending on if the player does or does not already have any Leech. If the player does have\r\n * Leech we calculate this pretty much the same as int: for every Leech heal the increase in power from one leech is\r\n * simply 1 / totalLeechRating. If the player does not already have Leech, things are much more difficult. I have not yet\r\n * settled on an approach, and so this calculation is not yet implemented.\r\n *\r\n * Special Cases -\r\n *\r\n * A few special cases are considered. We're ignoring all Tranq healing, even ticks that don't overheal, under the assumption\r\n * that the last ticks always overheal so what's the difference? I know this is a violation of the \"would've\" rule I detailed\r\n * above. This decision may be revisited.\r\n *\r\n * Leech and Velens heals are disregarded for the purpose of the main stat's weights, as they scale with whatever procced them.\r\n * It's easiest to just not count them.\r\n *\r\n * If a heal is not in the database of heals, it's assumed to scale only with Vers. This is generally a good assumption,\r\n * and this is how most trinket heals behave.\r\n */\r\nclass StatWeights extends BaseHealerStatValues {\r\n  static dependencies = {\r\n    combatants: Combatants,\r\n    critEffectBonus: CritEffectBonus,\r\n    statTracker: StatTracker,\r\n    mastery: Mastery,\r\n  };\r\n\r\n  spellInfo = DRUID_HEAL_INFO;\r\n  qeLive = true;\r\n  done = false;\r\n\r\n  _getCritChance(event) {\r\n    const spellId = event.ability.guid;\r\n    const critChanceBreakdown = super._getCritChance(event);\r\n\r\n    if (spellId === SPELLS.REGROWTH.id) {\r\n      critChanceBreakdown.baseCritChance += 0.4;\r\n    }\r\n\r\n    // TODO handle Abundance\r\n\r\n    return critChanceBreakdown;\r\n  }\r\n\r\n  _criticalStrike(event, healVal) {\r\n    const bonusFromOneCrit = 1 / this.statTracker.ratingNeededForNextPercentage(this.statTracker.currentHasteRating, this.statTracker.statBaselineRatingPerPercent[STAT.CRITICAL_STRIKE]);\r\n\r\n    if (healVal.overheal) {\r\n      return 0;\r\n    }\r\n    const critMult = this.critEffectBonus.getBonus(event);\r\n    const noCritHealing = event.hitType === HIT_TYPES.CRIT ? healVal.effective / critMult : healVal.effective;\r\n    return noCritHealing * bonusFromOneCrit * (critMult - 1);\r\n\r\n  }\r\n\r\n  _hasteHpm(event, healVal) {\r\n    if (healVal.overheal) {\r\n      return 0;\r\n    }\r\n    if (event.ability.guid === SPELLS.REGROWTH.id && !event.tick) {\r\n      return 0;\r\n    }\r\n    return super._hasteHpm(event, healVal);\r\n  }\r\n\r\n  // _hasteHpct(event, healVal) {\r\n  //   return super._hasteHpct(event, healVal) + this._hasteHpm(event, healVal);\r\n  // }\r\n\r\n  _mastery(event, healVal) {\r\n    if (healVal.overheal) {\r\n      return 0;\r\n    }\r\n    const target = this.combatants.getEntity(event);\r\n    if (target === null) {\r\n      return 0;\r\n    }\r\n    const bonusFromOneMastery = 1 / this.statTracker.ratingNeededForNextPercentage(this.statTracker.currentMasteryRating, this.statTracker.statBaselineRatingPerPercent[STAT.MASTERY], this.selectedCombatant.spec.masteryCoefficient);\r\n    const hotCount = this.mastery.getHotCount(target);\r\n    const noMasteryHealing = healVal.effective / (1 + (this.statTracker.currentMasteryPercentage * hotCount));\r\n    return noMasteryHealing * bonusFromOneMastery * hotCount;\r\n  }\r\n\r\n  _prepareResults() {\r\n    return [\r\n      STAT.INTELLECT,\r\n      STAT.CRITICAL_STRIKE,\r\n      STAT.HASTE_HPCT, // TODO implement\r\n      STAT.HASTE_HPM,\r\n      STAT.MASTERY,\r\n      STAT.VERSATILITY,\r\n      STAT.VERSATILITY_DR,\r\n      STAT.LEECH,\r\n    ];\r\n  }\r\n\r\n  statistic() {\r\n    if (!this.done) {\r\n      this.totalOneHasteHpct = this.totalOneHasteHpm + this.totalOneHasteHpct;\r\n      this.done = true;\r\n    }\r\n    return super.statistic();\r\n  }\r\n\r\n}\r\n\r\nexport default StatWeights;\r\n","import AbilityTracker from 'parser/shared/modules/AbilityTracker';\r\nimport HealingDone from 'parser/shared/modules/throughput/HealingDone';\r\nimport DamageDone from 'parser/shared/modules/throughput/DamageDone';\r\nimport CastEfficiency from 'parser/shared/modules/CastEfficiency';\r\nimport HealingEfficiencyTracker from 'parser/core/healingEfficiency/HealingEfficiencyTracker';\r\nimport SPELLS from 'common/SPELLS/index';\r\nimport ManaTracker from 'parser/core/healingEfficiency/ManaTracker';\r\n\r\nimport RegrowthAttributor from 'parser/druid/restoration/modules/core/hottracking/RegrowthAttributor';\r\nimport Abilities from 'parser/druid/restoration/modules/Abilities';\r\nimport Clearcasting from 'parser/druid/restoration/modules/features/Clearcasting';\r\n\r\n/*\r\n    TODO:\r\n      * Some spells contain multiple healIds, create a graphical breakdown\r\n      * Factor in mastery healing\r\n      * Add more descriptions\r\n */\r\nclass RestoDruidHealingEfficiencyTracker extends HealingEfficiencyTracker {\r\n  static dependencies = {\r\n    manaTracker: ManaTracker,\r\n    abilityTracker: AbilityTracker,\r\n    healingDone: HealingDone,\r\n    damageDone: DamageDone,\r\n    castEfficiency: CastEfficiency,\r\n\r\n    // Custom dependencies\r\n    abilities: Abilities,\r\n    regrowthAttributor: RegrowthAttributor,\r\n    clearcasting: Clearcasting,\r\n  };\r\n\r\n  getCustomSpellStats(spellInfo, spellId) {\r\n    // If we have a spell that has custom logic for the healing/damage numbers, do that before the rest of our calculations.\r\n    if (spellId === SPELLS.REGROWTH.id) {\r\n      spellInfo = this.getRegrowthDetails(spellInfo);\r\n    }\r\n\r\n    return spellInfo;\r\n  }\r\n\r\n  getRegrowthDetails(spellInfo) {\r\n    // This represents that amount of healing done by HARD CASTING regrowth.\r\n    // We don't want regrowth to get Hpm credit for healing that we didn't spend mana on.\r\n    spellInfo.healingDone = this.regrowthAttributor.totalNonCCRegrowthHealing;\r\n    spellInfo.overhealingDone = this.regrowthAttributor.totalNonCCRegrowthOverhealing;\r\n    spellInfo.healingAbsorbed = this.regrowthAttributor.totalNonCCRegrowthAbsorbs;\r\n    spellInfo.casts = this.clearcasting.nonCCRegrowths;\r\n    spellInfo.hits = this.regrowthAttributor.totalNonCCRegrowthHealingTicks;\r\n\r\n    return spellInfo;\r\n  }\r\n}\r\n\r\nexport default RestoDruidHealingEfficiencyTracker;\r\n","import React from 'react';\r\n\r\nimport SPELLS from 'common/SPELLS';\r\nimport Events from 'parser/core/Events';\r\nimport Analyzer, { SELECTED_PLAYER } from 'parser/core/Analyzer';\r\n\r\nimport calculateEffectiveHealing from 'parser/core/calculateEffectiveHealing';\r\n\r\nimport BoringSpellValueText from 'interface/statistics/components/BoringSpellValueText';\r\nimport Statistic from 'interface/statistics/Statistic';\r\nimport STATISTIC_ORDER from 'interface/others/STATISTIC_ORDER';\r\nimport STATISTIC_CATEGORY from 'interface/others/STATISTIC_CATEGORY';\r\nimport ItemHealingDone from 'interface/ItemHealingDone';\r\n\r\nclass FlashOfClarity extends Analyzer {\r\n\r\n  healingBoost = 0;\r\n  healing = 0;\r\n\r\n  targetsWithClearCastingRegrowth = [];\r\n\r\n  /**\r\n   * Flash of Clarity makes it so any regrowth casted with clearcasting is boosted by x% on hot healing and direct heal\r\n   */\r\n  constructor(...args) {\r\n    super(...args);\r\n    this.active = false;\r\n\r\n    this.healingBoost = .20;//TODO Get from combat data when they EXPORT IT >:c\r\n\r\n    if (!this.active) {\r\n      return;\r\n    }\r\n\r\n    this.addEventListener(Events.cast.by(SELECTED_PLAYER).spell(SPELLS.REGROWTH), this.checkIfClearCasting);\r\n    this.addEventListener(Events.heal.by(SELECTED_PLAYER).spell(SPELLS.REGROWTH), this.normalizeBoost);\r\n  }\r\n\r\n  checkIfClearCasting(event){\r\n    const targetID = event.targetID;\r\n    // Currently this is bugged so when you are innervated each\r\n    // !this.selectedCombatant.hasBuff(SPELLS.INNERVATE.id)\r\n    if(this.selectedCombatant.hasBuff(SPELLS.CLEARCASTING_BUFF.id)) {\r\n      this.targetsWithClearCastingRegrowth[targetID] = targetID;\r\n    }else if(this.targetsWithClearCastingRegrowth[targetID]){\r\n      delete this.targetsWithClearCastingRegrowth[targetID];\r\n    }\r\n  }\r\n\r\n  normalizeBoost(event){\r\n    if(this.targetsWithClearCastingRegrowth[event.targetID]){\r\n      this.healing += calculateEffectiveHealing(event, this.healingBoost);\r\n    }\r\n  }\r\n\r\n  statistic() {\r\n    return (\r\n      <Statistic\r\n        position={STATISTIC_ORDER.OPTIONAL(13)}\r\n        size=\"flexible\"\r\n        category={STATISTIC_CATEGORY.COVENANTS}\r\n      >\r\n        <BoringSpellValueText spell={SPELLS.FLASH_OF_CLARITY}>\r\n          <ItemHealingDone amount={this.healing} /><br />\r\n        </BoringSpellValueText>\r\n      </Statistic>\r\n    );\r\n  }\r\n}\r\n\r\nexport default FlashOfClarity;\r\n","import CoreCombatLogParser from 'parser/core/CombatLogParser';\r\nimport LowHealthHealing from 'parser/shared/modules/features/LowHealthHealing';\r\nimport ManaLevelChart from 'parser/shared/modules/resources/mana/ManaLevelChart';\r\nimport ManaUsageChart from 'parser/shared/modules/resources/mana/ManaUsageChart';\r\n\r\nimport WildGrowthNormalizer from './normalizers/WildGrowth';\r\nimport ClearcastingNormalizer from './normalizers/ClearcastingNormalizer';\r\nimport HotApplicationNormalizer from './normalizers/HotApplicationNormalizer';\r\nimport TreeOfLifeNormalizer from './normalizers/TreeOfLifeNormalizer';\r\n\r\nimport Checklist from './modules/features/Checklist/Module';\r\n\r\nimport Mastery from './modules/core/Mastery';\r\nimport Rejuvenation from './modules/core/Rejuvenation';\r\n\r\nimport HotTrackerRestoDruid from './modules/core/hottracking/HotTrackerRestoDruid';\r\nimport RejuvenationAttributor from './modules/core/hottracking/RejuvenationAttributor';\r\nimport RegrowthAttributor from './modules/core/hottracking/RegrowthAttributor';\r\nimport SpellManaCost from './modules/core/SpellManaCost';\r\n\r\nimport AlwaysBeCasting from './modules/features/AlwaysBeCasting';\r\nimport AverageHots from './modules/features/AverageHots';\r\nimport Abilities from './modules/Abilities';\r\nimport CooldownThroughputTracker from './modules/features/CooldownThroughputTracker';\r\nimport WildGrowth from './modules/features/WildGrowth';\r\nimport Lifebloom from './modules/features/Lifebloom';\r\nimport Efflorescence from './modules/features/Efflorescence';\r\nimport Clearcasting from './modules/features/Clearcasting';\r\nimport Innervate from './modules/features/Innervate';\r\nimport Ironbark from './modules/features/Ironbark';\r\nimport PrematureRejuvenations from './modules/features/PrematureRejuvenations';\r\n\r\nimport CenarionWard from './modules/talents/CenarionWard';\r\nimport Cultivation from './modules/talents/Cultivation';\r\nimport Flourish from './modules/talents/Flourish';\r\nimport SpringBlossoms from './modules/talents/SpringBlossoms';\r\nimport SoulOfTheForest from './modules/talents/SoulOfTheForest';\r\nimport TreeOfLife from './modules/talents/TreeOfLife';\r\nimport Photosynthesis from './modules/talents/Photosynthesis';\r\nimport Abundance from './modules/talents/Abundance';\r\n\r\nimport StatWeights from './modules/features/StatWeights';\r\n\r\n// Mana Tracker\r\nimport ManaTracker from '../../core/healingEfficiency/ManaTracker';\r\nimport HealingEfficiencyDetails from '../../core/healingEfficiency/HealingEfficiencyDetails';\r\nimport HealingEfficiencyTracker from './modules/features/RestoDruidHealingEfficiencyTracker';\r\n\r\nimport { ABILITIES_AFFECTED_BY_HEALING_INCREASES } from './constants';\r\n\r\n// Concduits\r\n\r\n// Potency\r\nimport FlashOfClarity from './modules/shadowlands/conduits/FlashOfClarity';\r\n\r\nclass CombatLogParser extends CoreCombatLogParser {\r\n  static abilitiesAffectedByHealingIncreases = ABILITIES_AFFECTED_BY_HEALING_INCREASES;\r\n\r\n  static specModules = {\r\n    // Normalizers\r\n    wildGrowthNormalizer: WildGrowthNormalizer,\r\n    clearcastingNormalizer: ClearcastingNormalizer,\r\n    hotApplicationNormalizer: HotApplicationNormalizer, // this needs to be loaded after potaNormalizer, as potaNormalizer can sometimes unfix the events if loaded before...\r\n    treeOfLifeNormalizer: TreeOfLifeNormalizer,\r\n\r\n    // Core\r\n    rejuvenation: Rejuvenation,\r\n    mastery: Mastery,\r\n    spellManaCost: SpellManaCost,\r\n\r\n    // Generic healer things\r\n    manaLevelChart: ManaLevelChart,\r\n    manaUsageChart: ManaUsageChart,\r\n\r\n    // Checklist\r\n    checklist: Checklist,\r\n\r\n    // Hot Tracking\r\n    hotTracker: HotTrackerRestoDruid,\r\n    rejuvenationAttributor: RejuvenationAttributor,\r\n    regrowthAttributor: RegrowthAttributor,\r\n\r\n    // Features\r\n    lowHealthHealing: LowHealthHealing,\r\n    alwaysBeCasting: AlwaysBeCasting,\r\n    averageHots: AverageHots,\r\n    cooldownThroughputTracker: CooldownThroughputTracker,\r\n    abilities: Abilities,\r\n    wildGrowth: WildGrowth,\r\n    lifebloom: Lifebloom,\r\n    efflorescence: Efflorescence,\r\n    clearcasting: Clearcasting,\r\n    innervate: Innervate,\r\n    springBlossoms: SpringBlossoms,\r\n    cultivation: Cultivation,\r\n    ironbark: Ironbark,\r\n    prematureRejuvenations: PrematureRejuvenations,\r\n\r\n    // Talents\r\n    soulOfTheForest: SoulOfTheForest,\r\n    treeOfLife: TreeOfLife,\r\n    photosynthesis: Photosynthesis,\r\n    flourish: Flourish,\r\n    cenarionWard: CenarionWard,\r\n    abundance: Abundance,\r\n\r\n    //stat weights\r\n    statWeights: StatWeights,\r\n\r\n    // Mana Tab\r\n    manaTracker: ManaTracker,\r\n    hpmDetails: HealingEfficiencyDetails,\r\n    hpmTracker: HealingEfficiencyTracker,\r\n\r\n    // Conduits\r\n    // Potency\r\n    flashOfClarity: FlashOfClarity,\r\n  };\r\n}\r\n\r\nexport default CombatLogParser;\r\n","/**\r\n * A simple component that shows the spell value in the most plain way possible.\r\n * Use this only as the very last resort.\r\n */\r\nimport React from 'react';\r\n\r\nimport SpellIcon from 'common/SpellIcon';\r\nimport SpellLink from 'common/SpellLink';\r\nimport Spell from 'common/SPELLS/Spell';\r\n\r\ntype Props = {\r\n  spell: Spell;\r\n  children: React.ReactNode;\r\n  className?: string;\r\n}\r\n\r\nconst BoringSpellValueText = ({ spell, children, className }: Props) => (\r\n  <div className={`pad boring-text ${className || ''}`}>\r\n    <label>\r\n      <SpellIcon id={spell.id} /> <SpellLink id={spell.id} icon={false} />\r\n    </label>\r\n    <div className=\"value\">\r\n      {children}\r\n    </div>\r\n  </div>\r\n);\r\n\r\nexport default BoringSpellValueText;\r\n","import React from 'react';\r\n\r\n// https://thenounproject.com/term/duration/370713/\r\n// duration by Bohdan Burmich from the Noun Project\r\nconst Icon = ({ ...other }) => (\r\n  <svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"10 10 80 80\" className=\"icon\" {...other}>\r\n    <path d=\"M50,86.4865c17.4361,0,31.6216-14.1855,31.6216-31.6216c0-16.6168-12.8865-30.2714-29.1892-31.5189v-4.9677h7.2973v-4.8649  H40.2703v4.8649h7.2973v4.9677c-16.3027,1.2475-29.1892,14.902-29.1892,31.5189C18.3784,72.3009,32.5639,86.4865,50,86.4865z M52.4324,28.2236c3.1101,0.2817,6.0664,1.0982,8.7798,2.356l-8.7798,15.2073V28.2236z M47.5676,28.2236v26.6412 c0,1.1008,0.7393,2.0647,1.8029,2.3497c0.209,0.0561,0.4205,0.0827,0.6295,0.0827c0.8533,0,1.6642-0.4504,2.1065-1.2162 l13.3146-23.0616c6.8507,4.8503,11.3357,12.8315,11.3357,21.8454c0,14.7537-12.0031,26.7567-26.7568,26.7567 s-26.7568-12.003-26.7568-26.7567C23.2432,40.9315,33.9501,29.4573,47.5676,28.2236z\" />\r\n  </svg>\r\n);\r\n\r\nexport default Icon;\r\n","/**\r\n * A simple component that shows a value in the most plain way possible.\r\n * Use this only as the very last resort.\r\n */\r\nimport React from 'react';\r\n\r\ntype Props = {\r\n  label: React.ReactNode;\r\n  children: React.ReactNode;\r\n  className?: string;\r\n}\r\n\r\nconst BoringValue = ({ label, children, className }: Props) => (\r\n  <div className={`pad boring-text ${className || ''}`}>\r\n    <label>\r\n      {label}\r\n    </label>\r\n    <div className=\"value\">\r\n      {children}\r\n    </div>\r\n  </div>\r\n);\r\n\r\nexport default BoringValue;\r\n","/**\r\n * Velen's is a static 15% healing increase to the raw healing going out. If that increase turns out to be overhealing it is worthless, so my approach of reducing the healing gain by the overhealing really only gives you the gain in healing that actually did something. An implementation that ignores overhealing and acts like Velen's contributed 15% of the effective healing will be inaccurate if there was any overhealing.\r\n *\r\n * I'll try to explain this PoV with an example:\r\n * Normal spell heals for 1,000 raw\r\n * With Velen's this is 1,150 raw. So Velen's increased the heal by 150 raw healing, that healing is on top of the original 1,000 raw healing the spell normally does.\r\n * Then comes overhealing;\r\n * If the spell overheals for 50, then the spell will have healed for 1,100. At this point Velen's effectively contributes 100 healing.\r\n * If the spell overheals for 100, then the spell will have healed for 1,050. So velen's effectiveness is 50;\r\n * If the spell overheals for 150, then the spell will have healed for the original 1,000 and Velen's increase was completely wasted.\r\n * If the spell overheals for 200, then 50 healing of the original spell was already overhealing, and the increased healing from Velen's did nothing (0).\r\n *\r\n * If you ignore raw healing and look at the actual healing done you may see the last 950 healing and think 15% of that was contributed by Velen's, while in fact it was 0.\r\n */\r\n\r\nexport default function calculateEffectiveHealing(event, relativeHealIncrease) {\r\n  const amount = event.amount;\r\n  const absorbed = event.absorbed || 0;\r\n  const overheal = event.overheal || 0;\r\n  const raw = amount + absorbed + overheal;\r\n  const relativeHealingIncreaseFactor = 1 + relativeHealIncrease;\r\n  const healingIncrease = raw - raw / relativeHealingIncreaseFactor;\r\n  const effectiveHealing = healingIncrease - overheal;\r\n\r\n  return Math.max(0, effectiveHealing);\r\n}\r\n","import Analyzer, { SELECTED_PLAYER, Options } from 'parser/core/Analyzer';\r\nimport EventEmitter from 'parser/core/modules/EventEmitter';\r\nimport Events, { EventType, ClassResources, EnergizeEvent, CastEvent, HealEvent, SpendResourceEvent } from 'parser/core/Events';\r\nimport { Resource } from 'game/RESOURCE_TYPES';\r\n\r\nexport type BuilderObj = {\r\n  generated: number,\r\n  wasted: number,\r\n  casts: number,\r\n}\r\n\r\nexport type SpenderObj = {\r\n  spent: number,\r\n  spentByCast: number[],\r\n  casts: number,\r\n}\r\n\r\ntype ResourceUpdate = {\r\n  timestamp: number | undefined,\r\n  current: number,\r\n  waste: number,\r\n  generated: number,\r\n  used: number,\r\n}\r\n\r\n/**\r\n * This is an 'abstract' implementation of a framework for tracking resource generating/spending.\r\n * Extend it by following the instructions in the TODO comments below\r\n */\r\nclass ResourceTracker extends Analyzer {\r\n  static dependencies = {\r\n    eventEmitter: EventEmitter,\r\n    // Optional dependency for the `resourceCost` prop of events\r\n    // spellResourceCost: SpellResourceCost,\r\n  };\r\n\r\n  protected eventEmitter!: EventEmitter;\r\n\r\n  current = 0;\r\n  resourceUpdates: ResourceUpdate[] = [];\r\n\r\n  // stores resource gained/spent/wasted by ability ID\r\n  buildersObj: {[index: number]: BuilderObj} = {};\r\n  spendersObj: {[index: number]: SpenderObj} = {};\r\n\r\n  // TODO set this to the resource you wish to track constructor.. see the appropriate objects in game/RESOURCE_TYPES\r\n  resource!: Resource;\r\n\r\n  // TODO a classes 'main' resource passes the max along with events, but for other resources this may need to be defined\r\n  maxResource!: number;\r\n\r\n  constructor(options: Options){\r\n    super(options);\r\n    this.addEventListener(Events.energize.to(SELECTED_PLAYER), this.onEnergize);\r\n    this.addEventListener(Events.cast.by(SELECTED_PLAYER), this.onCast);\r\n  }\r\n\r\n  // FIXME implement natural regen\r\n  // TODO if the tracked resource naturally regenerates (like Energy), set this to true and set the parameters of the regeneration in the below fields\r\n  // naturallyRegenerates = false;\r\n  // baseRegenRate; // TODO resource's base regeneration rate in points per second\r\n  // isRegenHasted; // TODO iff true, regeneration rate will be scaled with haste\r\n\r\n  // TODO if you wish an ability to show in results even if it wasn't used, add it using these functions constructor\r\n  initBuilderAbility(spellId: number) {\r\n    this.buildersObj[spellId] = { generated: 0, wasted: 0, casts: 0 };\r\n  }\r\n  initSpenderAbility(spellId: number) {\r\n    this.spendersObj[spellId] = { spent: 0, spentByCast: [], casts: 0 };\r\n  }\r\n\r\n  // BUILDERS - Handled on energize, using the 'resourceChange' field\r\n  onEnergize(event: EnergizeEvent) {\r\n    const spellId = event.ability.guid;\r\n\r\n    if(event.resourceChangeType !== this.resource.id) {\r\n        return;\r\n    }\r\n\r\n    const waste = event.waste;\r\n    const gain = event.resourceChange - waste;\r\n    this._applyBuilder(spellId, gain, waste, this.getResource(event), event.timestamp);\r\n  }\r\n\r\n  // FIXME Track resource drains too, so that the 'current' value can be more accurate\r\n\r\n  // TODO if a resource gain isn't showing as an energize in events, handle it manually by calling this\r\n  /**\r\n   * FIXME solve with a normalizer instead?\r\n   * Applies an energize of the tracked resource type.\r\n   * @param {number} spellId - The spellId to attribute the resource gain to\r\n   * @param {number} amount - The raw amount of resources to gain\r\n   */\r\n  processInvisibleEnergize(spellId: number, amount: number) {\r\n    const maxGain = this.maxResource !== undefined ? this.maxResource - this.current : amount;\r\n    const gain = Math.min(amount, maxGain);\r\n    const waste = Math.max(amount - maxGain, 0);\r\n    this._applyBuilder(spellId, gain, waste);\r\n  }\r\n\r\n  _applyBuilder(spellId: number, gain: number, waste: number,  resource?: ClassResources, timestamp?: number) {\r\n    if (!this.buildersObj[spellId]) {\r\n        this.initBuilderAbility(spellId);\r\n    }\r\n\r\n    this.buildersObj[spellId].wasted += waste;\r\n    this.buildersObj[spellId].generated += gain;\r\n    this.buildersObj[spellId].casts += 1;\r\n\r\n    // resource.amount for an energize is the amount AFTER the energize\r\n    if (resource !== null && resource !== undefined && resource.amount !== undefined) {\r\n      this.current = resource.amount;\r\n      if (resource.max !== undefined) {\r\n        this.maxResource = resource.max; // track changes in max resource, which can happen due to procs / casts\r\n      }\r\n    } else {\r\n      this.current += gain;\r\n    }\r\n\r\n    this.resourceUpdates.push({\r\n      timestamp: timestamp,\r\n      current: this.current,\r\n      waste: waste,\r\n      generated: gain,\r\n      used: 0,\r\n    });\r\n  }\r\n\r\n  // SPENDERS - Handled on cast, using the 'classResources' field\r\n  onCast(event: CastEvent) {\r\n    const spellId = event.ability.guid;\r\n\r\n    if(!this.shouldProcessCastEvent(event)) {\r\n        return;\r\n    }\r\n    const eventResource = this.getResource(event);\r\n\r\n    if(!eventResource){\r\n      return;\r\n    }\r\n\r\n    if (eventResource.max) {\r\n      this.maxResource = eventResource.max; // track changes in max resource, which can happen due to procs / casts\r\n    }\r\n    const cost = this.getReducedCost(event);\r\n\r\n    if (!this.spendersObj[spellId]) {\r\n      this.initSpenderAbility(spellId);\r\n    }\r\n\r\n    if (!cost || cost === 0) {\r\n      return;\r\n    }\r\n\r\n    this.spendersObj[spellId].casts += 1;\r\n    this.spendersObj[spellId].spentByCast.push(cost);\r\n    if(cost > 0) {\r\n      this.spendersObj[spellId].spent += cost;\r\n    }\r\n\r\n    //Re-sync current amount, to update not-tracked gains.\r\n    this.current = eventResource.amount - cost;\r\n\r\n    this.resourceUpdates.push({\r\n      timestamp: event.timestamp,\r\n      current: this.current,\r\n      waste: 0,\r\n      generated: 0,\r\n      used: eventResource.amount,\r\n    });\r\n\r\n    this.triggerSpendEvent(cost, event);\r\n  }\r\n\r\n  // TODO if your spec has an ability cost reduction that doesn't show in events, handle it manually by overriding here. Or extend SpellResourceCost and apply the discount there.\r\n  getReducedCost(event: CastEvent) {\r\n    if (event.resourceCost && event.resourceCost[this.resource.id] !== undefined) {\r\n      return event.resourceCost[this.resource.id];\r\n    }\r\n    return this.getResource(event)?.cost;\r\n  }\r\n\r\n  getResource(event: CastEvent | HealEvent | EnergizeEvent ) {\r\n    if(!event.classResources) {\r\n      return undefined;\r\n    } else {\r\n      return event.classResources.find(r => r.type === this.resource.id);\r\n    }\r\n  }  \r\n\r\n  triggerSpendEvent(spent: number, event: CastEvent) {\r\n\r\n    const fabricatedEvent: SpendResourceEvent = {\r\n      type: EventType.SpendResource,\r\n      timestamp: event.timestamp,\r\n      sourceID: event.sourceID,\r\n      targetID: event.targetID,\r\n      resourceChange: spent,\r\n      resourceChangeType: this.resource.id,\r\n      ability: event.ability,\r\n      __fabricated: true,\r\n    };\r\n\r\n    this.eventEmitter.fabricateEvent(fabricatedEvent, event);\r\n  }\r\n\r\n  shouldProcessCastEvent(event: CastEvent) {\r\n    return Boolean(this.getResource(event));\r\n  }\r\n\r\n  getGeneratedBySpell(spellId: number) {\r\n    return (this.buildersObj[spellId] && this.buildersObj[spellId].generated) || 0;\r\n  }\r\n\r\n  getWastedBySpell(spellId: number) {\r\n    return (this.buildersObj[spellId] && this.buildersObj[spellId].wasted) || 0;\r\n  }\r\n\r\n  getBuilderCastsBySpell(spellId: number) {\r\n    return (this.buildersObj[spellId] && this.buildersObj[spellId].casts) || 0;\r\n  }\r\n\r\n  get generated() {\r\n    return Object.values(this.buildersObj).reduce((acc, spell) => acc + spell.generated, 0);\r\n  }\r\n\r\n  get wasted() {\r\n    return Object.values(this.buildersObj).reduce((acc, spell) => acc + spell.wasted, 0);\r\n  }\r\n\r\n  get spent() {\r\n    return Object.values(this.spendersObj).reduce((acc, spell) => acc + spell.spent, 0);\r\n  }\r\n\r\n  get spendersCasts() {\r\n    return Object.values(this.spendersObj).reduce((acc, spell) => acc + spell.casts, 0);\r\n  }\r\n}\r\n\r\nexport default ResourceTracker;\r\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _propTypes = require('prop-types');\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _classnames = require('classnames');\n\nvar _classnames2 = _interopRequireDefault(_classnames);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar ANIMATION_STATE_CLASSES = {\n  animating: 'rah-animating',\n  animatingUp: 'rah-animating--up',\n  animatingDown: 'rah-animating--down',\n  animatingToHeightZero: 'rah-animating--to-height-zero',\n  animatingToHeightAuto: 'rah-animating--to-height-auto',\n  animatingToHeightSpecific: 'rah-animating--to-height-specific',\n  static: 'rah-static',\n  staticHeightZero: 'rah-static--height-zero',\n  staticHeightAuto: 'rah-static--height-auto',\n  staticHeightSpecific: 'rah-static--height-specific'\n};\n\nvar PROPS_TO_OMIT = ['animateOpacity', 'animationStateClasses', 'applyInlineTransitions', 'children', 'contentClassName', 'delay', 'duration', 'easing', 'height', 'onAnimationEnd', 'onAnimationStart'];\n\nfunction omit(obj) {\n  for (var _len = arguments.length, keys = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    keys[_key - 1] = arguments[_key];\n  }\n\n  if (!keys.length) {\n    return obj;\n  }\n\n  var res = {};\n  var objectKeys = Object.keys(obj);\n\n  for (var i = 0; i < objectKeys.length; i++) {\n    var key = objectKeys[i];\n\n    if (keys.indexOf(key) === -1) {\n      res[key] = obj[key];\n    }\n  }\n\n  return res;\n}\n\n// Start animation helper using nested requestAnimationFrames\nfunction startAnimationHelper(callback) {\n  var requestAnimationFrameIDs = [];\n\n  requestAnimationFrameIDs[0] = requestAnimationFrame(function () {\n    requestAnimationFrameIDs[1] = requestAnimationFrame(function () {\n      callback();\n    });\n  });\n\n  return requestAnimationFrameIDs;\n}\n\nfunction cancelAnimationFrames(requestAnimationFrameIDs) {\n  requestAnimationFrameIDs.forEach(function (id) {\n    return cancelAnimationFrame(id);\n  });\n}\n\nfunction isNumber(n) {\n  return !isNaN(parseFloat(n)) && isFinite(n);\n}\n\nfunction isPercentage(height) {\n  // Percentage height\n  return typeof height === 'string' && height.search('%') === height.length - 1 && isNumber(height.substr(0, height.length - 1));\n}\n\nfunction runCallback(callback, params) {\n  if (callback && typeof callback === 'function') {\n    callback(params);\n  }\n}\n\nvar AnimateHeight = function (_React$Component) {\n  _inherits(AnimateHeight, _React$Component);\n\n  function AnimateHeight(props) {\n    _classCallCheck(this, AnimateHeight);\n\n    var _this = _possibleConstructorReturn(this, (AnimateHeight.__proto__ || Object.getPrototypeOf(AnimateHeight)).call(this, props));\n\n    _this.animationFrameIDs = [];\n\n    var height = 'auto';\n    var overflow = 'visible';\n\n    if (isNumber(props.height)) {\n      // If value is string \"0\" make sure we convert it to number 0\n      height = props.height < 0 || props.height === '0' ? 0 : props.height;\n      overflow = 'hidden';\n    } else if (isPercentage(props.height)) {\n      // If value is string \"0%\" make sure we convert it to number 0\n      height = props.height === '0%' ? 0 : props.height;\n      overflow = 'hidden';\n    }\n\n    _this.animationStateClasses = _extends({}, ANIMATION_STATE_CLASSES, props.animationStateClasses);\n\n    var animationStateClasses = _this.getStaticStateClasses(height);\n\n    _this.state = {\n      animationStateClasses: animationStateClasses,\n      height: height,\n      overflow: overflow,\n      shouldUseTransitions: false\n    };\n    return _this;\n  }\n\n  _createClass(AnimateHeight, [{\n    key: 'componentDidMount',\n    value: function componentDidMount() {\n      var height = this.state.height;\n\n      // Hide content if height is 0 (to prevent tabbing into it)\n      // Check for contentElement is added cause this would fail in tests (react-test-renderer)\n      // Read more here: https://github.com/Stanko/react-animate-height/issues/17\n\n      if (this.contentElement && this.contentElement.style) {\n        this.hideContent(height);\n      }\n    }\n  }, {\n    key: 'componentDidUpdate',\n    value: function componentDidUpdate(prevProps, prevState) {\n      var _this2 = this;\n\n      var _props = this.props,\n          delay = _props.delay,\n          duration = _props.duration,\n          height = _props.height,\n          onAnimationEnd = _props.onAnimationEnd,\n          onAnimationStart = _props.onAnimationStart;\n\n      // Check if 'height' prop has changed\n\n      if (this.contentElement && height !== prevProps.height) {\n        var _cx;\n\n        // Remove display: none from the content div\n        // if it was hidden to prevent tabbing into it\n        this.showContent(prevState.height);\n\n        // Cache content height\n        this.contentElement.style.overflow = 'hidden';\n        var contentHeight = this.contentElement.offsetHeight;\n        this.contentElement.style.overflow = '';\n\n        // set total animation time\n        var totalDuration = duration + delay;\n\n        var newHeight = null;\n        var timeoutState = {\n          height: null, // it will be always set to either 'auto' or specific number\n          overflow: 'hidden'\n        };\n        var isCurrentHeightAuto = prevState.height === 'auto';\n\n        if (isNumber(height)) {\n          // If value is string \"0\" make sure we convert it to number 0\n          newHeight = height < 0 || height === '0' ? 0 : height;\n          timeoutState.height = newHeight;\n        } else if (isPercentage(height)) {\n          // If value is string \"0%\" make sure we convert it to number 0\n          newHeight = height === '0%' ? 0 : height;\n          timeoutState.height = newHeight;\n        } else {\n          // If not, animate to content height\n          // and then reset to auto\n          newHeight = contentHeight; // TODO solve contentHeight = 0\n          timeoutState.height = 'auto';\n          timeoutState.overflow = null;\n        }\n\n        if (isCurrentHeightAuto) {\n          // This is the height to be animated to\n          timeoutState.height = newHeight;\n\n          // If previous height was 'auto'\n          // set starting height explicitly to be able to use transition\n          newHeight = contentHeight;\n        }\n\n        // Animation classes\n        var animationStateClasses = (0, _classnames2.default)((_cx = {}, _defineProperty(_cx, this.animationStateClasses.animating, true), _defineProperty(_cx, this.animationStateClasses.animatingUp, prevProps.height === 'auto' || height < prevProps.height), _defineProperty(_cx, this.animationStateClasses.animatingDown, height === 'auto' || height > prevProps.height), _defineProperty(_cx, this.animationStateClasses.animatingToHeightZero, timeoutState.height === 0), _defineProperty(_cx, this.animationStateClasses.animatingToHeightAuto, timeoutState.height === 'auto'), _defineProperty(_cx, this.animationStateClasses.animatingToHeightSpecific, timeoutState.height > 0), _cx));\n\n        // Animation classes to be put after animation is complete\n        var timeoutAnimationStateClasses = this.getStaticStateClasses(timeoutState.height);\n\n        // Set starting height and animating classes\n        // We are safe to call set state as it will not trigger infinite loop\n        // because of the \"height !== prevProps.height\" check\n        this.setState({ // eslint-disable-line react/no-did-update-set-state\n          animationStateClasses: animationStateClasses,\n          height: newHeight,\n          overflow: 'hidden',\n          // When animating from 'auto' we first need to set fixed height\n          // that change should be animated\n          shouldUseTransitions: !isCurrentHeightAuto\n        });\n\n        // Clear timeouts\n        clearTimeout(this.timeoutID);\n        clearTimeout(this.animationClassesTimeoutID);\n\n        if (isCurrentHeightAuto) {\n          // When animating from 'auto' we use a short timeout to start animation\n          // after setting fixed height above\n          timeoutState.shouldUseTransitions = true;\n\n          cancelAnimationFrames(this.animationFrameIDs);\n          this.animationFrameIDs = startAnimationHelper(function () {\n            _this2.setState(timeoutState);\n\n            // ANIMATION STARTS, run a callback if it exists\n            runCallback(onAnimationStart, { newHeight: timeoutState.height });\n          });\n\n          // Set static classes and remove transitions when animation ends\n          this.animationClassesTimeoutID = setTimeout(function () {\n            _this2.setState({\n              animationStateClasses: timeoutAnimationStateClasses,\n              shouldUseTransitions: false\n            });\n\n            // ANIMATION ENDS\n            // Hide content if height is 0 (to prevent tabbing into it)\n            _this2.hideContent(timeoutState.height);\n            // Run a callback if it exists\n            runCallback(onAnimationEnd, { newHeight: timeoutState.height });\n          }, totalDuration);\n        } else {\n          // ANIMATION STARTS, run a callback if it exists\n          runCallback(onAnimationStart, { newHeight: newHeight });\n\n          // Set end height, classes and remove transitions when animation is complete\n          this.timeoutID = setTimeout(function () {\n            timeoutState.animationStateClasses = timeoutAnimationStateClasses;\n            timeoutState.shouldUseTransitions = false;\n\n            _this2.setState(timeoutState);\n\n            // ANIMATION ENDS\n            // If height is auto, don't hide the content\n            // (case when element is empty, therefore height is 0)\n            if (height !== 'auto') {\n              // Hide content if height is 0 (to prevent tabbing into it)\n              _this2.hideContent(newHeight); // TODO solve newHeight = 0\n            }\n            // Run a callback if it exists\n            runCallback(onAnimationEnd, { newHeight: newHeight });\n          }, totalDuration);\n        }\n      }\n    }\n  }, {\n    key: 'componentWillUnmount',\n    value: function componentWillUnmount() {\n      cancelAnimationFrames(this.animationFrameIDs);\n\n      clearTimeout(this.timeoutID);\n      clearTimeout(this.animationClassesTimeoutID);\n\n      this.timeoutID = null;\n      this.animationClassesTimeoutID = null;\n      this.animationStateClasses = null;\n    }\n  }, {\n    key: 'showContent',\n    value: function showContent(height) {\n      if (height === 0) {\n        this.contentElement.style.display = '';\n      }\n    }\n  }, {\n    key: 'hideContent',\n    value: function hideContent(newHeight) {\n      if (newHeight === 0) {\n        this.contentElement.style.display = 'none';\n      }\n    }\n  }, {\n    key: 'getStaticStateClasses',\n    value: function getStaticStateClasses(height) {\n      var _cx2;\n\n      return (0, _classnames2.default)((_cx2 = {}, _defineProperty(_cx2, this.animationStateClasses.static, true), _defineProperty(_cx2, this.animationStateClasses.staticHeightZero, height === 0), _defineProperty(_cx2, this.animationStateClasses.staticHeightSpecific, height > 0), _defineProperty(_cx2, this.animationStateClasses.staticHeightAuto, height === 'auto'), _cx2));\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var _cx3,\n          _this3 = this;\n\n      var _props2 = this.props,\n          animateOpacity = _props2.animateOpacity,\n          applyInlineTransitions = _props2.applyInlineTransitions,\n          children = _props2.children,\n          className = _props2.className,\n          contentClassName = _props2.contentClassName,\n          delay = _props2.delay,\n          duration = _props2.duration,\n          easing = _props2.easing,\n          id = _props2.id,\n          style = _props2.style;\n      var _state = this.state,\n          height = _state.height,\n          overflow = _state.overflow,\n          animationStateClasses = _state.animationStateClasses,\n          shouldUseTransitions = _state.shouldUseTransitions;\n\n\n      var componentStyle = _extends({}, style, {\n        height: height,\n        overflow: overflow || style.overflow\n      });\n\n      if (shouldUseTransitions && applyInlineTransitions) {\n        componentStyle.transition = 'height ' + duration + 'ms ' + easing + ' ' + delay + 'ms';\n\n        // Include transition passed through styles\n        if (style.transition) {\n          componentStyle.transition = style.transition + ', ' + componentStyle.transition;\n        }\n\n        // Add webkit vendor prefix still used by opera, blackberry...\n        componentStyle.WebkitTransition = componentStyle.transition;\n      }\n\n      var contentStyle = {};\n\n      if (animateOpacity) {\n        contentStyle.transition = 'opacity ' + duration + 'ms ' + easing + ' ' + delay + 'ms';\n        // Add webkit vendor prefix still used by opera, blackberry...\n        contentStyle.WebkitTransition = contentStyle.transition;\n\n        if (height === 0) {\n          contentStyle.opacity = 0;\n        }\n      }\n\n      var componentClasses = (0, _classnames2.default)((_cx3 = {}, _defineProperty(_cx3, animationStateClasses, true), _defineProperty(_cx3, className, className), _cx3));\n\n      // Check if user passed aria-hidden prop\n      var hasAriaHiddenProp = typeof this.props['aria-hidden'] !== 'undefined';\n      var ariaHidden = hasAriaHiddenProp ? this.props['aria-hidden'] : height === 0;\n\n      return _react2.default.createElement(\n        'div',\n        _extends({}, omit.apply(undefined, [this.props].concat(PROPS_TO_OMIT)), {\n          'aria-hidden': ariaHidden,\n          className: componentClasses,\n          id: id,\n          style: componentStyle\n        }),\n        _react2.default.createElement(\n          'div',\n          {\n            className: contentClassName,\n            style: contentStyle,\n            ref: function ref(el) {\n              return _this3.contentElement = el;\n            }\n          },\n          children\n        )\n      );\n    }\n  }]);\n\n  return AnimateHeight;\n}(_react2.default.Component);\n\nvar heightPropType = function heightPropType(props, propName, componentName) {\n  var value = props[propName];\n\n  if (typeof value === 'number' && value >= 0 || isPercentage(value) || value === 'auto') {\n    return null;\n  }\n\n  return new TypeError('value \"' + value + '\" of type \"' + (typeof value === 'undefined' ? 'undefined' : _typeof(value)) + '\" is invalid type for ' + propName + ' in ' + componentName + '. ' + 'It needs to be a positive number, string \"auto\" or percentage string (e.g. \"15%\").');\n};\n\nAnimateHeight.propTypes = {\n  'aria-hidden': _propTypes2.default.bool,\n  animateOpacity: _propTypes2.default.bool,\n  animationStateClasses: _propTypes2.default.object,\n  applyInlineTransitions: _propTypes2.default.bool,\n  children: _propTypes2.default.any.isRequired,\n  className: _propTypes2.default.string,\n  contentClassName: _propTypes2.default.string,\n  delay: _propTypes2.default.number,\n  duration: _propTypes2.default.number,\n  easing: _propTypes2.default.string,\n  height: heightPropType,\n  id: _propTypes2.default.string,\n  onAnimationEnd: _propTypes2.default.func,\n  onAnimationStart: _propTypes2.default.func,\n  style: _propTypes2.default.object\n};\n\nAnimateHeight.defaultProps = {\n  animateOpacity: false,\n  animationStateClasses: ANIMATION_STATE_CLASSES,\n  applyInlineTransitions: true,\n  duration: 250,\n  delay: 0,\n  easing: 'ease',\n  style: {}\n};\n\nexports.default = AnimateHeight;","import RESOURCE_TYPES from 'game/RESOURCE_TYPES';\r\nimport ResourceTracker from 'parser/shared/modules/resources/resourcetracker/ResourceTracker';\r\nimport { Options } from 'parser/core/Analyzer';\r\n\r\nclass ManaTracker extends ResourceTracker {\r\n  constructor(options: Options) {\r\n    super(options);\r\n    this.resource = RESOURCE_TYPES.MANA;\r\n    this.maxResource = 50000;\r\n  }\r\n\r\n  maxResource: number;\r\n}\r\n\r\nexport default ManaTracker;\r\n","import AbilityTracker from 'parser/shared/modules/AbilityTracker';\r\nimport HealingDone from 'parser/shared/modules/throughput/HealingDone';\r\nimport DamageDone from 'parser/shared/modules/throughput/DamageDone';\r\nimport CastEfficiency from 'parser/shared/modules/CastEfficiency';\r\nimport CoreAbilities from 'parser/core/modules/Abilities';\r\nimport Analyzer from 'parser/core/Analyzer';\r\nimport SPELLS from 'common/SPELLS/index';\r\nimport Spell from 'common/SPELLS/Spell';\r\n\r\nimport ManaTracker from './ManaTracker';\r\nimport { SpellbookAbility } from '../modules/Ability';\r\n\r\nexport interface SpellInfoDetails {\r\n  spell: Spell;\r\n  casts: number;\r\n  healingHits: number;\r\n  healingDone: number;\r\n  overhealingDone: number;\r\n  damageHits: number;\r\n  damageDone: number;\r\n  damageAbsorbed: number;\r\n  manaSpent: number;\r\n  manaGained: ManaTracker;\r\n  percentOverhealingDone: number;\r\n  percentHealingDone: number;\r\n  percentDamageDone: number;\r\n  manaPercentSpent: number;\r\n  hpm: number;\r\n  dpm: number;\r\n  timeSpentCasting: number;\r\n  percentTimeSpentCasting: number;\r\n  hpet: number;\r\n  dpet: number;\r\n}\r\n\r\nclass HealingEfficiencyTracker extends Analyzer {\r\n  static dependencies = {\r\n    manaTracker: ManaTracker,\r\n    abilityTracker: AbilityTracker,\r\n    healingDone: HealingDone,\r\n    damageDone: DamageDone,\r\n    castEfficiency: CastEfficiency,\r\n    abilities: CoreAbilities,\r\n  };\r\n\r\n  protected manaTracker!: ManaTracker;\r\n  protected abilityTracker!: AbilityTracker;\r\n  protected healingDone!: HealingDone;\r\n  protected damageDone!: DamageDone;\r\n  protected castEfficiency!: CastEfficiency;\r\n  protected abilities!: CoreAbilities;\r\n\r\n  getSpellStats(spellId: number, healingSpellIds: number[] | null = null) {\r\n    let spellInfo: SpellInfoDetails = {\r\n      spell: SPELLS[spellId],\r\n      casts: 0,\r\n      healingHits: 0,\r\n      healingDone: 0,\r\n      overhealingDone: 0,\r\n      damageHits: 0,\r\n      damageDone: 0,\r\n      damageAbsorbed: 0,\r\n      manaSpent: 0,\r\n      manaGained: this.manaTracker,\r\n      percentOverhealingDone: 0,\r\n      percentHealingDone: 0,\r\n      percentDamageDone: 0,\r\n      manaPercentSpent: 0,\r\n      hpm: 0,\r\n      dpm: 0,\r\n      timeSpentCasting: 0,\r\n      percentTimeSpentCasting: 0,\r\n      hpet: 0,\r\n      dpet: 0,\r\n    };\r\n\r\n    const ability = this.abilityTracker.getAbility(spellId);\r\n\r\n    spellInfo.casts = ability.casts || 0;\r\n    spellInfo.healingHits = ability.healingHits || 0;\r\n    spellInfo.healingDone = (ability.healingEffective || 0) + (ability.healingAbsorbed || 0);\r\n    spellInfo.overhealingDone = ability.healingOverheal || 0;\r\n\r\n    if (healingSpellIds) {\r\n      for (const healingSpellId in healingSpellIds) {\r\n        const healingAbility = this.abilityTracker.getAbility(healingSpellIds[healingSpellId]);\r\n\r\n        spellInfo.healingHits += healingAbility.healingHits || 0;\r\n        spellInfo.healingDone += (healingAbility.healingEffective || 0) + (healingAbility.healingAbsorbed || 0);\r\n        spellInfo.overhealingDone += healingAbility.healingOverheal || 0;\r\n      }\r\n    }\r\n\r\n    spellInfo.damageHits = ability.damageHits || 0;\r\n    spellInfo.damageDone = ability.damageEffective || 0;\r\n    spellInfo.damageAbsorbed = ability.damageAbsorbed || 0;\r\n\r\n    const spenders = this.manaTracker.spendersObj as {\r\n      [spellId: number]: {\r\n        spent: number;\r\n        spentByCast: number[];\r\n        casts: number\r\n      }\r\n    };\r\n    spellInfo.manaSpent = spenders[spellId] ? spenders[spellId].spent : 0;\r\n\r\n    // All of the following information can be derived from the data in SpellInfo.\r\n    // Now we can add custom logic for spells.\r\n    spellInfo = this.getCustomSpellStats(spellInfo, spellId, healingSpellIds);\r\n\r\n    spellInfo.percentOverhealingDone = spellInfo.overhealingDone / ((spellInfo.healingDone || 0) + spellInfo.overhealingDone) || 0;\r\n    spellInfo.percentHealingDone = spellInfo.healingDone / this.healingDone.total.regular || 0;\r\n    spellInfo.percentDamageDone = spellInfo.damageDone / this.damageDone.total.regular || 0;\r\n    spellInfo.manaPercentSpent = spellInfo.manaSpent / this.manaTracker.spent;\r\n\r\n    spellInfo.hpm = (spellInfo.healingDone / spellInfo.manaSpent) | 0;\r\n    spellInfo.dpm = (spellInfo.damageDone / spellInfo.manaSpent) | 0;\r\n\r\n    spellInfo.timeSpentCasting = this.castEfficiency.getTimeSpentCasting(spellId).timeSpentCasting + this.castEfficiency.getTimeSpentCasting(spellId).gcdSpent;\r\n    spellInfo.percentTimeSpentCasting = spellInfo.timeSpentCasting / this.owner.fightDuration;\r\n\r\n    spellInfo.hpet = (spellInfo.healingDone / spellInfo.timeSpentCasting) | 0;\r\n    spellInfo.dpet = (spellInfo.damageDone / spellInfo.timeSpentCasting) | 0;\r\n\r\n    return spellInfo;\r\n  }\r\n\r\n  getCustomSpellStats(spellInfo: SpellInfoDetails, spellId: number, healingSpellIds: number[] | null) {\r\n    // Overwrite this function to add specific logic for spells.\r\n    return spellInfo;\r\n  }\r\n\r\n  getAllSpellStats(includeCooldowns = false) {\r\n    const spells: { [spellId: number]: SpellInfoDetails } = {};\r\n    let topHpm = 0;\r\n    let topDpm = 0;\r\n    let topHpet = 0;\r\n    let topDpet = 0;\r\n\r\n    for (const index in this.abilities.abilities) {\r\n      const ability = this.abilities.abilities[index] as unknown as SpellbookAbility;\r\n\r\n      if (ability.spell instanceof Array) {\r\n        continue;\r\n      }\r\n      if (ability.spell && ability.spell.manaCost && ability.spell.manaCost > 0) {\r\n        if (includeCooldowns || ability.category !== 'Cooldown') {\r\n          spells[ability.spell.id] = this.getSpellStats(ability.spell.id, ability.healSpellIds);\r\n\r\n          topHpm = Math.max(topHpm, spells[ability.spell.id].hpm);\r\n          topDpm = Math.max(topDpm, spells[ability.spell.id].dpm);\r\n          topHpet = Math.max(topHpet, spells[ability.spell.id].hpet);\r\n          topDpet = Math.max(topDpet, spells[ability.spell.id].dpet);\r\n        }\r\n      }\r\n    }\r\n\r\n    return {\r\n      spells,\r\n      topHpm,\r\n      topDpm,\r\n      topHpet,\r\n      topDpet,\r\n    };\r\n  }\r\n}\r\n\r\nexport default HealingEfficiencyTracker;\r\n","import React from 'react';\r\n\r\nimport colorForPerformance from 'common/colorForPerformance';\r\n\r\ninterface Props {\r\n  percent: number;\r\n}\r\n\r\nconst PerformanceBar = ({ percent }: Props) => (\r\n  <div className=\"performance-bar-container\">\r\n    <div\r\n      className=\"performance-bar\"\r\n      style={{\r\n        width: `${percent * 100}%`,\r\n        transition: 'background-color 800ms',\r\n        backgroundColor: colorForPerformance(percent),\r\n      }}\r\n    />\r\n  </div>\r\n);\r\n\r\nexport default PerformanceBar;\r\n","module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEwAAAAuCAYAAACCq/96AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAYdEVYdFNvZnR3YXJlAHBhaW50Lm5ldCA0LjEuNv1OCegAAAPKSURBVGhD7ZtLSBRxHMcttegQPYhKKCii94PeWVD0Lo+uVFoQRJck9BAF+WAJDS8FXUItzdVMzQ5ejO5B++jhW7e3eggCL+2641p0+Pf9zf5n3V3/7u6sO40j84EPiLM7/vbD/GcWdzaFMXYMZkV4Bm6EC1NMwgmJlDU+VNfs/179UvZbZbvUb20ZfXelxuvIqdRSPko0ymEVrIaP4GNYA2vhE24dtMF62ACfwkb4DDbBZtgCn3Nb4QsVBlBi+YdsjWPuuyxUaeAO83XfYF7XJYYXppkeh6WdjyPCCpnODsEAcqzhBltkLEU5Ws8tzaN57TltfKRQiqDoBfxvJ4KNDzdViUKFStGk3tuIlid+scnSbqFlolAARcPrYWiw+gZRpEiD0ZwXxC82CWJpOvhYRAkUDa+HE8H8n+89nBToY4VES0RTHZb+BIL9grR09TDAqNNS4uu+GR7s0/2vfLNmIE5RAsE6oL5QMBqWlpsZLA6UYF7neSb1lZrBYhEMRuKELkczg01NWDDSmcskd8UXvlkzZk8wGtyZ18U3a8bsCmbP0XwwwwbTCzOYSowcTJfBphGsUCeDGCmYXv6GQcxgsTWDqdQMplLDBvsLR3QyiJGCaT5XPJjBVGIGU4kug3k7rpWZwVQgucsfeF0XzWDx4h+sqR3tyA/7FMoMFgX/UL2N/rs7+v4qYp0zg8WCPm2XBsqY1FvMvG8vm8FiodyeQNGUWxGMHiwjijIjr7MzEnVssLZVDuYuZ1K/lfk6C5jHmeviuyYSmUtLg4gGi6WMcrKOJp2jKErwM0+BgaVZxPBW4wNjLI3vPpG5tHLiVgGgaTCSoolChSrfJdRX3INgi+Ec7H7GBlsOe6DogVMpI4ozlfFEG//RVoRYm+E87D6RubQyLBihdjgZUZho+jqvC0ORf36+siIU3dx3BK6Bc/EnZkq0ScEINcPJiKLE0tdVGC0WeRbugysgLc2ZEE0YTDWeN5b8yCAee46bb54ShNgBlUCRnoZ0lNHSXAQp2uwg0WAEQuyCkbHo6KJgR+EeuBou4E8xPtMJRiCGEo1CkcrPJ+EhuAkugan8KcZmusEIxNgPKdApqESj7wkoR9kqmM4fbmySFCwV7oSH4XFIsSgaLU363Va4FBr/XJaMYARipMMtMBPSkUWxKBoddQfgWmj8b6UkKxiBIGlwHdwN6SpJ0U7Ag5BiroTGvgB4XdmZHrulNFK+WTUIQsszA26HdLRRrL2QgtEVk95mzI7zWbJAkLlwGdwAt0E6h62HdPKnK+Z8qNP5LCXlH/EZJ5PjYeR7AAAAAElFTkSuQmCC\"","import React from 'react';\r\nimport { formatNumber, formatPercentage, formatDuration } from 'common/format';\r\nimport Toggle from 'react-toggle';\r\nimport PerformanceBar from 'interface/PerformanceBar';\r\nimport SpellLink from 'common/SpellLink';\r\nimport { TooltipElement } from 'common/Tooltip';\r\nimport HolyPriestHealingEfficiencyTracker from 'parser/priest/holy/modules/features/HolyPriestHealingEfficiencyTracker';\r\nimport { Trans } from '@lingui/macro';\r\n\r\nimport HealingEfficiencyTracker, { SpellInfoDetails } from './HealingEfficiencyTracker';\r\n\r\nexport interface Props {\r\n  tracker: HealingEfficiencyTracker | HolyPriestHealingEfficiencyTracker;\r\n}\r\nexport interface State {\r\n  showHealing: boolean;\r\n  detailedView: boolean;\r\n  showCooldowns: boolean;\r\n  showEchoOfLight?: boolean;\r\n}\r\n\r\nclass HealingEfficiencyBreakdown extends React.Component<Props, State> {\r\n  constructor(props: Props) {\r\n    super(props);\r\n\r\n    this.state = {\r\n      showHealing: true,\r\n      detailedView: false,\r\n      showCooldowns: false,\r\n    };\r\n  }\r\n\r\n  HealingEfficiencyTable = (props: Props) => {\r\n    const { tracker } = props;\r\n    const { spells, topHpm, topDpm, topHpet, topDpet } = tracker.getAllSpellStats(this.state.showCooldowns);\r\n\r\n    const spellArray = Object.values(spells);\r\n\r\n    spellArray.sort((a, b) => {\r\n      if (this.state.showHealing) {\r\n        if (a.hpm < b.hpm) {\r\n          return 1;\r\n        } else if (a.hpm > b.hpm) {\r\n          return -1;\r\n        }\r\n      } else {\r\n        if (a.dpm < b.dpm) {\r\n          return 1;\r\n        } else if (a.dpm > b.dpm) {\r\n          return -1;\r\n        }\r\n      }\r\n\r\n      return 0;\r\n    });\r\n\r\n    const spellRows = spellArray.map((spellDetail => {\r\n      if (spellDetail.casts > 0) {\r\n        return this.HealingEfficiencySpellRow(spellDetail, topHpm, topDpm, topHpet, topDpet);\r\n      }\r\n      return null;\r\n    }));\r\n\r\n    return <>{spellRows}</>;\r\n  };\r\n\r\n  HealingEfficiencySpellRow = (spellDetail: SpellInfoDetails, topHpm: number, topDpm: number, topHpet: number, topDpet: number) => (\r\n    <tr key={spellDetail.spell.id}>\r\n      <td>\r\n        <SpellLink id={spellDetail.spell.id} />\r\n      </td>\r\n      {this.state.detailedView ? this.DetailView(spellDetail) : this.BarView(spellDetail, topHpm, topDpm, topHpet, topDpet)}\r\n    </tr>\r\n  );\r\n\r\n  BarHeader = () => (\r\n    <>\r\n      <Trans render=\"th\" id=\"shared.healingEfficiency.tableHeader.manaSpent\">Mana Spent</Trans>\r\n      {this.state.showHealing && (\r\n        <>\r\n          <th colSpan={2} className=\"text-center\"><Trans id=\"common.stat.healingPerMana\">Healing per mana spent</Trans></th>\r\n          <th colSpan={2} className=\"text-center\">\r\n            <TooltipElement content={<Trans id=\"common.stat.healingPerExecutionTime.long\">Healing per second spent casting the spell, including GCD wait time.</Trans>}>\r\n              <Trans id=\"common.stat.healingPerExecutionTime\">Healing per second spent casting</Trans>\r\n            </TooltipElement>\r\n          </th>\r\n        </>\r\n      )}\r\n      {!this.state.showHealing && (\r\n        <>\r\n          <th colSpan={2} className=\"text-center\"><Trans id=\"common.stat.damagePerMana\">Damage per mana spent</Trans></th>\r\n          <th colSpan={2} className=\"text-center\"><Trans id=\"common.stat.damagePerExecutionTime.long\">Damage per second spent casting the spell</Trans></th>\r\n        </>\r\n      )}\r\n    </>\r\n  );\r\n\r\n\r\n  BarView = (spellDetail: SpellInfoDetails, topHpm: number, topDpm: number, topHpet: number, topDpet: number) => {\r\n    const hasHealing = spellDetail.healingDone;\r\n    const hasDamage = spellDetail.damageDone > 0;\r\n    const barWidth = 20;\r\n\r\n    return (\r\n      <>\r\n        <td>\r\n          {formatNumber(spellDetail.manaSpent)}\r\n          {' (' + formatPercentage(spellDetail.manaPercentSpent) + '%)'}\r\n        </td>\r\n        {this.state.showHealing && (\r\n          <>\r\n            <td className=\"text-right\">{hasHealing ? formatNumber(spellDetail.hpm) : '-'}</td>\r\n            <td width={barWidth + '%'}><PerformanceBar percent={spellDetail.hpm / topHpm} /></td>\r\n\r\n            <td className=\"text-right\">{hasHealing ? formatNumber(spellDetail.hpet * 1000) : '-'}</td>\r\n            <td width={barWidth + '%'}><PerformanceBar percent={(spellDetail.hpet / topHpet)} /></td>\r\n          </>\r\n        )}\r\n        {!this.state.showHealing && (\r\n          <>\r\n            <td className=\"text-right\">{hasDamage ? formatNumber(spellDetail.dpm) : '-'}</td>\r\n            <td width={barWidth + '%'}><PerformanceBar percent={spellDetail.dpm / topDpm} /></td>\r\n\r\n            <td className=\"text-right\">{hasDamage ? formatNumber(spellDetail.dpet * 1000) : '-'}</td>\r\n            <td width={barWidth + '%'}><PerformanceBar percent={(spellDetail.dpet / topDpet)} /></td>\r\n          </>\r\n        )}\r\n      </>\r\n    );\r\n  };\r\n\r\n  DetailHeader = () => (\r\n    <>\r\n      <th>\r\n        <TooltipElement content={<Trans id=\"shared.healingEfficiency.tableHeader.casts.tooltip\">Total Casts (Number of targets hit)</Trans>}><Trans id=\"shared.healingEfficiency.tableHeader.casts\">Casts</Trans></TooltipElement>\r\n      </th>\r\n      <Trans render=\"th\" id=\"shared.healingEfficiency.tableHeader.manaSpent\">Mana Spent</Trans>\r\n      <Trans render=\"th\" id=\"shared.healingEfficiency.tableHeader.timeSpent\">Time Spent</Trans>\r\n      {this.state.showHealing && (\r\n        <>\r\n          <Trans render=\"th\" id=\"shared.healingEfficiency.tableHeader.healingDone\">Healing Done</Trans>\r\n          <Trans render=\"th\" id=\"shared.healingEfficiency.tableHeader.overhealingDone\">Overhealing</Trans>\r\n          <th>\r\n            <TooltipElement content={<Trans id=\"common.stat.healingPerMana.long\">Healing per mana spent casting the spell</Trans>}>\r\n              <Trans id=\"common.stat.healingPerMana.short\">HPM</Trans>\r\n            </TooltipElement>\r\n          </th>\r\n          <th>\r\n            <TooltipElement content={<Trans id=\"common.stat.healingPerExecutionTime.long\">Healing per second spent casting the spell, including GCD wait time.</Trans>}>\r\n              <Trans id=\"common.stat.healingPerExecutionTime.short\">HPET</Trans>\r\n            </TooltipElement>\r\n          </th>\r\n        </>\r\n      )}\r\n      {!this.state.showHealing && (\r\n        <>\r\n          <Trans render=\"th\" id=\"shared.healingEfficiency.tableHeader.damageDone\">Damage Done</Trans>\r\n          <th>\r\n            <TooltipElement content={<Trans id=\"common.stat.damagePerMana.long\">Damage per mana spent casting the spell</Trans>}>\r\n              <Trans id=\"common.stat.damagePerMana.short\">DPM</Trans>\r\n            </TooltipElement>\r\n          </th>\r\n          <th>\r\n            <TooltipElement content={<Trans id=\"common.stat.damagePerExecutionTime.long\">Damage per second spent casting the spell</Trans>}>\r\n              <Trans id=\"common.stat.damagePerExecutionTime.short\">DPET</Trans>\r\n            </TooltipElement>\r\n          </th>\r\n        </>\r\n      )}\r\n    </>\r\n  );\r\n\r\n  DetailView = (spellDetail: SpellInfoDetails) => {\r\n    const hasHealing = spellDetail.healingDone;\r\n    const hasOverhealing = spellDetail.healingDone > 0 || spellDetail.overhealingDone > 0;\r\n    const hasDamage = spellDetail.damageDone > 0;\r\n\r\n    return (\r\n      <>\r\n        <td>{spellDetail.casts} ({this.state.showHealing ? Math.floor(spellDetail.healingHits) : Math.floor(spellDetail.damageHits)})</td>\r\n        <td>\r\n          {formatNumber(spellDetail.manaSpent)}\r\n          {' (' + formatPercentage(spellDetail.manaPercentSpent) + '%)'}\r\n        </td>\r\n        <td>{spellDetail.timeSpentCasting !== 0 ? (formatDuration(spellDetail.timeSpentCasting / 1000) + ' (' + formatPercentage(spellDetail.percentTimeSpentCasting) + '%)') : '-'}</td>\r\n        {this.state.showHealing && (\r\n          <>\r\n            <td>\r\n              {hasHealing ? formatNumber(spellDetail.healingDone) : '-'}\r\n              {hasHealing ? ' (' + formatPercentage(spellDetail.percentHealingDone) + '%)' : ''}\r\n            </td>\r\n            <td>\r\n              {hasOverhealing ? formatNumber(spellDetail.overhealingDone) : '-'}\r\n              {hasOverhealing ? ' (' + formatPercentage(spellDetail.percentOverhealingDone) + '%)' : ''}\r\n            </td>\r\n            <td>{hasHealing ? formatNumber(spellDetail.hpm) : '-'}</td>\r\n            <td>{hasHealing ? formatNumber(spellDetail.hpet * 1000) : '-'}</td>\r\n          </>\r\n        )}\r\n        {!this.state.showHealing && (\r\n          <>\r\n            <td>\r\n              {hasDamage ? formatNumber(spellDetail.damageDone) : '-'}\r\n              {hasDamage ? ' (' + formatPercentage(spellDetail.percentDamageDone) + '%)' : ''}\r\n            </td>\r\n            <td>{hasDamage ? formatNumber(spellDetail.dpm) : '-'}</td>\r\n            <td>{hasDamage ? formatNumber(spellDetail.dpet * 1000) : '-'}</td>\r\n          </>\r\n        )}\r\n      </>\r\n    );\r\n  };\r\n\r\n  render() {\r\n    const { tracker } = this.props;\r\n\r\n    return (\r\n      <>\r\n        <div className=\"pad\">\r\n          <div className=\"pull-left\">\r\n            <div className=\"toggle-control pull-right\" style={{ marginRight: '.5em' }}>\r\n              <Toggle\r\n                defaultChecked={false}\r\n                icons={false}\r\n                onChange={event => this.setState({ detailedView: event.target.checked })}\r\n                id=\"detailed-toggle\"\r\n              />\r\n              <label htmlFor=\"detailed-toggle\" style={{ marginLeft: '0.5em' }}>\r\n                <Trans id=\"shared.healingEfficiency.toggle.detailed\">Detailed View</Trans>\r\n              </label>\r\n            </div>\r\n          </div>\r\n          <div className=\"pull-right\">\r\n            <div className=\"toggle-control pull-left\" style={{ marginLeft: '.5em', marginRight: '.5em' }}>\r\n              <Toggle\r\n                defaultChecked={false}\r\n                icons={false}\r\n                onChange={event => this.setState({ showCooldowns: event.target.checked })}\r\n                id=\"cooldown-toggle\"\r\n              />\r\n              <label htmlFor=\"cooldown-toggle\" style={{ marginLeft: '0.5em' }}>\r\n                <Trans id=\"shared.healingEfficiency.toggle.cooldowns\">Show Cooldowns</Trans>\r\n              </label>\r\n            </div>\r\n            <div className=\"toggle-control pull-left\" style={{ marginLeft: '.5em' }}>\r\n              <label htmlFor=\"healing-toggle\" style={{ marginLeft: '0.5em', marginRight: '1em' }}>\r\n                <Trans id=\"shared.healingEfficiency.toggle.damage\">Show Damage</Trans>\r\n              </label>\r\n              <Toggle\r\n                defaultChecked\r\n                icons={false}\r\n                onChange={event => this.setState({ showHealing: event.target.checked })}\r\n                id=\"healing-toggle\"\r\n              />\r\n              <label htmlFor=\"healing-toggle\" style={{ marginLeft: '0.5em' }}>\r\n                <Trans id=\"shared.healingEfficiency.toggle.healing\">Show Healing</Trans>\r\n              </label>\r\n            </div>\r\n          </div>\r\n        </div>\r\n        <table className=\"data-table\">\r\n          <thead>\r\n            <tr>\r\n              <Trans render=\"th\" id=\"common.ability\">Ability</Trans>\r\n              {this.state.detailedView ? <this.DetailHeader /> : <this.BarHeader />}\r\n            </tr>\r\n          </thead>\r\n          <tbody>\r\n            <this.HealingEfficiencyTable tracker={tracker} />\r\n          </tbody>\r\n        </table>\r\n      </>\r\n    );\r\n  }\r\n}\r\n\r\nexport default HealingEfficiencyBreakdown;\r\n","/**\r\n * @deprecated Use `interface/statistic/StatisticGroup` instead.\r\n */\r\nconst StatisticWrapper = props => props.children;\r\n\r\nexport default StatisticWrapper;\r\n","import SPELLS from 'common/SPELLS/index';\r\n\r\n/*\r\n * Fields:\r\n * int: spell scales with Intellect\r\n * crit: spell scales with (is able to or procced from) Critical Strike\r\n * hasteHpm: spell does more healing due to Haste, e.g. HoTs that gain more ticks\r\n * hasteHpct: spell can be cast more frequently due to Haste, basically any spell except for non haste scaling CDs\r\n * mastery: spell is boosted by Mastery\r\n * masteryStack: spell's HoT counts as a Mastery Stack\r\n * vers: spell scales with Versatility\r\n * multiplier: spell scales with whatever procs it, should be ignored for purpose of weights and for 'total healing' number\r\n * ignored: spell should be ignored for purpose of stat weights\r\n */\r\n\r\n// This only works with actual healing events; casts are not recognized.\r\nexport default {\r\n  [SPELLS.LEECH.id]: { // procs a percent of all your healing, so we ignore for weights and total healing\r\n    multiplier: true,\r\n  },\r\n  [SPELLS.HEALTHSTONE.id]: {\r\n    int: false,\r\n    crit: false,\r\n    hasteHpct: false,\r\n    mastery: false,\r\n    vers: true, // confirmed\r\n  },\r\n  [SPELLS.MARK_OF_THE_ANCIENT_PRIESTESS.id]: {\r\n    int: false,\r\n    crit: true,\r\n    hasteHpct: false,\r\n    mastery: false,\r\n    vers: true,\r\n  },\r\n};\r\n","import React from 'react';\r\n\r\nimport InformationIcon from 'interface/icons/Information';\r\n\r\nimport SPELLS from 'common/SPELLS/index';\r\nimport Tooltip, { TooltipElement } from 'common/Tooltip';\r\nimport { formatNumber } from 'common/format';\r\nimport { calculatePrimaryStat, calculateSecondaryStatDefault } from 'common/stats';\r\nimport Analyzer, { SELECTED_PLAYER, SELECTED_PLAYER_PET } from 'parser/core/Analyzer';\r\nimport Events, { EventType } from 'parser/core/Events';\r\nimport HIT_TYPES from 'game/HIT_TYPES';\r\nimport HealingValue from 'parser/shared/modules/HealingValue';\r\nimport DamageValue from 'parser/shared/modules/DamageValue';\r\nimport CritEffectBonus from 'parser/shared/modules/helpers/CritEffectBonus';\r\nimport StatTracker from 'parser/shared/modules/StatTracker';\r\nimport { STATISTIC_ORDER } from 'interface/others/StatisticBox';\r\nimport StatisticWrapper from 'interface/others/StatisticWrapper';\r\nimport InfoIcon from 'interface/icons/Info';\r\nimport { Trans } from '@lingui/macro';\r\n\r\nimport CORE_SPELL_INFO from './SpellInfo';\r\nimport STAT, { getClassNameColor, getIcon, getName, getNameTranslated } from './STAT';\r\nimport QELiveLogo from './images/QE-Logo-New-Small.png';\r\n\r\nconst DEBUG = false;\r\n\r\n/**\r\n * This is currently completely focussed on Healer stat weights but it should be relatively easy to modify it to work for a DPS, it just requires some work. The only reason no effort was put towards this is that we currently have no DPS interested in implementing this so it would be wasted time. If you do want to implement stat weights for a DPS this should provide you with a very good basis.\r\n * @property {CritEffectBonus} critEffectBonus\r\n * @property {StatTracker} statTracker\r\n */\r\nclass BaseHealerStatValues extends Analyzer {\r\n  static dependencies = {\r\n    critEffectBonus: CritEffectBonus,\r\n    statTracker: StatTracker,\r\n  };\r\n\r\n  /**\r\n   * QE Live Link Setter\r\n   * As of right now this is only enabled for MW, Resto Druid, and Holy Pally\r\n   * Unless you talk to Voulk, the creator of QElive, Do not flip the switch for other healers\r\n   */\r\n  qeLive = false;\r\n\r\n  // region Spell info\r\n\r\n  // We assume unlisted spells scale with vers only (this will mostly be trinkets)\r\n  fallbackSpellInfo = {\r\n    int: false,\r\n    crit: true,\r\n    hasteHpm: false,\r\n    hasteHpct: false,\r\n    mastery: false,\r\n    vers: true,\r\n  };\r\n  // This will contain shared settings for things like trinkets and Leech\r\n  sharedSpellInfo = CORE_SPELL_INFO;\r\n  // This is for spec specific implementations to override. It gets priority over defaultSpellInfo.\r\n  spellInfo = {};\r\n\r\n  mentioned = [];\r\n  _getSpellInfo(event) {\r\n    const spellId = event.ability.guid;\r\n\r\n    const specSpecific = this.spellInfo[spellId];\r\n    if (specSpecific) {\r\n      return specSpecific;\r\n    }\r\n    const shared = this.sharedSpellInfo[spellId];\r\n    if (shared) {\r\n      return shared;\r\n    }\r\n\r\n    if (process.env.NODE_ENV === 'development') {\r\n      if (!this.mentioned.includes(spellId)) {\r\n        console.warn(`Missing spell definition: ${spellId}: ${event.ability.name}, using fallback:`, this.fallbackSpellInfo);\r\n        this.mentioned.push(spellId);\r\n      }\r\n    }\r\n\r\n    return this.fallbackSpellInfo;\r\n  }\r\n\r\n  // endregion\r\n\r\n  totalAdjustedHealing = 0; // total healing after excluding 'multiplier' spells like Leech / Velens\r\n\r\n  // These are the total healing that would be gained if their respective stats ratings were increased by one.\r\n  totalOneInt = 0;\r\n  totalOneCrit = 0;\r\n  totalOneHasteHpct = 0;\r\n  totalOneHasteHpm = 0;\r\n  totalOneMastery = 0;\r\n  totalOneVers = 0; // from healing increase only\r\n  totalOneVersDr = 0; // from damage reduced only\r\n  totalOneLeech = 0;\r\n\r\n  playerHealthMissing = 0;\r\n\r\n  scaleWeightsWithHealth = false;\r\n\r\n  constructor(options){\r\n    super(options);\r\n    this.addEventListener(Events.heal.by(SELECTED_PLAYER), this.onHeal);\r\n    this.addEventListener(Events.heal.by(SELECTED_PLAYER_PET), this.onHeal);\r\n    this.addEventListener(Events.absorbed.by(SELECTED_PLAYER), this.onAbsorb);\r\n    this.addEventListener(Events.absorbed.by(SELECTED_PLAYER_PET), this.onAbsorb);\r\n    this.addEventListener(Events.removebuff.by(SELECTED_PLAYER), this.onRemoveBuff);\r\n    this.addEventListener(Events.removebuff.by(SELECTED_PLAYER_PET), this.onRemoveBuff);\r\n    this.addEventListener(Events.heal.to(SELECTED_PLAYER), this.onHealTaken);\r\n    this.addEventListener(Events.damage.to(SELECTED_PLAYER), this.onDamageTaken);\r\n    this.addEventListener(Events.fightend, this.onFightend);\r\n  }\r\n\r\n  onHeal(event) {\r\n    const healVal = new HealingValue(event.amount, event.absorbed, event.overheal);\r\n    this._handleHealEvent(event, healVal);\r\n  }\r\n  onAbsorb(event) {\r\n    const healVal = new HealingValue(event.amount, 0, 0);\r\n    this._handleHealEvent(event, healVal);\r\n  }\r\n  onRemoveBuff(event) {\r\n    if (event.absorb) {\r\n      const healVal = new HealingValue(0, 0, event.absorb);\r\n      this._handleHealEvent(event, healVal);\r\n    }\r\n  }\r\n  _handleHealEvent(event, healVal) {\r\n    const spellInfo = this._getSpellInfo(event);\r\n    const targetHealthPercentage = (event.hitPoints - healVal.effective) / event.maxHitPoints; // hitPoints contains HP *after* the heal\r\n    this._handleHeal(spellInfo, event, healVal, targetHealthPercentage);\r\n  }\r\n  /**\r\n   * This actually does that stat weights calculations.\r\n   * @param spellInfo An object containing information about how to treat the spell, like on what stats it scales.\r\n   * @param eventForWeights The event that uses the stats to scale its healing. If we're tracking a multiplier (like Beacons), this should be the source of the multiplier.\r\n   * @param {HealingValue} healVal The actual healing done, all child weight calculators should use this instead of the event data as that might be for another event.\r\n   * @param targetHealthPercentage The percentage of health the target has remaining BEFORE the heal.\r\n   * @private\r\n   */\r\n  _handleHeal(spellInfo, eventForWeights, healVal, targetHealthPercentage) {\r\n    // Most spells are counted in healing total, but some spells scale not on their own but 'second hand' from other spells\r\n    // I adjust them out of total healing to preserve some accuracy in the \"Rating per 1%\" stat.\r\n    // Good examples of multiplier spells are Leech and Velens.\r\n    if (!spellInfo.multiplier) {\r\n      this.totalAdjustedHealing += this._adjustGain(healVal.effective, targetHealthPercentage);\r\n    }\r\n\r\n    if (spellInfo.ignored) {\r\n      return;\r\n    }\r\n\r\n    this.totalOneLeech += this._adjustGain(this._leech(eventForWeights, healVal, spellInfo), targetHealthPercentage);\r\n\r\n    if (spellInfo.multiplier) {\r\n      // Multiplier spells aren't counted for weights because they don't **directly** benefit from stat weights\r\n      return;\r\n    }\r\n\r\n    if (spellInfo.int) {\r\n      this.totalOneInt += this._adjustGain(this._intellect(eventForWeights, healVal), targetHealthPercentage);\r\n    }\r\n    if (spellInfo.crit) {\r\n      this.totalOneCrit += this._adjustGain(this._criticalStrike(eventForWeights, healVal), targetHealthPercentage);\r\n    }\r\n    if (spellInfo.hasteHpct) {\r\n      this.totalOneHasteHpct += this._adjustGain(this._hasteHpct(eventForWeights, healVal), targetHealthPercentage);\r\n    }\r\n    if (spellInfo.hasteHpm) {\r\n      this.totalOneHasteHpm += this._adjustGain(this._hasteHpm(eventForWeights, healVal), targetHealthPercentage);\r\n    }\r\n    if (spellInfo.mastery) {\r\n      this.totalOneMastery += this._adjustGain(this._mastery(eventForWeights, healVal), targetHealthPercentage);\r\n    }\r\n    if (spellInfo.vers) {\r\n      this.totalOneVers += this._adjustGain(this._versatility(eventForWeights, healVal), targetHealthPercentage);\r\n    }\r\n  }\r\n  _adjustGain(gain, targetHealthPercentage) {\r\n    if (gain === 0) {\r\n      return 0;\r\n    }\r\n    // We want 0-20% health to get value gain, and then linearly decay to 100% health\r\n    const maxValueHealthPercentage = 0.3;\r\n    const mult = 1 - Math.max(0, (targetHealthPercentage - maxValueHealthPercentage) / (1 - maxValueHealthPercentage));\r\n    return this.scaleWeightsWithHealth ? gain * mult : gain;\r\n  }\r\n  _leech(event, healVal, spellInfo) {\r\n    if (event.type !== EventType.Heal) {\r\n      return 0; // leech doesn't proc from absorbs\r\n    }\r\n\r\n    // We have to calculate leech weight differently depending on if we already have any leech rating.\r\n    // Leech is marked as a 'multplier' heal, so we have to check it before we do the early return below\r\n    const hasLeech = this.statTracker.currentLeechPercentage > 0;\r\n    if (hasLeech) {\r\n      return this._leechHasLeech(event, healVal, spellInfo);\r\n    } else {\r\n      return this._leechPrediction(event, healVal, spellInfo);\r\n    }\r\n  }\r\n  _leechHasLeech(event, healVal/*, spellInfo*/) {\r\n    // When the user has Leech we can use the actual Leech healing to accuractely calculate its HPS value without having to do any kind of predicting\r\n    const spellId = event.ability.guid;\r\n    if (spellId !== SPELLS.LEECH.id) {\r\n      return 0;\r\n    }\r\n    if (!healVal.overheal) {\r\n      return healVal.effective / this.statTracker.currentLeechRating; // TODO: Make a generic method to account for base percentage\r\n    }\r\n    return 0;\r\n  }\r\n  _leechPrediction(event, healVal, spellInfo) {\r\n    // Without Leech we will have to make an estimation so we can still provide the user with a decent value\r\n    if (this.owner.toPlayer(event)) {\r\n      return 0; // Leech doesn't proc from self-healing\r\n    }\r\n    if (spellInfo.multiplier) {\r\n      return 0; // Leech doesn't proc from multipliers such as Velen's Future Sight\r\n    }\r\n    if (this.playerHealthMissing > 0) { // if the player is full HP this would have overhealed.\r\n      const healIncreaseFromOneLeech = this.statTracker.statMultiplier.leech / this.statTracker.ratingNeededForNextPercentage(this.statTracker.currentLeechRating, this.statTracker.statBaselineRatingPerPercent[STAT.LEECH], 1, false);\r\n      return healVal.raw * healIncreaseFromOneLeech;\r\n    }\r\n    return 0;\r\n  }\r\n  _intellect(event, healVal) {\r\n    if (healVal.overheal) {\r\n      // If a spell overheals, it could not have healed for more. Seeing as Int only adds HP on top of the existing heal we can skip it as increasing the power of this heal would only be more overhealing.\r\n      return 0;\r\n    }\r\n    const healIncreaseFromOneInt = this.statTracker.statMultiplier.intellect / this.statTracker.currentIntellectRating;\r\n    return healVal.effective * healIncreaseFromOneInt;\r\n  }\r\n  _getCritChance(event) {\r\n    const rating = this.statTracker.currentCritRating;\r\n    const baseCritChance = this.statTracker.baseCritPercentage;\r\n    const ratingCritChance = rating / this.statTracker.ratingNeededForNextPercentage(this.statTracker.currentCritRating, this.statTracker.statBaselineRatingPerPercent[STAT.CRITICAL_STRIKE]);\r\n\r\n    return { baseCritChance, ratingCritChance };\r\n  }\r\n  _isCrit(event) {\r\n    return event.hitType === HIT_TYPES.CRIT;\r\n  }\r\n  _criticalStrike(event, healVal) {\r\n    if (this._isCrit(event)) {\r\n      // This collects the total effective healing contributed by the last 1 point of critical strike rating.\r\n      // We don't make any predictions on normal hits based on crit chance since this would be guess work and we are a log analysis system so we prefer to only work with facts. Actual crit heals are undeniable facts, unlike speculating the chance a normal hit might have crit (and accounting for the potential overhealing of that).\r\n\r\n      const { baseCritChance, ratingCritChance } = this._getCritChance(event);\r\n\r\n      const totalCritChance = baseCritChance + ratingCritChance;\r\n      if (totalCritChance > (1 + 1 / this.statTracker.ratingNeededForNextPercentage(this.statTracker.currentCritRating, this.statTracker.statBaselineRatingPerPercent[STAT.CRITICAL_STRIKE]))) {\r\n        // If the crit chance was more than 100%+1 rating, then the last rating was over the cap and worth 0.\r\n        return 0;\r\n      }\r\n      const ratingCritChanceContribution = 1 - baseCritChance / totalCritChance;\r\n\r\n      const critMult = this.critEffectBonus.getBonus(event);\r\n      const rawBaseHealing = healVal.raw / critMult;\r\n      const effectiveCritHealing = Math.max(0, healVal.effective - rawBaseHealing);\r\n      const rating = this.statTracker.currentCritRating;\r\n      const healIncreaseFromOneCrit = this.statTracker.statMultiplier.crit * ratingCritChanceContribution / rating;\r\n\r\n      return effectiveCritHealing * healIncreaseFromOneCrit;\r\n    }\r\n    return 0;\r\n  }\r\n  _hasteHpct(event, healVal) {\r\n    const currHastePerc = this.statTracker.currentHastePercentage;\r\n    const healIncreaseFromOneHaste = this.statTracker.statMultiplier.haste / this.statTracker.ratingNeededForNextPercentage(this.statTracker.currentHasteRating, this.statTracker.statBaselineRatingPerPercent[STAT.HASTE]);\r\n    const baseHeal = healVal.effective / (1 + currHastePerc);\r\n    return baseHeal * healIncreaseFromOneHaste;\r\n  }\r\n  _hasteHpm(event, healVal) {\r\n    const healIncreaseFromOneHaste = this.statTracker.statMultiplier.haste / this.statTracker.ratingNeededForNextPercentage(this.statTracker.currentHasteRating, this.statTracker.statBaselineRatingPerPercent[STAT.HASTE]);\r\n    const noHasteHealing = healVal.effective / (1 + this.statTracker.currentHastePercentage);\r\n    return noHasteHealing * healIncreaseFromOneHaste;\r\n  }\r\n  _mastery(event, healVal) {\r\n    throw new Error('Missing custom Mastery implementation. This is different per spec.');\r\n  }\r\n  _versatility(event, healVal) {\r\n    if (healVal.overheal) {\r\n      // If a spell overheals, it could not have healed for more. Seeing as Versatility only adds HP on top of the existing heal we can skip it as increasing the power of this heal would only be more overhealing.\r\n      return 0;\r\n    }\r\n    const currVersPerc = this.statTracker.currentVersatilityPercentage;\r\n    const healIncreaseFromOneVers = this.statTracker.statMultiplier.versatility / this.statTracker.ratingNeededForNextPercentage(this.statTracker.currentVersatilityRating, this.statTracker.statBaselineRatingPerPercent[STAT.VERSATILITY], 1, false);\r\n    const baseHeal = healVal.effective / (1 + currVersPerc);\r\n    return baseHeal * healIncreaseFromOneVers;\r\n  }\r\n\r\n  onDamageTaken(event) {\r\n    this._updateMissingHealth(event);\r\n\r\n    const damageVal = new DamageValue(event.amount, event.absorbed, event.blocked, event.overkill);\r\n    // const targetHealthPercentage = event.hitPoints / event.maxHitPoints; // hitPoints contains HP *after* the damage taken, which in this case is desirable\r\n    // this.totalOneVersDr += this._adjustGain(this._versatilityDamageReduction(event, damageVal), targetHealthPercentage);\r\n    // TODO: Figure out how to make this account for target health since damage event don't appear to have hitPoints info\r\n    this.totalOneVersDr += this._versatilityDamageReduction(event, damageVal);\r\n  }\r\n  _versatilityDamageReduction(event, damageVal) {\r\n    const amount = damageVal.effective;\r\n    const currentVersDamageReductionPercentage = this.statTracker.currentVersatilityPercentage / 2;\r\n    const damageReductionIncreaseFromOneVers = this.statTracker.statMultiplier.versatility / this.statTracker.ratingNeededForNextPercentage(this.statTracker.currentVersatilityRating, this.statTracker.statBaselineRatingPerPercent[STAT.VERSATILITY], 1, false) / 2; // the DR part is only 50% of the Versa percentage\r\n\r\n    const noVersDamage = amount / (1 - currentVersDamageReductionPercentage);\r\n    return noVersDamage * damageReductionIncreaseFromOneVers;\r\n  }\r\n\r\n  onHealTaken(event) {\r\n    this._updateMissingHealth(event);\r\n  }\r\n  _updateMissingHealth(event) {\r\n    if (event.hitPoints && event.maxHitPoints) { // fields not always populated, don't know why\r\n      // `maxHitPoints` is always the value *after* the effect applied\r\n      this.playerHealthMissing = event.maxHitPoints - event.hitPoints;\r\n    }\r\n  }\r\n\r\n  onFightend() {\r\n    if (DEBUG) {\r\n      console.log('total', formatNumber(this.totalAdjustedHealing));\r\n      console.log(`Int - ${formatNumber(this.totalOneInt)}`);\r\n      console.log(`Crit - ${formatNumber(this.totalOneCrit)}`);\r\n      console.log(`Haste HPCT - ${formatNumber(this.totalOneHasteHpct)}`);\r\n      console.log(`Haste HPM - ${formatNumber(this.totalOneHasteHpm)}`);\r\n      console.log(`Mastery - ${formatNumber(this.totalOneMastery)}`);\r\n      console.log(`Vers - ${formatNumber(this.totalOneVers)}`);\r\n      console.log(`Leech - ${formatNumber(this.totalOneLeech)}`);\r\n    }\r\n  }\r\n\r\n  get hpsPerIntellect() {\r\n    return this._getGain(STAT.INTELLECT) / this.owner.fightDuration * 1000;\r\n  }\r\n  get hpsPerCriticalStrike() {\r\n    return this._getGain(STAT.CRITICAL_STRIKE) / this.owner.fightDuration * 1000;\r\n  }\r\n  get hpsPerHasteHPCT() {\r\n    return this._getGain(STAT.HASTE_HPCT) / this.owner.fightDuration * 1000;\r\n  }\r\n  get hpsPerHasteHPM() {\r\n    return this._getGain(STAT.HASTE_HPM) / this.owner.fightDuration * 1000;\r\n  }\r\n  get hpsPerHaste() {\r\n    return this.hpsPerHasteHPCT + this.hpsPerHasteHPM;\r\n  }\r\n  get hpsPerMastery() {\r\n    return this._getGain(STAT.MASTERY) / this.owner.fightDuration * 1000;\r\n  }\r\n  get hpsPerVersatility() {\r\n    return this._getGain(STAT.VERSATILITY) / this.owner.fightDuration * 1000;\r\n  }\r\n  get hpsPerVersatilityDR() {\r\n    return this._getGain(STAT.VERSATILITY_DR) / this.owner.fightDuration * 1000;\r\n  }\r\n  get hpsPerLeech() {\r\n    return this._getGain(STAT.LEECH) / this.owner.fightDuration * 1000;\r\n  }\r\n\r\n  // region Item values\r\n  calculateItemStatsHps(baseStats, itemLevel) {\r\n    let hps = 0;\r\n    if (baseStats.primary) {\r\n      hps += calculatePrimaryStat(baseStats.itemLevel, baseStats.primary, itemLevel) * this.hpsPerIntellect;\r\n    }\r\n    if (baseStats.criticalStrike) {\r\n      hps += calculateSecondaryStatDefault(baseStats.itemLevel, baseStats.criticalStrike, itemLevel) * this.hpsPerCriticalStrike;\r\n    }\r\n    if (baseStats.haste) {\r\n      hps += calculateSecondaryStatDefault(baseStats.itemLevel, baseStats.haste, itemLevel) * this.hpsPerHaste;\r\n    }\r\n    if (baseStats.mastery) {\r\n      hps += calculateSecondaryStatDefault(baseStats.itemLevel, baseStats.mastery, itemLevel) * this.hpsPerMastery;\r\n    }\r\n    if (baseStats.versatility) {\r\n      hps += calculateSecondaryStatDefault(baseStats.itemLevel, baseStats.versatility, itemLevel) * this.hpsPerVersatility;\r\n    }\r\n    if (baseStats.leech) {\r\n      hps += calculateSecondaryStatDefault(baseStats.itemLevel, baseStats.leech, itemLevel) * this.hpsPerLeech;\r\n    }\r\n    return hps;\r\n  }\r\n  // endregion\r\n\r\n  // region statistic\r\n  _ratingPerOnePercent(oneRatingHealing) {\r\n    const onePercentHealing = this.totalAdjustedHealing / 100;\r\n    return onePercentHealing / oneRatingHealing;\r\n  }\r\n  _getGain(stat) {\r\n    switch (stat) {\r\n      case STAT.INTELLECT:\r\n        return this.totalOneInt;\r\n      case STAT.CRITICAL_STRIKE:\r\n        return this.totalOneCrit;\r\n      case STAT.HASTE_HPCT:\r\n        return this.totalOneHasteHpct;\r\n      case STAT.HASTE_HPM:\r\n        return this.totalOneHasteHpm;\r\n      case STAT.MASTERY:\r\n        return this.totalOneMastery;\r\n      case STAT.VERSATILITY:\r\n        return this.totalOneVers;\r\n      case STAT.VERSATILITY_DR:\r\n        return this.totalOneVers + this.totalOneVersDr;\r\n      case STAT.LEECH:\r\n        return this.totalOneLeech;\r\n      default:\r\n        return 0;\r\n    }\r\n  }\r\n  _getTooltip(stat) {\r\n    switch (stat) {\r\n      case STAT.HASTE_HPCT:\r\n        return <Trans id=\"shared.healerStatValues.stats.hpct\">HPCT stands for \"Healing per Cast Time\". This is the value that Haste would be worth if you would cast everything you are already casting (and that scales with Haste) faster. Mana is not accounted for in any way and you should consider the Haste stat weight 0 if you run out of mana while doing everything else right.</Trans>;\r\n      case STAT.HASTE_HPM:\r\n        return <Trans id=\"shared.healerStatValues.stats.hpm\">HPM stands for \"Healing per Mana\". In valuing Haste, it considers only the faster HoT ticking and not the reduced cast times. Effectively it models haste's bonus to mana efficiency. This is typically the better calculation to use for raid encounters where mana is an issue.</Trans>;\r\n      case STAT.VERSATILITY_DR:\r\n        return <Trans id=\"shared.healerStatValues.stats.versDR\">Weight includes both healing boost and damage reduction, counting the damage reduced as additional throughput.</Trans>;\r\n      default:\r\n        return null;\r\n    }\r\n  }\r\n  moreInformationLink = null;\r\n  static position = STATISTIC_ORDER.CORE(9);\r\n  statistic() {\r\n    const results = this._prepareResults();\r\n    const qeLink = results.reduce((urlParts, stat) => {\r\n      if (stat === 'intellect' || stat === 'versatilitydr') {\r\n        return urlParts;\r\n      }\r\n\r\n      const statValue = typeof stat === 'object' ? stat.stat : stat;\r\n      const gain = this._getGain(statValue);\r\n      const weight = gain / (this.totalOneInt || 1);\r\n      const statName = getName(statValue).replace(/[()\\s+]/g, '');\r\n\r\n      urlParts.push(statName + '=' + weight.toFixed(2));\r\n      return urlParts;\r\n    }, []).join('&');\r\n    return (\r\n      <StatisticWrapper position={this.constructor.position}>\r\n        <div className=\"col-lg-6 col-md-6 col-sm-6 col-xs-12\">\r\n          <div className=\"panel items statistic\">\r\n            {this.moreInformationLink && (\r\n              <a\r\n                href={this.moreInformationLink}\r\n                target=\"_blank\"\r\n                rel=\"noopener noreferrer\"\r\n              >\r\n                <Tooltip content=\"Click for more information.\">\r\n                  <div\r\n                    className=\"detail-corner\"\r\n                    data-place=\"top\"\r\n                  >\r\n                    <InfoIcon />\r\n                  </div>\r\n                </Tooltip>\r\n              </a>\r\n            )}\r\n            <div className=\"panel-body\" style={{ padding: '10px 0 16px' }}>\r\n              <table className=\"data-table compact\" style={{ margin: 0 }}>\r\n                <thead>\r\n                  <tr className=\"text-muted\">\r\n                    <th style={{ minWidth: 30, fontWeight: 400 }}>\r\n                      <TooltipElement\r\n                        content={(\r\n                          <Trans id=\"shared.healerStatValues.statistic.title.tooltip\">\r\n                            These stat values are calculated using the actual circumstances of this encounter. These values reveal the value of the last 1 rating of each stat, they may not necessarily be the best way to gear. The stat values are likely to differ based on fight, raid size, items used, talents chosen, etc.<br /><br />\r\n                            DPS gains are not included in any of the stat values.\r\n                          </Trans>\r\n                        )}\r\n                      >\r\n                        <Trans id=\"shared.healerStatValues.statistic.title\">Stat Values</Trans>\r\n                      </TooltipElement>\r\n                      {false && this.qeLive && this.selectedCombatant.characterProfile && ( // globally disable the QELive button until QE is updated to accept Shadowlands data\r\n                        <Tooltip content=\"Opens in a new tab. Leverage the QE Live Tool to directly compare gear, azerite traits, and trinkets based on your stat values.\">\r\n                          <a\r\n                            href={`https://www.questionablyepic.com/live?import=WoWA&spec=${this.selectedCombatant.specId}&pname=${this.selectedCombatant.name}&realm=${this.selectedCombatant.characterProfile.realm}&region=${this.selectedCombatant.characterProfile.region}&${qeLink}`}\r\n                            target=\"_blank\"\r\n                            rel=\"noopener noreferrer\"\r\n                          >\r\n                            <Trans id=\"shared.healerStatValues.statistic.qeLink\"><img src={QELiveLogo} alt=\"Questionably Epic Live\" style={{ height: '1.2em', marginLeft: 15 }} /> Open Questionably Epic Live</Trans>\r\n                          </a>\r\n                        </Tooltip>\r\n                      )}\r\n                    </th>\r\n                    <th className=\"text-right\" style={{ minWidth: 30, fontWeight: 400 }} colSpan={2}>\r\n                      <TooltipElement content={<Trans id=\"shared.healerStatValues.statistic.title.value.tooltip\">Normalized so Intellect is always 1.00.</Trans>}>\r\n                        <Trans id=\"shared.healerStatValues.statistic.title.value\">Value</Trans>\r\n                      </TooltipElement>\r\n                    </th>\r\n                  </tr>\r\n                </thead>\r\n                <tbody>\r\n                  {results.map(row => {\r\n                    const stat = typeof row === 'object' ? row.stat : row;\r\n                    const tooltip = typeof row === 'object' ? row.tooltip : this._getTooltip(stat);\r\n                    const gain = this._getGain(stat);\r\n                    const weight = gain / (this.totalOneInt || 1);\r\n                    const ratingForOne = this._ratingPerOnePercent(gain);\r\n\r\n                    const Icon = getIcon(stat);\r\n\r\n                    const gainPerSecond = (gain / this.owner.fightDuration * 1000).toFixed(2);\r\n                    const rating = gain !== null ? (ratingForOne === Infinity ? '' : formatNumber(ratingForOne)) : 'NYI';\r\n                    const informationIconTooltip = <Trans id=\"shared.healerStatValues.statistic.stats.tooltip\">{gainPerSecond} HPS per 1 rating / {rating} rating per 1% throughput</Trans>;\r\n\r\n                    return (\r\n                      <tr key={stat}>\r\n                        <td className={getClassNameColor(stat)}>\r\n                          <Icon\r\n                            style={{\r\n                              height: '1.6em',\r\n                              width: '1.6em',\r\n                              marginRight: 10,\r\n                            }}\r\n                          />{' '}\r\n                          {tooltip ? <TooltipElement content={tooltip}>{getNameTranslated(stat)}</TooltipElement> : getNameTranslated(stat)}\r\n                        </td>\r\n                        <td className=\"text-right\">\r\n                          {stat === STAT.HASTE_HPCT && '0.00 - '}{gain !== null ? weight.toFixed(2) : 'NYI'}\r\n                        </td>\r\n                        <td style={{ padding: 6 }}>\r\n                          <Tooltip content={informationIconTooltip}>\r\n                            <div>\r\n                              <InformationIcon />\r\n                            </div>\r\n                          </Tooltip>\r\n                        </td>\r\n                      </tr>\r\n                    );\r\n                  })}\r\n                </tbody>\r\n              </table>\r\n            </div>\r\n          </div>\r\n        </div>\r\n      </StatisticWrapper>\r\n    );\r\n  }\r\n  // endregion\r\n}\r\n\r\nexport default BaseHealerStatValues;\r\n","import React from 'react';\r\n\r\nimport Panel from 'interface/statistics/Panel';\r\nimport Analyzer from 'parser/core/Analyzer';\r\nimport { Trans } from '@lingui/macro';\r\n\r\nimport HealingEfficiencyTracker from './HealingEfficiencyTracker';\r\nimport HealingEfficiencyBreakdown from './HealingEfficiencyBreakdown';\r\n\r\nclass HealingEfficiencyDetails extends Analyzer {\r\n  static dependencies = {\r\n    healingEfficiencyTracker: HealingEfficiencyTracker,\r\n  };\r\n\r\n  protected healingEfficiencyTracker!: HealingEfficiencyTracker;\r\n\r\n  statistic() {\r\n    return (\r\n      <Panel\r\n        title={<Trans id=\"shared.healingEfficiency.title\">Mana Efficiency</Trans>}\r\n        position={120}\r\n      >\r\n        <HealingEfficiencyBreakdown tracker={this.healingEfficiencyTracker} />\r\n      </Panel>\r\n    );\r\n  }\r\n}\r\n\r\nexport default HealingEfficiencyDetails;\r\n","import Combatants from 'parser/shared/modules/Combatants';\r\nimport Haste from 'parser/shared/modules/Haste';\r\nimport calculateEffectiveHealing from 'parser/core/calculateEffectiveHealing';\r\nimport Analyzer, { SELECTED_PLAYER } from 'parser/core/Analyzer';\r\nimport Events from 'parser/core/Events';\r\nimport HIT_TYPES from 'game/HIT_TYPES';\r\nimport { EventType } from 'parser/core/Events';\r\n\r\nconst PANDEMIC_FACTOR = 1.3;\r\nconst PANDEMIC_EXTRA = 0.3;\r\n\r\n// tolerated difference between expected and actual HoT fall before a 'mismatch' is logged\r\nconst EXPECTED_REMOVAL_THRESHOLD = 200;\r\n\r\n// this class does a lot, a few different debug areas to cut down on the spam while debugging\r\nconst debug = false;\r\nconst extensionDebug = false; // logs pertaining to extensions\r\nconst applyRemoveDebug = false; // logs tracking HoT apply / refresh / remove\r\nconst healDebug = false; // logs tracking HoT heals\r\n\r\nclass HotTracker extends Analyzer {\r\n  static dependencies = {\r\n    combatants: Combatants,\r\n    haste: Haste,\r\n  };\r\n\r\n  //{\r\n  //  [playerId]:{\r\n  //    [hotId]: {start, end, originalEnd, spellId, guid, name, ticks, attributions, extensions, boosts, healingAfterOriginalEnd, maxDuration},\r\n  //  },\r\n  //}\r\n\r\n  hots = {};\r\n  bouncingHots = [];\r\n\r\n  currentGuid = 0;\r\n\r\n  hotHistory = [];\r\n\r\n  constructor(...args) {\r\n    super(...args);\r\n    this.hotInfo = this._generateHotInfo(); // some HoT info depends on traits and so must be generated dynamically\r\n    this.hotList = this._generateHotList();\r\n    if(!this.hotInfo){\r\n      this.active = false;\r\n    }\r\n\r\n    this.addEventListener(Events.applybuff.by(SELECTED_PLAYER).spell(this.hotList), this.hotApplied);\r\n    this.addEventListener(Events.heal.by(SELECTED_PLAYER).spell(this.hotList), this.hotHeal);\r\n    this.addEventListener(Events.refreshbuff.by(SELECTED_PLAYER).spell(this.hotList), this.hotReapplied);\r\n    this.addEventListener(Events.removebuff.by(SELECTED_PLAYER).spell(this.hotList), this.hotRemoved);\r\n  }\r\n\r\n  hotApplied(event){\r\n    const spellId = event.ability.guid;\r\n    const target = this._getTarget(event);\r\n    if (!target) {\r\n      return;\r\n    }\r\n    const targetId = event.targetID;\r\n    if (!this._validateHot(event)) {\r\n      return;\r\n    }\r\n\r\n    if(this.hotInfo[spellId].bouncy && this.bouncingHots.length !== 0){\r\n      if (!this.hots[targetId]) {\r\n        this.hots[targetId] = {};\r\n      }\r\n      this.hots[targetId][spellId] = this.bouncingHots[0];\r\n      this.bouncingHots.shift();\r\n      return;\r\n    }\r\n\r\n    let hotDuration = this.hotInfo[spellId].duration;\r\n    if(this.hotInfo[spellId].durationConditions){\r\n      event.selectedCombatant = this.selectedCombatant;\r\n      hotDuration = this.hotInfo[spellId].durationConditions(event);\r\n    }\r\n\r\n    let maxDuration = -1;\r\n    if(this.hotInfo[spellId].maxDuration){\r\n      event.selectedCombatant = this.selectedCombatant;\r\n      maxDuration = this.hotInfo[spellId].maxDuration(event);\r\n    }\r\n\r\n    const newHot = {\r\n      start: event.timestamp,\r\n      end: event.timestamp + hotDuration,\r\n      originalEnd: event.timestamp + hotDuration,\r\n      spellId, // stored extra here so I don't have to convert string to number like I would if I used its key in the object.\r\n      guid: this.currentGuid,\r\n      name: event.ability.name, // stored for logging\r\n      ticks: [], // listing of ticks w/ effective heal amount and timestamp, to be used as part of the HoT extension calculations\r\n      attributions: [], // The effect or bonus that procced this HoT application. No attribution implies the spell was hardcast.\r\n      extensions: [], // The effects or bonuses that caused this HoT to have extended duration. Format: { amount, attribution }\r\n      boosts: [], // The effects or bonuses that caused the strength of this HoT to be boosted for its full duration.\r\n      healingAfterOriginalEnd: 0,//healing this hot did after the base duration due to extensions\r\n      maxDuration: maxDuration,//the true max duration that extensions will obey by (looking at rising mist)\r\n    };\r\n\r\n    this.currentGuid += 1;\r\n\r\n    if (!this.hots[targetId]) {\r\n      this.hots[targetId] = {};\r\n    }\r\n    this.hots[targetId][spellId] = newHot;\r\n    this.hotHistory.push(newHot);\r\n  }\r\n\r\n  hotHeal(event) {\r\n    const spellId = event.ability.guid;\r\n    const target = this._getTarget(event);\r\n\r\n    if (!target) {\r\n      return;\r\n    }\r\n    const targetId = event.targetID;\r\n    const healing = event.amount + (event.absorbed || 0);\r\n\r\n    if (!this._validateHot(event)) {\r\n      return;\r\n    }\r\n    const hot = this.hots[targetId][spellId];\r\n    if (event.tick) { // direct healing (say from a PotA procced regrowth) still should be counted for attribution, but not part of tick tracking\r\n      hot.ticks.push({ healing, timestamp: event.timestamp });\r\n    }\r\n\r\n    if(hot.originalEnd < event.timestamp && event.timestamp < (hot.start + hot.maxDuration)){\r\n      hot.healingAfterOriginalEnd += healing;\r\n    }\r\n\r\n    hot.attributions.forEach(att => {\r\n      att.healing += healing;\r\n    });\r\n    hot.boosts.forEach(att => {\r\n      att.healing += calculateEffectiveHealing(event, att.boost);\r\n    });\r\n\r\n    if(event.hitType === HIT_TYPES.CRIT && this.hotInfo[spellId].effectOnCrit){//if the heal crits and it does something fancy on crits do that\r\n      hot.effectOnCrit(event);\r\n    }\r\n    // extensions handled when HoT falls, using ticks list\r\n  }\r\n\r\n  hotReapplied(event) {\r\n    const spellId = event.ability.guid;\r\n    const target = this._getTarget(event);\r\n    if (!target) {\r\n      return;\r\n    }\r\n    const targetId = event.targetID;\r\n    if (!this._validateHot(event)) {\r\n      return;\r\n    }\r\n\r\n    const hot = this.hots[targetId][spellId];\r\n\r\n    const oldEnd = hot.end;\r\n    let freshDuration = this.hotInfo[spellId].duration;\r\n    if(this.hotInfo[spellId].durationConditions){\r\n      event.selectedCombatant = this.selectedCombatant;\r\n      freshDuration = this.hotInfo[spellId].durationConditions(spellId);\r\n    }\r\n    hot.end += this._calculateExtension(freshDuration, hot, spellId, true, true);\r\n\r\n    hot.originalEnd = hot.end;//reframe our info\r\n\r\n    // seperately calculating if refresh was in pandemic, because for display to the player I want to avoid factoring in tick clipping...\r\n    const remaining = oldEnd - event.timestamp;\r\n    const clipped = remaining - (freshDuration * PANDEMIC_EXTRA);\r\n    if (clipped > 0) {\r\n      debug && console.log(`${event.ability.name} on target ID ${targetId} was refreshed early @${this.owner.formatTimestamp(event.timestamp)}, clipping ${(clipped / 1000).toFixed(1)}s`);\r\n      hot.extensions.forEach(ext => {\r\n        ext.amount -= clipped;\r\n        extensionDebug && console.log(`Extension ${ext.attribution.name} on ${event.ability.name} / ${targetId} @${this.owner.formatTimestamp(event.timestamp)} was clipped by ${(clipped / 1000).toFixed(1)}s`);\r\n      });\r\n      // TODO do more stuff about clipped HoT duration (a suggestion?). Only suggest for clipping hardcasts, of course.\r\n    }\r\n\r\n    hot.attributions = []; // new attributions on refresh\r\n\r\n    this._tallyExtensions(hot);\r\n    hot.extensions = [];\r\n\r\n    hot.boosts = [];\r\n  }\r\n\r\n\r\n  hotRemoved(event) {\r\n    const spellId = event.ability.guid;\r\n    const target = this._getTarget(event);\r\n    if (!target) {\r\n      return;\r\n    }\r\n    const targetId = event.targetID;\r\n    if (!this._validateHot(event)) {\r\n      return;\r\n    }\r\n\r\n    if(this.hotInfo[spellId].bouncy && this.hots[targetId][spellId].end > event.timestamp){\r\n      this.bouncingHots.push(this.hots[targetId][spellId]);\r\n    }else{\r\n      this._checkRemovalTime(this.hots[targetId][spellId], event.timestamp, targetId);\r\n      this._tallyExtensions(this.hots[targetId][spellId]);\r\n    }\r\n    //delete hot no matter what\r\n    delete this.hots[targetId][spellId];\r\n  }\r\n\r\n  /*\r\n   * Adds an attribution to the HoT with the given spellId on the given targetId.\r\n   * Attribution object passed in will be modified as the HoT heals, and must have the following fields:\r\n   *    name: String (used only for logging)\r\n   *    healing: Number (tallies the direct healing attributable)\r\n   *    procs: Number (tallies the number of times this attribution was made)\r\n   */\r\n  addAttribution(attribution, targetId, spellId) {\r\n    if (!this.hots[targetId] || !this.hots[targetId][spellId]) {\r\n      debug && console.warn(`Tried to add attribution ${attribution.name} to targetId=${targetId}, spellId=${spellId}, but that HoT isn't recorded as present`);\r\n      return;\r\n    }\r\n    attribution.procs += 1;\r\n    this.hots[targetId][spellId].attributions.push(attribution);\r\n    debug && console.log(`${this.hots[targetId][spellId].name} on ${targetId} @${this.owner.formatTimestamp(this.owner.currentTimestamp, 1)} attributed to ${attribution.name}`);\r\n  }\r\n\r\n  /*\r\n   * Extends the duration of the HoT with the the given spellId on the given targetId, and adds an attribution to that extension.\r\n   * Attribution object passed in will be modified when the HoT expires, and must have the following fields:\r\n   *    name: String (used only for logging)\r\n   *    healing: Number (tallies the direct healing attributable)\r\n   *    procs: Number (tallies the number of times this attribution was made)\r\n   *    duration: Number (tallies the actual amount of extension applied, after clamping)\r\n   * tickClamps and pandemicClamps specify if / how the extension should be clamped\r\n   *\r\n   * NOTE: can pass a null attribution to extend HoT without attributing it\r\n   */\r\n  addExtension(attribution, amount, targetId, spellId, timestamp, tickClamps = true, pandemicClamps = false) {\r\n    if (!this.hots[targetId] || !this.hots[targetId][spellId]) {\r\n      debug && console.warn(`Tried to add extension ${attribution.name || 'NO-ATT'} to targetId=${targetId}, spellId=${spellId}, but that HoT isn't recorded as present`);\r\n      return;\r\n    }\r\n\r\n    const hot = this.hots[targetId][spellId];\r\n\r\n    //double check if we can even extend in the first place\r\n    if(hot.maxDuration !== -1){\r\n      const timeOut = timestamp - hot.start;\r\n      const timeLeft = hot.maxDuration - timeOut;\r\n      const timeToAdd = Math.min(amount, timeLeft);//find the smaller one as this will be added\r\n      amount = Math.max(timeToAdd, 0);//make sure we are not negative\r\n    }\r\n\r\n    const finalAmount = this._calculateExtension(amount, hot, spellId, tickClamps, pandemicClamps);\r\n    hot.end += finalAmount;\r\n\r\n    // TODO log the result\r\n    if (!attribution) {\r\n      return;\r\n    }\r\n\r\n    attribution.procs += 1;\r\n    const existingExtension = hot.extensions.find(extension => extension.attribution.name === attribution.name);\r\n    if (existingExtension) {\r\n      existingExtension.amount += finalAmount;\r\n    } else {\r\n      hot.extensions.push({\r\n        attribution,\r\n        amount: finalAmount,\r\n      });\r\n    }\r\n    debug && console.log(`${hot.name} on ${targetId} @${this.owner.formatTimestamp(this.owner.currentTimestamp, 1)} extended ${(finalAmount / 1000).toFixed(1)}s by ${attribution.name}`);\r\n  }\r\n\r\n  /*\r\n   * For each attributed extension on a HoT, tallies the granted healing\r\n   */\r\n  _tallyExtensions(hot) {\r\n    hot.extensions\r\n      .filter(ext => ext.amount > 0) // early refreshes can wipe out the effect of an extension, filter those ones out\r\n      .forEach(ext => this._tallyExtension(hot.ticks, ext.amount, ext.attribution));\r\n  }\r\n\r\n  _tallyExtension(ticks, amount, attribution) {\r\n    const now = this.owner.currentTimestamp;\r\n\r\n    let foundEarlier = false;\r\n    let latestOutside = now;\r\n    let healing = 0;\r\n    // sums healing of every tick within 'amount',\r\n    // also gets the latest tick outside the range, used to scale the healing amount\r\n    for (let i = ticks.length - 1; i >= 0; i -= 1) {\r\n      const tick = ticks[i];\r\n      latestOutside = tick.timestamp;\r\n      if ((now - tick.timestamp) > amount) {\r\n        foundEarlier = true;\r\n        break;\r\n      }\r\n\r\n      healing += tick.healing;\r\n    }\r\n\r\n    if (foundEarlier) {\r\n      // TODO better explanation of why I need to scale direct healing\r\n      const scale = amount / (now - latestOutside);\r\n      attribution.healing += (healing * scale);\r\n      attribution.duration += amount;\r\n    } else {\r\n      // TODO error log, because this means the extension was almost all the HoT's duration? Check for an early removal of HoT.\r\n    }\r\n  }\r\n\r\n  /*\r\n   * HoT extensions (for whatever reason) do not always extend by exactly the listed amount.\r\n   * Instead, they follow the following formula, which this function implements:\r\n   *\r\n   * Add the raw extension amount to the current time remaining on the HoT, then round to the nearest whole number of ticks (with respect to haste)\r\n   * Note that as most tick periods scale with haste, this rounding effectively works on a snapshot of the player's haste at the moment of the extension.\r\n   *\r\n   * An example:\r\n   * The player casts Flourish (raw extension = 6 seconds), extending a Rejuvenation with 5.4s remaining.\r\n   * The player's current haste is 20%, meaning rejuv's current tick period = 3 / (1 + 0.2) = 2.5\r\n   * Time remaining after raw extension = 5.4 + 6 = 11.6\r\n   * Ticks remaining after extension, before rounding = 11.6 / 2.5 = 4.64\r\n   * Round(4.64) = 5 ticks => 5 * 2.5 = 12.5 seconds remaining after extension and rounding\r\n   * Effective extension amount = 12.6 - 5.4 = 7.2\r\n   * Note that this can round up or down\r\n   *\r\n   * Thanks @tremaho for the detailed explanation of the formula\r\n   */\r\n  _calculateExtension(rawAmount, hot, spellId, tickClamps, pandemicClamps) {\r\n    let amount = rawAmount;\r\n    const currentTimeRemaining = hot.end - this.owner.currentTimestamp;\r\n\r\n    let pandemicLog = '';\r\n    if (pandemicClamps) {\r\n      const newTimeRemaining = currentTimeRemaining + amount;\r\n      const pandemicMax = this.hotInfo[spellId].duration * PANDEMIC_FACTOR;\r\n      if (newTimeRemaining > pandemicMax) {\r\n        amount = pandemicMax - currentTimeRemaining;\r\n        pandemicLog = `PANDEMIC:(remaining=${(pandemicMax / 1000).toFixed(2)}s)`;\r\n      } else {\r\n        pandemicLog = `PANDEMIC:(N/A)`;\r\n      }\r\n    }\r\n\r\n    let tickLog = '';\r\n    if (tickClamps) {\r\n      const currentTickPeriod = this.hotInfo[spellId].tickPeriod / (1 + this.haste.current);\r\n      const newTimeRemaining = currentTimeRemaining + amount;\r\n      const newTicksRemaining = newTimeRemaining / currentTickPeriod;\r\n      const newRoundedTimeRemaining = Math.round(newTicksRemaining) * currentTickPeriod;\r\n      amount = newRoundedTimeRemaining - currentTimeRemaining;\r\n      tickLog = `TICK:(period=${(currentTickPeriod / 1000).toFixed(2)}s)`;\r\n    }\r\n\r\n    // an extension can never reduce HoT's remaining duration, even after clamping\r\n    amount = Math.max(0, amount);\r\n\r\n    extensionDebug && console.log(`${hot.name} w/ ${(currentTimeRemaining / 1000).toFixed(2)}s remaining gets ${(rawAmount / 1000).toFixed(2)}s extension clamped by ${pandemicLog} ${tickLog} => actual: ${(amount / 1000).toFixed(2)}s, new remaining: ${((amount + currentTimeRemaining) / 1000).toFixed(2)}s`);\r\n\r\n    return amount;\r\n  }\r\n\r\n  // Returns the difference between the timestamp and the expected removal time listed in the hot object.\r\n  // Return will be positive if HoT actually ended after expected end (eg HoT lasted longer than expected).\r\n  // Return will be negative if HoT actually ended before expected end (eg HoT lasted shorter than expected).\r\n  // Logs when difference is over a certain threshold.\r\n  _checkRemovalTime(hot, actual, targetId) {\r\n    const expected = hot.end;\r\n    const diff = actual - expected;\r\n    if (diff > EXPECTED_REMOVAL_THRESHOLD) {\r\n      // The only reason HoT could last longer than expected is we are missing an extension, which is a bug -> log a warning\r\n      extensionDebug && console.warn(`${hot.name} on ${targetId} fell @${this.owner.formatTimestamp(actual, 1)}, which is ${(diff / 1000).toFixed(1)}s LATER than expected... Missing an extension?`);\r\n    } else if (diff < (-1 * EXPECTED_REMOVAL_THRESHOLD)) {\r\n      // Several legitimate reasons HoT could last shorter than expected: lifebloom swap, target dies, target was purged, target cancelled the spell -> log only when debug on\r\n      extensionDebug && console.warn(`${hot.name} on ${targetId} fell @${this.owner.formatTimestamp(actual, 1)}, which is ${-(diff / 1000).toFixed(1)}s earlier than expected`);\r\n    }\r\n    return diff;\r\n  }\r\n\r\n\r\n  // gets an event's target ... returns null if for any reason the event should not be further processed\r\n  _getTarget(event) {\r\n    const target = this.combatants.getEntity(event);\r\n    if (!target) {\r\n      return null; // target wasn't important (a pet probably)\r\n    }\r\n\r\n    const targetId = event.targetID;\r\n    if (!targetId) {\r\n      debug && console.log(`${event.ability.name} ${event.type} to target without ID @${this.owner.formatTimestamp(event.timestamp, 1)}... HoT will not be tracked.`);\r\n      return null;\r\n    } else {\r\n      if (event.type === EventType.Heal) {\r\n        healDebug && console.log(`${event.ability.name} ${event.type} to ID ${targetId} @${this.owner.formatTimestamp(event.timestamp, 1)}`);\r\n      } else {\r\n        applyRemoveDebug && console.log(`${event.ability.name} ${event.type} to ID ${targetId} @${this.owner.formatTimestamp(event.timestamp, 1)}`);\r\n      }\r\n    }\r\n\r\n    return target;\r\n  }\r\n\r\n  // validates that event is for one of the tracked hots and that HoT tracking involving it is in the expected state\r\n  _validateHot(event) {\r\n    const spellId = event.ability.guid;\r\n    const targetId = event.targetID;\r\n    if (!(this.hotInfo[spellId])) {\r\n      return false; // we only care about the listed HoTs\r\n    }\r\n\r\n    if ([EventType.RemoveBuff, EventType.RefreshBuff, EventType.Heal].includes(event.type) &&\r\n      (!this.hots[targetId] || !this.hots[targetId][spellId])) {\r\n      debug && console.warn(`${event.ability.name} ${event.type} on target ID ${targetId} @${this.owner.formatTimestamp(event.timestamp)} but there's no record of that HoT being added...`);\r\n      return false;\r\n    } else if (event.type === EventType.ApplyBuff && this.hots[targetId] && this.hots[targetId][spellId]) {\r\n      debug && console.warn(`${event.ability.name} ${event.type} on target ID ${targetId} @${this.owner.formatTimestamp(event.timestamp)} but that HoT is recorded as already added...`);\r\n      return false;\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  /*{\r\n   *  [SPELLS.NAME.id]:{\r\n   *    duration: xxxx,                 //base duration\r\n   *    tickPeriod: xxxx,               //rate at which it heals\r\n   *    effectOnCrit: function,         //if anything special happens on crit\r\n   *    maxDuration: function,          //how to caculate max non-pandmic duration (return the max duration)\r\n   *    bouncy: boolean,                //if a hot will bounce to another target on any event\r\n   *    durationConditions: functions,  //function that will fire if the duration of the hot depend on event info\r\n   *    id: SPELLS.NAME.id,             //store again for dynamic listeners\r\n   *  },\r\n   * }\r\n   */\r\n  _generateHotInfo() { // must be generated dynamically because it reads from traits\r\n  }\r\n}\r\n\r\nexport default HotTracker;\r\n"],"sourceRoot":""}