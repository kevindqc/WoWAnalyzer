{"version":3,"sources":["parser/monk/windwalker/modules/core/GlobalCooldown.tsx","parser/monk/windwalker/modules/features/AlwaysBeCasting.tsx","parser/monk/windwalker/modules/Abilities.tsx","parser/monk/windwalker/modules/Buffs.tsx","parser/monk/windwalker/modules/features/CooldownThroughputTracker.tsx","parser/monk/windwalker/modules/spells/ComboBreaker.tsx","parser/monk/windwalker/modules/spells/FistsofFury.tsx","parser/monk/windwalker/modules/spells/TouchOfKarma.tsx","parser/monk/windwalker/constants.ts","parser/monk/windwalker/modules/spells/ComboStrikes.tsx","parser/monk/windwalker/modules/spells/BlackoutKick.tsx","parser/monk/windwalker/modules/talents/HitCombo.tsx","parser/monk/windwalker/modules/resources/ChiTracker.js","parser/monk/windwalker/modules/resources/ChiDetails.js","parser/monk/windwalker/modules/items/LastEmperorsCapacitor.tsx","parser/monk/windwalker/modules/items/JadeIgnition.tsx","parser/monk/windwalker/modules/features/checklist/Component.tsx","parser/monk/windwalker/modules/features/checklist/Module.tsx","parser/monk/windwalker/modules/resources/EnergyCapTracker.js","parser/monk/windwalker/modules/core/Channeling.tsx","parser/monk/windwalker/modules/spells/SpinningCraneKick.tsx","parser/monk/windwalker/modules/talents/Serenity.tsx","parser/monk/windwalker/CombatLogParser.ts","parser/core/calculateEffectiveDamage.js","interface/icons/Uptime.js","parser/shared/ExecuteHelper.ts","parser/shared/modules/resources/resourcetracker/RegenResourceCapTracker.js","parser/monk/shared/modules/spells/TouchOfDeath.js","parser/monk/shared/modules/covenants/FallenOrder.tsx"],"names":["GlobalCooldown","event","spellId","ability","guid","SPELLS","FISTS_OF_FURY_CAST","id","this","isOnGlobalCooldown","CoreGlobalCooldown","AlwaysBeCasting","statisticOrder","STATISTIC_ORDER","CORE","when","suggestionThresholds","addSuggestion","suggest","actual","recommended","icon","i18n","_","formatPercentage","totalTimeWasted","owner","fightDuration","downtimePercentage","isGreaterThan","minor","average","major","style","ThresholdStyle","PERCENTAGE","CoreAlwaysBeCasting","Abilities","combatant","selectedCombatant","spell","category","SPELL_CATEGORIES","ROTATIONAL","cooldown","haste","gcd","static","castEfficiency","suggestion","recommendedEfficiency","extraSuggestion","RISING_SUN_KICK","WHIRLING_DRAGON_PUNCH_TALENT","enabled","hasTalent","FIST_OF_THE_WHITE_TIGER_TALENT","BLACKOUT_KICK","TIGER_PALM","EXPEL_HARM","CHI_WAVE_TALENT","base","minimum","SPINNING_CRANE_KICK","CHI_BURST_TALENT","RUSHING_JADE_WIND_TALENT_WINDWALKER","ROTATIONAL_AOE","TOUCH_OF_KARMA_CAST","buffSpellId","SEMI_DEFENSIVE","SERENITY_TALENT","COOLDOWNS","STORM_EARTH_AND_FIRE_CAST","charges","INVOKE_XUEN_THE_WHITE_TIGER","ENERGIZING_ELIXIR_TALENT","RING_OF_PEACE_TALENT","UTILITY","LEG_SWEEP","PARALYSIS","DISABLE","ROLL","CELERITY_TALENT","CHI_TORPEDO_TALENT","FLYING_SERPENT_KICK","TIGERS_LUST_TALENT","TRANSCENDENCE","TRANSCENDENCE_TRANSFER","VIVIFY","DETOX_ENERGY","SPEAR_HAND_STRIKE","PROVOKE","CRACKLING_JADE_LIGHTNING","STORM_EARTH_AND_FIRE_FIXATE","FORTIFYING_BREW","DEFENSIVE","DIFFUSE_MAGIC_TALENT","DAMPEN_HARM_TALENT","CoreAbilities","Buffs","timelineHighlight","DANCE_OF_CHIJI_BUFF","COMBO_BREAKER_BUFF","Object","keys","BLOODLUST_BUFFS","map","item","Number","CoreBuffs","CooldownThroughputTracker","CoreCooldownThroughputTracker","cooldownSpells","summary","BUILT_IN_SUMMARY_TYPES","DAMAGE","castCooldowns","ComboBreaker","options","abilityTracker","CBProcsTotal","lastCBProcTime","consumedCBProc","overwrittenCBProc","addEventListener","Events","applybuff","by","SELECTED_PLAYER","onApplyBuff","refreshbuff","onRefreshBuff","cast","onCast","timestamp","cbTimeframe","SpellLink","averageCBProcs","getAbility","casts","Statistic","position","size","tooltip","toFixed","BoringSpellValueText","usedCBProcs","isLessThan","Analyzer","dependencies","AbilityTracker","FistsofFury","previousTickTimestamp","fistsTicks","damage","FISTS_OF_FURY_DAMAGE","onFistsDamage","isNewFistsTick","averageTicks","DECIMAL","TouchOfKarma","healingDone","totalPossibleAbsorb","maxHitPoints","OPTIONAL","absorbUsed","byAbility","effective","HealingDone","ABILITIES_AFFECTED_BY_DAMAGE_INCREASES","MELEE","RISING_SUN_KICK_SECOND","EYE_OF_THE_TIGER_TALENT","ABILITIES_AFFECTED_BY_MASTERY","TOUCH_OF_DEATH","CHI_SPENDERS","ComboStrikes","_lastSpellUsed","_lastThreeSpellsUsed","masteryDropSpellSequence","hasHitCombo","HIT_COMBO_TALENT","onMasteryCast","eventTimestamp","length","slice","push","COMBO_STRIKES","dropdown","masteryDropEvents","padding","className","index","key","scope","formatDuration","fight","start_time","SpellIcon","height","formatNumber","hitComboMultiplier","masteryDropsPerMinute","NUMBER","BlackoutKick","spellUsable","IMPORTANT_SPELLS","effectiveRisingSunKickReductionMs","wastedRisingSunKickReductionMs","effectiveFistsOfFuryReductionMs","wastedFistsOfFuryReductionMs","hasImportantCastsAvailable","some","isAvailable","currentCooldownReductionMS","hasBuff","meta","isInefficientCast","inefficientCastReason","isOnCooldown","reductionMs","reduceCooldown","fontSize","marginTop","totalWastedReductionPerMinute","SpellUsable","HitCombo","totalDamage","active","SELECTED_PLAYER_PET","onAffectedDamage","buffInfo","getBuff","HIT_COMBO_BUFF","mod","stacks","increase","calculateEffectiveDamage","Uptime","uptime","src","alt","dps","getPercentageOfTotalDamageDone","getStackWeightedBuffUptime","ChiTracker","args","maxResource","resource","RESOURCE_TYPES","CHI","ASCENSION_TALENT","getResource","cost","ResourceTracker","ChiDetails","chiWasted","chiWastedPercent","BoringResourceValue","value","label","title","url","render","Panel","ResourceBreakdown","tracker","chiTracker","resourceName","showSpenders","wasted","generated","chiWastedPerMinute","LastEmperorsCapacitor","totalStacks","currentStacks","stacksUsed","stacksWasted","buffedCast","hasLegendaryByBonusID","LAST_EMPERORS_CAPACITOR","bonusID","LAST_EMPERORS_CAPACITOR_BUFF","applyBuff","applybuffstack","applyBuffStack","castChiSpender","castCracklingJadeLightning","cracklingJadeLightningDamage","amount","absorbed","STATISTIC_CATEGORY","ITEMS","averageStacksUsed","ItemDamageDone","wastedStacksSuggestionThresholds","averageStacksSuggestionThresholds","stacksWastedPerMinute","JadeIgnition","JADE_IGNITION","JADE_IGNITION_BUFF","castSpinningCraneKick","damageDone","stackUsage","JADE_IGNITION_DAMAGE","damageEffective","WindwalkerMonkChecklist","thresholds","AbilityRequirement","props","GenericCastEfficiencyRequirement","getCastEfficiencyForSpellId","Rule","name","description","Requirement","comboBreaker","fistsofFury","jadeIgnition","touchOfKarma","blackoutKick","chiDetails","comboStrikes","hitCombo","lastEmperorsCapacitorAverageStacks","lastEmperorsCapacitorWastedStacks","PreparationRule","Checklist","combatants","preparationRuleAnalyzer","lastEmperorsCapacitor","Component","selected","BaseChecklist","Combatants","CastEfficiency","PreparationRuleAnalyzer","EnergyCapTracker","regen","combatantHasBuffActive","max","Math","floor","StatisticBox","Icon","cappedProportion","missedRegenPerMinute","footer","Tooltip","content","atCap","width","RegenResourceCapTracker","resourceType","ENERGY","baseRegenRate","isRegenHasted","cumulativeEventWindow","resourceRefundOnMiss","buffsChangeRegen","Channeling","removebuff","onRemoveBuff","applydebuff","onApplyDebuff","removedebuff","onRemoveDebuff","isChannelingSpell","log","_currentChannel","endChannel","beginChannel","CoreChanneling","SpinningCraneKick","statTracker","cycloneStrikesMarks","spinningCraneKickHits","totalMarksDuringHits","MARK_OF_THE_CRANE","onMarkApplication","refreshdebuff","onMarkRefresh","onSCKCast","SPINNING_CRANE_KICK_DAMAGE","onSCKDamage","targetInstance","undefined","_verifyTargetInstance","markOfTheCrane","target","targetID","instance","refreshedMark","forEach","mark","a","b","filter","isEnhancedCast","enhancedCastReason","averageMarks","averageEnemiesHit","StatTracker","Serenity","damageGain","onRSK","onFoF","onSerenityStart","onSerenityEnd","cooldownReduction","cooldownRemaining","_reduceRSK","_reduceFoF","cooldownExtension","extendCooldown","CombatLogParser","CoreCombatLogParser","specModules","channeling","globalCooldown","alwaysBeCasting","abilities","buffs","cooldownThroughputTracker","checklist","energyCapTracker","serenity","spinningCraneKick","touchOfDeath","TouchOfDeath","fallenOrder","FallenOrder","raw","other","xmlns","viewBox","d","ExecuteHelper","inExecuteWindow","inHealthExecuteWindow","executeWindowStart","lastExecuteHitTimestamp","totalExecuteWindowDuration","castsWithExecute","executeSources","onGeneralDamage","executeSpells","onExecuteCast","onExecuteDamage","to","executeOutsideRangeEnablers","applyExecuteEnablerBuff","removeExecuteEnablerBuff","fightend","onFightEnd","hitPoints","lowerThreshold","upperThreshold","isTargetInExecuteRange","isTargetInReverseExecuteRange","usable","allOnCD","targetIsFriendly","areExecuteSpellsOnCD","isExecuteUsableOutsideExecuteRange","isTargetInHealthExecuteWindow","modifiesDamage","damageModifier","constructor","HIT_TYPES_THAT_REFUND","HIT_TYPES","MISS","DODGE","PARRY","missedRegen","naturalRegen","regenState","prevSpender","hasReportedBelowCap","debugErrorSum","debugGreatestError","debugAccuracyCheckCount","currentMaxResourceWithFallback","naturalRegenRate","onFightend","energize","onEnergize","onDamage","drain","onDrain","ChangeHaste","onChangeHaste","predictValue","currentTimestamp","current","resourceChange","getBaseRegenRate","isNaN","Error","before","gain","min","applyEnergize","classResources","find","r","type","resourceCost","buffId","buffHistory","getBuffHistory","Boolean","buff","start","end","updateState","end_time","resourceChangeType","waste","applyCumulatively","energizersToApplyCumulatively","includes","time","eventResource","shouldAccumulate","isLastUpdateRecent","getCost","exemptFromRefund","castsToApplyCumulatively","tick","hitType","refund","getReducedDrain","buffsChangeMax","buffChangesResourceMax","buffChangesRegen","oldState","newState","durationCapped","timeCappedBetweenStates","onBelowCap","reachCap","predictReachValue","Infinity","onAtCap","calculated","currentMaxResource","startTime","startValue","targetValue","elapsed","predicted","fabricateEndCap","fabricateBeginCap","eventEmitter","fabricateEvent","sourceID","playerId","EventEmitter","Haste","spellResourceCost","SpellResourceCost","drainsToApplyCumulatively","maxCasts","MINUTE","adjustMaxCasts","add","ceil","totalExecuteDuration","windDamage","brewDamage","mistDamage","mistHealing","mistOverhealing","cloneMap","Map","hasCovenant","COVENANTS","VENTHYR","FALLEN_ORDER_CAST","summon","FALLEN_ORDER_OX_CLONE","FALLEN_ORDER_TIGER_CLONE","FALLEN_ORDER_CRANE_CLONE","trackSummons","heal","FALLEN_ORDER_ENVELOPING_MIST","FALLEN_ORDER_SOOTHING_MIST","mistHealingTracker","FALLEN_ORDER_KEG_SMASH","FALLEN_ORDER_BREATH_OF_FIRE","BREATH_OF_FIRE_DEBUFF","brewDamageTracker","FALLEN_ORDER_SPINNING_CRANE_KICK","windDamageTracker","handleMelee","set","overheal","cloneType","get","mistDamageTracker"],"mappings":"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","file":"static/js/WindwalkerMonk.480ac87b.chunk.js","sourcesContent":["import CoreGlobalCooldown from 'parser/shared/modules/GlobalCooldown';\r\nimport SPELLS from 'common/SPELLS';\r\nimport { CastEvent } from 'parser/core/Events';\r\n\r\n/**\r\n * The Global Cooldown of Fists of Fury is also being triggered by fabricated channeling events\r\n */\r\nclass GlobalCooldown extends CoreGlobalCooldown {\r\n  onCast(event: CastEvent) {\r\n    const spellId = event.ability.guid;\r\n    if (spellId === SPELLS.FISTS_OF_FURY_CAST.id) {\r\n      return;\r\n    }\r\n    const isOnGCD = this.isOnGlobalCooldown(spellId);\r\n    if (!isOnGCD) {\r\n      // This ensures we don't crash when boss abilities are registered as casts which could even happen while channeling. For example on Trilliax: http://i.imgur.com/7QAFy1q.png\r\n      return;\r\n    }\r\n    super.onCast(event);\r\n  }\r\n}\r\n\r\nexport default GlobalCooldown;\r\n","import React from 'react';\r\n\r\nimport CoreAlwaysBeCasting from 'parser/shared/modules/AlwaysBeCasting';\r\n\r\nimport { formatPercentage } from 'common/format';\r\nimport { STATISTIC_ORDER } from 'interface/others/StatisticBox';\r\nimport { i18n } from '@lingui/core';\r\nimport { t } from '@lingui/macro';\r\nimport { ThresholdStyle, When } from 'parser/core/ParseResults';\r\n\r\nclass AlwaysBeCasting extends CoreAlwaysBeCasting {\r\n  get downtimePercentage() {\r\n    return this.totalTimeWasted / this.owner.fightDuration;\r\n  }\r\n\r\n  get suggestionThresholds() {\r\n    return {\r\n      actual: this.downtimePercentage,\r\n      isGreaterThan: {\r\n        minor: 0.2,\r\n        average: 0.3,\r\n        major: 0.4,\r\n      },\r\n      style: ThresholdStyle.PERCENTAGE,\r\n    };\r\n  }\r\n\r\n  suggestions(when: When) {\r\n    when(this.suggestionThresholds).addSuggestion((suggest, actual, recommended) => suggest(<span>Your downtime can be improved. Try to Always Be Casting (ABC), try to reduce the delay between casting spells.</span>)\r\n          .icon('spell_mage_altertime')\r\n          .actual(i18n._(t('monk.windwalker.alwaysBeCasting.downtime')`${formatPercentage(actual)}% downtime`))\r\n          .recommended(`<${formatPercentage(recommended)}% is recommended`));\r\n  }\r\n\r\n  statisticOrder = STATISTIC_ORDER.CORE(10);\r\n}\r\n\r\nexport default AlwaysBeCasting;\r\n","import SPELLS from 'common/SPELLS';\r\n\r\nimport CoreAbilities from 'parser/core/modules/Abilities';\r\nimport { SpellbookAbility } from 'parser/core/modules/Ability';\r\n\r\nclass Abilities extends CoreAbilities {\r\n  spellbook(): SpellbookAbility[] {\r\n    const combatant = this.selectedCombatant;\r\n    // Windwalker GCD is 1 second by default and static in almost all cases, 750 is lowest recorded GCD\r\n    // Serenity's interaction with cooldowns is handled in the Serenity module\r\n    return [\r\n      {\r\n        spell: SPELLS.FISTS_OF_FURY_CAST,\r\n        category: Abilities.SPELL_CATEGORIES.ROTATIONAL,\r\n        cooldown: haste => 24 / (1 + haste),\r\n        gcd: {\r\n          static: 1000,\r\n        },\r\n        castEfficiency: {\r\n          suggestion: true,\r\n          recommendedEfficiency: 0.9,\r\n          extraSuggestion: 'Delaying the cast somewhat to line up with add spawns is acceptable, however.',\r\n        },\r\n      },\r\n      {\r\n        spell: SPELLS.RISING_SUN_KICK,\r\n        category: Abilities.SPELL_CATEGORIES.ROTATIONAL,\r\n        cooldown: haste => (10 / (1 + haste)),\r\n        gcd: {\r\n          static: 1000,\r\n        },\r\n        castEfficiency: {\r\n          suggestion: true,\r\n        },\r\n      },\r\n      {\r\n        spell: SPELLS.WHIRLING_DRAGON_PUNCH_TALENT,\r\n        category: Abilities.SPELL_CATEGORIES.ROTATIONAL,\r\n        cooldown: haste => 24 / (1 + haste),\r\n        gcd: {\r\n          static: 1000,\r\n        },\r\n        enabled: combatant.hasTalent(SPELLS.WHIRLING_DRAGON_PUNCH_TALENT.id),\r\n        castEfficiency: {\r\n          suggestion: true,\r\n          recommendedEfficiency: 0.85,\r\n          extraSuggestion: 'Delaying the cast somewhat to line up with add spawns is acceptable, however.',\r\n        },\r\n      },\r\n      {\r\n        spell: SPELLS.FIST_OF_THE_WHITE_TIGER_TALENT,\r\n        category: Abilities.SPELL_CATEGORIES.ROTATIONAL,\r\n        cooldown: 30,\r\n        gcd: {\r\n          static: 1000,\r\n        },\r\n        enabled: combatant.hasTalent(SPELLS.FIST_OF_THE_WHITE_TIGER_TALENT.id),\r\n        castEfficiency: {\r\n          suggestion: true,\r\n        },\r\n      },\r\n      {\r\n        spell: SPELLS.BLACKOUT_KICK,\r\n        category: Abilities.SPELL_CATEGORIES.ROTATIONAL,\r\n        gcd: {\r\n          static: 1000,\r\n        },\r\n      },\r\n      {\r\n        spell: SPELLS.TIGER_PALM,\r\n        category: Abilities.SPELL_CATEGORIES.ROTATIONAL,\r\n        gcd: {\r\n          static: 1000,\r\n        },\r\n      },\r\n      {\r\n        spell: SPELLS.EXPEL_HARM,\r\n        category: Abilities.SPELL_CATEGORIES.ROTATIONAL,\r\n        cooldown: 15,\r\n        gcd: {\r\n          static: 500,\r\n        },\r\n        castEfficiency: {\r\n          suggestion: true,\r\n        },\r\n      },\r\n      {\r\n        spell: SPELLS.CHI_WAVE_TALENT,\r\n        category: Abilities.SPELL_CATEGORIES.ROTATIONAL,\r\n        cooldown: 15,\r\n        gcd: {\r\n          base: 1000,\r\n          minimum: 750,\r\n        },\r\n        enabled: combatant.hasTalent(SPELLS.CHI_WAVE_TALENT.id),\r\n        castEfficiency: {\r\n          suggestion: true,\r\n          recommendedEfficiency: 0.65,\r\n        },\r\n      },\r\n      {\r\n        spell: SPELLS.SPINNING_CRANE_KICK,\r\n        category: Abilities.SPELL_CATEGORIES.ROTATIONAL,\r\n        gcd: {\r\n          static: 1000,\r\n        },\r\n      },\r\n      {\r\n        spell: SPELLS.CHI_BURST_TALENT,\r\n        category: Abilities.SPELL_CATEGORIES.ROTATIONAL,\r\n        cooldown: 30,\r\n        gcd: {\r\n          base: 1000,\r\n          minimum: 750,\r\n        },\r\n        enabled: combatant.hasTalent(SPELLS.CHI_BURST_TALENT.id),\r\n        castEfficiency: {\r\n          suggestion: true,\r\n        },\r\n      },\r\n      {\r\n        spell: SPELLS.RUSHING_JADE_WIND_TALENT_WINDWALKER,\r\n        category: Abilities.SPELL_CATEGORIES.ROTATIONAL_AOE,\r\n        cooldown: haste => 6 / (1 + haste),\r\n        gcd: {\r\n          static: 1000,\r\n        },\r\n        enabled: combatant.hasTalent(SPELLS.RUSHING_JADE_WIND_TALENT_WINDWALKER.id),\r\n      },\r\n      // cooldowns\r\n      {\r\n        spell: SPELLS.TOUCH_OF_KARMA_CAST,\r\n        buffSpellId: SPELLS.TOUCH_OF_KARMA_CAST.id,\r\n        category: Abilities.SPELL_CATEGORIES.SEMI_DEFENSIVE,\r\n        cooldown: 90,\r\n        gcd: null,\r\n        castEfficiency: {\r\n          suggestion: true,\r\n          recommendedEfficiency: 0.6,\r\n          extraSuggestion: \"Touch of Karma is typically used offensively as often as possible, but use changes a lot varying on the encounter\",\r\n        },\r\n      },\r\n      {\r\n        spell: SPELLS.SERENITY_TALENT,\r\n        category: Abilities.SPELL_CATEGORIES.COOLDOWNS,\r\n        cooldown: 90,\r\n        gcd: null,\r\n        enabled: combatant.hasTalent(SPELLS.SERENITY_TALENT.id),\r\n        castEfficiency: {\r\n          suggestion: true,\r\n          recommendedEfficiency: 0.95,\r\n        },\r\n      },\r\n      {\r\n        spell: SPELLS.STORM_EARTH_AND_FIRE_CAST,\r\n        category: Abilities.SPELL_CATEGORIES.COOLDOWNS,\r\n        cooldown: 90,\r\n        gcd: null,\r\n        enabled: !combatant.hasTalent(SPELLS.SERENITY_TALENT.id),\r\n        charges: 2,\r\n        castEfficiency: {\r\n          suggestion: true,\r\n          recommendedEfficiency: 0.95,\r\n        },\r\n      },\r\n      {\r\n        spell: SPELLS.INVOKE_XUEN_THE_WHITE_TIGER,\r\n        category: Abilities.SPELL_CATEGORIES.COOLDOWNS,\r\n        cooldown: 120,\r\n        gcd: {\r\n          base: 1000,\r\n          minimum: 750,\r\n        },\r\n        castEfficiency: {\r\n          suggestion: true,\r\n          recommendedEfficiency: 0.95,\r\n        },\r\n      },\r\n      {\r\n        spell: SPELLS.ENERGIZING_ELIXIR_TALENT,\r\n        category: Abilities.SPELL_CATEGORIES.COOLDOWNS,\r\n        cooldown: 60,\r\n        gcd: null,\r\n        enabled: combatant.hasTalent(SPELLS.ENERGIZING_ELIXIR_TALENT.id),\r\n      },\r\n      // Utility\r\n      {\r\n        spell: SPELLS.RING_OF_PEACE_TALENT,\r\n        category: Abilities.SPELL_CATEGORIES.UTILITY,\r\n        gcd: {\r\n          base: 1000,\r\n          minimum: 750,\r\n        },\r\n      },\r\n      {\r\n        spell: SPELLS.LEG_SWEEP,\r\n        category: Abilities.SPELL_CATEGORIES.UTILITY,\r\n        gcd: {\r\n          static: 1000,\r\n        },\r\n      },\r\n      {\r\n        spell: SPELLS.PARALYSIS,\r\n        category: Abilities.SPELL_CATEGORIES.UTILITY,\r\n        gcd: {\r\n          static: 1000,\r\n        },\r\n      },\r\n      {\r\n        spell: SPELLS.DISABLE,\r\n        category: Abilities.SPELL_CATEGORIES.UTILITY,\r\n        gcd: {\r\n          static: 1000,\r\n        },\r\n      },\r\n      {\r\n        spell: SPELLS.ROLL,\r\n        category: Abilities.SPELL_CATEGORIES.UTILITY,\r\n        cooldown: combatant.hasTalent(SPELLS.CELERITY_TALENT.id) ? 15 : 20,\r\n        gcd: null,\r\n        charges: combatant.hasTalent(SPELLS.CELERITY_TALENT.id) ? 3 : 2,\r\n        enabled: !combatant.hasTalent(SPELLS.CHI_TORPEDO_TALENT.id),\r\n      },\r\n      {\r\n        spell: SPELLS.CHI_TORPEDO_TALENT,\r\n        category: Abilities.SPELL_CATEGORIES.UTILITY,\r\n        cooldown: 20,\r\n        gcd: null,\r\n        charges: 2,\r\n        enabled: combatant.hasTalent(SPELLS.CHI_TORPEDO_TALENT.id),\r\n      },\r\n      {\r\n        spell: SPELLS.FLYING_SERPENT_KICK,\r\n        category: Abilities.SPELL_CATEGORIES.UTILITY,\r\n        cooldown: 25,\r\n        gcd: {\r\n          static: 1000,\r\n        },\r\n      },\r\n      {\r\n        spell: SPELLS.TIGERS_LUST_TALENT,\r\n        category: Abilities.SPELL_CATEGORIES.UTILITY,\r\n        cooldown: 30,\r\n        gcd: {\r\n          static: 1000,\r\n        },\r\n        enabled: combatant.hasTalent(SPELLS.TIGERS_LUST_TALENT.id),\r\n      },\r\n      {\r\n        spell: SPELLS.TRANSCENDENCE,\r\n        category: Abilities.SPELL_CATEGORIES.UTILITY,\r\n        gcd: {\r\n          static: 1000,\r\n        },\r\n      },\r\n      {\r\n        spell: SPELLS.TRANSCENDENCE_TRANSFER,\r\n        category: Abilities.SPELL_CATEGORIES.UTILITY,\r\n        cooldown: 45,\r\n        gcd: {\r\n          base: 1000,\r\n          minimum: 750,\r\n        },\r\n      },\r\n      {\r\n        spell: SPELLS.VIVIFY,\r\n        category: Abilities.SPELL_CATEGORIES.UTILITY,\r\n        gcd: {\r\n          base: 1500,\r\n          minimum: 750,\r\n        },\r\n      },\r\n      {\r\n        spell: SPELLS.DETOX_ENERGY,\r\n        category: Abilities.SPELL_CATEGORIES.UTILITY,\r\n        gcd: {\r\n          base: 1000,\r\n          minimum: 750,\r\n        },\r\n      },\r\n      {\r\n        spell: SPELLS.SPEAR_HAND_STRIKE,\r\n        category: Abilities.SPELL_CATEGORIES.UTILITY,\r\n        gcd: null,\r\n      },\r\n      {\r\n        spell: SPELLS.PROVOKE,\r\n        category: Abilities.SPELL_CATEGORIES.UTILITY,\r\n        gcd: null,\r\n      },\r\n      {\r\n        spell: SPELLS.CRACKLING_JADE_LIGHTNING,\r\n        category: Abilities.SPELL_CATEGORIES.UTILITY,\r\n        gcd: {\r\n          base: 1000,\r\n          minimum: 750,\r\n        },\r\n      },\r\n      {\r\n        spell: SPELLS.STORM_EARTH_AND_FIRE_FIXATE,\r\n        category: Abilities.SPELL_CATEGORIES.UTILITY,\r\n        gcd: null,\r\n      },\r\n      // Defensives\r\n      {\r\n        spell: SPELLS.FORTIFYING_BREW,\r\n        buffSpellId: SPELLS.FORTIFYING_BREW.id,\r\n        category: Abilities.SPELL_CATEGORIES.DEFENSIVE,\r\n        cooldown: 120,\r\n        gcd: null,\r\n      },\r\n      {\r\n        spell: SPELLS.DIFFUSE_MAGIC_TALENT,\r\n        buffSpellId: SPELLS.DIFFUSE_MAGIC_TALENT.id,\r\n        category: Abilities.SPELL_CATEGORIES.DEFENSIVE,\r\n        cooldown: 90,\r\n        gcd: null,\r\n        enabled: combatant.hasTalent(SPELLS.DIFFUSE_MAGIC_TALENT.id),\r\n      },\r\n      {\r\n        spell: SPELLS.DAMPEN_HARM_TALENT,\r\n        buffSpellId: SPELLS.DAMPEN_HARM_TALENT.id,\r\n        category: Abilities.SPELL_CATEGORIES.DEFENSIVE,\r\n        cooldown: 90,\r\n        gcd: null,\r\n        enabled: combatant.hasTalent(SPELLS.DAMPEN_HARM_TALENT.id),\r\n      },\r\n    ];\r\n  }\r\n}\r\n\r\nexport default Abilities;\r\n","import SPELLS from 'common/SPELLS';\r\nimport BLOODLUST_BUFFS from 'game/BLOODLUST_BUFFS';\r\nimport CoreBuffs from 'parser/core/modules/Buffs';\r\n\r\nclass Buffs extends CoreBuffs {\r\n  buffs() {\r\n    return [\r\n      {\r\n        spellId: SPELLS.STORM_EARTH_AND_FIRE_CAST.id,\r\n        timelineHighlight: true,\r\n      },\r\n      {\r\n        spellId: SPELLS.SERENITY_TALENT.id,\r\n        timelineHighlight: true,\r\n      },\r\n      {\r\n        spellId: SPELLS.TOUCH_OF_KARMA_CAST.id,\r\n        timelineHighlight: true,\r\n      },\r\n      {\r\n        spellId: SPELLS.DANCE_OF_CHIJI_BUFF.id,\r\n        timelineHighlight: true,\r\n      },\r\n      {\r\n        spellId: SPELLS.COMBO_BREAKER_BUFF.id,\r\n        timelineHighlight: true,\r\n      },\r\n      {\r\n        spellId: Object.keys(BLOODLUST_BUFFS).map(item => Number(item)),\r\n        timelineHighlight: true,\r\n      },\r\n    ];\r\n  }\r\n}\r\n\r\nexport default Buffs;\r\n","import SPELLS from 'common/SPELLS';\r\n\r\nimport CoreCooldownThroughputTracker, { BUILT_IN_SUMMARY_TYPES } from 'parser/shared/modules/CooldownThroughputTracker';\r\n\r\n\r\nclass CooldownThroughputTracker extends CoreCooldownThroughputTracker {\r\n  static cooldownSpells = [\r\n    ...CoreCooldownThroughputTracker.cooldownSpells,\r\n    {\r\n      spell: SPELLS.SERENITY_TALENT,\r\n      summary: [\r\n        BUILT_IN_SUMMARY_TYPES.DAMAGE,\r\n      ],\r\n    },\r\n  ];\r\n\r\n  static castCooldowns = [\r\n    ...CoreCooldownThroughputTracker.castCooldowns,\r\n    {\r\n      spell: SPELLS.STORM_EARTH_AND_FIRE_CAST,\r\n      summary: [\r\n        BUILT_IN_SUMMARY_TYPES.DAMAGE,\r\n      ],\r\n    },\r\n    {\r\n      spell: SPELLS.INVOKE_XUEN_THE_WHITE_TIGER,\r\n      summary: [\r\n        BUILT_IN_SUMMARY_TYPES.DAMAGE,\r\n      ],\r\n    },\r\n  ];\r\n}\r\n\r\nexport default CooldownThroughputTracker;\r\n","import React from 'react';\r\nimport SPELLS from 'common/SPELLS';\r\nimport SpellLink from 'common/SpellLink';\r\nimport { formatPercentage } from 'common/format';\r\nimport Statistic from 'interface/statistics/Statistic';\r\nimport AbilityTracker from 'parser/shared/modules/AbilityTracker';\r\nimport Analyzer, { Options, SELECTED_PLAYER } from 'parser/core/Analyzer';\r\nimport { STATISTIC_ORDER } from 'interface/others/StatisticBox';\r\nimport BoringSpellValueText from 'interface/statistics/components/BoringSpellValueText/index';\r\nimport Events, { ApplyBuffEvent, CastEvent, RefreshBuffEvent } from 'parser/core/Events';\r\nimport { i18n } from '@lingui/core';\r\nimport { t } from '@lingui/macro';\r\nimport { ThresholdStyle, When } from 'parser/core/ParseResults';\r\n\r\nconst COMBO_BREAKER_DURATION = 15000;\r\nconst COMBO_BREAKER_PROC_CHANCE = 0.08;\r\nconst debug = false;\r\n\r\nclass ComboBreaker extends Analyzer {\r\n  static dependencies = {\r\n    abilityTracker: AbilityTracker,\r\n  };\r\n\r\n  protected abilityTracker!: AbilityTracker;\r\n\r\n  CBProcsTotal = 0;\r\n  lastCBProcTime: number | null = null;\r\n  consumedCBProc = 0;\r\n  overwrittenCBProc = 0;\r\n\r\n  constructor(options: Options) {\r\n    super(options);\r\n    this.addEventListener(Events.applybuff.by(SELECTED_PLAYER).spell(SPELLS.COMBO_BREAKER_BUFF), this.onApplyBuff);\r\n    this.addEventListener(Events.refreshbuff.by(SELECTED_PLAYER).spell(SPELLS.COMBO_BREAKER_BUFF), this.onRefreshBuff);\r\n    this.addEventListener(Events.cast.by(SELECTED_PLAYER).spell(SPELLS.BLACKOUT_KICK), this.onCast);\r\n  }\r\n\r\n  onApplyBuff(event: ApplyBuffEvent) {\r\n    this.lastCBProcTime = event.timestamp;\r\n    debug && console.log('CB Proc Applied');\r\n    this.CBProcsTotal += 1;\r\n  }\r\n\r\n  onRefreshBuff(event: RefreshBuffEvent) {\r\n    this.lastCBProcTime = event.timestamp;\r\n    debug && console.log('CB Proc Overwritten');\r\n    this.CBProcsTotal += 1;\r\n    this.overwrittenCBProc += 1;\r\n  }\r\n\r\n  onCast(event: CastEvent) {\r\n    if (this.lastCBProcTime === null) {\r\n      return;\r\n    }\r\n    if (this.lastCBProcTime !== event.timestamp) {\r\n      const cbTimeframe = this.lastCBProcTime + COMBO_BREAKER_DURATION;\r\n      if (event.timestamp <= cbTimeframe) {\r\n        this.consumedCBProc += 1;\r\n        debug && console.log(`CB Proc Consumed / Timestamp: ${event.timestamp}`);\r\n        this.lastCBProcTime = null;\r\n      }\r\n    }\r\n  }\r\n\r\n  get usedCBProcs() {\r\n    return this.consumedCBProc / this.CBProcsTotal;\r\n  }\r\n\r\n  get suggestionThresholds() {\r\n    return {\r\n      actual: this.usedCBProcs,\r\n      isLessThan: {\r\n        minor: 0.9,\r\n        average: 0.8,\r\n        major: 0.7,\r\n      },\r\n      style: ThresholdStyle.PERCENTAGE,\r\n    };\r\n  }\r\n\r\n  suggestions(when: When) {\r\n    when(this.suggestionThresholds).addSuggestion((suggest, actual, recommended) => suggest(<span>Your <SpellLink id={SPELLS.COMBO_BREAKER_BUFF.id} /> procs should be used before you tiger palm again so they are not overwritten. While some will be overwritten due to higher priority of getting Chi for spenders, wasting <SpellLink id={SPELLS.COMBO_BREAKER_BUFF.id} /> procs is not optimal.</span>)\r\n      .icon(SPELLS.COMBO_BREAKER_BUFF.icon)\r\n      .actual(i18n._(t('monk.windwalker.suggestions.comboBreaker.procsUsed')`${formatPercentage(actual)}% used Combo Breaker procs`))\r\n      .recommended(`>${formatPercentage(recommended)}% used Combo Breaker Procs is recommended`));\r\n  }\r\n\r\n  statistic() {\r\n    const averageCBProcs = this.abilityTracker.getAbility(SPELLS.TIGER_PALM.id).casts * COMBO_BREAKER_PROC_CHANCE;\r\n    return (\r\n      <Statistic\r\n        position={STATISTIC_ORDER.CORE(6)}\r\n        size=\"flexible\"\r\n        tooltip={<>You got a total of <strong>{this.CBProcsTotal} Combo Breaker procs</strong> and <strong>used {this.consumedCBProc}</strong> of them. The average expected number of procs from your Tiger Palms this fight is <strong>{averageCBProcs.toFixed(2)}</strong>, and you got <strong>{this.CBProcsTotal}</strong>.</>}\r\n      >\r\n        <BoringSpellValueText spell={SPELLS.COMBO_BREAKER_BUFF}>\r\n          {formatPercentage(this.usedCBProcs, 0)}% <small>Proc utilization</small>\r\n        </BoringSpellValueText>\r\n      </Statistic>\r\n    );\r\n  }\r\n}\r\n\r\nexport default ComboBreaker;\r\n","import React from 'react';\r\nimport SPELLS from 'common/SPELLS';\r\nimport SpellLink from 'common/SpellLink';\r\nimport Analyzer, { Options, SELECTED_PLAYER } from 'parser/core/Analyzer';\r\nimport { STATISTIC_ORDER } from 'interface/others/StatisticBox';\r\nimport Statistic from 'interface/statistics/Statistic';\r\nimport BoringSpellValueText from 'interface/statistics/components/BoringSpellValueText/index';\r\nimport Events, { DamageEvent } from 'parser/core/Events';\r\nimport AbilityTracker from 'parser/shared/modules/AbilityTracker';\r\nimport { i18n } from '@lingui/core';\r\nimport { t } from '@lingui/macro';\r\nimport { ThresholdStyle, When } from 'parser/core/ParseResults';\r\n\r\n// Inspired by the penance bolt counter module from Discipline Priest\r\n\r\nconst FISTS_OF_FURY_MINIMUM_TICK_TIME = 100; // This is to check that additional ticks aren't just hitting secondary targets\r\n\r\nclass FistsofFury extends Analyzer {\r\n  static dependencies = {\r\n    abilityTracker: AbilityTracker,\r\n  };\r\n  previousTickTimestamp = 0;\r\n  fistsTicks = 0;\r\n\r\n  protected abilityTracker!: AbilityTracker;\r\n\r\n  constructor(options: Options) {\r\n    super(options);\r\n    this.addEventListener(Events.damage.by(SELECTED_PLAYER).spell(SPELLS.FISTS_OF_FURY_DAMAGE), this.onFistsDamage);\r\n  }\r\n\r\n  isNewFistsTick(timestamp: number) {\r\n    return !this.previousTickTimestamp || (timestamp - this.previousTickTimestamp) > FISTS_OF_FURY_MINIMUM_TICK_TIME;\r\n  }\r\n\r\n  onFistsDamage(event: DamageEvent) {\r\n    if (!this.isNewFistsTick(event.timestamp)) {\r\n      return;\r\n    }\r\n    this.fistsTicks += 1;\r\n    this.previousTickTimestamp = event.timestamp;\r\n  }\r\n\r\n  get averageTicks() {\r\n    return this.fistsTicks / this.casts;\r\n  }\r\n\r\n  get casts() {\r\n    return this.abilityTracker.getAbility(SPELLS.FISTS_OF_FURY_CAST.id).casts;\r\n  }\r\n\r\n  get suggestionThresholds() {\r\n    return {\r\n      actual: this.averageTicks,\r\n      isLessThan: {\r\n        minor: 5,\r\n        average: 4.75,\r\n        major: 4.5,\r\n      },\r\n      style: ThresholdStyle.DECIMAL,\r\n    };\r\n  }\r\n\r\n  suggestions(when: When) {\r\n    when(this.suggestionThresholds).addSuggestion((suggest, actual, recommended) => suggest(<span> You are cancelling your <SpellLink id={SPELLS.FISTS_OF_FURY_CAST.id} /> casts early and losing ticks </span>)\r\n      .icon(SPELLS.FISTS_OF_FURY_CAST.icon).actual(i18n._(t('monk.windwalker.suggestions.fistOfFury.avgTicksPerCast')`${actual.toFixed(2)} average ticks on each Fists of Fury cast`))\r\n      .recommended(`Aim to get ${recommended} ticks with each Fists of Fury cast.`));\r\n  }\r\n\r\n  statistic() {\r\n    return (\r\n      <Statistic\r\n        position={STATISTIC_ORDER.CORE(4)}\r\n        size=\"flexible\"\r\n        tooltip=\"Fists of Fury ticks 5 times over the duration of the channel\"\r\n      >\r\n        <BoringSpellValueText spell={SPELLS.FISTS_OF_FURY_CAST}>\r\n          {this.averageTicks.toFixed(2)} <small>Average ticks per cast</small>\r\n        </BoringSpellValueText>\r\n      </Statistic>\r\n    );\r\n  }\r\n}\r\n\r\nexport default FistsofFury;\r\n","import React from 'react';\r\nimport SPELLS from 'common/SPELLS';\r\nimport SpellLink from 'common/SpellLink';\r\nimport { formatPercentage } from 'common/format';\r\nimport Statistic from 'interface/statistics/Statistic';\r\nimport Analyzer, { Options, SELECTED_PLAYER } from 'parser/core/Analyzer';\r\nimport HealingDone from 'parser/shared/modules/throughput/HealingDone';\r\nimport { STATISTIC_ORDER } from 'interface/others/StatisticBox';\r\nimport BoringSpellValueText from 'interface/statistics/components/BoringSpellValueText/index';\r\nimport Events, { CastEvent } from 'parser/core/Events';\r\nimport { i18n } from '@lingui/core';\r\nimport { t } from '@lingui/macro';\r\nimport { ThresholdStyle, When } from 'parser/core/ParseResults';\r\n\r\nconst TOUCH_OF_KARMA_HP_SCALING = 0.5;\r\n\r\nclass TouchOfKarma extends Analyzer {\r\n  static dependencies = {\r\n    healingDone: HealingDone,\r\n  };\r\n\r\n  protected healingDone!: HealingDone;\r\n\r\n  totalPossibleAbsorb = 0;\r\n\r\n  constructor(options: Options) {\r\n    super(options);\r\n    this.addEventListener(Events.cast.by(SELECTED_PLAYER).spell(SPELLS.TOUCH_OF_KARMA_CAST), this.onCast);\r\n  }\r\n\r\n  onCast(event: CastEvent) {\r\n    this.totalPossibleAbsorb += (event.maxHitPoints || 0) * TOUCH_OF_KARMA_HP_SCALING;\r\n  }\r\n\r\n  get absorbUsed() {\r\n    return this.healingDone.byAbility(SPELLS.TOUCH_OF_KARMA_CAST.id).effective / this.totalPossibleAbsorb;\r\n  }\r\n\r\n  get suggestionThresholds() {\r\n    return {\r\n      actual: this.absorbUsed,\r\n      isLessThan: {\r\n        minor: 0.8,\r\n        average: 0.65,\r\n        major: 0.5,\r\n      },\r\n      style: ThresholdStyle.PERCENTAGE,\r\n    };\r\n  }\r\n\r\n  suggestions(when: When) {\r\n    when(this.suggestionThresholds).addSuggestion((suggest, actual, recommended) => suggest(<> You consumed a low amount of your total <SpellLink id={SPELLS.TOUCH_OF_KARMA_CAST.id} /> absorb. It's best used when you can take enough damage to consume most of the absorb. Getting full absorb usage shouldn't be expected on lower difficulty encounters </>)\r\n      .icon(SPELLS.TOUCH_OF_KARMA_CAST.icon)\r\n      .actual(i18n._(t('monk.windwalker.suggestions.touchOfKarma.absorbUsed')`${formatPercentage(actual)}% Touch of Karma absorb used`))\r\n      .recommended(`>${formatPercentage(recommended)}% is recommended`));\r\n  }\r\n\r\n  statistic() {\r\n    return (\r\n      <Statistic\r\n        position={STATISTIC_ORDER.OPTIONAL(2)}\r\n        size=\"flexible\"\r\n        tooltip=\"This does not account for possible absorbs from missed Touch of Karma casts\"\r\n      >\r\n        <BoringSpellValueText spell={SPELLS.TOUCH_OF_KARMA_CAST}>\r\n          {formatPercentage(this.absorbUsed, 0)}% <small>Absorb used</small>\r\n        </BoringSpellValueText>\r\n      </Statistic>\r\n    );\r\n  }\r\n}\r\n\r\nexport default TouchOfKarma;\r\n","import SPELLS from 'common/SPELLS';\r\n\r\n// Based on SpellData for Hit Combo and Serenity\r\nexport const ABILITIES_AFFECTED_BY_DAMAGE_INCREASES = [\r\n  SPELLS.MELEE,\r\n  SPELLS.TIGER_PALM,\r\n  SPELLS.BLACKOUT_KICK,\r\n  SPELLS.FISTS_OF_FURY_CAST,\r\n  SPELLS.FISTS_OF_FURY_DAMAGE,\r\n  SPELLS.RISING_SUN_KICK,\r\n  SPELLS.RISING_SUN_KICK_SECOND,\r\n  SPELLS.SPINNING_CRANE_KICK,\r\n  SPELLS.FLYING_SERPENT_KICK,\r\n  SPELLS.CRACKLING_JADE_LIGHTNING,\r\n  // talents\r\n  SPELLS.CHI_WAVE_TALENT,\r\n  SPELLS.FIST_OF_THE_WHITE_TIGER_TALENT,\r\n  SPELLS.WHIRLING_DRAGON_PUNCH_TALENT,\r\n  SPELLS.RUSHING_JADE_WIND_TALENT_WINDWALKER,\r\n  SPELLS.CHI_BURST_TALENT,\r\n  SPELLS.EYE_OF_THE_TIGER_TALENT,\r\n];\r\n\r\nexport const ABILITIES_AFFECTED_BY_MASTERY = [\r\n  SPELLS.TIGER_PALM,\r\n  SPELLS.BLACKOUT_KICK,\r\n  SPELLS.FISTS_OF_FURY_CAST,\r\n  SPELLS.RISING_SUN_KICK,\r\n  SPELLS.CHI_WAVE_TALENT,\r\n  SPELLS.FIST_OF_THE_WHITE_TIGER_TALENT,\r\n  SPELLS.SPINNING_CRANE_KICK,\r\n  SPELLS.FLYING_SERPENT_KICK,\r\n  SPELLS.CRACKLING_JADE_LIGHTNING,\r\n  SPELLS.WHIRLING_DRAGON_PUNCH_TALENT,\r\n  SPELLS.TOUCH_OF_DEATH,\r\n  SPELLS.CHI_BURST_TALENT,\r\n  SPELLS.RUSHING_JADE_WIND_TALENT_WINDWALKER,\r\n  SPELLS.EXPEL_HARM,\r\n];\r\n\r\nexport const CHI_SPENDERS = [\r\n  SPELLS.BLACKOUT_KICK.id,\r\n  SPELLS.RISING_SUN_KICK.id,\r\n  SPELLS.FISTS_OF_FURY_CAST.id,\r\n  SPELLS.SPINNING_CRANE_KICK.id,\r\n  SPELLS.RUSHING_JADE_WIND_TALENT_WINDWALKER.id,\r\n];\r\n","import React from 'react';\r\nimport SPELLS from 'common/SPELLS';\r\nimport SpellIcon from 'common/SpellIcon';\r\nimport SpellLink from 'common/SpellLink';\r\nimport { STATISTIC_ORDER } from 'interface/others/StatisticBox';\r\nimport { formatDuration, formatNumber } from 'common/format';\r\nimport Analyzer, { Options, SELECTED_PLAYER } from 'parser/core/Analyzer';\r\nimport Statistic from 'interface/statistics/Statistic';\r\nimport BoringSpellValueText from 'interface/statistics/components/BoringSpellValueText/index';\r\nimport Events, { CastEvent } from 'parser/core/Events';\r\n\r\nimport { i18n } from '@lingui/core';\r\nimport { t } from '@lingui/macro';\r\n\r\nimport { ThresholdStyle, When } from 'parser/core/ParseResults';\r\n\r\nimport { ABILITIES_AFFECTED_BY_MASTERY } from '../../constants';\r\n\r\ninterface MasteryCast {\r\n  ability: number;\r\n  timestamp: number;\r\n}\r\n\r\nconst HIT_COMBO_STRING = ' and dropping the Hit Combo damage buff';\r\n\r\nclass ComboStrikes extends Analyzer {\r\n  _lastSpellUsed: number | null = null;\r\n  _lastThreeSpellsUsed: MasteryCast[] = [];\r\n  masteryDropSpellSequence: MasteryCast[][] = [];\r\n  hasHitCombo = false;\r\n\r\n  constructor(options: Options) {\r\n    super(options);\r\n    this.hasHitCombo = this.selectedCombatant.hasTalent(SPELLS.HIT_COMBO_TALENT.id);\r\n    this.addEventListener(Events.cast.by(SELECTED_PLAYER).spell(ABILITIES_AFFECTED_BY_MASTERY), this.onMasteryCast);\r\n  }\r\n\r\n  onMasteryCast(event: CastEvent) {\r\n    const spellId = event.ability.guid;\r\n    const eventTimestamp = event.timestamp;\r\n    // Track Details on the last 3 spells used - Need to populate up to 3 first, then begin to modify the array.\r\n    if (this._lastThreeSpellsUsed.length < 3) {\r\n      this._lastThreeSpellsUsed.push({\r\n        ability: spellId,\r\n        timestamp: eventTimestamp,\r\n      });\r\n    } else {\r\n      this._lastThreeSpellsUsed = this._lastThreeSpellsUsed.slice(1);\r\n      this._lastThreeSpellsUsed.push({\r\n        ability: spellId,\r\n        timestamp: eventTimestamp,\r\n      });\r\n    }\r\n\r\n    if (this._lastSpellUsed === spellId) {\r\n      this.masteryDropSpellSequence.push(this._lastThreeSpellsUsed);\r\n    }\r\n    this._lastSpellUsed = spellId;\r\n  }\r\n\r\n  get masteryDropEvents() {\r\n    return this.masteryDropSpellSequence.length;\r\n  }\r\n\r\n  get masteryDropsPerMinute() {\r\n    return (this.masteryDropEvents / this.owner.fightDuration) * 1000 * 60;\r\n  }\r\n\r\n  get suggestionThresholds() {\r\n    const hitComboMultiplier = this.hasHitCombo ? 1 : 2;\r\n    return {\r\n      actual: this.masteryDropsPerMinute,\r\n      isGreaterThan: {\r\n        minor: 0,\r\n        average: 0.5 * hitComboMultiplier,\r\n        major: Number(hitComboMultiplier),\r\n      },\r\n      style: ThresholdStyle.NUMBER,\r\n    };\r\n  }\r\n\r\n  suggestions(when: When) {\r\n    when(this.suggestionThresholds).addSuggestion((suggest, actual, recommended) => suggest(<span>You ignored your <SpellLink id={SPELLS.COMBO_STRIKES.id} /> buff by casting the same spell twice in a row, missing out on the damage increase from your mastery{HIT_COMBO_STRING}.</span>)\r\n      .icon(SPELLS.COMBO_STRIKES.icon)\r\n      .actual(i18n._(t('monk.windwalker.comboStrikes.masteryBreaksPerMinute')`${actual.toFixed(2)} mastery breaks per minute.`))\r\n      .recommended(`mastery should be broken ${recommended} times`));\r\n  }\r\n\r\n  statistic() {\r\n    return (\r\n      <Statistic\r\n        position={STATISTIC_ORDER.CORE(2)}\r\n        size=\"flexible\"\r\n        tooltip={`This is the number of times you incorrectly cast the same spell twice in a row, missing out on the damage increase from your mastery${HIT_COMBO_STRING}.`}\r\n        dropdown={(\r\n          // only add a dropdown when there are any mastery breaks to show\r\n          this.masteryDropEvents > 0 ? (\r\n            <>\r\n              <div>\r\n                <span style={{ padding: '1.3em' }}>Spell sequence when mastery dropped.</span>\r\n              </div>\r\n              <table className=\"table table-condensed\">\r\n                <thead>\r\n                  <tr>\r\n                    <th>Timestamp</th>\r\n                    <th>1</th>\r\n                    <th>2</th>\r\n                    <th>3</th>\r\n                  </tr>\r\n                </thead>\r\n                <tbody>\r\n                  {\r\n                    this.masteryDropSpellSequence\r\n                      .map((item, index) => (\r\n                        <tr key={index}>\r\n                          <th scope=\"row\">{formatDuration((item[0].timestamp - this.owner.fight.start_time) / 1000)}</th>\r\n                          <td><SpellIcon id={item[0].ability} style={{ height: '2.4em' }} /></td>\r\n                          <td><SpellIcon id={item[1].ability} style={{ height: '2.4em' }} /></td>\r\n                          {item[2] && item[2].ability && (\r\n                            <td><SpellIcon id={item[2].ability} style={{ height: '2.4em' }} /></td>\r\n                          )}\r\n                        </tr>\r\n                      ))\r\n                  }\r\n                </tbody>\r\n              </table>\r\n            </>\r\n          ) : null\r\n        )}\r\n      >\r\n        <BoringSpellValueText spell={SPELLS.COMBO_STRIKES}>\r\n          {formatNumber(this.masteryDropEvents)} <small>Mastery benefit mistakes</small>\r\n        </BoringSpellValueText>\r\n      </Statistic>\r\n    );\r\n  }\r\n}\r\n\r\nexport default ComboStrikes;\r\n","import React from 'react';\r\nimport SPELLS from 'common/SPELLS';\r\nimport SpellIcon from 'common/SpellIcon';\r\nimport { STATISTIC_ORDER } from 'interface/others/StatisticBox';\r\nimport Analyzer, { Options, SELECTED_PLAYER } from 'parser/core/Analyzer';\r\nimport SpellUsable from 'parser/shared/modules/SpellUsable';\r\nimport Statistic from 'interface/statistics/Statistic';\r\nimport BoringSpellValueText from 'interface/statistics/components/BoringSpellValueText/index';\r\nimport Events, { CastEvent } from 'parser/core/Events';\r\nimport { i18n } from '@lingui/core';\r\nimport { t } from '@lingui/macro';\r\nimport { ThresholdStyle, When } from 'parser/core/ParseResults';\r\n\r\n/**\r\n *  Inspired by filler modules in Holy Paladin Analyzer\r\n */\r\n\r\nconst COOLDOWN_REDUCTION_MS = 1000;\r\n\r\nclass BlackoutKick extends Analyzer {\r\n  static dependencies = {\r\n    spellUsable: SpellUsable,\r\n  };\r\n\r\n  protected spellUsable!: SpellUsable;\r\n\r\n  IMPORTANT_SPELLS = [\r\n    SPELLS.RISING_SUN_KICK.id,\r\n    SPELLS.FISTS_OF_FURY_CAST.id,\r\n  ];\r\n  effectiveRisingSunKickReductionMs = 0;\r\n  wastedRisingSunKickReductionMs = 0;\r\n  effectiveFistsOfFuryReductionMs = 0;\r\n  wastedFistsOfFuryReductionMs = 0;\r\n\r\n  constructor(options: Options) {\r\n    super(options);\r\n\r\n    if (this.selectedCombatant.hasTalent(SPELLS.WHIRLING_DRAGON_PUNCH_TALENT.id)) {\r\n      this.IMPORTANT_SPELLS.push(SPELLS.WHIRLING_DRAGON_PUNCH_TALENT.id);\r\n    }\r\n    this.addEventListener(Events.cast.by(SELECTED_PLAYER).spell(SPELLS.BLACKOUT_KICK), this.onCast);\r\n  }\r\n\r\n  onCast(event: CastEvent) {\r\n    const hasImportantCastsAvailable = this.IMPORTANT_SPELLS.some(spellId => this.spellUsable.isAvailable(spellId));\r\n    const currentCooldownReductionMS = (this.selectedCombatant.hasBuff(SPELLS.SERENITY_TALENT.id) ? 0.5 : 1) * COOLDOWN_REDUCTION_MS;\r\n    if (hasImportantCastsAvailable) {\r\n      event.meta = event.meta || {};\r\n      event.meta.isInefficientCast = true;\r\n      event.meta.inefficientCastReason = 'You cast this Blackout Kick while more important spells were available';\r\n    }\r\n\r\n    if (!this.spellUsable.isOnCooldown(SPELLS.RISING_SUN_KICK.id)) {\r\n      this.wastedRisingSunKickReductionMs += currentCooldownReductionMS;\r\n    } else {\r\n      const reductionMs = this.spellUsable.reduceCooldown(SPELLS.RISING_SUN_KICK.id, currentCooldownReductionMS);\r\n      this.effectiveRisingSunKickReductionMs += reductionMs;\r\n      this.wastedRisingSunKickReductionMs += currentCooldownReductionMS - reductionMs;\r\n    }\r\n    if (!this.spellUsable.isOnCooldown(SPELLS.FISTS_OF_FURY_CAST.id)) {\r\n      this.wastedFistsOfFuryReductionMs += currentCooldownReductionMS;\r\n    } else {\r\n      const reductionMs = this.spellUsable.reduceCooldown(SPELLS.FISTS_OF_FURY_CAST.id, currentCooldownReductionMS);\r\n      this.effectiveFistsOfFuryReductionMs += reductionMs;\r\n      this.wastedFistsOfFuryReductionMs += currentCooldownReductionMS - reductionMs;\r\n    }\r\n  }\r\n\r\n  get totalWastedReductionPerMinute() {\r\n    return (this.wastedFistsOfFuryReductionMs + this.wastedRisingSunKickReductionMs) / (this.owner.fightDuration) * 60;\r\n  }\r\n\r\n  get suggestionThresholds() {\r\n    return {\r\n      actual: this.totalWastedReductionPerMinute,\r\n      isGreaterThan: {\r\n        minor: 0,\r\n        average: 2,\r\n        major: 4,\r\n      },\r\n      style: ThresholdStyle.DECIMAL,\r\n    };\r\n  }\r\n\r\n  suggestions(when: When) {\r\n    when(this.suggestionThresholds).addSuggestion((suggest, actual, recommended) => suggest('You are wasting cooldown reduction by casting Blackout Kick while having important casts available')\r\n      .icon(SPELLS.BLACKOUT_KICK.icon)\r\n      .actual(i18n._(t('monk.windwalker.suggestions.blackoutKick.cdrWasted')`${actual.toFixed(2)} seconds of wasted cooldown reduction per minute`))\r\n      .recommended(`${recommended} is recommended`));\r\n  }\r\n\r\n  statistic() {\r\n    return (\r\n      <Statistic\r\n        position={STATISTIC_ORDER.CORE(3)}\r\n        size=\"flexible\"\r\n      >\r\n        <BoringSpellValueText spell={SPELLS.BLACKOUT_KICK}>\r\n          <span style={{ fontSize: '75%' }}>\r\n            <SpellIcon\r\n              id={SPELLS.RISING_SUN_KICK.id}\r\n              style={{\r\n                height: '1.3em',\r\n                marginTop: '-1.em',\r\n              }}\r\n            /> {(this.effectiveRisingSunKickReductionMs / 1000).toFixed(1)} <small>Seconds reduced</small>\r\n            <br />\r\n            <SpellIcon\r\n              id={SPELLS.FISTS_OF_FURY_CAST.id}\r\n              style={{\r\n                height: '1.3em',\r\n                marginTop: '-1.em',\r\n              }}\r\n            /> {(this.effectiveFistsOfFuryReductionMs / 1000).toFixed(1)} <small>Seconds reduced</small>\r\n          </span>\r\n        </BoringSpellValueText>\r\n      </Statistic>\r\n    );\r\n  }\r\n}\r\n\r\nexport default BlackoutKick;\r\n","import React from 'react';\r\nimport SPELLS from 'common/SPELLS';\r\nimport SpellLink from 'common/SpellLink';\r\nimport UptimeIcon from 'interface/icons/Uptime';\r\nimport { STATISTIC_ORDER } from 'interface/others/StatisticBox';\r\nimport Events, { DamageEvent } from 'parser/core/Events';\r\nimport { formatNumber, formatPercentage } from 'common/format';\r\nimport Analyzer , { Options } from 'parser/core/Analyzer';\r\nimport { SELECTED_PLAYER, SELECTED_PLAYER_PET } from 'parser/core/EventFilter';\r\nimport calculateEffectiveDamage from 'parser/core/calculateEffectiveDamage';\r\nimport Statistic from 'interface/statistics/Statistic';\r\nimport BoringSpellValueText from 'interface/statistics/components/BoringSpellValueText/index';\r\nimport { ABILITIES_AFFECTED_BY_DAMAGE_INCREASES } from 'parser/monk/windwalker/constants';\r\nimport { i18n } from '@lingui/core';\r\nimport { t } from '@lingui/macro';\r\nimport { ThresholdStyle, When } from 'parser/core/ParseResults';\r\n\r\nconst MOD_PER_STACK = 0.01;\r\nconst MAX_STACKS = 6;\r\n\r\nclass HitCombo extends Analyzer {\r\n  constructor(options: Options) {\r\n    super(options);\r\n    this.active = this.selectedCombatant.hasTalent(SPELLS.HIT_COMBO_TALENT.id);\r\n    if (this.active) {\r\n      this.addEventListener(Events.damage.by(SELECTED_PLAYER | SELECTED_PLAYER_PET).spell(ABILITIES_AFFECTED_BY_DAMAGE_INCREASES), this.onAffectedDamage);\r\n    }\r\n  }\r\n  totalDamage = 0;\r\n\r\n  onAffectedDamage(event: DamageEvent) {\r\n    const buffInfo = this.selectedCombatant.getBuff(SPELLS.HIT_COMBO_BUFF.id);\r\n    if (!buffInfo) {\r\n      return;\r\n    }\r\n    const mod = buffInfo.stacks * MOD_PER_STACK;\r\n    const increase = calculateEffectiveDamage(event, mod);\r\n    this.totalDamage += increase;\r\n  }\r\n\r\n  get uptime() {\r\n    return this.selectedCombatant.getStackWeightedBuffUptime(SPELLS.HIT_COMBO_BUFF.id) / (this.owner.fightDuration * MAX_STACKS);\r\n  }\r\n\r\n  get dps(){\r\n    return this.totalDamage / this.owner.fightDuration * 1000;\r\n  }\r\n\r\n  get suggestionThresholds() {\r\n    return {\r\n      actual: this.uptime,\r\n      isLessThan: {\r\n        minor: 0.95,\r\n        average: 0.90,\r\n        major: 0.85,\r\n      },\r\n      style: ThresholdStyle.PERCENTAGE,\r\n    };\r\n  }\r\n\r\n  suggestions(when: When) {\r\n    when(this.suggestionThresholds).addSuggestion((suggest, actual, recommended) => suggest(<span>You let your <SpellLink id={SPELLS.HIT_COMBO_TALENT.id} /> buff drop by casting a spell twice in a row. Dropping this buff is a large DPS decrease so be mindful of the spells being cast.</span>)\r\n          .icon(SPELLS.HIT_COMBO_TALENT.icon)\r\n          .actual(i18n._(t('monk.windwalker.suggestions.hitCombo.uptime')`${formatPercentage(actual)} % uptime`))\r\n          .recommended(`>${formatPercentage(recommended)} % is recommended`));\r\n  }\r\n\r\n  statistic() {\r\n    return (\r\n      <Statistic\r\n        position={STATISTIC_ORDER.CORE(11)}\r\n        size=\"flexible\"\r\n        tooltip={(\r\n          <>\r\n            Total damage increase: {formatNumber(this.totalDamage)}<br />\r\n            Uptime is weighted so less stacks count less towards 100% uptime\r\n          </>\r\n        )}\r\n      >\r\n        <BoringSpellValueText spell={SPELLS.HIT_COMBO_TALENT}>\r\n          <UptimeIcon /> {formatPercentage(this.uptime)}% <small>Weighted uptime</small><br />\r\n          <img\r\n            src=\"/img/sword.png\"\r\n            alt=\"Damage\"\r\n            className=\"icon\"\r\n          /> {formatNumber(this.dps)} DPS <small>{formatPercentage(this.owner.getPercentageOfTotalDamageDone(this.totalDamage))} % of total</small>\r\n        </BoringSpellValueText>\r\n      </Statistic>\r\n    );\r\n  }\r\n}\r\n\r\nexport default HitCombo;\r\n","import RESOURCE_TYPES from 'game/RESOURCE_TYPES';\r\nimport ResourceTracker from 'parser/shared/modules/resources/resourcetracker/ResourceTracker';\r\nimport SPELLS from 'common/SPELLS';\r\n\r\nclass ChiTracker extends ResourceTracker {\r\n  maxResource = 5;\r\n\r\n  constructor(...args) {\r\n    super(...args);\r\n    this.resource = RESOURCE_TYPES.CHI;\r\n\r\n    if (this.selectedCombatant.hasTalent(SPELLS.ASCENSION_TALENT.id)) {\r\n      this.maxResource = 6;\r\n    }\r\n  }\r\n\r\n  getReducedCost(event) {\r\n    if (!this.getResource(event).cost) {\r\n      return 0;\r\n    }\r\n    let cost = this.getResource(event).cost;\r\n    const spellId = event.ability.guid;\r\n\r\n    // Blackout Kick costs 3 chi when learned, but is reduced in cost during levelling\r\n    if (spellId === SPELLS.BLACKOUT_KICK.id) {\r\n        cost = 1;\r\n    }\r\n    return cost;\r\n  }\r\n}\r\n\r\nexport default ChiTracker;\r\n","// Heavily inspired by resource breakdown in Feral and Retribution\r\nimport React from 'react';\r\n\r\nimport Analyzer from 'parser/core/Analyzer';\r\nimport Panel from 'interface/others/Panel';\r\nimport Statistic from 'interface/statistics/Statistic';\r\nimport { STATISTIC_ORDER } from 'interface/others/StatisticBox';\r\nimport ResourceBreakdown from 'parser/shared/modules/resources/resourcetracker/ResourceBreakdown';\r\nimport ChiTracker from 'parser/monk/windwalker/modules/resources/ChiTracker';\r\nimport RESOURCE_TYPES from 'game/RESOURCE_TYPES';\r\nimport BoringResourceValue from 'interface/statistics/components/BoringResourceValue/index';\r\nimport { formatPercentage } from 'common/format';\r\nimport { i18n } from '@lingui/core';\r\nimport { t } from '@lingui/macro';\r\n\r\nclass ChiDetails extends Analyzer {\r\n  static dependencies = {\r\n    chiTracker: ChiTracker,\r\n  };\r\n\r\n  get chiWasted() {\r\n    return this.chiTracker.wasted;\r\n  }\r\n\r\n  get chiWastedPercent() {\r\n    return this.chiWasted / (this.chiWasted + this.chiTracker.generated) || 0;\r\n  }\r\n\r\n  get chiWastedPerMinute() {\r\n    return (this.chiWasted / this.owner.fightDuration) * 1000 * 60;\r\n  }\r\n\r\n  get suggestionThresholds() {\r\n    return {\r\n      actual: this.chiWastedPerMinute,\r\n      isGreaterThan: {\r\n        minor: 0,\r\n        average: 1,\r\n        major: 2,\r\n      },\r\n      style: 'decimal',\r\n    };\r\n  }\r\n\r\n  suggestions(when) {\r\n    when(this.suggestionThresholds).addSuggestion((suggest, actual, recommended) => suggest('You are wasting Chi. Try to use it and not let it cap and go to waste')\r\n        .icon('creatureportrait_bubble')\r\n        .actual(i18n._(t('monk.windwalker.suggestions.chi.wastedPerMinute')`${this.chiWasted} Chi wasted (${(actual.toFixed(2))} per minute)`))\r\n        .recommended(`${recommended} Chi wasted is recommended`));\r\n  }\r\n\r\n  statistic() {\r\n    return (\r\n      <Statistic\r\n        size=\"small\"\r\n        position={STATISTIC_ORDER.CORE(1)}\r\n        tooltip={<>{formatPercentage(this.chiWastedPercent)}% wasted</>}\r\n      >\r\n        <BoringResourceValue\r\n          resource={RESOURCE_TYPES.CHI}\r\n          value={this.chiWasted}\r\n          label=\"Wasted Chi\"\r\n        />\r\n      </Statistic>\r\n    );\r\n  }\r\n\r\n  tab() {\r\n    return {\r\n      title: 'Chi',\r\n      url: 'chi',\r\n      render: () => (\r\n        <Panel>\r\n          <ResourceBreakdown\r\n            tracker={this.chiTracker}\r\n            resourceName=\"Chi\"\r\n            showSpenders\r\n          />\r\n        </Panel>\r\n      ),\r\n    };\r\n  }\r\n}\r\n\r\nexport default ChiDetails;\r\n","import React from 'react';\r\nimport Analyzer, { Options, SELECTED_PLAYER } from 'parser/core/Analyzer';\r\nimport { Trans, t } from '@lingui/macro';\r\nimport SPELLS from 'common/SPELLS';\r\nimport SpellLink from 'common/SpellLink';\r\nimport Statistic from 'interface/statistics/Statistic';\r\nimport { STATISTIC_ORDER } from 'interface/others/StatisticBox';\r\nimport STATISTIC_CATEGORY from 'interface/others/STATISTIC_CATEGORY';\r\nimport AbilityTracker from 'parser/shared/modules/AbilityTracker';\r\nimport BoringSpellValueText from 'interface/statistics/components/BoringSpellValueText';\r\nimport ItemDamageDone from 'interface/ItemDamageDone';\r\nimport Events, { DamageEvent } from 'parser/core/Events';\r\n\r\nimport { ThresholdStyle, When } from 'parser/core/ParseResults';\r\n\r\nimport { CHI_SPENDERS } from '../../constants';\r\n\r\nconst MAX_STACKS = 20;\r\n\r\nclass LastEmperorsCapacitor extends Analyzer {\r\n  static dependencies = {\r\n    abilityTracker: AbilityTracker,\r\n  };\r\n\r\n  protected abilityTracker!: AbilityTracker;\r\n\r\n  totalStacks = 0;\r\n  currentStacks = 0;\r\n  stacksUsed = 0;\r\n  stacksWasted = 0;\r\n  damage = 0;\r\n  buffedCast = false;\r\n\r\n  constructor(options: Options) {\r\n    super(options);\r\n    this.active = this.selectedCombatant.hasLegendaryByBonusID(SPELLS.LAST_EMPERORS_CAPACITOR.bonusID);\r\n    if (!this.active) {\r\n      return;\r\n    }\r\n    this.addEventListener(Events.applybuff.by(SELECTED_PLAYER).spell(SPELLS.LAST_EMPERORS_CAPACITOR_BUFF), this.applyBuff);\r\n    this.addEventListener(Events.applybuffstack.by(SELECTED_PLAYER).spell(SPELLS.LAST_EMPERORS_CAPACITOR_BUFF), this.applyBuffStack);\r\n    this.addEventListener(Events.cast.by(SELECTED_PLAYER).spell(CHI_SPENDERS), this.castChiSpender);\r\n    this.addEventListener(Events.cast.by(SELECTED_PLAYER).spell(SPELLS.CRACKLING_JADE_LIGHTNING), this.castCracklingJadeLightning);\r\n    this.addEventListener(Events.damage.by(SELECTED_PLAYER).spell(SPELLS.CRACKLING_JADE_LIGHTNING), this.cracklingJadeLightningDamage);\r\n  }\r\n\r\n  applyBuff() {\r\n    this.totalStacks += 1;\r\n    this.currentStacks += 1;\r\n  }\r\n\r\n  applyBuffStack() {\r\n    this.totalStacks += 1;\r\n    this.currentStacks += 1;\r\n  }\r\n\r\n  castChiSpender() {\r\n    if (this.currentStacks === MAX_STACKS) {\r\n      this.stacksWasted += 1;\r\n    }\r\n  }\r\n\r\n  castCracklingJadeLightning() {\r\n    if (this.currentStacks > 0) {\r\n      this.buffedCast = true;\r\n      this.stacksUsed += this.currentStacks;\r\n      this.currentStacks = 0;\r\n    }\r\n  }\r\n\r\n  cracklingJadeLightningDamage(event: DamageEvent) {\r\n    if (this.buffedCast) {\r\n      this.damage += event.amount + (event.absorbed || 0);\r\n      this.buffedCast = false;\r\n    }\r\n  }\r\n\r\n  get averageStacksUsed() {\r\n    return this.stacksUsed / this.abilityTracker.getAbility(SPELLS.CRACKLING_JADE_LIGHTNING.id).casts;\r\n  }\r\n\r\n  get stacksWastedPerMinute() {\r\n    return this.stacksWasted / this.owner.fightDuration * 1000 / 60;\r\n  }\r\n\r\n  get averageStacksSuggestionThresholds() {\r\n    return {\r\n      actual: this.averageStacksUsed,\r\n      isLessThan: {\r\n        minor: 18,\r\n        average: 16,\r\n        major: 14,\r\n      },\r\n      style: ThresholdStyle.NUMBER,\r\n    };\r\n  }\r\n\r\n  get wastedStacksSuggestionThresholds() {\r\n    return {\r\n      actual: this.stacksWastedPerMinute,\r\n      isGreaterThan: {\r\n        minor: 0,\r\n        average: 2,\r\n        major: 4,\r\n      },\r\n      style: ThresholdStyle.NUMBER,\r\n    };\r\n  }\r\n\r\n  statistic() {\r\n    return (\r\n      <Statistic\r\n        position={STATISTIC_ORDER.CORE()}\r\n        size=\"flexible\"\r\n        category={STATISTIC_CATEGORY.ITEMS}\r\n        tooltip={\r\n          <Trans id=\"monk.windwalker.modules.items.lastEmperorsCapacitor.tooltip\">Damage dealt does not account for opportunity cost\r\n            <br />\r\n            Stacks generated <b>{this.totalStacks}</b>\r\n            <br />\r\n            Stacks consumed: <b>{this.stacksUsed}</b>\r\n            <br />\r\n            Stacks wasted by generating at cap: <b>{this.stacksWasted}</b>\r\n            <br />\r\n            Average stacks spent on each cast: <b>{this.averageStacksUsed.toFixed(2)}</b></Trans>}\r\n      >\r\n        <BoringSpellValueText spell={SPELLS.LAST_EMPERORS_CAPACITOR}>\r\n          <ItemDamageDone amount={this.damage} />\r\n        </BoringSpellValueText>\r\n      </Statistic>\r\n    );\r\n  }\r\n\r\n  suggestions(when: When) {\r\n    when(this.wastedStacksSuggestionThresholds).addSuggestion((suggest, actual, recommended) => suggest(\r\n      <Trans id=\"monk.windwalker.modules.items.lastEmperorsCapacitor.wastedStacks\"> You wasted your <SpellLink id={SPELLS.LAST_EMPERORS_CAPACITOR_BUFF.id}/> stacks by using chi spenders while at 20 stacks </Trans>)\r\n        .icon(SPELLS.LAST_EMPERORS_CAPACITOR.icon)\r\n        .actual(t('monk.windwalker.modules.items.lastEmperorsCapacitor.wastedStacks.actual')`${actual.toFixed(2)} Wasted stacks per minute`)\r\n        .recommended(t('monk.windwalker.modules.items.lastEmperorsCapacitor.wastedStacks.recommended')`${(recommended)} Wasted stacks per minute is recommended`)\r\n    );\r\n    when(this.averageStacksSuggestionThresholds).addSuggestion((suggest, actual) => suggest(\r\n      <Trans id=\"monk.windwalker.modules.items.lastEmperorsCapacitor.averageStacks\"> Your average number of <SpellLink id={SPELLS.LAST_EMPERORS_CAPACITOR_BUFF.id} /> stacks used when you cast <SpellLink id={SPELLS.CRACKLING_JADE_LIGHTNING.id}/> was low </Trans>)\r\n        .icon(SPELLS.LAST_EMPERORS_CAPACITOR.icon)\r\n        .actual(t('monk.windwalker.modules.items.lastEmperorsCapacitor.averageStacks.actual')`${actual.toFixed(2)} average stacks used`)\r\n        .recommended(t('monk.windwalker.modules.items.lastEmperorsCapacitor.averageStacks.recommended')`Try to cast Crackling Jade Lightning while as close to 20 stacks as possible`)\r\n    );\r\n  }\r\n}\r\n\r\nexport default LastEmperorsCapacitor;\r\n","import React from 'react';\r\nimport Analyzer, { Options, SELECTED_PLAYER } from 'parser/core/Analyzer';\r\nimport { Trans } from '@lingui/macro';\r\nimport SPELLS from 'common/SPELLS';\r\nimport SpellLink from 'common/SpellLink';\r\nimport Statistic from 'interface/statistics/Statistic';\r\nimport { STATISTIC_ORDER } from 'interface/others/StatisticBox';\r\nimport STATISTIC_CATEGORY from 'interface/others/STATISTIC_CATEGORY';\r\nimport { formatPercentage } from 'common/format';\r\nimport AbilityTracker from 'parser/shared/modules/AbilityTracker';\r\nimport BoringSpellValueText from 'interface/statistics/components/BoringSpellValueText';\r\nimport ItemDamageDone from 'interface/ItemDamageDone';\r\nimport Events from 'parser/core/Events';\r\nimport { ThresholdStyle, When } from 'parser/core/ParseResults';\r\n\r\nconst MAX_STACKS = 30;\r\n\r\nclass JadeIgnition extends Analyzer {\r\n  static dependencies = {\r\n    abilityTracker: AbilityTracker,\r\n  };\r\n  totalStacks = 0;\r\n  currentStacks = 0;\r\n  stacksWasted = 0;\r\n\r\n  protected abilityTracker!: AbilityTracker;\r\n\r\n  constructor(options: Options) {\r\n    super(options);\r\n    this.active = this.selectedCombatant.hasLegendaryByBonusID(SPELLS.JADE_IGNITION.bonusID);\r\n    if (!this.active) {\r\n      return;\r\n    }\r\n    this.addEventListener(Events.applybuff.by(SELECTED_PLAYER).spell(SPELLS.JADE_IGNITION_BUFF), this.applyBuff);\r\n    this.addEventListener(Events.applybuffstack.by(SELECTED_PLAYER).spell(SPELLS.JADE_IGNITION_BUFF), this.applyBuffStack);\r\n    this.addEventListener(Events.damage.by(SELECTED_PLAYER).spell(SPELLS.FISTS_OF_FURY_DAMAGE), this.onFistsDamage);\r\n    this.addEventListener(Events.cast.by(SELECTED_PLAYER).spell(SPELLS.SPINNING_CRANE_KICK), this.castSpinningCraneKick);\r\n  }\r\n\r\n  applyBuff() {\r\n    this.currentStacks += 1;\r\n  }\r\n\r\n  applyBuffStack() {\r\n    this.currentStacks += 1;\r\n  }\r\n\r\n  onFistsDamage() {\r\n    this.totalStacks += 1;\r\n    if (this.currentStacks === MAX_STACKS) {\r\n      this.stacksWasted += 1;\r\n    }\r\n  }\r\n\r\n  castSpinningCraneKick() {\r\n    this.currentStacks = 0;\r\n  }\r\n\r\n  get damageDone() {\r\n    return this.abilityTracker.getAbility(SPELLS.JADE_IGNITION_DAMAGE.id).damageEffective;\r\n  }\r\n\r\n  get stackUsage() {\r\n    return 1 - (this.stacksWasted / this.totalStacks);\r\n  }\r\n\r\n  get suggestionThresholds() {\r\n    return {\r\n      actual: this.stackUsage,\r\n      isLessThan: {\r\n        minor: 1,\r\n        average: 0.95,\r\n        major: 0.9,\r\n      },\r\n      style: ThresholdStyle.PERCENTAGE,\r\n    };\r\n  }\r\n\r\n  statistic() {\r\n    return (\r\n      <Statistic\r\n        position={STATISTIC_ORDER.CORE()}\r\n        size=\"flexible\"\r\n        category={STATISTIC_CATEGORY.ITEMS}\r\n      >\r\n        <BoringSpellValueText spell={SPELLS.JADE_IGNITION}>\r\n          <ItemDamageDone amount={this.damageDone} />\r\n          <br />\r\n          {formatPercentage(this.stackUsage, 0)}% <small>Stacks used</small>\r\n        </BoringSpellValueText>\r\n      </Statistic>\r\n    );\r\n  }\r\n\r\n  suggestions(when: When) {\r\n    when(this.suggestionThresholds).addSuggestion((suggest, actual, recommended) => suggest(\r\n      <Trans id=\"monk.windwalker.suggestions.jadeIgnitionWastedStacks\"> You wasted your <SpellLink id={SPELLS.JADE_IGNITION_BUFF.id} /> stacks by using Fists of Fury at full stacks</Trans>)\r\n      .icon(SPELLS.JADE_IGNITION.icon)\r\n      .actual(`${formatPercentage(actual, 0)}% Stacks used`)\r\n      .recommended(`${formatPercentage(recommended, 0)}% Stacks used is recommended`),\r\n    );\r\n  }\r\n}\r\n\r\nexport default JadeIgnition;\r\n","import React from 'react';\r\nimport PropTypes from 'prop-types';\r\n\r\nimport SPELLS from 'common/SPELLS';\r\nimport SpellLink from 'common/SpellLink';\r\nimport Checklist from 'parser/shared/modules/features/Checklist';\r\nimport Rule from 'parser/shared/modules/features/Checklist/Rule';\r\nimport Requirement from 'parser/shared/modules/features/Checklist/Requirement';\r\nimport PreparationRule from 'parser/shared/modules/features/Checklist/PreparationRule';\r\nimport GenericCastEfficiencyRequirement from 'parser/shared/modules/features/Checklist/GenericCastEfficiencyRequirement';\r\n\r\nconst WindwalkerMonkChecklist = ({ combatant, castEfficiency, thresholds }: any) => {\r\n  const AbilityRequirement = (props: any) => (\r\n    <GenericCastEfficiencyRequirement\r\n      castEfficiency={castEfficiency.getCastEfficiencyForSpellId(props.spell)}\r\n      {...props}\r\n    />\r\n  );\r\n  AbilityRequirement.propTypes = {\r\n    spell: PropTypes.number.isRequired,\r\n  };\r\n\r\n  return (\r\n    <Checklist>\r\n      <Rule\r\n        name=\"Use core abilities as often as possible\"\r\n        description={(\r\n          <>\r\n            Spells with short cooldowns like <SpellLink id={SPELLS.RISING_SUN_KICK.id} /> and <SpellLink id={SPELLS.FISTS_OF_FURY_CAST.id} /> should be used as often as possible.\r\n          </>\r\n        )}\r\n      >\r\n        <AbilityRequirement spell={SPELLS.RISING_SUN_KICK.id} />\r\n        <AbilityRequirement spell={SPELLS.FISTS_OF_FURY_CAST.id} />\r\n        {combatant.hasTalent(SPELLS.WHIRLING_DRAGON_PUNCH_TALENT.id) && <AbilityRequirement spell={SPELLS.WHIRLING_DRAGON_PUNCH_TALENT.id} />}\r\n        {combatant.hasTalent(SPELLS.CHI_WAVE_TALENT.id) && <AbilityRequirement spell={SPELLS.CHI_WAVE_TALENT.id} />}\r\n        {combatant.hasTalent(SPELLS.CHI_BURST_TALENT.id) && <AbilityRequirement spell={SPELLS.CHI_BURST_TALENT.id} />}\r\n      </Rule>\r\n      <Rule\r\n        name=\"Use your procs and short CDs\"\r\n        description={(\r\n          <>\r\n            Make sure to use your procs and spells at the correct time. Wasting <SpellLink id={SPELLS.COMBO_BREAKER_BUFF.id} /> procs and not hitting all your <SpellLink id={SPELLS.FISTS_OF_FURY_CAST.id} /> ticks is a loss of potential damage.\r\n          </>\r\n        )}\r\n      >\r\n        <Requirement\r\n          name={(\r\n            <>\r\n              <SpellLink id={SPELLS.COMBO_BREAKER_BUFF.id} /> procs used\r\n            </>\r\n          )}\r\n          thresholds={thresholds.comboBreaker}\r\n        />\r\n        <Requirement\r\n          name={(\r\n            <>\r\n              Average ticks hit with <SpellLink id={SPELLS.FISTS_OF_FURY_CAST.id} />\r\n            </>\r\n          )}\r\n          thresholds={thresholds.fistsofFury}\r\n        />\r\n        {combatant.hasLegendaryByBonusID(SPELLS.JADE_IGNITION.bonusID) && (\r\n          <Requirement\r\n            name={(\r\n              <>\r\n                <SpellLink id={SPELLS.JADE_IGNITION_BUFF.id} /> stacks used\r\n              </>\r\n            )}\r\n            thresholds={thresholds.jadeIgnition}\r\n          />\r\n        )}\r\n      </Rule>\r\n      <Rule\r\n        name=\"Use your cooldowns effectively\"\r\n        description={(\r\n          <>\r\n            Your cooldowns have a big impact on your damage output. Make sure you use them as much as possible. <SpellLink id={SPELLS.TOUCH_OF_KARMA_CAST.id} icon /> is both a defensive and offensive cooldown, but is mostly used offensively.\r\n          </>\r\n        )}\r\n      >\r\n        <AbilityRequirement spell={SPELLS.TOUCH_OF_DEATH.id} />\r\n        <AbilityRequirement spell={SPELLS.TOUCH_OF_KARMA_CAST.id} />\r\n        {!combatant.hasTalent(SPELLS.SERENITY_TALENT.id) && <AbilityRequirement spell={SPELLS.STORM_EARTH_AND_FIRE_CAST.id} />}\r\n        {combatant.hasTalent(SPELLS.SERENITY_TALENT.id) && <AbilityRequirement spell={SPELLS.SERENITY_TALENT.id} />}\r\n        <AbilityRequirement spell={SPELLS.INVOKE_XUEN_THE_WHITE_TIGER.id} />\r\n        <Requirement\r\n          name={(\r\n            <>\r\n              Absorb from <SpellLink id={SPELLS.TOUCH_OF_KARMA_CAST.id} /> used\r\n            </>\r\n          )}\r\n          thresholds={thresholds.touchOfKarma}\r\n        />\r\n      </Rule>\r\n      <Rule\r\n        name=\"Manage your resources\"\r\n        description={(\r\n          <>\r\n            Windwalker is heavily dependent on having enough Chi to cast your core spells on cooldown. Wasting Chi either by generating while capped or using <SpellLink id={SPELLS.BLACKOUT_KICK.id} icon /> and <SpellLink id={SPELLS.SPINNING_CRANE_KICK.id} icon /> too much will cause you to delay your hard hitting Chi spenders and lose damage.\r\n          </>\r\n        )}\r\n      >\r\n        <AbilityRequirement spell={SPELLS.EXPEL_HARM.id} />\r\n        {combatant.hasTalent(SPELLS.ENERGIZING_ELIXIR_TALENT.id) && <AbilityRequirement spell={SPELLS.ENERGIZING_ELIXIR_TALENT.id} />}\r\n        {combatant.hasTalent(SPELLS.FIST_OF_THE_WHITE_TIGER_TALENT.id) && <AbilityRequirement spell={SPELLS.FIST_OF_THE_WHITE_TIGER_TALENT.id} />}\r\n        <Requirement\r\n          name={(\r\n            <>\r\n              Wasted cooldown reduction from <SpellLink id={SPELLS.BLACKOUT_KICK.id} /> per minute\r\n            </>\r\n          )}\r\n          thresholds={thresholds.blackoutKick}\r\n        />\r\n        <Requirement\r\n          name=\"Chi wasted per minute\"\r\n          thresholds={thresholds.chiDetails}\r\n        />\r\n      </Rule>\r\n      <Rule\r\n        name=\"Don't break mastery\"\r\n        description={(\r\n          <>\r\n            Using the same damaging ability twice in a row will lose mastery benefit on the second cast and drop the <SpellLink id={SPELLS.HIT_COMBO_TALENT.id} icon /> buff if specced.\r\n          </>\r\n        )}\r\n      >\r\n      <Requirement\r\n        name={(\r\n          <>\r\n            Times <SpellLink id={SPELLS.COMBO_STRIKES.id} /> was broken\r\n          </>\r\n        )}\r\n        thresholds={thresholds.comboStrikes}\r\n      />\r\n      {combatant.hasTalent(SPELLS.HIT_COMBO_TALENT) && (\r\n        <Requirement\r\n          name={(\r\n            <>\r\n              <SpellLink id={SPELLS.HIT_COMBO_TALENT.id} /> uptime\r\n            </>\r\n          )}\r\n          thresholds={thresholds.hitCombo}\r\n        />\r\n      )}\r\n      </Rule>\r\n      {combatant.hasLegendaryByBonusID(SPELLS.LAST_EMPERORS_CAPACITOR.bonusID) && (\r\n        <Rule\r\n          name={<>Utilize <SpellLink id={SPELLS.LAST_EMPERORS_CAPACITOR.id} /> effectively</>}\r\n          description={<>Use <SpellLink id={SPELLS.CRACKLING_JADE_LIGHTNING.id} /> with high stacks and avoid wasting stacks by using Chi spenders at cap</>}\r\n        >\r\n        <Requirement\r\n          name={<>Average stacks used per <SpellLink id={SPELLS.CRACKLING_JADE_LIGHTNING.id} /> cast </>}\r\n          thresholds={thresholds.lastEmperorsCapacitorAverageStacks}\r\n        />\r\n        <Requirement\r\n          name=\"Stacks wasted per minute\"\r\n          thresholds={thresholds.lastEmperorsCapacitorWastedStacks}\r\n        />\r\n        </Rule>\r\n      )}\r\n      <Rule\r\n        name=\"Use your defensive cooldowns effectively\"\r\n        description={(\r\n          <>\r\n            Make sure you use your defensive cooldowns at appropriate times throughout the fight. Make sure to use <SpellLink id={SPELLS.TOUCH_OF_KARMA_CAST.id} /> as much as possible to maximize its offensive benefit and use <SpellLink id={SPELLS.DIFFUSE_MAGIC_TALENT.id} />/<SpellLink id={SPELLS.DAMPEN_HARM_TALENT.id} icon /> for dangerous periods of damage intake.\r\n          </>\r\n        )}\r\n      >\r\n        <AbilityRequirement spell={SPELLS.TOUCH_OF_KARMA_CAST.id} />\r\n        {combatant.hasTalent(SPELLS.DIFFUSE_MAGIC_TALENT.id) && <AbilityRequirement spell={SPELLS.DIFFUSE_MAGIC_TALENT.id} />}\r\n        {combatant.hasTalent(SPELLS.DAMPEN_HARM_TALENT.id) && <AbilityRequirement spell={SPELLS.DAMPEN_HARM_TALENT.id} />}\r\n        <Requirement\r\n          name={(\r\n            <>\r\n              Absorb from <SpellLink id={SPELLS.TOUCH_OF_KARMA_CAST.id} /> used\r\n            </>\r\n          )}\r\n          thresholds={thresholds.touchOfKarma}\r\n        />\r\n      </Rule>\r\n      <PreparationRule thresholds={thresholds} />\r\n    </Checklist>\r\n  );\r\n};\r\n\r\nWindwalkerMonkChecklist.propTypes = {\r\n  castEfficiency: PropTypes.object.isRequired,\r\n  combatant: PropTypes.shape({\r\n    hasTalent: PropTypes.func.isRequired,\r\n    hasLegendaryByBonusID: PropTypes.func.isRequired,\r\n  }).isRequired,\r\n  thresholds: PropTypes.object.isRequired,\r\n};\r\n\r\nexport default WindwalkerMonkChecklist;\r\n","import React from 'react';\r\n\r\nimport BaseChecklist from 'parser/shared/modules/features/Checklist/Module';\r\nimport CastEfficiency from 'parser/shared/modules/CastEfficiency';\r\nimport Combatants from 'parser/shared/modules/Combatants';\r\nimport PreparationRuleAnalyzer from 'parser/shared/modules/features/Checklist/PreparationRuleAnalyzer';\r\n\r\nimport ComboBreaker from '../../spells/ComboBreaker';\r\nimport FistsofFury from '../../spells/FistsofFury';\r\nimport TouchOfKarma from '../../spells/TouchOfKarma';\r\nimport ComboStrikes from '../../spells/ComboStrikes';\r\nimport BlackoutKick from '../../spells/BlackoutKick';\r\n\r\nimport HitCombo from '../../talents/HitCombo';\r\nimport ChiDetails from '../../resources/ChiDetails';\r\n\r\nimport LastEmperorsCapacitor from '../../items/LastEmperorsCapacitor';\r\nimport JadeIgnition from '../../items/JadeIgnition';\r\n\r\nimport Component from './Component';\r\n\r\nclass Checklist extends BaseChecklist {\r\n  static dependencies = {\r\n    combatants: Combatants,\r\n    castEfficiency: CastEfficiency,\r\n    preparationRuleAnalyzer: PreparationRuleAnalyzer,\r\n\r\n    comboBreaker: ComboBreaker,\r\n    fistsofFury: FistsofFury,\r\n    touchOfKarma: TouchOfKarma,\r\n    comboStrikes: ComboStrikes,\r\n    blackoutKick: BlackoutKick,\r\n\r\n    hitCombo: HitCombo,\r\n    chiDetails: ChiDetails,\r\n\r\n    lastEmperorsCapacitor: LastEmperorsCapacitor,\r\n    jadeIgnition: JadeIgnition,\r\n  };\r\n\r\n  protected combatants!: Combatants;\r\n  protected castEfficiency!: CastEfficiency;\r\n  protected preparationRuleAnalyzer!: PreparationRuleAnalyzer;\r\n  protected comboBreaker!: ComboBreaker;\r\n  protected fistsofFury!: FistsofFury;\r\n  protected touchOfKarma!: TouchOfKarma;\r\n  protected comboStrikes!: ComboStrikes;\r\n  protected blackoutKick!: BlackoutKick;\r\n  protected hitCombo!: HitCombo;\r\n  protected chiDetails!: ChiDetails;\r\n  protected lastEmperorsCapacitor!: LastEmperorsCapacitor;\r\n  protected jadeIgnition!: JadeIgnition;\r\n\r\n  render() {\r\n    return (\r\n      <Component\r\n        combatant={this.combatants.selected}\r\n        castEfficiency={this.castEfficiency}\r\n        thresholds={{\r\n          ...this.preparationRuleAnalyzer.thresholds,\r\n\r\n          comboBreaker: this.comboBreaker.suggestionThresholds,\r\n          fistsofFury: this.fistsofFury.suggestionThresholds,\r\n          touchOfKarma: this.touchOfKarma.suggestionThresholds,\r\n          comboStrikes: this.comboStrikes.suggestionThresholds,\r\n          blackoutKick: this.blackoutKick.suggestionThresholds,\r\n\r\n          hitCombo: this.hitCombo.suggestionThresholds,\r\n          chiDetails: this.chiDetails.suggestionThresholds,\r\n\r\n          lastEmperorsCapacitorAverageStacks: this.lastEmperorsCapacitor.averageStacksSuggestionThresholds,\r\n          lastEmperorsCapacitorWastedStacks: this.lastEmperorsCapacitor.wastedStacksSuggestionThresholds,\r\n          jadeIgnition: this.jadeIgnition.suggestionThresholds,\r\n       }}\r\n     />\r\n    );\r\n  }\r\n}\r\n\r\nexport default Checklist;\r\n","import React from 'react';\r\nimport Icon from 'common/Icon';\r\nimport SPELLS from 'common/SPELLS';\r\nimport RESOURCE_TYPES from 'game/RESOURCE_TYPES';\r\nimport { formatDuration, formatPercentage } from 'common/format';\r\nimport StatisticBox, { STATISTIC_ORDER } from 'interface/others/StatisticBox';\r\nimport RegenResourceCapTracker from 'parser/shared/modules/resources/resourcetracker/RegenResourceCapTracker';\r\nimport Tooltip from 'common/Tooltip';\r\n\r\nconst BASE_ENERGY_REGEN = 10;\r\nconst ASCENSION_REGEN_MULTIPLIER = 1.1;\r\nconst EE_REGEN_ADDITION = 15;\r\n\r\nconst BASE_ENERGY_MAX = 100;\r\nconst ASCENSION_ENERGY_MAX_ADDITION = 20;\r\n\r\nconst RESOURCE_REFUND_ON_MISS = 0.8;\r\n\r\n/**\r\n * Sets up RegenResourceCapTracker to accurately track the regenerating energy of a Windwalker monk.\r\n * Taking into account the effect of buffs, talents, and items on the energy cost of abilities,\r\n * the maximum energy amount, and the regeneration rate.\r\n * Note that some cost reduction effects are already accounted for in the log.\r\n */\r\nclass EnergyCapTracker extends RegenResourceCapTracker {\r\n  static resourceType = RESOURCE_TYPES.ENERGY;\r\n  static baseRegenRate = BASE_ENERGY_REGEN;\r\n  static isRegenHasted = true;\r\n  static cumulativeEventWindow = 400;\r\n  static resourceRefundOnMiss = RESOURCE_REFUND_ON_MISS;\r\n  static buffsChangeRegen = [SPELLS.ENERGIZING_ELIXIR_TALENT.id];\r\n\r\n  naturalRegenRate() {\r\n    let regen = super.naturalRegenRate();\r\n    if (this.selectedCombatant.hasTalent(SPELLS.ASCENSION_TALENT.id)) {\r\n      regen *= ASCENSION_REGEN_MULTIPLIER;\r\n    }\r\n    // Energizing Elixir adds 15 energy per second regen for 5 seconds, not increased by haste\r\n    if (this.combatantHasBuffActive(SPELLS.ENERGIZING_ELIXIR_TALENT.id)){\r\n      regen += EE_REGEN_ADDITION;\r\n    }\r\n    return regen;\r\n  }\r\n\r\n  currentMaxResource() {\r\n    let max = BASE_ENERGY_MAX;\r\n    if (this.selectedCombatant.hasTalent(SPELLS.ASCENSION_TALENT.id)) {\r\n      max += ASCENSION_ENERGY_MAX_ADDITION;\r\n    }\r\n    // What should be x.5 becomes x in-game.\r\n    return Math.floor(max);\r\n  }\r\n\r\n  statistic() {\r\n    return (\r\n      <StatisticBox\r\n        position={STATISTIC_ORDER.CORE(8)}\r\n        icon={<Icon icon=\"spell_shadow_shadowworddominate\" alt=\"Capped Energy\" />}\r\n        value={`${formatPercentage(this.cappedProportion)}%`}\r\n        label=\"Time with capped energy\"\r\n        tooltip={(\r\n          <>\r\n            Although it can be beneficial to wait and let your energy pool ready to be used at the right time, you should still avoid letting it reach the cap.<br />\r\n            You spent <b>{formatPercentage(this.cappedProportion)}%</b> of the fight at capped energy, causing you to miss out on <b>{this.missedRegenPerMinute.toFixed(1)}</b> energy per minute from regeneration.\r\n          </>\r\n        )}\r\n        footer={(\r\n          <div className=\"statistic-box-bar\">\r\n            <Tooltip content={`Not at capped energy for ${formatDuration((this.owner.fightDuration - this.atCap) / 1000)}`}>\r\n              <div\r\n                className=\"stat-healing-bg\"\r\n                style={{ width: `${(1 - this.cappedProportion) * 100}%` }}\r\n              >\r\n                <img src=\"/img/sword.png\" alt=\"Uncapped Energy\" />\r\n              </div>\r\n            </Tooltip>\r\n\r\n            <Tooltip content={`At capped energy for ${formatDuration(this.atCap / 1000)}`}>\r\n              <div className=\"remainder DeathKnight-bg\" >\r\n                <img src=\"/img/overhealing.png\" alt=\"Capped Energy\" />\r\n              </div>\r\n            </Tooltip>\r\n          </div>\r\n        )}\r\n      />\r\n    );\r\n  }\r\n}\r\nexport default EnergyCapTracker;\r\n","import SPELLS from 'common/SPELLS';\r\nimport CoreChanneling from 'parser/shared/modules/Channeling';\r\nimport Events, { ApplyBuffEvent, ApplyDebuffEvent, CastEvent, RemoveBuffEvent, RemoveDebuffEvent } from 'parser/core/Events';\r\nimport { Options, SELECTED_PLAYER } from 'parser/core/Analyzer';\r\nimport Ability from 'parser/core/modules/Ability';\r\n\r\n/**\r\n * Crackling Jade Lightning don't reveal in the combatlog when channeling begins and ends, this fabricates the required events so that ABC can handle it properly.\r\n * Combatlog event order is messy, it often looks like:\r\n * 1. applydebuff Crackling Jade Lightning\r\n * 2. begincast/cast new spell\r\n * 3. removedebuff Crackling Jade Lightning\r\n * To avoid Crackling Jade Lightning as being marked \"canceled\" when we start a new spell we mark it as ended instead on the begincast/cast.\r\n */\r\nclass Channeling extends CoreChanneling {\r\n\r\n  constructor(options: Options) {\r\n    super(options);\r\n    this.addEventListener(Events.applybuff.by(SELECTED_PLAYER).spell(SPELLS.FISTS_OF_FURY_CAST), this.onApplyBuff);\r\n    this.addEventListener(Events.removebuff.by(SELECTED_PLAYER).spell(SPELLS.FISTS_OF_FURY_CAST), this.onRemoveBuff);\r\n    this.addEventListener(Events.applydebuff.by(SELECTED_PLAYER).spell(SPELLS.CRACKLING_JADE_LIGHTNING), this.onApplyDebuff);\r\n    this.addEventListener(Events.removedebuff.by(SELECTED_PLAYER).spell(SPELLS.CRACKLING_JADE_LIGHTNING), this.onRemoveDebuff);\r\n  }\r\n\r\n  onCast(event: CastEvent) {\r\n    if (event.ability.guid === SPELLS.CRACKLING_JADE_LIGHTNING.id || event.ability.guid === SPELLS.FISTS_OF_FURY_CAST.id) {\r\n      // We track Crackling Jade Lightning and Fists of Fury differently\r\n      return;\r\n    }\r\n    super.onCast(event);\r\n  }\r\n\r\n  cancelChannel(event: CastEvent, ability: Ability) {\r\n    if (this.isChannelingSpell(SPELLS.CRACKLING_JADE_LIGHTNING.id) || this.isChannelingSpell(SPELLS.FISTS_OF_FURY_CAST.id)) {\r\n      // If a channeling spell is \"canceled\" it was actually just ended, so if it looks canceled then instead just mark it as ended\r\n      this.log('Marking', this._currentChannel.ability.name, 'as ended since we started casting something else');\r\n      this.endChannel(event);\r\n    } else {\r\n      super.cancelChannel(event, ability);\r\n    }\r\n  }\r\n\r\n  onApplyBuff(event: ApplyBuffEvent) {\r\n    this.beginChannel(event);\r\n  }\r\n\r\n  onApplyDebuff(event: ApplyDebuffEvent) {\r\n    this.beginChannel(event);\r\n  }\r\n\r\n  // Looking at `removebuff` will includes progress towards a tick that never happened. This progress could be considered downtime as it accounts for nothing.\r\n  // If it's ever decided to consider the time between last tick and channel ending as downtime, just change the endchannel trigger.\r\n  onRemoveDebuff(event: RemoveDebuffEvent) {\r\n    if (!this.isChannelingSpell(SPELLS.CRACKLING_JADE_LIGHTNING.id)) {\r\n      // This may be true if we did the event-order fix in begincast/cast and it was already ended there.\r\n      return;\r\n    }\r\n    this.endChannel(event);\r\n  }\r\n\r\n  onRemoveBuff(event: RemoveBuffEvent) {\r\n    if (!this.isChannelingSpell(SPELLS.FISTS_OF_FURY_CAST.id)) {\r\n      // This may be true if we did the event-order fix in begincast/cast and it was already ended there.\r\n      return;\r\n    }\r\n    this.endChannel(event);\r\n  }\r\n}\r\n\r\nexport default Channeling;\r\n","import React from 'react';\r\n\r\nimport SPELLS from 'common/SPELLS';\r\nimport Analyzer, { Options, SELECTED_PLAYER, SELECTED_PLAYER_PET } from 'parser/core/Analyzer';\r\nimport AbilityTracker from 'parser/shared/modules/AbilityTracker';\r\nimport StatTracker from 'parser/shared/modules/StatTracker';\r\nimport Statistic from 'interface/statistics/Statistic';\r\nimport BoringSpellValueText from 'interface/statistics/components/BoringSpellValueText/index';\r\nimport { STATISTIC_ORDER } from 'interface/others/StatisticBox';\r\nimport Events, { ApplyDebuffEvent, CastEvent, RefreshDebuffEvent } from 'parser/core/Events';\r\n\r\ninterface MarkOfTheCrane {\r\n  target: MarkOfTheCraneTarget;\r\n  timestamp: number;\r\n}\r\n\r\ninterface MarkOfTheCraneTarget {\r\n  id: number;\r\n  instance: number;\r\n}\r\n\r\nconst isEqual = (a: MarkOfTheCraneTarget, b: MarkOfTheCraneTarget) => a.id === b.id && a.instance === b.instance;\r\n\r\nclass SpinningCraneKick extends Analyzer {\r\n  static dependencies = {\r\n    abilityTracker: AbilityTracker,\r\n    statTracker: StatTracker,\r\n  };\r\n\r\n  protected abilityTracker!: AbilityTracker;\r\n  protected statTracker!: StatTracker;\r\n\r\n  constructor(options: Options) {\r\n    super(options);\r\n    this.addEventListener(\r\n      Events.applydebuff.by(SELECTED_PLAYER | SELECTED_PLAYER_PET).spell(SPELLS.MARK_OF_THE_CRANE),\r\n      this.onMarkApplication,\r\n    );\r\n    this.addEventListener(\r\n      Events.refreshdebuff\r\n        .by(SELECTED_PLAYER | SELECTED_PLAYER_PET)\r\n        .spell(SPELLS.MARK_OF_THE_CRANE),\r\n      this.onMarkRefresh,\r\n    );\r\n    this.addEventListener(\r\n      Events.cast.by(SELECTED_PLAYER | SELECTED_PLAYER_PET).spell(SPELLS.SPINNING_CRANE_KICK),\r\n      this.onSCKCast,\r\n    );\r\n    this.addEventListener(\r\n      Events.damage\r\n        .by(SELECTED_PLAYER | SELECTED_PLAYER_PET)\r\n        .spell(SPELLS.SPINNING_CRANE_KICK_DAMAGE),\r\n      this.onSCKDamage,\r\n    );\r\n  }\r\n\r\n  cycloneStrikesMarks: MarkOfTheCrane[] = [];\r\n  spinningCraneKickHits = 0;\r\n  totalMarksDuringHits = 0;\r\n\r\n  // targetInstance is undefined when it's the first one.\r\n  _verifyTargetInstance(targetInstance: number | undefined) {\r\n    return targetInstance === undefined ? 1 : targetInstance;\r\n  }\r\n\r\n  onMarkApplication(event: ApplyDebuffEvent) {\r\n    const targetInstance = this._verifyTargetInstance(event.targetInstance);\r\n    const markOfTheCrane: MarkOfTheCrane = {\r\n      target: { id: event.targetID, instance: targetInstance },\r\n      timestamp: event.timestamp,\r\n    };\r\n    this.cycloneStrikesMarks.push(markOfTheCrane);\r\n  }\r\n\r\n  onMarkRefresh(event: RefreshDebuffEvent) {\r\n    const targetInstance = this._verifyTargetInstance(event.targetInstance);\r\n    const refreshedMark: MarkOfTheCrane = {\r\n      target: { id: event.targetID, instance: targetInstance },\r\n      timestamp: event.timestamp,\r\n    };\r\n    this.cycloneStrikesMarks.forEach((mark) => {\r\n      if (isEqual(mark.target, refreshedMark.target)) {\r\n        mark.timestamp = refreshedMark.timestamp;\r\n      }\r\n    });\r\n  }\r\n\r\n  onSCKCast(event: CastEvent) {\r\n    // Filter out expired targets\r\n    this.cycloneStrikesMarks = this.cycloneStrikesMarks.filter(\r\n      (mark) => event.timestamp - mark.timestamp <= 15000,\r\n    );\r\n    if (this.selectedCombatant.hasBuff(SPELLS.DANCE_OF_CHIJI_BUFF.id)) {\r\n      event.meta = event.meta || {};\r\n      event.meta.isEnhancedCast = true;\r\n      event.meta.enhancedCastReason = 'This cast was empowered by Dance of Chi-Ji';\r\n    }\r\n  }\r\n\r\n  onSCKDamage() {\r\n    this.spinningCraneKickHits += 1;\r\n    this.totalMarksDuringHits += this.cycloneStrikesMarks.length;\r\n  }\r\n\r\n  get casts() {\r\n    return this.abilityTracker.getAbility(SPELLS.SPINNING_CRANE_KICK.id).casts;\r\n  }\r\n\r\n  get averageEnemiesHit() {\r\n    return this.spinningCraneKickHits / ((this.casts > 0 ? this.casts : 1) * 4);\r\n  }\r\n\r\n  get averageMarks() {\r\n    return this.totalMarksDuringHits / this.spinningCraneKickHits;\r\n  }\r\n\r\n  statistic() {\r\n    if (this.casts > 0) {\r\n      // Spinning Crane Kick is usually not used outside aoe, so we're avoiding rendering it when it's not used\r\n      return (\r\n        <Statistic\r\n          position={STATISTIC_ORDER.CORE(7)}\r\n          size=\"flexible\"\r\n          tooltip=\"Spinning Crane Kick hits all nearby enemies 4 times over its duration. Mark of the crane, which increases the damage of your Spinning Crane Kick, is applied by your single target abilities and is capped at 5 targets.\"\r\n        >\r\n          <BoringSpellValueText spell={SPELLS.SPINNING_CRANE_KICK}>\r\n            {this.averageMarks.toFixed(2)} <small>Average marks</small>\r\n            <br />\r\n            {this.averageEnemiesHit.toFixed(2)} <small>Average enemies hit</small>\r\n          </BoringSpellValueText>\r\n        </Statistic>\r\n      );\r\n    }\r\n    return null;\r\n  }\r\n}\r\n\r\nexport default SpinningCraneKick;\r\n","import React from 'react';\r\n\r\nimport Statistic from 'interface/statistics/Statistic';\r\nimport { STATISTIC_ORDER } from 'interface/others/StatisticBox';\r\nimport SpellIcon from 'common/SpellIcon';\r\nimport BoringSpellValueText from 'interface/statistics/components/BoringSpellValueText/index';\r\nimport SPELLS from 'common/SPELLS';\r\nimport SpellUsable from 'parser/shared/modules/SpellUsable';\r\nimport Analyzer, { Options, SELECTED_PLAYER } from 'parser/core/Analyzer';\r\nimport Events, { DamageEvent } from 'parser/core/Events';\r\nimport { ABILITIES_AFFECTED_BY_DAMAGE_INCREASES } from 'parser/monk/windwalker/constants';\r\nimport calculateEffectiveDamage from 'parser/core/calculateEffectiveDamage';\r\nimport { formatNumber, formatPercentage } from 'common/format';\r\n\r\nconst DAMAGE_MULTIPLIER = 0.2;\r\n\r\nclass Serenity extends Analyzer {\r\n  static dependencies = {\r\n    spellUsable: SpellUsable,\r\n  };\r\n\r\n  protected spellUsable!: SpellUsable;\r\n\r\n  damageGain = 0;\r\n  effectiveRisingSunKickReductionMs = 0;\r\n  effectiveFistsOfFuryReductionMs = 0;\r\n\r\n  constructor(options: Options) {\r\n    super(options);\r\n    this.active = this.selectedCombatant.hasTalent(SPELLS.SERENITY_TALENT.id);\r\n\r\n    this.addEventListener(Events.cast.by(SELECTED_PLAYER).spell(SPELLS.RISING_SUN_KICK), this.onRSK);\r\n    this.addEventListener(Events.cast.by(SELECTED_PLAYER).spell(SPELLS.FISTS_OF_FURY_CAST), this.onFoF);\r\n    this.addEventListener(Events.applybuff.by(SELECTED_PLAYER).spell(SPELLS.SERENITY_TALENT), this.onSerenityStart);\r\n    this.addEventListener(Events.removebuff.by(SELECTED_PLAYER).spell(SPELLS.SERENITY_TALENT), this.onSerenityEnd);\r\n    this.addEventListener(Events.damage.by(SELECTED_PLAYER).spell(ABILITIES_AFFECTED_BY_DAMAGE_INCREASES), this.onAffectedDamage);\r\n  }\r\n\r\n  _reduceRSK() {\r\n    if (this.spellUsable.isOnCooldown(SPELLS.RISING_SUN_KICK.id)) {\r\n      const cooldownReduction = (this.spellUsable.cooldownRemaining(SPELLS.RISING_SUN_KICK.id)) * 0.5;\r\n      this.spellUsable.reduceCooldown(SPELLS.RISING_SUN_KICK.id, cooldownReduction);\r\n      this.effectiveRisingSunKickReductionMs += cooldownReduction;\r\n    }\r\n  }\r\n\r\n  _reduceFoF() {\r\n    if (this.spellUsable.isOnCooldown(SPELLS.FISTS_OF_FURY_CAST.id)) {\r\n      const cooldownReduction = (this.spellUsable.cooldownRemaining(SPELLS.FISTS_OF_FURY_CAST.id)) * 0.5;\r\n      this.spellUsable.reduceCooldown(SPELLS.FISTS_OF_FURY_CAST.id, cooldownReduction);\r\n      this.effectiveFistsOfFuryReductionMs += cooldownReduction;\r\n    }\r\n  }\r\n\r\n  onRSK() {\r\n    if (this.selectedCombatant.hasBuff(SPELLS.SERENITY_TALENT.id)){\r\n      this._reduceRSK();\r\n    }\r\n  }\r\n\r\n  onFoF() {\r\n    if (this.selectedCombatant.hasBuff(SPELLS.SERENITY_TALENT.id)){\r\n      this._reduceFoF();\r\n    }\r\n  }\r\n\r\n  onSerenityStart() {\r\n    this._reduceRSK();\r\n    this._reduceFoF();\r\n  }\r\n\r\n  onSerenityEnd() {\r\n    if (this.spellUsable.isOnCooldown(SPELLS.RISING_SUN_KICK.id)) {\r\n      const cooldownExtension = (this.spellUsable.cooldownRemaining(SPELLS.RISING_SUN_KICK.id));\r\n      this.spellUsable.extendCooldown(SPELLS.RISING_SUN_KICK.id, cooldownExtension);\r\n      this.effectiveRisingSunKickReductionMs -= cooldownExtension;\r\n    }\r\n    if (this.spellUsable.isOnCooldown(SPELLS.FISTS_OF_FURY_CAST.id)) {\r\n      const cooldownExtension = (this.spellUsable.cooldownRemaining(SPELLS.FISTS_OF_FURY_CAST.id));\r\n      this.spellUsable.extendCooldown(SPELLS.FISTS_OF_FURY_CAST.id, cooldownExtension);\r\n      this.effectiveFistsOfFuryReductionMs -= cooldownExtension;\r\n    }\r\n  }\r\n\r\n  onAffectedDamage(event: DamageEvent) {\r\n    if (!this.selectedCombatant.hasBuff(SPELLS.SERENITY_TALENT.id)) {\r\n      return;\r\n    }\r\n    this.damageGain += calculateEffectiveDamage(event, DAMAGE_MULTIPLIER);\r\n  }\r\n\r\n  get dps() {\r\n    return this.damageGain / this.owner.fightDuration * 1000;\r\n  }\r\n\r\n  statistic() {\r\n    return (\r\n      <Statistic\r\n        position={STATISTIC_ORDER.CORE(3)}\r\n        size=\"flexible\"\r\n        tooltip={(\r\n          <>\r\n            Total damage increase: {formatNumber(this.damageGain)}.\r\n            <br />\r\n            The damage increase is calculated from the {formatPercentage(DAMAGE_MULTIPLIER)}% damage bonus and doesn't count raw damage from extra casts gained from cooldown reduction.\r\n          </>\r\n        )}\r\n      >\r\n        <BoringSpellValueText spell={SPELLS.SERENITY_TALENT}>\r\n          <img\r\n            src=\"/img/sword.png\"\r\n            alt=\"Damage\"\r\n            className=\"icon\"\r\n          /> {formatNumber(this.dps)} DPS <small>{formatPercentage(this.owner.getPercentageOfTotalDamageDone(this.damageGain))} % of total</small>\r\n          <br />\r\n          <span style={{ fontSize: '75%' }}>\r\n            <SpellIcon\r\n              id={SPELLS.RISING_SUN_KICK.id}\r\n              style={{\r\n                height: '1.3em',\r\n                marginTop: '-1.em',\r\n              }}\r\n            /> {(this.effectiveRisingSunKickReductionMs / 1000).toFixed(1)} <small>Seconds reduced</small>\r\n            <br />\r\n            <SpellIcon\r\n              id={SPELLS.FISTS_OF_FURY_CAST.id}\r\n              style={{\r\n                height: '1.3em',\r\n                marginTop: '-1.em',\r\n              }}\r\n            /> {(this.effectiveFistsOfFuryReductionMs / 1000).toFixed(1)} <small>Seconds reduced</small>\r\n          </span>\r\n        </BoringSpellValueText>\r\n      </Statistic>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Serenity;\r\n","import CoreCombatLogParser from 'parser/core/CombatLogParser';\r\n\r\n// Features\r\nimport GlobalCooldown from './modules/core/GlobalCooldown';\r\nimport AlwaysBeCasting from './modules/features/AlwaysBeCasting';\r\nimport Abilities from './modules/Abilities';\r\nimport Buffs from './modules/Buffs';\r\nimport CooldownThroughputTracker from './modules/features/CooldownThroughputTracker';\r\nimport Checklist from './modules/features/checklist/Module';\r\n// Resources\r\nimport EnergyCapTracker from './modules/resources/EnergyCapTracker';\r\nimport ChiDetails from './modules/resources/ChiDetails';\r\nimport ChiTracker from './modules/resources/ChiTracker';\r\n// Core\r\nimport Channeling from './modules/core/Channeling';\r\n// Spells\r\nimport ComboBreaker from './modules/spells/ComboBreaker';\r\nimport FistsofFury from './modules/spells/FistsofFury';\r\nimport SpinningCraneKick from './modules/spells/SpinningCraneKick';\r\nimport ComboStrikes from './modules/spells/ComboStrikes';\r\nimport TouchOfKarma from './modules/spells/TouchOfKarma';\r\nimport TouchOfDeath from '../shared/modules/spells/TouchOfDeath';\r\nimport BlackoutKick from './modules/spells/BlackoutKick';\r\n// Talents\r\nimport HitCombo from './modules/talents/HitCombo';\r\nimport Serenity from './modules/talents/Serenity';\r\n\r\n// Items\r\nimport LastEmperorsCapacitor from './modules/items/LastEmperorsCapacitor';\r\nimport JadeIgnition from './modules/items/JadeIgnition';\r\n\r\n// Covenants\r\nimport FallenOrder from '../shared/modules/covenants/FallenOrder';\r\n\r\n\r\nclass CombatLogParser extends CoreCombatLogParser {\r\n  static specModules = {\r\n    // Core\r\n    channeling: Channeling,\r\n    globalCooldown: GlobalCooldown,\r\n\r\n    // Features\r\n    alwaysBeCasting: AlwaysBeCasting,\r\n    abilities: Abilities,\r\n    buffs: Buffs,\r\n    cooldownThroughputTracker: CooldownThroughputTracker,\r\n    checklist: Checklist,\r\n\r\n    // Resources\r\n    chiTracker: ChiTracker,\r\n    chiDetails: ChiDetails,\r\n    energyCapTracker: EnergyCapTracker,\r\n\r\n    // Talents:\r\n    hitCombo: HitCombo,\r\n    serenity: Serenity,\r\n\r\n    // Spells;\r\n    comboBreaker: ComboBreaker,\r\n    fistsofFury: FistsofFury,\r\n    spinningCraneKick: SpinningCraneKick,\r\n    touchOfKarma: TouchOfKarma,\r\n    touchOfDeath: TouchOfDeath,\r\n    comboStrikes: ComboStrikes,\r\n    blackoutKick: BlackoutKick,\r\n\r\n    // Items:\r\n    lastEmperorsCapacitor: LastEmperorsCapacitor,\r\n    jadeIgnition: JadeIgnition,\r\n\r\n    // Covenants\r\n    fallenOrder: FallenOrder,\r\n  };\r\n}\r\n\r\nexport default CombatLogParser;\r\n","export default function calculateEffectiveDamage(event, increase) {\r\n  const raw = (event.amount || 0) + (event.absorbed || 0);\r\n  return raw - (raw / (1 + increase));\r\n}\r\n","import React from 'react';\r\n\r\n// https://thenounproject.com/term/duration/370713/\r\n// duration by Bohdan Burmich from the Noun Project\r\nconst Icon = ({ ...other }) => (\r\n  <svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"10 10 80 80\" className=\"icon\" {...other}>\r\n    <path d=\"M50,86.4865c17.4361,0,31.6216-14.1855,31.6216-31.6216c0-16.6168-12.8865-30.2714-29.1892-31.5189v-4.9677h7.2973v-4.8649  H40.2703v4.8649h7.2973v4.9677c-16.3027,1.2475-29.1892,14.902-29.1892,31.5189C18.3784,72.3009,32.5639,86.4865,50,86.4865z M52.4324,28.2236c3.1101,0.2817,6.0664,1.0982,8.7798,2.356l-8.7798,15.2073V28.2236z M47.5676,28.2236v26.6412 c0,1.1008,0.7393,2.0647,1.8029,2.3497c0.209,0.0561,0.4205,0.0827,0.6295,0.0827c0.8533,0,1.6642-0.4504,2.1065-1.2162 l13.3146-23.0616c6.8507,4.8503,11.3357,12.8315,11.3357,21.8454c0,14.7537-12.0031,26.7567-26.7568,26.7567 s-26.7568-12.003-26.7568-26.7567C23.2432,40.9315,33.9501,29.4573,47.5676,28.2236z\" />\r\n  </svg>\r\n);\r\n\r\nexport default Icon;\r\n","import Events, { ApplyBuffEvent, DamageEvent, FightEndEvent, RemoveBuffEvent } from 'parser/core/Events';\r\nimport Analyzer, { Options } from 'parser/core/Analyzer';\r\nimport { formatDuration } from 'common/format';\r\nimport calculateEffectiveDamage from 'parser/core/calculateEffectiveDamage';\r\nimport Spell from 'common/SPELLS/Spell';\r\nimport SpellUsable from 'parser/shared/modules/SpellUsable';\r\n\r\nconst debug = false;\r\n\r\nconst MS_BUFFER = 500;\r\n\r\nclass ExecuteHelper extends Analyzer {\r\n  static dependencies = {\r\n    spellUsable: SpellUsable,\r\n  };\r\n\r\n  protected spellUsable!: SpellUsable;\r\n\r\n  //region IMPLEMENTME statics\r\n  /**\r\n   * Array of objects from common/SPELLS\r\n   * This should contain any execute spells such as Kill Shot, Execute etc.\r\n   */\r\n  static executeSpells: Spell[] = [];\r\n\r\n  /**\r\n   * SELECTED_PLAYER or SELECTED_PLAYER_PET for usage in the eventfilter\r\n   */\r\n  static executeSources: number;\r\n\r\n  /**\r\n   * Array of objects from common/SPELLS\r\n   * This should contain any SPELLS object that allows execute to be used outside normal execute range\r\n   */\r\n  static executeOutsideRangeEnablers: Spell[] = [];\r\n\r\n  /**\r\n   * The lower threshold where execute is enabled, shown in decimals.\r\n   */\r\n  static lowerThreshold: number;\r\n\r\n  /**\r\n   * The upper threshold where an execute can be enabled immediately at a pull, shown in decimals.\r\n   */\r\n  static upperThreshold: number;\r\n\r\n  /**\r\n   * A boolean representing if the given execute modifies the damage of an existing spell.\r\n   * An execute spell should be labelled as false, whereas a talent that modifies an existing spell should be labelled as true.\r\n   */\r\n  static modifiesDamage: boolean;\r\n\r\n  /**\r\n   * represents the modifier of of a talent (or some other effect) that modifies the damage done by an existing spell\r\n   */\r\n  static damageModifier: number;\r\n  //endregion\r\n\r\n  //region Generic Variables\r\n  /**\r\n   * Is true if we're in an execute window either because of a buff giving access to execute spells or because of health windows\r\n   */\r\n  inExecuteWindow: boolean = false;\r\n\r\n  /**\r\n   * Is true if we're in an execute window due to health on a target, so a buff granting access to execute is pointless at this point\r\n   */\r\n  inHealthExecuteWindow: boolean = false;\r\n\r\n  /**\r\n   * A variable marking the timestamp of the start of the current execute window\r\n   */\r\n  executeWindowStart: number = 0;\r\n\r\n  /**\r\n   * A variable marking the timestamp of the last damage event within the execute window\r\n   */\r\n  lastExecuteHitTimestamp: number = 0;\r\n\r\n  /**\r\n   * The amount of time spent inside executewindows, either caused by health or by buffs giving access to execute\r\n   */\r\n  totalExecuteWindowDuration: number = 0;\r\n\r\n  /**\r\n   * Amount of damage done by the spells defined in executeSpells\r\n   */\r\n  damage: number = 0;\r\n\r\n  /**\r\n   * returns the total amount of casts of the executes listed in executeSpells\r\n   */\r\n  casts: number = 0;\r\n\r\n  /**\r\n   * returns the amount of casts of the executes listed in executeSpells that were cast whilst being in an execute window\r\n   */\r\n  castsWithExecute: number = 0;\r\n  //endregion\r\n\r\n  //region Execute helpers\r\n  /**\r\n   * Returns true if the event has less HP than the threshold.\r\n   * This is useful for any generic execute.\r\n   * @param event\r\n   */\r\n  isTargetInExecuteRange(event: DamageEvent) {\r\n    if (!event.hitPoints || !event.maxHitPoints) {\r\n      return false;\r\n    }\r\n    return (event.hitPoints / event.maxHitPoints) < this.lowerThreshold;\r\n  }\r\n\r\n  /**\r\n   * Returns true if the event has more HP than the threshold.\r\n   * This is useful for things like Firestarter and Flashpoint.\r\n   * @param event\r\n   */\r\n  isTargetInReverseExecuteRange(event: DamageEvent) {\r\n    if (!event.hitPoints || !event.maxHitPoints) {\r\n      return false;\r\n    }\r\n    return (event.hitPoints / event.maxHitPoints) > this.upperThreshold;\r\n  }\r\n\r\n  /**\r\n   * Returns true if either isTargetInExecuteRange() or isTargetInReverseExecuteRange() is true.\r\n   * @param event\r\n   */\r\n  isTargetInHealthExecuteWindow(event: DamageEvent) {\r\n    if (!event.hitPoints || !event.maxHitPoints) {\r\n      return false;\r\n    }\r\n    return (this.isTargetInExecuteRange(event) || this.isTargetInReverseExecuteRange(event));\r\n  }\r\n\r\n  /**\r\n   * Returns true if the combatant has one of the buffs that enable execute to be used outside of the regular execute windows\r\n   */\r\n  get isExecuteUsableOutsideExecuteRange() {\r\n    let usable: boolean = false;\r\n    this.executeOutsideRangeEnablers.forEach(spell => {\r\n      if (this.selectedCombatant.hasBuff(spell.id)) {\r\n        usable = true;\r\n      }\r\n    });\r\n    return usable;\r\n  }\r\n\r\n  /**\r\n   * If all execute spells are on cooldown, then we should count the entire period of cooldown as \"inside execute\" to properly calculate maxCasts\r\n   */\r\n  get areExecuteSpellsOnCD() {\r\n    let allOnCD: boolean = true;\r\n    this.executeSpells.forEach(spell => {\r\n      if (!this.spellUsable.isOnCooldown(spell.id)) {\r\n        allOnCD = false;\r\n      }\r\n    });\r\n    return allOnCD;\r\n  }\r\n\r\n  //endregion\r\n\r\n  constructor(options: Options) {\r\n    super(options);\r\n    this.addEventListener(Events.damage.by(this.executeSources), this.onGeneralDamage);\r\n    this.addEventListener(Events.cast.by(this.executeSources).spell(this.executeSpells), this.onExecuteCast);\r\n    this.addEventListener(Events.damage.by(this.executeSources).spell(this.executeSpells), this.onExecuteDamage);\r\n    this.addEventListener(Events.applybuff.to(this.executeSources).spell(this.executeOutsideRangeEnablers), this.applyExecuteEnablerBuff);\r\n    this.addEventListener(Events.removebuff.to(this.executeSources).spell(this.executeOutsideRangeEnablers), this.removeExecuteEnablerBuff);\r\n    this.addEventListener(Events.fightend, this.onFightEnd);\r\n  }\r\n\r\n  //region Static Getters\r\n  get executeSources() {\r\n    const ctor = this.constructor as typeof ExecuteHelper;\r\n    return ctor.executeSources;\r\n  }\r\n\r\n  get executeSpells() {\r\n    const ctor = this.constructor as typeof ExecuteHelper;\r\n    return ctor.executeSpells;\r\n  }\r\n\r\n  get executeOutsideRangeEnablers() {\r\n    const ctor = this.constructor as typeof ExecuteHelper;\r\n    return ctor.executeOutsideRangeEnablers;\r\n  }\r\n\r\n  get lowerThreshold() {\r\n    const ctor = this.constructor as typeof ExecuteHelper;\r\n    return ctor.lowerThreshold;\r\n  }\r\n\r\n  get upperThreshold() {\r\n    const ctor = this.constructor as typeof ExecuteHelper;\r\n    return ctor.upperThreshold;\r\n  }\r\n\r\n  get modifiesDamage() {\r\n    const ctor = this.constructor as typeof ExecuteHelper;\r\n    return ctor.modifiesDamage;\r\n  }\r\n\r\n  get damageModifier() {\r\n    const ctor = this.constructor as typeof ExecuteHelper;\r\n    return ctor.damageModifier;\r\n  }\r\n\r\n  //endregion\r\n\r\n  //region Generic Getters\r\n  get executeDamage() {\r\n    return this.damage;\r\n  }\r\n\r\n  get totalExecuteDuration() {\r\n    return this.totalExecuteWindowDuration;\r\n  }\r\n\r\n  get totalCasts() {\r\n    return this.casts;\r\n  }\r\n\r\n  get totalExecuteCasts() {\r\n    return this.castsWithExecute;\r\n  }\r\n\r\n  //endregion\r\n\r\n  //region Event Listener functions\r\n  onGeneralDamage(event: DamageEvent) {\r\n    if (event.targetIsFriendly) {\r\n      return;\r\n    }\r\n    if (this.areExecuteSpellsOnCD || this.isExecuteUsableOutsideExecuteRange || this.isTargetInHealthExecuteWindow(event)) {\r\n      this.lastExecuteHitTimestamp = event.timestamp;\r\n      if (!this.inExecuteWindow) {\r\n        this.inExecuteWindow = true;\r\n        this.inHealthExecuteWindow = true;\r\n        this.executeWindowStart = event.timestamp;\r\n        debug && console.log('Execute window started');\r\n      }\r\n    } else {\r\n      if (this.inExecuteWindow && event.timestamp > this.lastExecuteHitTimestamp + MS_BUFFER) {\r\n        this.inExecuteWindow = false;\r\n        this.inHealthExecuteWindow = false;\r\n        this.totalExecuteWindowDuration += event.timestamp - this.executeWindowStart;\r\n        debug && console.log('Execute window ended, current total: ', this.totalExecuteDuration);\r\n      }\r\n    }\r\n  }\r\n\r\n  onExecuteCast() {\r\n    this.casts += 1;\r\n    if (this.inExecuteWindow || this.inHealthExecuteWindow) {\r\n      this.castsWithExecute += 1;\r\n    }\r\n  }\r\n\r\n  onExecuteDamage(event: DamageEvent) {\r\n    if (this.inExecuteWindow || this.inHealthExecuteWindow) {\r\n      if (this.modifiesDamage) {\r\n        this.damage += calculateEffectiveDamage(event, this.damageModifier);\r\n      } else {\r\n        this.damage += event.amount + (event.absorbed || 0);\r\n      }\r\n    }\r\n  }\r\n\r\n  applyExecuteEnablerBuff(event: ApplyBuffEvent) {\r\n    if (!this.inExecuteWindow && !this.inHealthExecuteWindow) {\r\n      this.executeWindowStart = event.timestamp;\r\n    }\r\n    this.inExecuteWindow = true;\r\n    this.lastExecuteHitTimestamp = event.timestamp;\r\n    debug && console.log(event.ability.name, ' was applied starting the execute window');\r\n  }\r\n\r\n  removeExecuteEnablerBuff(event: RemoveBuffEvent) {\r\n    if (!this.inHealthExecuteWindow) {\r\n      this.inExecuteWindow = false;\r\n      this.totalExecuteWindowDuration += event.timestamp - this.executeWindowStart;\r\n      debug && console.log(event.ability.name, ' was removed ending the execute window, current total: ', this.totalExecuteDuration);\r\n    } else {\r\n      debug && console.log('Execute enabler buff ended, but inside execute health window so window still ongoing.');\r\n    }\r\n  }\r\n\r\n  onFightEnd(event: FightEndEvent) {\r\n    if (this.inExecuteWindow) {\r\n      this.totalExecuteWindowDuration += event.timestamp - this.executeWindowStart;\r\n      this.inExecuteWindow = false;\r\n    }\r\n    debug && console.log('Fight ended, total duration of execute: ' + this.totalExecuteDuration + ' | ' + formatDuration(this.totalExecuteDuration));\r\n  }\r\n\r\n  //endregion\r\n}\r\n\r\nexport default ExecuteHelper;\r\n","import Analyzer, { SELECTED_PLAYER } from 'parser/core/Analyzer';\r\nimport Haste from 'parser/shared/modules/Haste';\r\nimport EventEmitter from 'parser/core/modules/EventEmitter';\r\nimport SpellResourceCost from 'parser/shared/modules/SpellResourceCost';\r\nimport HIT_TYPES from 'game/HIT_TYPES';\r\nimport Events from 'parser/core/Events';\r\n\r\n// turn on debug to find if there's inaccuracies, then verboseDebug to help track the cause.\r\nconst debug = false;\r\nconst verboseDebug = false;\r\n\r\n/**\r\n * Tracks when a regenerating resource reaches its cap. Most useful for specs such as rogues\r\n * and feral druids where their energy resource quickly recharges through natural regeneration\r\n * and may frequently reach its cap during a fight.\r\n *\r\n * It is an 'abstract' class, so should be extended and provided with settings for the resource\r\n * being tracked by your spec. Search for \"IMPLEMENTME\" for what should be set up.\r\n *\r\n * Reductions in spell costs should be handled by implementing parser/core/Modules/SpellResourceCost\r\n * for the relevant resource.\r\n *\r\n * If your derived class shares event handlers remember to call the original, e.g.\r\n * onCast(event) {\r\n *  super.onCast(event);\r\n *  // stuff related to your spec's implementation\r\n * }\r\n *\r\n * Example derived class: parser/Druid/Feral/Modules/Features/EnergyCapTracker\r\n *\r\n * For a more complete picture of how a combatant is using their resources you may want to\r\n * also use parser/core/Modules/ResourceTracker\r\n * ResourceTracker handles how it's energized and spent, RegenResourceCapTracker will tell\r\n * you about natural regeneration and how long it's at cap.\r\n *\r\n * The accuracy of this module's predictions depends heavily on finding the \"quirks\" of how\r\n * abilities and their resource behaviours appear in the combat log. It can never be perfectly\r\n * accurate due to resources being rounded to integer values and latency issues, but an error\r\n * of less than 2 should be possible.\r\n *\r\n * Fabricates events 'beginresourcecap' and 'endresourcecap'. See the functions fabricateBeginCap\r\n * and fabricateEndCap for details on these events and their limitations.\r\n */\r\n\r\n/**\r\n * How far (in ms) damage event can be separated from a cast and still use its information\r\n * to decide there should be a resource refund due to not hiting. 208ms is highest I've seen.\r\n */\r\nconst REFUND_SPENDER_WINDOW = 500;\r\nconst HIT_TYPES_THAT_REFUND = [\r\n  HIT_TYPES.MISS,\r\n  HIT_TYPES.DODGE,\r\n  HIT_TYPES.PARRY,\r\n];\r\n\r\n/**\r\n * @property {EventEmitter} eventEmitter\r\n * @property {Haste} haste\r\n * @property {SpellResourceCost} spellResourceCost\r\n */\r\nclass RegenResourceCapTracker extends Analyzer {\r\n  static dependencies = {\r\n    eventEmitter: EventEmitter,\r\n    haste: Haste,\r\n    // Needed for the `resourceCost` prop of events\r\n    spellResourceCost: SpellResourceCost,\r\n  };\r\n\r\n  // -- Start of IMPLEMENTME statics\r\n\r\n  // One of game/RESOURCE_TYPES\r\n  static resourceType;\r\n\r\n  // Resource's base regeneration rate in points per second (e.g. 10 for Energy)\r\n  static baseRegenRate = 0;\r\n\r\n  /**\r\n   * Is natural regeneration rate increased by haste.\r\n   * If a resource is affected by haste in an unusual way, set false and handle it manually in naturalRegenRate\r\n   */\r\n  static isRegenHasted = false;\r\n\r\n  /**\r\n   * Any buff or debuff IDs that change the max value for this resource. e.g. Berserk for Feral.\r\n   * Remember to check for their presence and apply the effect in currentMaxResource\r\n   */\r\n  static buffsChangeMax = [];\r\n\r\n  /**\r\n   * Any buff or debuff IDs that directly affect natural regeneration rate for this resource. e.g. Adrenaline Rush for Outlaw.\r\n   * Remember to check for their presence and apply the effect in naturalRegenRate\r\n   */\r\n  static buffsChangeRegen = [];\r\n\r\n  // Events for some abilities give inaccurate \"amount\" values, so their change is best applied cumulatively.\r\n  static energizersToApplyCumulatively = [];\r\n  static castsToApplyCumulatively = [];\r\n  static drainsToApplyCumulatively = [];\r\n\r\n  /**\r\n   * How close (in ms) a resource changing event must be to the last one to have the change handled cumulatively.\r\n   *\r\n   * When resource changing events occur in a very short time the values in the combat log can become inaccurate.\r\n   *  What happens in the fight:\r\n   * t: 1  player has 50 energy\r\n   * t: 2  cast spending 20 energy\r\n   * t: 2  energize gaining 30 energy\r\n   * t: 3  player has 60 energy\r\n   *\r\n   *  What the log shows:\r\n   * cast {timestamp: 2, classResources[i]: {amount: 50, cost: 20}}\r\n   * energize {timestamp: 2, resourceChange: 30, classResources[i]: {amount: 80}}\r\n   * ('amount' for cast events is what it was before the event, for energize events it's after.)\r\n   *\r\n   * If we trusted the resource information given by the last parsed event we'd expect energy to\r\n   * be 80 at t = 3.\r\n   */\r\n  static cumulativeEventWindow = 100;\r\n\r\n  /**\r\n   * For some specs (e.g. energy for rogues and feral) a ability that doesn't hit refunds some of the resource.\r\n   * A value of 0 means no refund, 0.8 seems to be the standard refund amount.\r\n   */\r\n  static resourceRefundOnMiss = 0;\r\n\r\n  // Some abilities never get their resources refunded, usually AoEs. List their spellIds here.\r\n  static exemptFromRefund = [];\r\n\r\n  // -- end of IMPLEMENTME statics\r\n\r\n  // Total time spent with resource at maximum (in ms)\r\n  atCap = 0;\r\n\r\n  // Total resources lost from natural regeneration (ONLY natural regeneration) due to being capped\r\n  missedRegen = 0;\r\n\r\n  // Total resources generated from natural regeneration, includes wasted resources.\r\n  naturalRegen = 0;\r\n\r\n  regenState = null;\r\n  prevSpender = null;\r\n  hasReportedBelowCap = false;\r\n\r\n  /**\r\n   * Amount of resource that should be available at current timestamp, accounting for natural regeneration.\r\n   * @returns {number}\r\n   */\r\n  get current() {\r\n    return this.predictValue(this.owner.currentTimestamp);\r\n  }\r\n\r\n  /**\r\n   * Whether the resource is at its cap at the current timestamp.\r\n   * @returns {boolean}\r\n   */\r\n  get isCapped() {\r\n    return this.current >= this.regenState.max;\r\n  }\r\n\r\n  /**\r\n   * What fraction of the fight was spent with this resource at its cap.\r\n   * @returns {number}\r\n   */\r\n  get cappedProportion() {\r\n    return this.atCap / this.owner.fightDuration;\r\n  }\r\n\r\n  /**\r\n   * Resource lost from natural regeneration (only from natural regeneration, not energizers) due\r\n   * to the resource reaching cap, averaged to a per-minute value.\r\n   */\r\n  get missedRegenPerMinute() {\r\n    return (this.missedRegen / this.owner.fightDuration) * 1000 * 60;\r\n  }\r\n\r\n  constructor(...args) {\r\n    super(...args);\r\n    // can't know resource state for certain until the first combat events, but assume a regenerating resource starts full.\r\n    const max = this.currentMaxResourceWithFallback();\r\n    this.regenState = {\r\n      amount: max ? max : 0,\r\n      max,\r\n      regen: this.naturalRegenRate(),\r\n      timestamp: this.owner.fight.start_time,\r\n    };\r\n    this.addEventListener(Events.fightend, this.onFightend);\r\n    this.addEventListener(Events.energize.to(SELECTED_PLAYER), this.onEnergize);\r\n    this.addEventListener(Events.cast.by(SELECTED_PLAYER), this.onCast);\r\n    this.addEventListener(Events.damage.by(SELECTED_PLAYER), this.onDamage);\r\n    this.addEventListener(Events.drain.by(SELECTED_PLAYER), this.onDrain);\r\n    this.addEventListener(Events.applybuff.to(SELECTED_PLAYER), this.onApplyBuff);\r\n    this.addEventListener(Events.removebuff.to(SELECTED_PLAYER), this.onRemoveBuff);\r\n    this.addEventListener(Events.ChangeHaste.to(SELECTED_PLAYER), this.onChangeHaste);\r\n  }\r\n\r\n  /**\r\n   * IMPLEMENTME\r\n   * Some specs have drain reductions that aren't already shown in events, which should be implemented\r\n   * here. Drain events are separate from an ability cast cost.\r\n   * @param   {object}  event A drain event being applied to the player.\r\n   * @returns {number}  Drain amount after any reductions are applied.\r\n   */\r\n  getReducedDrain(event) {\r\n    return event.resourceChange;\r\n  }\r\n\r\n  /**\r\n   * IMPLEMENTME\r\n   * Some specs have modifiers to the base regen rate that apply before haste, which should\r\n   * be implemented here.\r\n   * @returns {number} Base regen rate of the resource.\r\n   */\r\n  getBaseRegenRate(){\r\n    return this.constructor.baseRegenRate;\r\n  }\r\n\r\n  /**\r\n   * IMPLEMENTME\r\n   * Calculate current natural regeneration rate of the resource.\r\n   * When checking combant's buffs/debuffs you may want to use this.combatantHasBuffActive() rather than\r\n   * the .hasBuff of the combatant directly, doing so will exclude buffs which wore off at this timestamp.\r\n   * @returns {number}  Resource expected to be generated per ms.\r\n   */\r\n  naturalRegenRate() {\r\n    let regen = this.getBaseRegenRate() / 1000;\r\n    if (this.constructor.isRegenHasted) {\r\n      regen *= (1 + this.haste.current);\r\n    }\r\n    return regen;\r\n  }\r\n\r\n  /**\r\n   * IMPLEMENTME\r\n   * Calculate current maximum value for the resource. Accounting for items, talents, and active buffs.\r\n   * When checking combant's buffs/debuffs you may want to use this.combatantHasBuffActive() rather than\r\n   * the .hasBuff of the combatant directly, doing so will exclude buffs which wore off at this timestamp.\r\n   * @returns {number}  Maximum resource value, or null to try to use value from resource events.\r\n   */\r\n  currentMaxResource() {\r\n   /**\r\n    * If left unimplemented and no events provide max resource information the Analyzer will never know\r\n    * the resource's max value. It handles that situation without crashing, but without a cap value it\r\n    * is largely useless.\r\n    */\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Applies an energize of the tracked resource type at the current timestamp.\r\n   * Use when a spec has a source of resource which doesn't appear as an energize event in the log.\r\n   * If you have an invisible energize that happens over a duration you should generate an event for\r\n   * each tick, as applying it all at once can lead to inaccuracies. If it doesn't have ticks consider\r\n   * handling it as a buff to the natural regeneration rate instead.\r\n   * @param {number} amount Raw amount of resources to gain. Limiting to max is done within this function\r\n   * so there's no need to check before passing it in.\r\n   */\r\n  processInvisibleEnergize(amount) {\r\n    if (amount == null || isNaN(amount)) {\r\n      throw new Error(`processInvisibleEnergize called without required parameter. amount: ${amount}`);\r\n    }\r\n    if (amount === 0) {\r\n      return;\r\n    }\r\n    const before = this.current;\r\n    const after = Math.min(before + amount, this.currentMaxResourceWithFallback());\r\n    const gain = after - before;\r\n    this.applyEnergize(gain);\r\n  }\r\n\r\n  /**\r\n   * Fetches the appropriate classResources object from an event, or null if there is none available.\r\n   * @param {object} event An event object which may have an appropriate .classResources property.\r\n   */\r\n  getResource(event) {\r\n    if (!event || !event.classResources) {\r\n      return null;\r\n    }\r\n    return event.classResources.find(r => r.type === this.constructor.resourceType.id);\r\n  }\r\n\r\n  /**\r\n   * Fetches the cost of a cast event. Using its resourceCost property (added by SpellResourceCost)\r\n   * if it's available or the resource cost given by the combat log if not.\r\n   * @param {object} event A cast event object with a resource cost associated with it.\r\n   */\r\n  getCost(event) {\r\n    if (event.resourceCost[this.constructor.resourceType.id] !== undefined) {\r\n      return event.resourceCost[this.constructor.resourceType.id];\r\n    }\r\n    return this.getResource(event).cost;\r\n  }\r\n\r\n  /**\r\n   * A variation of this.selectedCombatant.hasBuff that excludes any buffs which were removed on the timestamp.\r\n   * @param {number} buffId ID of buff or debuff to check for on the current combatant.\r\n   * @param {number} timestamp Time to check, or null to use current timestamp. Cannot be a future timestamp.\r\n   */\r\n  combatantHasBuffActive(buffId, timestamp = null) {\r\n    if (!buffId || isNaN(buffId)) {\r\n      throw new Error(`combatantHasBuffActive called without required parameter. buffId: ${buffId}`);\r\n    }\r\n    if (!timestamp) {\r\n      timestamp = this.owner.currentTimestamp;\r\n    }\r\n    const buffHistory = this.selectedCombatant.getBuffHistory(buffId);\r\n    return Boolean(buffHistory.find(buff => (buff.start <= timestamp && (!buff.end || buff.end > timestamp))));\r\n  }\r\n\r\n  onFightend() {\r\n    // updateState one last time to catch any resource capping after the final resource event\r\n    this.updateState(this.predictValue(this.owner.fight.end_time));\r\n    debug && console.log(`mean prediction error magnitude: ${this.debugMeanPredictionError.toFixed(2)}`);\r\n    debug && console.log(`greatest magnitude prediction error: ${this.debugGreatestError.toFixed(2)}`);\r\n  }\r\n\r\n  onEnergize(event) {\r\n    if(event.resourceChangeType !== this.constructor.resourceType.id || !event.resourceChange) {\r\n      return;\r\n    }\r\n    const waste = event.waste ? event.waste : 0;\r\n    const gain = event.resourceChange - waste;\r\n    const applyCumulatively = this.constructor.energizersToApplyCumulatively.includes(event.ability.guid);\r\n    this.applyEnergize(gain, event, applyCumulatively);\r\n  }\r\n\r\n  applyEnergize(gain, event = null, applyCumulatively = false) {\r\n    if (gain == null || isNaN(gain)) {\r\n      // using == null to catch undefined, but still allow 0\r\n      throw new Error(`applyEnergize called without required parameter. gain: ${gain}`);\r\n    }\r\n    const time = event ? event.timestamp : this.owner.currentTimestamp;\r\n    const eventResource = event ? this.getResource(event) : null;\r\n\r\n    const shouldAccumulate = applyCumulatively ||\r\n      this.isLastUpdateRecent(time) ||\r\n      !eventResource || eventResource.amount == null;\r\n\r\n    // eventResource.amount for an energize is the value after the change\r\n    const current = shouldAccumulate ? (this.predictValue(time) + gain) : eventResource.amount;\r\n    if (debug && !shouldAccumulate) {\r\n      this.debugActualVsPredicted(eventResource.amount - gain, time);\r\n    }\r\n    const max = this.currentMaxResourceWithFallback(event);\r\n    this.updateState(current, max);\r\n  }\r\n\r\n  onCast(event) {\r\n    const eventResource = this.getResource(event);\r\n    if (!eventResource) {\r\n      return;\r\n    }\r\n    const cost = this.getCost(event);\r\n    if (!cost) {\r\n      // only interested in cast events that spend resource\r\n      return;\r\n    }\r\n    if (cost < 0) {\r\n      debug && console.warn(`${this.owner.formatTimestamp(event.timestamp, 3)} Unexpected negative cost ${cost} for spell ${event.ability.guid}`);\r\n    }\r\n    if (!this.constructor.exemptFromRefund.includes(event.ability.guid)) {\r\n      this.prevSpender = {\r\n        id: event.ability.guid,\r\n        cost,\r\n        timestamp: event.timestamp,\r\n      };\r\n    }\r\n\r\n    const shouldAccumulate = eventResource.amount == null ||\r\n      this.constructor.castsToApplyCumulatively.includes(event.ability.guid) ||\r\n      this.isLastUpdateRecent(event.timestamp);\r\n    const current = (shouldAccumulate ? this.predictValue(event.timestamp) : eventResource.amount) - cost;\r\n    if (debug && !shouldAccumulate) {\r\n      this.debugActualVsPredicted(eventResource.amount, event.timestamp);\r\n    }\r\n    const max = this.currentMaxResourceWithFallback(event);\r\n    this.updateState(current, max);\r\n  }\r\n\r\n  onDamage(event) {\r\n    // only interested in damage events if they show a spending ability failing to connect (and so triggering a refund)\r\n    if (!this.prevSpender || event.ability.guid !== this.prevSpender.id ||\r\n        (event.timestamp - this.prevSpender.timestamp) > REFUND_SPENDER_WINDOW ||\r\n        event.tick || !HIT_TYPES_THAT_REFUND.includes(event.hitType)) {\r\n      return;\r\n    }\r\n    verboseDebug && console.log(`${this.owner.formatTimestamp(this.owner.currentTimestamp, 3)} attack didn't connect so restoring ${Math.round(this.constructor.resourceRefundOnMiss * 100)}% resource`);\r\n    const refund = Math.floor(this.prevSpender.cost * this.constructor.resourceRefundOnMiss);\r\n    const current = this.predictValue(event.timestamp) + refund;\r\n    this.updateState(current);\r\n  }\r\n\r\n  onDrain(event) {\r\n    if(event.resourceChangeType !== this.constructor.resourceType.id || !event.resourceChange) {\r\n      return;\r\n    }\r\n    const eventResource = this.getResource(event);\r\n    const drain = this.getReducedDrain(event);\r\n\r\n    const shouldAccumulate = !eventResource || eventResource.amount == null ||\r\n      this.constructor.energizersToApplyCumulatively.includes(event.ability.guid) ||\r\n      this.isLastUpdateRecent(event.timestamp);\r\n\r\n    // eventResource.amount for a drain is the value before the change\r\n    const current = (shouldAccumulate ? this.predictValue(event.timestamp) : eventResource.amount) - drain;\r\n    if (debug && !shouldAccumulate) {\r\n      this.debugActualVsPredicted(eventResource.amount, event.timestamp);\r\n    }\r\n    const max = this.currentMaxResourceWithFallback(event);\r\n    this.updateState(current, max);\r\n  }\r\n\r\n  isLastUpdateRecent(timestamp) {\r\n    return this.regenState.timestamp + this.constructor.cumulativeEventWindow >= timestamp;\r\n  }\r\n\r\n  onApplyBuff(event) {\r\n    if (this.constructor.buffsChangeMax.includes(event.ability.guid)) {\r\n      this.buffChangesResourceMax(event);\r\n    }\r\n    if (this.constructor.buffsChangeRegen.includes(event.ability.guid)) {\r\n      this.buffChangesRegen();\r\n    }\r\n  }\r\n\r\n  onRemoveBuff(event) {\r\n    if (this.constructor.buffsChangeMax.includes(event.ability.guid)) {\r\n      this.buffChangesResourceMax(event);\r\n    }\r\n    if (this.constructor.buffsChangeRegen.includes(event.ability.guid)) {\r\n      this.buffChangesRegen();\r\n    }\r\n  }\r\n\r\n  onChangeHaste() {\r\n    const regen = this.naturalRegenRate();\r\n    this.updateState(null, null, regen);\r\n  }\r\n\r\n  buffChangesResourceMax(event) {\r\n    const max = this.currentMaxResourceWithFallback(event);\r\n    this.updateState(null, max);\r\n  }\r\n\r\n  buffChangesRegen() {\r\n    const regen = this.naturalRegenRate();\r\n    this.updateState(null, null, regen);\r\n  }\r\n\r\n  /**\r\n   * Called when current, max, or regen rate for the resource has changed.\r\n   * Builds a new regenState reflecting the current state.\r\n   * Detects if resource capping occurred since the last regenState.\r\n   * @param {number} amount Current amount of resource, or null to use prediction.\r\n   * @param {number} max Current resource maximum, or null to use calculation.\r\n   * @param {number} regen Current resource regeneration rate, or null to use calculation.\r\n   */\r\n  updateState(amount = null, max = null, regen = null) {\r\n    const timestamp = this.owner.currentTimestamp;\r\n    verboseDebug && console.log(`${this.owner.formatTimestamp(timestamp, 3)} amount: ${amount ? amount.toFixed(1) : 'n/a'}, max: ${max ? max.toFixed(1) : 'n/a'} , regen: ${regen ? (regen * 1000).toFixed(3) : 'n/a'}`);\r\n    if (amount == null || isNaN(amount)) {\r\n      amount = this.predictValue(timestamp);\r\n    }\r\n    if (max == null || isNaN(max)) {\r\n      max = this.currentMaxResourceWithFallback();\r\n    }\r\n    if (regen == null || isNaN(regen)) {\r\n      regen = this.naturalRegenRate();\r\n    }\r\n    amount = max ? Math.min(max, amount) : amount;\r\n    const oldState = this.regenState;\r\n    const newState = {\r\n      amount,\r\n      max,\r\n      regen,\r\n      timestamp,\r\n    };\r\n    this.regenState = newState;\r\n    if (oldState) {\r\n      const durationCapped = this.timeCappedBetweenStates(oldState, newState);\r\n      this.atCap += durationCapped;\r\n      this.missedRegen += durationCapped * oldState.regen;\r\n      this.naturalRegen += (newState.timestamp - oldState.timestamp) * oldState.regen;\r\n    }\r\n    if (newState.amount < newState.max) {\r\n      this.onBelowCap(newState.timestamp);\r\n    }\r\n  }\r\n\r\n  timeCappedBetweenStates(oldState, newState) {\r\n    if (!oldState || !newState){\r\n      throw new Error(`timeCappedBetweenStates called without required parameters. oldState: ${oldState}, newState: ${newState}`);\r\n    }\r\n    const reachCap = oldState.max ? this.predictReachValue(oldState.timestamp, oldState.amount, oldState.regen, oldState.max) : Infinity;\r\n    if (reachCap >= newState.timestamp) {\r\n      return 0;\r\n    }\r\n    this.onAtCap(reachCap);\r\n\r\n    return newState.timestamp - reachCap;\r\n  }\r\n\r\n  currentMaxResourceWithFallback(event = null) {\r\n    const calculated = this.currentMaxResource();\r\n    if (calculated) {\r\n      return calculated;\r\n    }\r\n    const eventResource = this.getResource(event);\r\n    if (eventResource && eventResource.max != null && !isNaN(eventResource.max)) {\r\n      return eventResource.max;\r\n    }\r\n    // when neither source provides a value just use the existing\r\n    return this.regenState.max;\r\n  }\r\n\r\n  /**\r\n   * Given a start value and regen rate, calculate when resource will reach a given value.\r\n   * @param {number} startTime Timestamp for known resource value\r\n   * @param {number} startValue Known resource value\r\n   * @param {number} regen Regeneration rate in units per ms\r\n   * @param {number} targetValue Resource value being aimed for\r\n   * @returns {number} Timestamp when targetValue would be reached through natural regen.\r\n   */\r\n  predictReachValue(startTime, startValue, regen, targetValue) {\r\n    if (startValue == null || isNaN(startValue) ||\r\n        regen == null || isNaN(regen) ||\r\n        targetValue == null || isNaN(targetValue) ||\r\n        startTime == null || isNaN(startTime)) {\r\n      throw new Error(`predictReachValue called without required parameters. startValue: ${startValue}, regen: ${regen}, cap: ${targetValue}, startTime: ${startTime}`);\r\n    }\r\n    if (startValue >= targetValue) {\r\n      return startTime;\r\n    }\r\n    if (regen === 0) {\r\n      return Infinity;\r\n    }\r\n    return startTime + ((targetValue - startValue) / regen);\r\n  }\r\n\r\n  /**\r\n   * Calculates available resource accounting for natural regen.\r\n   * @param {number} time Timestamp for which to create a prediction, or null for current timestamp.\r\n   * @returns {number} Predicted resource value at given time.\r\n   */\r\n  predictValue(time = null) {\r\n    if (!time) {\r\n      time = this.owner.currentTimestamp;\r\n    }\r\n    if (time < this.regenState.timestamp) {\r\n      debug && console.warn(`Attempting to predict the past. State's time: ${this.owner.formatTimestamp(this.regenState.timestamp, 3)}, target time: ${this.owner.formatTimestamp(time, 3)}`);\r\n      return this.regenState.amount;\r\n    }\r\n    const elapsed = time - this.regenState.timestamp;\r\n    const predicted = this.regenState.amount + this.regenState.regen * elapsed;\r\n    return this.regenState.max ? Math.min(this.regenState.max, predicted) : predicted;\r\n  }\r\n\r\n  onBelowCap(time) {\r\n    if (this.hasReportedBelowCap) {\r\n      return;\r\n    }\r\n    this.fabricateEndCap(time);\r\n    this.hasReportedBelowCap = true;\r\n  }\r\n\r\n  onAtCap(time) {\r\n    if (!this.hasReportedBelowCap) {\r\n      return;\r\n    }\r\n    this.fabricateBeginCap(time);\r\n    this.hasReportedBelowCap = false;\r\n  }\r\n\r\n  /**\r\n   * Fabricates an event indicating the tracked resource has reached its cap value.\r\n   * May be triggered by an energize or natural regeneration bringing the value to the cap, or\r\n   * by the cap being lowered.\r\n   *\r\n   * Although the timestamp of this event should be accurate, because cap events are sometimes\r\n   * only detected after they happen it may be misplaced within the event stream.\r\n   * So do NOT assume that an event parsed between beginresourcecap and endresourcecap events\r\n   * being parsed happened while the resource was capped. Either look at the timestamps of\r\n   * the events or if you're interested in the current cap state use this analyzer's isCapped\r\n   *\r\n   * Also note that endresourcecap and beginresourcecap events may occur extremely close to\r\n   * one-another, sometimes on the same timestamp if there's a spend and energize event.\r\n   *\r\n   * @param {number} time Timestamp for when the resource reached cap.\r\n   */\r\n  fabricateBeginCap(time) {\r\n    if (time == null || isNaN(time)) {\r\n      throw new Error(`fabricateBeginCap called without required parameter. time: ${time}`);\r\n    }\r\n    verboseDebug && console.log(`${this.owner.formatTimestamp(time, 3)} begin cap`);\r\n    this.eventEmitter.fabricateEvent({\r\n      type: 'beginresourcecap',\r\n      timestamp: time,\r\n      sourceID: this.owner.playerId,\r\n      targetID: this.owner.playerId,\r\n      resourceType: this.constructor.resourceType.id,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Fabricates an event indicating that the tracked resource is no longer at its cap.\r\n   * May be triggered by cast or drain using resource or the cap value being increased.\r\n   * @param {number} time Timestamp for when the resource ceased to be at the cap.\r\n   */\r\n  fabricateEndCap(time) {\r\n    if (time == null || isNaN(time)) {\r\n      throw new Error(`fabricateEndCap called without required parameter. time: ${time}`);\r\n    }\r\n    verboseDebug && console.log(`${this.owner.formatTimestamp(time, 3)} end cap`);\r\n    this.eventEmitter.fabricateEvent({\r\n      type: 'endresourcecap',\r\n      timestamp: time,\r\n      sourceID: this.owner.playerId,\r\n      targetID: this.owner.playerId,\r\n      resourceType: this.constructor.resourceType.id,\r\n    });\r\n  }\r\n\r\n  // -- debug code to check accuracy of predictions against values reported by log\r\n  debugErrorSum = 0;\r\n  debugGreatestError = 0;\r\n  debugAccuracyCheckCount = 0;\r\n  debugActualVsPredicted(actual, timestamp) {\r\n    if (!debug) {\r\n      return;\r\n    }\r\n    const predicted = this.predictValue(timestamp);\r\n    const difference = predicted - actual;\r\n    const errorMagnitude = Math.abs(difference);\r\n    this.debugGreatestError = Math.max(this.debugGreatestError, errorMagnitude);\r\n    this.debugAccuracyCheckCount += 1;\r\n    this.debugErrorSum += errorMagnitude;\r\n    if (errorMagnitude > 3) {\r\n      console.log(`${this.owner.formatTimestamp(timestamp, 3)} actual: ${actual} prediction: ${predicted.toFixed(1)} (error: ${difference > 0 ? '+' : ''}${difference.toFixed(1)})`);\r\n    }\r\n  }\r\n  get debugMeanPredictionError() {\r\n    return this.debugErrorSum / this.debugAccuracyCheckCount;\r\n  }\r\n}\r\n\r\nexport default RegenResourceCapTracker;\r\n","import { SELECTED_PLAYER } from 'parser/core/Analyzer';\r\nimport Abilities from 'parser/core/modules/Abilities';\r\nimport SPELLS from 'common/SPELLS';\r\nimport Events from 'parser/core/Events';\r\nimport ExecuteHelper from 'parser/shared/ExecuteHelper';\r\n\r\nconst MINUTE = 600000;\r\n\r\nclass TouchOfDeath extends ExecuteHelper {\r\n  static executeSpells = [\r\n    SPELLS.TOUCH_OF_DEATH,\r\n  ];\r\n  static executeSources = SELECTED_PLAYER;\r\n  static lowerThreshold = 0.15;\r\n  static executeOutsideRangeEnablers = [];\r\n  static modifiesDamage = false;\r\n\r\n  static dependencies = {\r\n    ...ExecuteHelper.dependencies,\r\n    abilities: Abilities,\r\n  };\r\n\r\n  maxCasts = 0;\r\n\r\n  cooldown = MINUTE * 3;\r\n\r\n  constructor(options) {\r\n    super(options);\r\n    this.addEventListener(Events.fightend, this.adjustMaxCasts);\r\n\r\n    //FIXME added reduction from legendary when we can get that info\r\n\r\n    //if(hasLego) {\r\n    //  this.cooldown = this.cooldown - MINUTE;\r\n    // }\r\n\r\n    options.abilities.add({\r\n      spell: SPELLS.TOUCH_OF_DEATH,\r\n      category: Abilities.SPELL_CATEGORIES.COOLDOWNS,\r\n      cooldown: 180,\r\n      gcd: {\r\n        static: 1000,\r\n      },\r\n      castEfficiency: {\r\n        suggestion: true,\r\n        recommendedEfficiency: 0.85,\r\n        maxCasts: () => this.maxCasts || 0,\r\n      },\r\n    });\r\n  }\r\n\r\n  adjustMaxCasts(event) {\r\n    super.onFightEnd(event);\r\n    this.maxCasts += Math.ceil(this.totalExecuteDuration / this.cooldown);\r\n  }\r\n}\r\n\r\nexport default TouchOfDeath;\r\n","import Analyzer, { Options, SELECTED_PLAYER, SELECTED_PLAYER_PET } from 'parser/core/Analyzer';\r\nimport Abilities from 'parser/core/modules/Abilities';\r\nimport SPELLS from 'common/SPELLS';\r\nimport Events, { DamageEvent, HealEvent, SummonEvent } from 'parser/core/Events';\r\nimport Statistic from 'interface/statistics/Statistic';\r\nimport STATISTIC_ORDER from 'interface/others/STATISTIC_ORDER';\r\nimport STATISTIC_CATEGORY from 'interface/others/STATISTIC_CATEGORY';\r\nimport ItemDamageDone from 'interface/ItemDamageDone';\r\nimport ItemHealingDone from 'interface/ItemHealingDone';\r\nimport React from 'react';\r\nimport BoringSpellValueText from 'interface/statistics/components/BoringSpellValueText';\r\nimport { formatNumber } from 'common/format';\r\nimport COVENANTS from 'game/shadowlands/COVENANTS';\r\n\r\nclass FallenOrder extends Analyzer {\r\n  static dependencies = {\r\n    abilities: Abilities,\r\n  };\r\n  windDamage: number = 0;\r\n  brewDamage: number = 0;\r\n  mistDamage: number = 0;\r\n  mistHealing: number = 0;\r\n  mistOverhealing: number = 0;\r\n  cloneMap: Map<number, number> = new Map<number, number>();\r\n  protected abilities!: Abilities;\r\n\r\n  constructor(options: Options) {\r\n    super(options);\r\n\r\n    // In my testing this line always returns false but its what putput uses so I have faith\r\n    // it will work in the future. (might just be a bad log too)\r\n    this.active = this.selectedCombatant.hasCovenant(COVENANTS.VENTHYR.id);\r\n\r\n    if (!this.active) {\r\n      return;\r\n    }\r\n\r\n    this.abilities.add({\r\n      spell: SPELLS.FALLEN_ORDER_CAST,\r\n      category: Abilities.SPELL_CATEGORIES.COOLDOWNS,\r\n      cooldown: 180,\r\n      gcd: {\r\n        base: 1500,\r\n      },\r\n      castEfficiency: {\r\n        suggestion: true,\r\n        recommendedEfficiency: 0.8,\r\n      },\r\n    });\r\n\r\n    //summon events (need to track this to get melees)\r\n    this.addEventListener(Events.summon.by(SELECTED_PLAYER).spell([SPELLS.FALLEN_ORDER_OX_CLONE, SPELLS.FALLEN_ORDER_TIGER_CLONE, SPELLS.FALLEN_ORDER_CRANE_CLONE]), this.trackSummons);\r\n\r\n    //mistweaver spells\r\n    this.addEventListener(Events.heal.by(SELECTED_PLAYER_PET).spell([SPELLS.FALLEN_ORDER_ENVELOPING_MIST, SPELLS.FALLEN_ORDER_SOOTHING_MIST]), this.mistHealingTracker);\r\n    //brewmaster spells\r\n    this.addEventListener(Events.damage.by(SELECTED_PLAYER_PET).spell([SPELLS.FALLEN_ORDER_KEG_SMASH, SPELLS.FALLEN_ORDER_BREATH_OF_FIRE, SPELLS.BREATH_OF_FIRE_DEBUFF]), this.brewDamageTracker);\r\n    //windwalker spells\r\n    this.addEventListener(Events.damage.by(SELECTED_PLAYER_PET).spell([SPELLS.FALLEN_ORDER_SPINNING_CRANE_KICK, SPELLS.FISTS_OF_FURY_DAMAGE]), this.windDamageTracker);\r\n    //shared\r\n    this.addEventListener(Events.damage.by(SELECTED_PLAYER_PET).spell(SPELLS.MELEE), this.handleMelee);\r\n  }\r\n\r\n  trackSummons(event: SummonEvent) {\r\n    this.cloneMap.set(event.targetID, event.ability.guid);\r\n  }\r\n\r\n  mistHealingTracker(event: HealEvent) {\r\n    this.mistHealing += (event.amount || 0) + (event.absorbed || 0);\r\n    this.mistOverhealing += event.overheal || 0;\r\n  }\r\n\r\n  brewDamageTracker(event: DamageEvent) {\r\n    this.brewDamage += event.amount || 0;\r\n  }\r\n\r\n  windDamageTracker(event: DamageEvent) {\r\n    this.windDamage += event.amount || 0;\r\n  }\r\n\r\n  mistDamageTracker(event: DamageEvent) {\r\n    this.mistDamage += event.amount || 0;\r\n  }\r\n\r\n  handleMelee(event: DamageEvent) {\r\n    //if we don't know who its from then we can't add it\r\n    if (!event.sourceID) {\r\n      return;\r\n    }\r\n\r\n    const id: number = event.sourceID;\r\n\r\n    const cloneType: number | undefined = this.cloneMap.get(id);\r\n    //because typescript won't let me just do this.cloneMap.get(id) i might as well add a null check too\r\n    if (cloneType === undefined) {\r\n      return;\r\n    }\r\n\r\n    if (cloneType === SPELLS.FALLEN_ORDER_OX_CLONE.id) {\r\n      this.brewDamageTracker(event);\r\n    } else if (cloneType === SPELLS.FALLEN_ORDER_TIGER_CLONE.id) {\r\n      this.windDamageTracker(event);\r\n    } else {\r\n      this.mistDamageTracker(event);\r\n    }\r\n\r\n  }\r\n\r\n  statistic() {\r\n    const totalDamage: number = this.brewDamage + this.mistDamage + this.windDamage;\r\n\r\n    return (\r\n      <Statistic\r\n        position={STATISTIC_ORDER.CORE()}\r\n        size=\"flexible\"\r\n        category={STATISTIC_CATEGORY.COVENANTS}\r\n        tooltip={(\r\n          <>\r\n            <ul>\r\n              <li>Damage from Brewmaster clones: {formatNumber(this.brewDamage)}</li>\r\n              <li>Damage from Mistweaver clones: {formatNumber(this.mistDamage)}</li>\r\n              <li>Damage from Windwalker clones: {formatNumber(this.windDamage)}</li>\r\n            </ul>\r\n          </>\r\n        )}\r\n      >\r\n        <BoringSpellValueText spell={SPELLS.FALLEN_ORDER_CAST}>\r\n          <ItemHealingDone amount={this.mistHealing} /><br />\r\n          <ItemDamageDone amount={totalDamage} />\r\n        </BoringSpellValueText>\r\n      </Statistic>\r\n    );\r\n  }\r\n}\r\n\r\nexport default FallenOrder;\r\n"],"sourceRoot":""}