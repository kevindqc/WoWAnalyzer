{"version":3,"sources":["parser/rogue/shared/stealth/IsStealth.js","parser/rogue/shared/constants.ts","interface/statistics/components/BoringSpellValueText/index.tsx","parser/shared/modules/resources/resourcetracker/ResourceTracker.ts","parser/shared/modules/resources/resourcetracker/ResourceBreakdown.tsx","common/ResourceIcon.tsx","common/ResourceLink.tsx","../node_modules/react-animate-height/lib/AnimateHeight.js","parser/shared/modules/resources/resourcetracker/ResourceSuggest.tsx","parser/shared/modules/resources/resourcetracker/RegenResourceCapTracker.js","parser/rogue/shared/resources/ComboPointTracker.js","parser/rogue/shared/resources/EnergyTracker.js","parser/rogue/shared/resources/EnergyCapTracker.js","parser/rogue/shared/resources/ComboPointDetails.js","parser/rogue/shared/resources/EnergyDetails.js","parser/rogue/shared/resources/SpellEnergyCost.js","parser/rogue/shared/SpellUsable.js","parser/rogue/shared/shadowlands/covenants/necrolord/SerratedBoneSpike.tsx","parser/rogue/shared/shadowlands/covenants/kyrian/EchoingReprimand.tsx","parser/rogue/shared/shadowlands/covenants/nightfae/Sepsis.tsx","parser/rogue/shared/shadowlands/covenants/venthyr/Flagellation.tsx","parser/rogue/shared/shadowlands/legendaries/EssenceOfBloodfang.tsx","parser/rogue/shared/shadowlands/legendaries/InvigoratingShadowdust.tsx"],"names":["STEALTH_BUFFS","SPELLS","STEALTH","VANISH_BUFF","STEALTH_DANCE_BUFFS","SHADOW_DANCE","isStealth","combatant","delayWindow","some","s","hasBuff","id","isStealthOrDance","SHARED_ABILITY_COOLDOWNS","CRIMSON_VIAL","SPRINT","KIDNEY_SHOT","EVASION","FEINT","BLIND","CLOAK_OF_SHADOWS","TRICKS_OF_THE_TRADE","SHROUD_OF_CONCEALMENT","SUBTLETY_ABILITY_COOLDOWNS","SHADOWSTEP","SYMBOLS_OF_DEATH","SHADOW_BLADES","ASSASSINATION_ABILITY_COOLDOWNS","VENDETTA","OUTLAW_ABILITY_COOLDOWNS","BETWEEN_THE_EYES","BLADE_FLURRY","ROLL_THE_BONES","ADRENALINE_RUSH","GRAPPLING_HOOK","ASS_VEN_CDR_PER_ENERGY","BoringSpellValueText","spell","children","className","icon","ResourceTracker","options","eventEmitter","current","resourceUpdates","buildersObj","spendersObj","resource","maxResource","addEventListener","Events","energize","to","SELECTED_PLAYER","onEnergize","cast","by","onCast","spellId","this","generated","wasted","casts","spent","spentByCast","event","ability","guid","resourceChangeType","waste","gain","resourceChange","_applyBuilder","getResource","timestamp","amount","maxGain","undefined","Math","min","max","initBuilderAbility","push","used","shouldProcessCastEvent","eventResource","cost","getReducedCost","initSpenderAbility","triggerSpendEvent","resourceCost","classResources","find","r","type","fabricatedEvent","EventType","SpendResource","sourceID","targetID","__fabricated","fabricateEvent","Boolean","Object","values","reduce","acc","Analyzer","dependencies","EventEmitter","ResourceBreakdown","keys","map","abilityId","Number","sort","a","b","filter","props","tracker","showSpenders","resourceName","name","prepareGenerated","prepareSpent","totalGenerated","totalWasted","totalSpent","totalCasts","spendersCasts","colSpan","content","key","style","width","paddingRight","textAlign","formatPercentage","toFixed","React","Component","ResourceIcon","noLink","others","RESOURCE_TYPES","alt","ResourceLink","useState","elem","setElem","useEffect","TooltipProvider","refresh","category","other","href","target","rel","ref","defineProperty","exports","value","_typeof","Symbol","iterator","obj","constructor","prototype","_extends","assign","i","arguments","length","source","hasOwnProperty","call","_createClass","defineProperties","descriptor","enumerable","configurable","writable","Constructor","protoProps","staticProps","_react2","_interopRequireDefault","require","_propTypes2","_classnames2","__esModule","default","_defineProperty","ANIMATION_STATE_CLASSES","animating","animatingUp","animatingDown","animatingToHeightZero","animatingToHeightAuto","animatingToHeightSpecific","static","staticHeightZero","staticHeightAuto","staticHeightSpecific","PROPS_TO_OMIT","omit","_len","Array","_key","res","objectKeys","indexOf","cancelAnimationFrames","requestAnimationFrameIDs","forEach","cancelAnimationFrame","isNumber","n","isNaN","parseFloat","isFinite","isPercentage","height","search","substr","runCallback","callback","params","AnimateHeight","_React$Component","instance","TypeError","_classCallCheck","_this","self","ReferenceError","_possibleConstructorReturn","__proto__","getPrototypeOf","animationFrameIDs","overflow","animationStateClasses","getStaticStateClasses","state","shouldUseTransitions","subClass","superClass","create","setPrototypeOf","_inherits","contentElement","hideContent","prevProps","prevState","_this2","_props","delay","duration","onAnimationEnd","onAnimationStart","_cx","showContent","contentHeight","offsetHeight","totalDuration","newHeight","timeoutState","isCurrentHeightAuto","timeoutAnimationStateClasses","setState","clearTimeout","timeoutID","animationClassesTimeoutID","requestAnimationFrame","startAnimationHelper","setTimeout","display","_cx2","_cx3","_this3","_props2","animateOpacity","applyInlineTransitions","contentClassName","easing","_state","componentStyle","transition","WebkitTransition","contentStyle","opacity","componentClasses","ariaHidden","createElement","apply","concat","el","propTypes","bool","object","any","isRequired","string","number","propName","componentName","func","defaultProps","suggest","when","suggestion","tracked","isArray","newSuggestionSpell","maxGenerated","wastedShare","resourceNameLower","toLowerCase","isGreaterThan","minor","addSuggestion","extraSuggestion","actual","i18n","_","recommended","regular","avg","major","HIT_TYPES_THAT_REFUND","HIT_TYPES","MISS","DODGE","PARRY","RegenResourceCapTracker","args","atCap","missedRegen","naturalRegen","regenState","prevSpender","hasReportedBelowCap","debugErrorSum","debugGreatestError","debugAccuracyCheckCount","currentMaxResourceWithFallback","regen","naturalRegenRate","owner","fight","start_time","fightend","onFightend","damage","onDamage","drain","onDrain","applybuff","onApplyBuff","removebuff","onRemoveBuff","ChangeHaste","onChangeHaste","predictValue","currentTimestamp","fightDuration","baseRegenRate","getBaseRegenRate","isRegenHasted","haste","Error","before","applyEnergize","resourceType","buffId","buffHistory","selectedCombatant","getBuffHistory","buff","start","end","updateState","end_time","applyCumulatively","energizersToApplyCumulatively","includes","time","shouldAccumulate","isLastUpdateRecent","getCost","exemptFromRefund","castsToApplyCumulatively","tick","hitType","refund","floor","resourceRefundOnMiss","getReducedDrain","cumulativeEventWindow","buffsChangeMax","buffChangesResourceMax","buffsChangeRegen","buffChangesRegen","oldState","newState","durationCapped","timeCappedBetweenStates","onBelowCap","reachCap","predictReachValue","Infinity","onAtCap","calculated","currentMaxResource","startTime","startValue","targetValue","elapsed","predicted","fabricateEndCap","fabricateBeginCap","playerId","Haste","spellResourceCost","SpellResourceCost","drainsToApplyCumulatively","ComboPointTracker","COMBO_POINTS","EnergyTracker","ENERGY","EnergyCapTracker","hasTalent","VIGOR_TALENT","suggestionThresholds","position","STATISTIC_ORDER","CORE","wastedPercent","label","tooltip","cappedProportion","footer","formatDuration","src","isLessThan","average","SpellEnergyCost","ComboPointDetails","total","title","url","render","comboPointTracker","EnergyDetails","energyTracker","discountShadowFocus","SHADOW_FOCUS_TALENT","SpellUsable","markMap","MARKED_FOR_DEATH_TALENT","targetString","encodeTargetString","targetInstance","isOnCooldown","endCooldown","CoreSpellUsable","SerratedBoneSpike","comboPointsGained","comboPointsWasted","abilities","spellUsable","active","hasCovenant","COVENANTS","NECROLORD","SERRATED_BONE_SPIKE","SERRATED_BONE_SPIKE_ENERGIZE","removedebuff","SERRATED_BONE_SPIKE_DEBUFF","onSBSRemoveDebuff","absorbed","expectedCooldownDuration","getExpectedCooldownDuration","cooldownTriggerEvent","reduceCooldown","size","STATISTIC_CATEGORY","Abilities","EchoingReprimand","KYRIAN","ECHOING_REPRIMAND","ECHOING_REPRIMAND_ENERGIZE","Sepsis","poisonDamage","NIGHT_FAE","SEPSIS","SEPSIS_POISON","onPoisonDamage","formatNumber","Flagellation","lashDamage","VENTHYR","FLAGELLATION","FLAGELLATION_LASH","onLashDamage","EssenceOfBloodfang","bloodfangDamage","bloodfangHealing","hasLegendaryByBonusID","ESSENCE_OF_BLOODFANG","bonusID","heal","ESSENCE_OF_BLOODFANG_BUFF","onHeal","ITEMS","InvigoratingShadowdust","spec","cooldownReduction","cooldowns","specName","INVIGORATING_SHADOWDUST","VANISH","cooldown","index"],"mappings":"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","file":"static/js/5.09c65483.chunk.js","sourcesContent":["import SPELLS from 'common/SPELLS';\r\n\r\nconst STEALTH_BUFFS = [\r\n  SPELLS.STEALTH,\r\n  SPELLS.VANISH_BUFF,\r\n];\r\nconst STEALTH_DANCE_BUFFS = [\r\n  ...STEALTH_BUFFS,\r\n  SPELLS.SHADOW_DANCE,\r\n];\r\n\r\nfunction isStealth(combatant, delayWindow) {\r\n  return STEALTH_BUFFS.some(s => combatant.hasBuff(s.id, null, delayWindow));\r\n}\r\n\r\nfunction isStealthOrDance(combatant, delayWindow) {\r\n  return STEALTH_DANCE_BUFFS.some(s => combatant.hasBuff(s.id, null, delayWindow));\r\n}\r\n\r\nexport { isStealth, isStealthOrDance };\r\n","import SPELLS from 'common/SPELLS';\r\nimport { SpellList } from 'common/SPELLS/Spell';\r\n\r\nconst SHARED_ABILITY_COOLDOWNS: SpellList[] = [\r\n  SPELLS.CRIMSON_VIAL,\r\n  SPELLS.SPRINT,\r\n  SPELLS.KIDNEY_SHOT,\r\n  SPELLS.EVASION,\r\n  SPELLS.FEINT,\r\n  SPELLS.BLIND,\r\n  SPELLS.CLOAK_OF_SHADOWS,\r\n  SPELLS.TRICKS_OF_THE_TRADE,\r\n  SPELLS.SHROUD_OF_CONCEALMENT,\r\n];\r\n\r\nexport const SUBTLETY_ABILITY_COOLDOWNS: SpellList[] = [\r\n  SPELLS.SHADOWSTEP,\r\n  SPELLS.SHADOW_DANCE,\r\n  SPELLS.SYMBOLS_OF_DEATH,\r\n  SPELLS.SHADOW_BLADES,\r\n  ...SHARED_ABILITY_COOLDOWNS,\r\n];\r\n\r\nexport const ASSASSINATION_ABILITY_COOLDOWNS: SpellList[] = [\r\n  SPELLS.SHADOWSTEP,\r\n  SPELLS.VENDETTA,\r\n  ...SHARED_ABILITY_COOLDOWNS,\r\n];\r\n\r\nexport const OUTLAW_ABILITY_COOLDOWNS: SpellList[] = [\r\n  SPELLS.BETWEEN_THE_EYES,\r\n  SPELLS.BLADE_FLURRY,\r\n  SPELLS.ROLL_THE_BONES,\r\n  SPELLS.ADRENALINE_RUSH,\r\n  SPELLS.GRAPPLING_HOOK,\r\n  ...SHARED_ABILITY_COOLDOWNS,\r\n];\r\n\r\n//region Legendaries\r\n// 1 second per 65 energy cost\r\nexport const ASS_VEN_CDR_PER_ENERGY = 1000 / 65;\r\n//endregion\r\n","/**\r\n * A simple component that shows the spell value in the most plain way possible.\r\n * Use this only as the very last resort.\r\n */\r\nimport React from 'react';\r\n\r\nimport SpellIcon from 'common/SpellIcon';\r\nimport SpellLink from 'common/SpellLink';\r\nimport Spell from 'common/SPELLS/Spell';\r\n\r\ntype Props = {\r\n  spell: Spell;\r\n  children: React.ReactNode;\r\n  className?: string;\r\n}\r\n\r\nconst BoringSpellValueText = ({ spell, children, className }: Props) => (\r\n  <div className={`pad boring-text ${className || ''}`}>\r\n    <label>\r\n      <SpellIcon id={spell.id} /> <SpellLink id={spell.id} icon={false} />\r\n    </label>\r\n    <div className=\"value\">\r\n      {children}\r\n    </div>\r\n  </div>\r\n);\r\n\r\nexport default BoringSpellValueText;\r\n","import Analyzer, { SELECTED_PLAYER, Options } from 'parser/core/Analyzer';\r\nimport EventEmitter from 'parser/core/modules/EventEmitter';\r\nimport Events, { EventType, ClassResources, EnergizeEvent, CastEvent, HealEvent, SpendResourceEvent } from 'parser/core/Events';\r\nimport { Resource } from 'game/RESOURCE_TYPES';\r\n\r\nexport type BuilderObj = {\r\n  generated: number,\r\n  wasted: number,\r\n  casts: number,\r\n}\r\n\r\nexport type SpenderObj = {\r\n  spent: number,\r\n  spentByCast: number[],\r\n  casts: number,\r\n}\r\n\r\ntype ResourceUpdate = {\r\n  timestamp: number | undefined,\r\n  current: number,\r\n  waste: number,\r\n  generated: number,\r\n  used: number,\r\n}\r\n\r\n/**\r\n * This is an 'abstract' implementation of a framework for tracking resource generating/spending.\r\n * Extend it by following the instructions in the TODO comments below\r\n */\r\nclass ResourceTracker extends Analyzer {\r\n  static dependencies = {\r\n    eventEmitter: EventEmitter,\r\n    // Optional dependency for the `resourceCost` prop of events\r\n    // spellResourceCost: SpellResourceCost,\r\n  };\r\n\r\n  protected eventEmitter!: EventEmitter;\r\n\r\n  current = 0;\r\n  resourceUpdates: ResourceUpdate[] = [];\r\n\r\n  // stores resource gained/spent/wasted by ability ID\r\n  buildersObj: {[index: number]: BuilderObj} = {};\r\n  spendersObj: {[index: number]: SpenderObj} = {};\r\n\r\n  // TODO set this to the resource you wish to track constructor.. see the appropriate objects in game/RESOURCE_TYPES\r\n  resource!: Resource;\r\n\r\n  // TODO a classes 'main' resource passes the max along with events, but for other resources this may need to be defined\r\n  maxResource!: number;\r\n\r\n  constructor(options: Options){\r\n    super(options);\r\n    this.addEventListener(Events.energize.to(SELECTED_PLAYER), this.onEnergize);\r\n    this.addEventListener(Events.cast.by(SELECTED_PLAYER), this.onCast);\r\n  }\r\n\r\n  // FIXME implement natural regen\r\n  // TODO if the tracked resource naturally regenerates (like Energy), set this to true and set the parameters of the regeneration in the below fields\r\n  // naturallyRegenerates = false;\r\n  // baseRegenRate; // TODO resource's base regeneration rate in points per second\r\n  // isRegenHasted; // TODO iff true, regeneration rate will be scaled with haste\r\n\r\n  // TODO if you wish an ability to show in results even if it wasn't used, add it using these functions constructor\r\n  initBuilderAbility(spellId: number) {\r\n    this.buildersObj[spellId] = { generated: 0, wasted: 0, casts: 0 };\r\n  }\r\n  initSpenderAbility(spellId: number) {\r\n    this.spendersObj[spellId] = { spent: 0, spentByCast: [], casts: 0 };\r\n  }\r\n\r\n  // BUILDERS - Handled on energize, using the 'resourceChange' field\r\n  onEnergize(event: EnergizeEvent) {\r\n    const spellId = event.ability.guid;\r\n\r\n    if(event.resourceChangeType !== this.resource.id) {\r\n        return;\r\n    }\r\n\r\n    const waste = event.waste;\r\n    const gain = event.resourceChange - waste;\r\n    this._applyBuilder(spellId, gain, waste, this.getResource(event), event.timestamp);\r\n  }\r\n\r\n  // FIXME Track resource drains too, so that the 'current' value can be more accurate\r\n\r\n  // TODO if a resource gain isn't showing as an energize in events, handle it manually by calling this\r\n  /**\r\n   * FIXME solve with a normalizer instead?\r\n   * Applies an energize of the tracked resource type.\r\n   * @param {number} spellId - The spellId to attribute the resource gain to\r\n   * @param {number} amount - The raw amount of resources to gain\r\n   */\r\n  processInvisibleEnergize(spellId: number, amount: number) {\r\n    const maxGain = this.maxResource !== undefined ? this.maxResource - this.current : amount;\r\n    const gain = Math.min(amount, maxGain);\r\n    const waste = Math.max(amount - maxGain, 0);\r\n    this._applyBuilder(spellId, gain, waste);\r\n  }\r\n\r\n  _applyBuilder(spellId: number, gain: number, waste: number,  resource?: ClassResources, timestamp?: number) {\r\n    if (!this.buildersObj[spellId]) {\r\n        this.initBuilderAbility(spellId);\r\n    }\r\n\r\n    this.buildersObj[spellId].wasted += waste;\r\n    this.buildersObj[spellId].generated += gain;\r\n    this.buildersObj[spellId].casts += 1;\r\n\r\n    // resource.amount for an energize is the amount AFTER the energize\r\n    if (resource !== null && resource !== undefined && resource.amount !== undefined) {\r\n      this.current = resource.amount;\r\n      if (resource.max !== undefined) {\r\n        this.maxResource = resource.max; // track changes in max resource, which can happen due to procs / casts\r\n      }\r\n    } else {\r\n      this.current += gain;\r\n    }\r\n\r\n    this.resourceUpdates.push({\r\n      timestamp: timestamp,\r\n      current: this.current,\r\n      waste: waste,\r\n      generated: gain,\r\n      used: 0,\r\n    });\r\n  }\r\n\r\n  // SPENDERS - Handled on cast, using the 'classResources' field\r\n  onCast(event: CastEvent) {\r\n    const spellId = event.ability.guid;\r\n\r\n    if(!this.shouldProcessCastEvent(event)) {\r\n        return;\r\n    }\r\n    const eventResource = this.getResource(event);\r\n\r\n    if(!eventResource){\r\n      return;\r\n    }\r\n\r\n    if (eventResource.max) {\r\n      this.maxResource = eventResource.max; // track changes in max resource, which can happen due to procs / casts\r\n    }\r\n    const cost = this.getReducedCost(event);\r\n\r\n    if (!this.spendersObj[spellId]) {\r\n      this.initSpenderAbility(spellId);\r\n    }\r\n\r\n    if (!cost || cost === 0) {\r\n      return;\r\n    }\r\n\r\n    this.spendersObj[spellId].casts += 1;\r\n    this.spendersObj[spellId].spentByCast.push(cost);\r\n    if(cost > 0) {\r\n      this.spendersObj[spellId].spent += cost;\r\n    }\r\n\r\n    //Re-sync current amount, to update not-tracked gains.\r\n    this.current = eventResource.amount - cost;\r\n\r\n    this.resourceUpdates.push({\r\n      timestamp: event.timestamp,\r\n      current: this.current,\r\n      waste: 0,\r\n      generated: 0,\r\n      used: eventResource.amount,\r\n    });\r\n\r\n    this.triggerSpendEvent(cost, event);\r\n  }\r\n\r\n  // TODO if your spec has an ability cost reduction that doesn't show in events, handle it manually by overriding here. Or extend SpellResourceCost and apply the discount there.\r\n  getReducedCost(event: CastEvent) {\r\n    if (event.resourceCost && event.resourceCost[this.resource.id] !== undefined) {\r\n      return event.resourceCost[this.resource.id];\r\n    }\r\n    return this.getResource(event)?.cost;\r\n  }\r\n\r\n  getResource(event: CastEvent | HealEvent | EnergizeEvent ) {\r\n    if(!event.classResources) {\r\n      return undefined;\r\n    } else {\r\n      return event.classResources.find(r => r.type === this.resource.id);\r\n    }\r\n  }  \r\n\r\n  triggerSpendEvent(spent: number, event: CastEvent) {\r\n\r\n    const fabricatedEvent: SpendResourceEvent = {\r\n      type: EventType.SpendResource,\r\n      timestamp: event.timestamp,\r\n      sourceID: event.sourceID,\r\n      targetID: event.targetID,\r\n      resourceChange: spent,\r\n      resourceChangeType: this.resource.id,\r\n      ability: event.ability,\r\n      __fabricated: true,\r\n    };\r\n\r\n    this.eventEmitter.fabricateEvent(fabricatedEvent, event);\r\n  }\r\n\r\n  shouldProcessCastEvent(event: CastEvent) {\r\n    return Boolean(this.getResource(event));\r\n  }\r\n\r\n  getGeneratedBySpell(spellId: number) {\r\n    return (this.buildersObj[spellId] && this.buildersObj[spellId].generated) || 0;\r\n  }\r\n\r\n  getWastedBySpell(spellId: number) {\r\n    return (this.buildersObj[spellId] && this.buildersObj[spellId].wasted) || 0;\r\n  }\r\n\r\n  getBuilderCastsBySpell(spellId: number) {\r\n    return (this.buildersObj[spellId] && this.buildersObj[spellId].casts) || 0;\r\n  }\r\n\r\n  get generated() {\r\n    return Object.values(this.buildersObj).reduce((acc, spell) => acc + spell.generated, 0);\r\n  }\r\n\r\n  get wasted() {\r\n    return Object.values(this.buildersObj).reduce((acc, spell) => acc + spell.wasted, 0);\r\n  }\r\n\r\n  get spent() {\r\n    return Object.values(this.spendersObj).reduce((acc, spell) => acc + spell.spent, 0);\r\n  }\r\n\r\n  get spendersCasts() {\r\n    return Object.values(this.spendersObj).reduce((acc, spell) => acc + spell.casts, 0);\r\n  }\r\n}\r\n\r\nexport default ResourceTracker;\r\n","import React from 'react';\r\n\r\nimport SpellLink from 'common/SpellLink';\r\nimport { formatPercentage } from 'common/format';\r\nimport { TooltipElement } from 'common/Tooltip';\r\n\r\nimport ResourceTracker, { BuilderObj, SpenderObj } from './ResourceTracker';\r\n\r\ninterface Props {\r\n  tracker: ResourceTracker,\r\n  showSpenders: boolean,\r\n}\r\n\r\nclass ResourceBreakdown extends React.Component<Props> {\r\n\r\n  prepareGenerated(buildersObj: {[index: number]: BuilderObj}) {\r\n    return Object.keys(buildersObj)\r\n      .map(abilityId => ({\r\n        abilityId: Number(abilityId),\r\n        generated: buildersObj[Number(abilityId)].generated,\r\n        wasted: buildersObj[Number(abilityId)].wasted,\r\n      }))\r\n      .sort((a, b) => b.generated - a.generated)\r\n      .filter(ability => ability.generated > 0 || ability.wasted);\r\n  }\r\n\r\n  prepareSpent(spendersObj: {[index: number]: SpenderObj}) {\r\n    return Object.keys(spendersObj)\r\n      .map(abilityId => ({\r\n        abilityId: Number(abilityId),\r\n        spent: spendersObj[Number(abilityId)].spent,\r\n        casts: spendersObj[Number(abilityId)].casts,\r\n      }))\r\n      .sort((a, b) => b.spent - a.spent)\r\n      .filter(ability => ability.spent > 0);\r\n  }\r\n\r\n  render() {\r\n    const { tracker, showSpenders } = this.props;\r\n    const resourceName = tracker.resource.name;\r\n\r\n    const generated = this.prepareGenerated(tracker.buildersObj);\r\n    const spent = this.prepareSpent(tracker.spendersObj);\r\n\r\n    let totalGenerated = tracker.generated;\r\n    let totalWasted = tracker.wasted;\r\n\r\n    let totalSpent = tracker.spent;\r\n    let totalCasts = tracker.spendersCasts;\r\n\r\n    // looks wrong but totals are only for the purpose of percentage, and if nothing was wasted, then 0/1 gives correct result 0% wasted, if it's not 0 it retains its original value\r\n    totalGenerated = (totalGenerated === 0) ? 1 : totalGenerated;\r\n    totalWasted = (totalWasted === 0) ? 1 : totalWasted;\r\n\r\n    totalSpent = (totalSpent === 0) ? 1 : totalSpent;\r\n    totalCasts = (totalCasts === 0) ? 1 : totalCasts;\r\n\r\n    return (\r\n      <>\r\n        <table className=\"data-table\">\r\n          <thead>\r\n            <tr>\r\n              <th>Ability</th>\r\n              <th colSpan={2}>{resourceName} generated</th>\r\n              <th colSpan={2}><TooltipElement content=\"This is the amount of resources that were generated while you were already at cap.\">{resourceName} wasted</TooltipElement></th>\r\n            </tr>\r\n          </thead>\r\n          <tbody>\r\n            {generated && generated\r\n              .map(ability => (\r\n                <tr key={ability.abilityId}>\r\n                  <td style={{ width: '30%' }}>\r\n                    <SpellLink id={ability.abilityId} />\r\n                  </td>\r\n                  <td style={{ width: 50, paddingRight: 5, textAlign: 'center' }}>\r\n                    <TooltipElement content={`${formatPercentage(ability.generated / totalGenerated)} %`}>{ability.generated.toFixed(0)}</TooltipElement>\r\n                  </td>\r\n                  <td style={{ width: '40%' }}>\r\n                    <div\r\n                      className=\"performance-bar\"\r\n                      style={{ width: `${(ability.generated / totalGenerated) * 100}%` }}\r\n                    />\r\n                  </td>\r\n                  <td style={{ width: 50, paddingRight: 5, textAlign: 'center' }}>\r\n                    <TooltipElement content={`${formatPercentage(ability.wasted / totalWasted)} %`}>{ability.wasted.toFixed(0)}</TooltipElement>\r\n                  </td>\r\n                  <td style={{ width: '30%' }}>\r\n                    <div\r\n                      className=\"performance-bar\"\r\n                      style={{ width: `${(ability.wasted / totalWasted) * 100}%` }}\r\n                    />\r\n                  </td>\r\n                </tr>\r\n              ))}\r\n          </tbody>\r\n        </table>\r\n        {showSpenders && (\r\n          <table className=\"data-table\">\r\n            <thead>\r\n              <tr>\r\n                <th>Ability</th>\r\n                <th colSpan={2}>{resourceName} spent</th>\r\n                <th colSpan={2}>Casts</th>\r\n              </tr>\r\n            </thead>\r\n            <tbody>\r\n              {spent && spent\r\n                .map(ability => (\r\n                  <tr key={ability.abilityId}>\r\n                    <td style={{ width: '30%' }}>\r\n                      <SpellLink id={ability.abilityId} />\r\n                    </td>\r\n                    <td style={{ width: 50, paddingRight: 5, textAlign: 'center' }}>\r\n                      <TooltipElement content={`${formatPercentage(ability.spent / totalSpent)} %`}>{ability.spent.toFixed(0)}</TooltipElement>\r\n                    </td>\r\n                    <td style={{ width: '40%' }}>\r\n                      <div\r\n                        className=\"performance-bar\"\r\n                        style={{ width: `${(ability.spent / totalSpent) * 100}%` }}\r\n                      />\r\n                    </td>\r\n                    <td style={{ width: 50, paddingRight: 5, textAlign: 'center' }}>\r\n                      <TooltipElement content={`${formatPercentage(ability.casts / totalCasts)} %`}>{ability.casts}</TooltipElement>\r\n                    </td>\r\n                    <td style={{ width: '30%' }}>\r\n                      <div\r\n                        className=\"performance-bar\"\r\n                        style={{ width: `${(ability.casts / totalCasts) * 100}%` }}\r\n                      />\r\n                    </td>\r\n                  </tr>\r\n                ))}\r\n            </tbody>\r\n          </table>\r\n        )}\r\n      </>\r\n    );\r\n  }\r\n}\r\n\r\nexport default ResourceBreakdown;\r\n","import React from 'react';\r\nimport RESOURCE_TYPES from 'game/RESOURCE_TYPES';\r\n\r\nimport ResourceLink from './ResourceLink';\r\nimport Icon from './Icon';\r\n\r\ninterface Props extends Omit<React.ComponentProps<typeof Icon>, 'id' | 'icon'> {\r\n  id: number;\r\n  noLink?: boolean;\r\n}\r\n\r\nconst ResourceIcon = ({ id, noLink, ...others }: Props) => {\r\n  if (process.env.NODE_ENV === 'development' && !RESOURCE_TYPES[id]) {\r\n    throw new Error(`Unknown spell: ${id}`);\r\n  }\r\n\r\n  const spell = RESOURCE_TYPES[id] || {\r\n    name: 'Spell not recognized',\r\n    icon: 'inv_misc_questionmark',\r\n  };\r\n\r\n  const icon = (\r\n    <Icon\r\n      icon={spell.icon}\r\n      alt={spell.name}\r\n      {...others}\r\n    />\r\n  );\r\n\r\n  if (noLink) {\r\n    return icon;\r\n  }\r\n\r\n  return (\r\n    <ResourceLink id={id} icon={false}>\r\n      {icon}\r\n    </ResourceLink>\r\n  );\r\n};\r\n\r\nexport default ResourceIcon;\r\n","import React, {useEffect, useState} from 'react';\r\n\r\nimport TooltipProvider from 'interface/common/TooltipProvider';\r\n\r\nimport RESOURCE_TYPES from 'game/RESOURCE_TYPES';\r\n\r\nimport ResourceIcon from './ResourceIcon';\r\n\r\ninterface Props {\r\n  id: number;\r\n  children?: React.ReactNode;\r\n  category?: string;\r\n  icon?: boolean,\r\n}\r\n\r\nconst ResourceLink = ({icon = true, ...props}: Props) => {\r\n\r\n  const [elem, setElem] = useState<HTMLAnchorElement | null>(null);\r\n\r\n  useEffect(() => {TooltipProvider.refresh(elem);})\r\n\r\n  const { id, children, category = undefined, ...other } = props;\r\n\r\n  if (process.env.NODE_ENV === 'development' && !children && !RESOURCE_TYPES[id]) {\r\n    throw new Error(`Unknown spell: ${id}`);\r\n  }\r\n\r\n  return (\r\n    <a\r\n      href={TooltipProvider.resource(id)}\r\n      target=\"_blank\"\r\n      rel=\"noopener noreferrer\"\r\n      className={category}\r\n      ref={elem => {setElem(elem);}}\r\n      {...other}\r\n    >\r\n      {icon && <ResourceIcon id={id} noLink />}{' '}\r\n      {children || RESOURCE_TYPES[id].name}\r\n    </a>\r\n  );\r\n}\r\n\r\nexport default ResourceLink;\r\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _propTypes = require('prop-types');\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _classnames = require('classnames');\n\nvar _classnames2 = _interopRequireDefault(_classnames);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar ANIMATION_STATE_CLASSES = {\n  animating: 'rah-animating',\n  animatingUp: 'rah-animating--up',\n  animatingDown: 'rah-animating--down',\n  animatingToHeightZero: 'rah-animating--to-height-zero',\n  animatingToHeightAuto: 'rah-animating--to-height-auto',\n  animatingToHeightSpecific: 'rah-animating--to-height-specific',\n  static: 'rah-static',\n  staticHeightZero: 'rah-static--height-zero',\n  staticHeightAuto: 'rah-static--height-auto',\n  staticHeightSpecific: 'rah-static--height-specific'\n};\n\nvar PROPS_TO_OMIT = ['animateOpacity', 'animationStateClasses', 'applyInlineTransitions', 'children', 'contentClassName', 'delay', 'duration', 'easing', 'height', 'onAnimationEnd', 'onAnimationStart'];\n\nfunction omit(obj) {\n  for (var _len = arguments.length, keys = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    keys[_key - 1] = arguments[_key];\n  }\n\n  if (!keys.length) {\n    return obj;\n  }\n\n  var res = {};\n  var objectKeys = Object.keys(obj);\n\n  for (var i = 0; i < objectKeys.length; i++) {\n    var key = objectKeys[i];\n\n    if (keys.indexOf(key) === -1) {\n      res[key] = obj[key];\n    }\n  }\n\n  return res;\n}\n\n// Start animation helper using nested requestAnimationFrames\nfunction startAnimationHelper(callback) {\n  var requestAnimationFrameIDs = [];\n\n  requestAnimationFrameIDs[0] = requestAnimationFrame(function () {\n    requestAnimationFrameIDs[1] = requestAnimationFrame(function () {\n      callback();\n    });\n  });\n\n  return requestAnimationFrameIDs;\n}\n\nfunction cancelAnimationFrames(requestAnimationFrameIDs) {\n  requestAnimationFrameIDs.forEach(function (id) {\n    return cancelAnimationFrame(id);\n  });\n}\n\nfunction isNumber(n) {\n  return !isNaN(parseFloat(n)) && isFinite(n);\n}\n\nfunction isPercentage(height) {\n  // Percentage height\n  return typeof height === 'string' && height.search('%') === height.length - 1 && isNumber(height.substr(0, height.length - 1));\n}\n\nfunction runCallback(callback, params) {\n  if (callback && typeof callback === 'function') {\n    callback(params);\n  }\n}\n\nvar AnimateHeight = function (_React$Component) {\n  _inherits(AnimateHeight, _React$Component);\n\n  function AnimateHeight(props) {\n    _classCallCheck(this, AnimateHeight);\n\n    var _this = _possibleConstructorReturn(this, (AnimateHeight.__proto__ || Object.getPrototypeOf(AnimateHeight)).call(this, props));\n\n    _this.animationFrameIDs = [];\n\n    var height = 'auto';\n    var overflow = 'visible';\n\n    if (isNumber(props.height)) {\n      // If value is string \"0\" make sure we convert it to number 0\n      height = props.height < 0 || props.height === '0' ? 0 : props.height;\n      overflow = 'hidden';\n    } else if (isPercentage(props.height)) {\n      // If value is string \"0%\" make sure we convert it to number 0\n      height = props.height === '0%' ? 0 : props.height;\n      overflow = 'hidden';\n    }\n\n    _this.animationStateClasses = _extends({}, ANIMATION_STATE_CLASSES, props.animationStateClasses);\n\n    var animationStateClasses = _this.getStaticStateClasses(height);\n\n    _this.state = {\n      animationStateClasses: animationStateClasses,\n      height: height,\n      overflow: overflow,\n      shouldUseTransitions: false\n    };\n    return _this;\n  }\n\n  _createClass(AnimateHeight, [{\n    key: 'componentDidMount',\n    value: function componentDidMount() {\n      var height = this.state.height;\n\n      // Hide content if height is 0 (to prevent tabbing into it)\n      // Check for contentElement is added cause this would fail in tests (react-test-renderer)\n      // Read more here: https://github.com/Stanko/react-animate-height/issues/17\n\n      if (this.contentElement && this.contentElement.style) {\n        this.hideContent(height);\n      }\n    }\n  }, {\n    key: 'componentDidUpdate',\n    value: function componentDidUpdate(prevProps, prevState) {\n      var _this2 = this;\n\n      var _props = this.props,\n          delay = _props.delay,\n          duration = _props.duration,\n          height = _props.height,\n          onAnimationEnd = _props.onAnimationEnd,\n          onAnimationStart = _props.onAnimationStart;\n\n      // Check if 'height' prop has changed\n\n      if (this.contentElement && height !== prevProps.height) {\n        var _cx;\n\n        // Remove display: none from the content div\n        // if it was hidden to prevent tabbing into it\n        this.showContent(prevState.height);\n\n        // Cache content height\n        this.contentElement.style.overflow = 'hidden';\n        var contentHeight = this.contentElement.offsetHeight;\n        this.contentElement.style.overflow = '';\n\n        // set total animation time\n        var totalDuration = duration + delay;\n\n        var newHeight = null;\n        var timeoutState = {\n          height: null, // it will be always set to either 'auto' or specific number\n          overflow: 'hidden'\n        };\n        var isCurrentHeightAuto = prevState.height === 'auto';\n\n        if (isNumber(height)) {\n          // If value is string \"0\" make sure we convert it to number 0\n          newHeight = height < 0 || height === '0' ? 0 : height;\n          timeoutState.height = newHeight;\n        } else if (isPercentage(height)) {\n          // If value is string \"0%\" make sure we convert it to number 0\n          newHeight = height === '0%' ? 0 : height;\n          timeoutState.height = newHeight;\n        } else {\n          // If not, animate to content height\n          // and then reset to auto\n          newHeight = contentHeight; // TODO solve contentHeight = 0\n          timeoutState.height = 'auto';\n          timeoutState.overflow = null;\n        }\n\n        if (isCurrentHeightAuto) {\n          // This is the height to be animated to\n          timeoutState.height = newHeight;\n\n          // If previous height was 'auto'\n          // set starting height explicitly to be able to use transition\n          newHeight = contentHeight;\n        }\n\n        // Animation classes\n        var animationStateClasses = (0, _classnames2.default)((_cx = {}, _defineProperty(_cx, this.animationStateClasses.animating, true), _defineProperty(_cx, this.animationStateClasses.animatingUp, prevProps.height === 'auto' || height < prevProps.height), _defineProperty(_cx, this.animationStateClasses.animatingDown, height === 'auto' || height > prevProps.height), _defineProperty(_cx, this.animationStateClasses.animatingToHeightZero, timeoutState.height === 0), _defineProperty(_cx, this.animationStateClasses.animatingToHeightAuto, timeoutState.height === 'auto'), _defineProperty(_cx, this.animationStateClasses.animatingToHeightSpecific, timeoutState.height > 0), _cx));\n\n        // Animation classes to be put after animation is complete\n        var timeoutAnimationStateClasses = this.getStaticStateClasses(timeoutState.height);\n\n        // Set starting height and animating classes\n        // We are safe to call set state as it will not trigger infinite loop\n        // because of the \"height !== prevProps.height\" check\n        this.setState({ // eslint-disable-line react/no-did-update-set-state\n          animationStateClasses: animationStateClasses,\n          height: newHeight,\n          overflow: 'hidden',\n          // When animating from 'auto' we first need to set fixed height\n          // that change should be animated\n          shouldUseTransitions: !isCurrentHeightAuto\n        });\n\n        // Clear timeouts\n        clearTimeout(this.timeoutID);\n        clearTimeout(this.animationClassesTimeoutID);\n\n        if (isCurrentHeightAuto) {\n          // When animating from 'auto' we use a short timeout to start animation\n          // after setting fixed height above\n          timeoutState.shouldUseTransitions = true;\n\n          cancelAnimationFrames(this.animationFrameIDs);\n          this.animationFrameIDs = startAnimationHelper(function () {\n            _this2.setState(timeoutState);\n\n            // ANIMATION STARTS, run a callback if it exists\n            runCallback(onAnimationStart, { newHeight: timeoutState.height });\n          });\n\n          // Set static classes and remove transitions when animation ends\n          this.animationClassesTimeoutID = setTimeout(function () {\n            _this2.setState({\n              animationStateClasses: timeoutAnimationStateClasses,\n              shouldUseTransitions: false\n            });\n\n            // ANIMATION ENDS\n            // Hide content if height is 0 (to prevent tabbing into it)\n            _this2.hideContent(timeoutState.height);\n            // Run a callback if it exists\n            runCallback(onAnimationEnd, { newHeight: timeoutState.height });\n          }, totalDuration);\n        } else {\n          // ANIMATION STARTS, run a callback if it exists\n          runCallback(onAnimationStart, { newHeight: newHeight });\n\n          // Set end height, classes and remove transitions when animation is complete\n          this.timeoutID = setTimeout(function () {\n            timeoutState.animationStateClasses = timeoutAnimationStateClasses;\n            timeoutState.shouldUseTransitions = false;\n\n            _this2.setState(timeoutState);\n\n            // ANIMATION ENDS\n            // If height is auto, don't hide the content\n            // (case when element is empty, therefore height is 0)\n            if (height !== 'auto') {\n              // Hide content if height is 0 (to prevent tabbing into it)\n              _this2.hideContent(newHeight); // TODO solve newHeight = 0\n            }\n            // Run a callback if it exists\n            runCallback(onAnimationEnd, { newHeight: newHeight });\n          }, totalDuration);\n        }\n      }\n    }\n  }, {\n    key: 'componentWillUnmount',\n    value: function componentWillUnmount() {\n      cancelAnimationFrames(this.animationFrameIDs);\n\n      clearTimeout(this.timeoutID);\n      clearTimeout(this.animationClassesTimeoutID);\n\n      this.timeoutID = null;\n      this.animationClassesTimeoutID = null;\n      this.animationStateClasses = null;\n    }\n  }, {\n    key: 'showContent',\n    value: function showContent(height) {\n      if (height === 0) {\n        this.contentElement.style.display = '';\n      }\n    }\n  }, {\n    key: 'hideContent',\n    value: function hideContent(newHeight) {\n      if (newHeight === 0) {\n        this.contentElement.style.display = 'none';\n      }\n    }\n  }, {\n    key: 'getStaticStateClasses',\n    value: function getStaticStateClasses(height) {\n      var _cx2;\n\n      return (0, _classnames2.default)((_cx2 = {}, _defineProperty(_cx2, this.animationStateClasses.static, true), _defineProperty(_cx2, this.animationStateClasses.staticHeightZero, height === 0), _defineProperty(_cx2, this.animationStateClasses.staticHeightSpecific, height > 0), _defineProperty(_cx2, this.animationStateClasses.staticHeightAuto, height === 'auto'), _cx2));\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var _cx3,\n          _this3 = this;\n\n      var _props2 = this.props,\n          animateOpacity = _props2.animateOpacity,\n          applyInlineTransitions = _props2.applyInlineTransitions,\n          children = _props2.children,\n          className = _props2.className,\n          contentClassName = _props2.contentClassName,\n          delay = _props2.delay,\n          duration = _props2.duration,\n          easing = _props2.easing,\n          id = _props2.id,\n          style = _props2.style;\n      var _state = this.state,\n          height = _state.height,\n          overflow = _state.overflow,\n          animationStateClasses = _state.animationStateClasses,\n          shouldUseTransitions = _state.shouldUseTransitions;\n\n\n      var componentStyle = _extends({}, style, {\n        height: height,\n        overflow: overflow || style.overflow\n      });\n\n      if (shouldUseTransitions && applyInlineTransitions) {\n        componentStyle.transition = 'height ' + duration + 'ms ' + easing + ' ' + delay + 'ms';\n\n        // Include transition passed through styles\n        if (style.transition) {\n          componentStyle.transition = style.transition + ', ' + componentStyle.transition;\n        }\n\n        // Add webkit vendor prefix still used by opera, blackberry...\n        componentStyle.WebkitTransition = componentStyle.transition;\n      }\n\n      var contentStyle = {};\n\n      if (animateOpacity) {\n        contentStyle.transition = 'opacity ' + duration + 'ms ' + easing + ' ' + delay + 'ms';\n        // Add webkit vendor prefix still used by opera, blackberry...\n        contentStyle.WebkitTransition = contentStyle.transition;\n\n        if (height === 0) {\n          contentStyle.opacity = 0;\n        }\n      }\n\n      var componentClasses = (0, _classnames2.default)((_cx3 = {}, _defineProperty(_cx3, animationStateClasses, true), _defineProperty(_cx3, className, className), _cx3));\n\n      // Check if user passed aria-hidden prop\n      var hasAriaHiddenProp = typeof this.props['aria-hidden'] !== 'undefined';\n      var ariaHidden = hasAriaHiddenProp ? this.props['aria-hidden'] : height === 0;\n\n      return _react2.default.createElement(\n        'div',\n        _extends({}, omit.apply(undefined, [this.props].concat(PROPS_TO_OMIT)), {\n          'aria-hidden': ariaHidden,\n          className: componentClasses,\n          id: id,\n          style: componentStyle\n        }),\n        _react2.default.createElement(\n          'div',\n          {\n            className: contentClassName,\n            style: contentStyle,\n            ref: function ref(el) {\n              return _this3.contentElement = el;\n            }\n          },\n          children\n        )\n      );\n    }\n  }]);\n\n  return AnimateHeight;\n}(_react2.default.Component);\n\nvar heightPropType = function heightPropType(props, propName, componentName) {\n  var value = props[propName];\n\n  if (typeof value === 'number' && value >= 0 || isPercentage(value) || value === 'auto') {\n    return null;\n  }\n\n  return new TypeError('value \"' + value + '\" of type \"' + (typeof value === 'undefined' ? 'undefined' : _typeof(value)) + '\" is invalid type for ' + propName + ' in ' + componentName + '. ' + 'It needs to be a positive number, string \"auto\" or percentage string (e.g. \"15%\").');\n};\n\nAnimateHeight.propTypes = {\n  'aria-hidden': _propTypes2.default.bool,\n  animateOpacity: _propTypes2.default.bool,\n  animationStateClasses: _propTypes2.default.object,\n  applyInlineTransitions: _propTypes2.default.bool,\n  children: _propTypes2.default.any.isRequired,\n  className: _propTypes2.default.string,\n  contentClassName: _propTypes2.default.string,\n  delay: _propTypes2.default.number,\n  duration: _propTypes2.default.number,\n  easing: _propTypes2.default.string,\n  height: heightPropType,\n  id: _propTypes2.default.string,\n  onAnimationEnd: _propTypes2.default.func,\n  onAnimationStart: _propTypes2.default.func,\n  style: _propTypes2.default.object\n};\n\nAnimateHeight.defaultProps = {\n  animateOpacity: false,\n  animationStateClasses: ANIMATION_STATE_CLASSES,\n  applyInlineTransitions: true,\n  duration: 250,\n  delay: 0,\n  easing: 'ease',\n  style: {}\n};\n\nexports.default = AnimateHeight;","import React from 'react';\r\nimport { formatPercentage } from 'common/format';\r\nimport SpellLink from 'common/SpellLink';\r\nimport { i18n } from '@lingui/core';\r\nimport { t } from '@lingui/macro';\r\n\r\nimport Spell from 'common/SPELLS/Spell';\r\n\r\nimport { When } from 'parser/core/ParseResults';\r\n\r\nimport ResourceTracker from './ResourceTracker';\r\n\r\ninterface Suggestion {\r\n  spell: Spell | any;\r\n  minor: number;\r\n  avg: number;\r\n  major: number;\r\n  extraSuggestion?: string | JSX.Element;\r\n}\r\n\r\nfunction suggest(when: When, tracker: ResourceTracker, suggestion: Suggestion) {\r\n  let tracked = { generated: 0, wasted: 0, casts: 0 };\r\n  //If an array of spells is passed, we manipulate the data to aggregate all the generated and wasted resources as well as the individual focus instances into 1 spell so that it can be displayed.\r\n  if (Array.isArray(suggestion.spell)) {\r\n    let newSuggestionSpell: Spell = { id: -1, name: \"\", icon: \"\" };\r\n    for (const spell of suggestion.spell) {\r\n      if (!tracker.buildersObj[spell.id]) {\r\n        continue;\r\n      }\r\n      if (newSuggestionSpell.id === -1) {\r\n        newSuggestionSpell = spell;\r\n      }\r\n      tracked.generated += tracker.buildersObj[spell.id].generated;\r\n      tracked.wasted += tracker.buildersObj[spell.id].wasted;\r\n      tracked.casts += tracker.buildersObj[spell.id].casts;\r\n    }\r\n    suggestion.spell = newSuggestionSpell;\r\n  } else {\r\n    tracked = tracker.buildersObj[suggestion.spell.id];\r\n  }\r\n  if (!tracked) {\r\n    return;\r\n  }\r\n\r\n  const maxGenerated = tracked.generated + tracked.wasted;\r\n  const wastedShare = (tracked.wasted / maxGenerated) || 0;\r\n  const resourceNameLower = tracker.resource.name.toLowerCase();\r\n\r\n  when(wastedShare).isGreaterThan(suggestion.minor)\r\n    .addSuggestion((suggest) => suggest(\r\n        <>\r\n          You are wasting {resourceNameLower} generated by <SpellLink id={suggestion.spell.id} />. {suggestion.extraSuggestion}\r\n        </>,\r\n      )\r\n        .icon(suggestion.spell.icon)\r\n        .actual(i18n._(t('shared.suggestions.resources.wasted')`${formatPercentage(wastedShare)}% wasted. Generated ${tracked.generated} out of ${maxGenerated} possible ${resourceNameLower}`))\r\n        .recommended(`<${formatPercentage(suggestion.minor)}%  ${resourceNameLower} wasted is recommend`)\r\n        .regular(suggestion.avg).major(suggestion.major));\r\n}\r\n\r\nexport default suggest;\r\n","import Analyzer, { SELECTED_PLAYER } from 'parser/core/Analyzer';\r\nimport Haste from 'parser/shared/modules/Haste';\r\nimport EventEmitter from 'parser/core/modules/EventEmitter';\r\nimport SpellResourceCost from 'parser/shared/modules/SpellResourceCost';\r\nimport HIT_TYPES from 'game/HIT_TYPES';\r\nimport Events from 'parser/core/Events';\r\n\r\n// turn on debug to find if there's inaccuracies, then verboseDebug to help track the cause.\r\nconst debug = false;\r\nconst verboseDebug = false;\r\n\r\n/**\r\n * Tracks when a regenerating resource reaches its cap. Most useful for specs such as rogues\r\n * and feral druids where their energy resource quickly recharges through natural regeneration\r\n * and may frequently reach its cap during a fight.\r\n *\r\n * It is an 'abstract' class, so should be extended and provided with settings for the resource\r\n * being tracked by your spec. Search for \"IMPLEMENTME\" for what should be set up.\r\n *\r\n * Reductions in spell costs should be handled by implementing parser/core/Modules/SpellResourceCost\r\n * for the relevant resource.\r\n *\r\n * If your derived class shares event handlers remember to call the original, e.g.\r\n * onCast(event) {\r\n *  super.onCast(event);\r\n *  // stuff related to your spec's implementation\r\n * }\r\n *\r\n * Example derived class: parser/Druid/Feral/Modules/Features/EnergyCapTracker\r\n *\r\n * For a more complete picture of how a combatant is using their resources you may want to\r\n * also use parser/core/Modules/ResourceTracker\r\n * ResourceTracker handles how it's energized and spent, RegenResourceCapTracker will tell\r\n * you about natural regeneration and how long it's at cap.\r\n *\r\n * The accuracy of this module's predictions depends heavily on finding the \"quirks\" of how\r\n * abilities and their resource behaviours appear in the combat log. It can never be perfectly\r\n * accurate due to resources being rounded to integer values and latency issues, but an error\r\n * of less than ±2 should be possible.\r\n *\r\n * Fabricates events 'beginresourcecap' and 'endresourcecap'. See the functions fabricateBeginCap\r\n * and fabricateEndCap for details on these events and their limitations.\r\n */\r\n\r\n/**\r\n * How far (in ms) damage event can be separated from a cast and still use its information\r\n * to decide there should be a resource refund due to not hiting. 208ms is highest I've seen.\r\n */\r\nconst REFUND_SPENDER_WINDOW = 500;\r\nconst HIT_TYPES_THAT_REFUND = [\r\n  HIT_TYPES.MISS,\r\n  HIT_TYPES.DODGE,\r\n  HIT_TYPES.PARRY,\r\n];\r\n\r\n/**\r\n * @property {EventEmitter} eventEmitter\r\n * @property {Haste} haste\r\n * @property {SpellResourceCost} spellResourceCost\r\n */\r\nclass RegenResourceCapTracker extends Analyzer {\r\n  static dependencies = {\r\n    eventEmitter: EventEmitter,\r\n    haste: Haste,\r\n    // Needed for the `resourceCost` prop of events\r\n    spellResourceCost: SpellResourceCost,\r\n  };\r\n\r\n  // -- Start of IMPLEMENTME statics\r\n\r\n  // One of game/RESOURCE_TYPES\r\n  static resourceType;\r\n\r\n  // Resource's base regeneration rate in points per second (e.g. 10 for Energy)\r\n  static baseRegenRate = 0;\r\n\r\n  /**\r\n   * Is natural regeneration rate increased by haste.\r\n   * If a resource is affected by haste in an unusual way, set false and handle it manually in naturalRegenRate\r\n   */\r\n  static isRegenHasted = false;\r\n\r\n  /**\r\n   * Any buff or debuff IDs that change the max value for this resource. e.g. Berserk for Feral.\r\n   * Remember to check for their presence and apply the effect in currentMaxResource\r\n   */\r\n  static buffsChangeMax = [];\r\n\r\n  /**\r\n   * Any buff or debuff IDs that directly affect natural regeneration rate for this resource. e.g. Adrenaline Rush for Outlaw.\r\n   * Remember to check for their presence and apply the effect in naturalRegenRate\r\n   */\r\n  static buffsChangeRegen = [];\r\n\r\n  // Events for some abilities give inaccurate \"amount\" values, so their change is best applied cumulatively.\r\n  static energizersToApplyCumulatively = [];\r\n  static castsToApplyCumulatively = [];\r\n  static drainsToApplyCumulatively = [];\r\n\r\n  /**\r\n   * How close (in ms) a resource changing event must be to the last one to have the change handled cumulatively.\r\n   *\r\n   * When resource changing events occur in a very short time the values in the combat log can become inaccurate.\r\n   *  What happens in the fight:\r\n   * t: 1  player has 50 energy\r\n   * t: 2  cast spending 20 energy\r\n   * t: 2  energize gaining 30 energy\r\n   * t: 3  player has 60 energy\r\n   *\r\n   *  What the log shows:\r\n   * cast {timestamp: 2, classResources[i]: {amount: 50, cost: 20}}\r\n   * energize {timestamp: 2, resourceChange: 30, classResources[i]: {amount: 80}}\r\n   * ('amount' for cast events is what it was before the event, for energize events it's after.)\r\n   *\r\n   * If we trusted the resource information given by the last parsed event we'd expect energy to\r\n   * be 80 at t = 3.\r\n   */\r\n  static cumulativeEventWindow = 100;\r\n\r\n  /**\r\n   * For some specs (e.g. energy for rogues and feral) a ability that doesn't hit refunds some of the resource.\r\n   * A value of 0 means no refund, 0.8 seems to be the standard refund amount.\r\n   */\r\n  static resourceRefundOnMiss = 0;\r\n\r\n  // Some abilities never get their resources refunded, usually AoEs. List their spellIds here.\r\n  static exemptFromRefund = [];\r\n\r\n  // -- end of IMPLEMENTME statics\r\n\r\n  // Total time spent with resource at maximum (in ms)\r\n  atCap = 0;\r\n\r\n  // Total resources lost from natural regeneration (ONLY natural regeneration) due to being capped\r\n  missedRegen = 0;\r\n\r\n  // Total resources generated from natural regeneration, includes wasted resources.\r\n  naturalRegen = 0;\r\n\r\n  regenState = null;\r\n  prevSpender = null;\r\n  hasReportedBelowCap = false;\r\n\r\n  /**\r\n   * Amount of resource that should be available at current timestamp, accounting for natural regeneration.\r\n   * @returns {number}\r\n   */\r\n  get current() {\r\n    return this.predictValue(this.owner.currentTimestamp);\r\n  }\r\n\r\n  /**\r\n   * Whether the resource is at its cap at the current timestamp.\r\n   * @returns {boolean}\r\n   */\r\n  get isCapped() {\r\n    return this.current >= this.regenState.max;\r\n  }\r\n\r\n  /**\r\n   * What fraction of the fight was spent with this resource at its cap.\r\n   * @returns {number}\r\n   */\r\n  get cappedProportion() {\r\n    return this.atCap / this.owner.fightDuration;\r\n  }\r\n\r\n  /**\r\n   * Resource lost from natural regeneration (only from natural regeneration, not energizers) due\r\n   * to the resource reaching cap, averaged to a per-minute value.\r\n   */\r\n  get missedRegenPerMinute() {\r\n    return (this.missedRegen / this.owner.fightDuration) * 1000 * 60;\r\n  }\r\n\r\n  constructor(...args) {\r\n    super(...args);\r\n    // can't know resource state for certain until the first combat events, but assume a regenerating resource starts full.\r\n    const max = this.currentMaxResourceWithFallback();\r\n    this.regenState = {\r\n      amount: max ? max : 0,\r\n      max,\r\n      regen: this.naturalRegenRate(),\r\n      timestamp: this.owner.fight.start_time,\r\n    };\r\n    this.addEventListener(Events.fightend, this.onFightend);\r\n    this.addEventListener(Events.energize.to(SELECTED_PLAYER), this.onEnergize);\r\n    this.addEventListener(Events.cast.by(SELECTED_PLAYER), this.onCast);\r\n    this.addEventListener(Events.damage.by(SELECTED_PLAYER), this.onDamage);\r\n    this.addEventListener(Events.drain.by(SELECTED_PLAYER), this.onDrain);\r\n    this.addEventListener(Events.applybuff.to(SELECTED_PLAYER), this.onApplyBuff);\r\n    this.addEventListener(Events.removebuff.to(SELECTED_PLAYER), this.onRemoveBuff);\r\n    this.addEventListener(Events.ChangeHaste.to(SELECTED_PLAYER), this.onChangeHaste);\r\n  }\r\n\r\n  /**\r\n   * IMPLEMENTME\r\n   * Some specs have drain reductions that aren't already shown in events, which should be implemented\r\n   * here. Drain events are separate from an ability cast cost.\r\n   * @param   {object}  event A drain event being applied to the player.\r\n   * @returns {number}  Drain amount after any reductions are applied.\r\n   */\r\n  getReducedDrain(event) {\r\n    return event.resourceChange;\r\n  }\r\n\r\n  /**\r\n   * IMPLEMENTME\r\n   * Some specs have modifiers to the base regen rate that apply before haste, which should\r\n   * be implemented here.\r\n   * @returns {number} Base regen rate of the resource.\r\n   */\r\n  getBaseRegenRate(){\r\n    return this.constructor.baseRegenRate;\r\n  }\r\n\r\n  /**\r\n   * IMPLEMENTME\r\n   * Calculate current natural regeneration rate of the resource.\r\n   * When checking combant's buffs/debuffs you may want to use this.combatantHasBuffActive() rather than\r\n   * the .hasBuff of the combatant directly, doing so will exclude buffs which wore off at this timestamp.\r\n   * @returns {number}  Resource expected to be generated per ms.\r\n   */\r\n  naturalRegenRate() {\r\n    let regen = this.getBaseRegenRate() / 1000;\r\n    if (this.constructor.isRegenHasted) {\r\n      regen *= (1 + this.haste.current);\r\n    }\r\n    return regen;\r\n  }\r\n\r\n  /**\r\n   * IMPLEMENTME\r\n   * Calculate current maximum value for the resource. Accounting for items, talents, and active buffs.\r\n   * When checking combant's buffs/debuffs you may want to use this.combatantHasBuffActive() rather than\r\n   * the .hasBuff of the combatant directly, doing so will exclude buffs which wore off at this timestamp.\r\n   * @returns {number}  Maximum resource value, or null to try to use value from resource events.\r\n   */\r\n  currentMaxResource() {\r\n   /**\r\n    * If left unimplemented and no events provide max resource information the Analyzer will never know\r\n    * the resource's max value. It handles that situation without crashing, but without a cap value it\r\n    * is largely useless.\r\n    */\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Applies an energize of the tracked resource type at the current timestamp.\r\n   * Use when a spec has a source of resource which doesn't appear as an energize event in the log.\r\n   * If you have an invisible energize that happens over a duration you should generate an event for\r\n   * each tick, as applying it all at once can lead to inaccuracies. If it doesn't have ticks consider\r\n   * handling it as a buff to the natural regeneration rate instead.\r\n   * @param {number} amount Raw amount of resources to gain. Limiting to max is done within this function\r\n   * so there's no need to check before passing it in.\r\n   */\r\n  processInvisibleEnergize(amount) {\r\n    if (amount == null || isNaN(amount)) {\r\n      throw new Error(`processInvisibleEnergize called without required parameter. amount: ${amount}`);\r\n    }\r\n    if (amount === 0) {\r\n      return;\r\n    }\r\n    const before = this.current;\r\n    const after = Math.min(before + amount, this.currentMaxResourceWithFallback());\r\n    const gain = after - before;\r\n    this.applyEnergize(gain);\r\n  }\r\n\r\n  /**\r\n   * Fetches the appropriate classResources object from an event, or null if there is none available.\r\n   * @param {object} event An event object which may have an appropriate .classResources property.\r\n   */\r\n  getResource(event) {\r\n    if (!event || !event.classResources) {\r\n      return null;\r\n    }\r\n    return event.classResources.find(r => r.type === this.constructor.resourceType.id);\r\n  }\r\n\r\n  /**\r\n   * Fetches the cost of a cast event. Using its resourceCost property (added by SpellResourceCost)\r\n   * if it's available or the resource cost given by the combat log if not.\r\n   * @param {object} event A cast event object with a resource cost associated with it.\r\n   */\r\n  getCost(event) {\r\n    if (event.resourceCost[this.constructor.resourceType.id] !== undefined) {\r\n      return event.resourceCost[this.constructor.resourceType.id];\r\n    }\r\n    return this.getResource(event).cost;\r\n  }\r\n\r\n  /**\r\n   * A variation of this.selectedCombatant.hasBuff that excludes any buffs which were removed on the timestamp.\r\n   * @param {number} buffId ID of buff or debuff to check for on the current combatant.\r\n   * @param {number} timestamp Time to check, or null to use current timestamp. Cannot be a future timestamp.\r\n   */\r\n  combatantHasBuffActive(buffId, timestamp = null) {\r\n    if (!buffId || isNaN(buffId)) {\r\n      throw new Error(`combatantHasBuffActive called without required parameter. buffId: ${buffId}`);\r\n    }\r\n    if (!timestamp) {\r\n      timestamp = this.owner.currentTimestamp;\r\n    }\r\n    const buffHistory = this.selectedCombatant.getBuffHistory(buffId);\r\n    return Boolean(buffHistory.find(buff => (buff.start <= timestamp && (!buff.end || buff.end > timestamp))));\r\n  }\r\n\r\n  onFightend() {\r\n    // updateState one last time to catch any resource capping after the final resource event\r\n    this.updateState(this.predictValue(this.owner.fight.end_time));\r\n    debug && console.log(`mean prediction error magnitude: ${this.debugMeanPredictionError.toFixed(2)}`);\r\n    debug && console.log(`greatest magnitude prediction error: ${this.debugGreatestError.toFixed(2)}`);\r\n  }\r\n\r\n  onEnergize(event) {\r\n    if(event.resourceChangeType !== this.constructor.resourceType.id || !event.resourceChange) {\r\n      return;\r\n    }\r\n    const waste = event.waste ? event.waste : 0;\r\n    const gain = event.resourceChange - waste;\r\n    const applyCumulatively = this.constructor.energizersToApplyCumulatively.includes(event.ability.guid);\r\n    this.applyEnergize(gain, event, applyCumulatively);\r\n  }\r\n\r\n  applyEnergize(gain, event = null, applyCumulatively = false) {\r\n    if (gain == null || isNaN(gain)) {\r\n      // using == null to catch undefined, but still allow 0\r\n      throw new Error(`applyEnergize called without required parameter. gain: ${gain}`);\r\n    }\r\n    const time = event ? event.timestamp : this.owner.currentTimestamp;\r\n    const eventResource = event ? this.getResource(event) : null;\r\n\r\n    const shouldAccumulate = applyCumulatively ||\r\n      this.isLastUpdateRecent(time) ||\r\n      !eventResource || eventResource.amount == null;\r\n\r\n    // eventResource.amount for an energize is the value after the change\r\n    const current = shouldAccumulate ? (this.predictValue(time) + gain) : eventResource.amount;\r\n    if (debug && !shouldAccumulate) {\r\n      this.debugActualVsPredicted(eventResource.amount - gain, time);\r\n    }\r\n    const max = this.currentMaxResourceWithFallback(event);\r\n    this.updateState(current, max);\r\n  }\r\n\r\n  onCast(event) {\r\n    const eventResource = this.getResource(event);\r\n    if (!eventResource) {\r\n      return;\r\n    }\r\n    const cost = this.getCost(event);\r\n    if (!cost) {\r\n      // only interested in cast events that spend resource\r\n      return;\r\n    }\r\n    if (cost < 0) {\r\n      debug && console.warn(`${this.owner.formatTimestamp(event.timestamp, 3)} Unexpected negative cost ${cost} for spell ${event.ability.guid}`);\r\n    }\r\n    if (!this.constructor.exemptFromRefund.includes(event.ability.guid)) {\r\n      this.prevSpender = {\r\n        id: event.ability.guid,\r\n        cost,\r\n        timestamp: event.timestamp,\r\n      };\r\n    }\r\n\r\n    const shouldAccumulate = eventResource.amount == null ||\r\n      this.constructor.castsToApplyCumulatively.includes(event.ability.guid) ||\r\n      this.isLastUpdateRecent(event.timestamp);\r\n    const current = (shouldAccumulate ? this.predictValue(event.timestamp) : eventResource.amount) - cost;\r\n    if (debug && !shouldAccumulate) {\r\n      this.debugActualVsPredicted(eventResource.amount, event.timestamp);\r\n    }\r\n    const max = this.currentMaxResourceWithFallback(event);\r\n    this.updateState(current, max);\r\n  }\r\n\r\n  onDamage(event) {\r\n    // only interested in damage events if they show a spending ability failing to connect (and so triggering a refund)\r\n    if (!this.prevSpender || event.ability.guid !== this.prevSpender.id ||\r\n        (event.timestamp - this.prevSpender.timestamp) > REFUND_SPENDER_WINDOW ||\r\n        event.tick || !HIT_TYPES_THAT_REFUND.includes(event.hitType)) {\r\n      return;\r\n    }\r\n    verboseDebug && console.log(`${this.owner.formatTimestamp(this.owner.currentTimestamp, 3)} attack didn't connect so restoring ${Math.round(this.constructor.resourceRefundOnMiss * 100)}% resource`);\r\n    const refund = Math.floor(this.prevSpender.cost * this.constructor.resourceRefundOnMiss);\r\n    const current = this.predictValue(event.timestamp) + refund;\r\n    this.updateState(current);\r\n  }\r\n\r\n  onDrain(event) {\r\n    if(event.resourceChangeType !== this.constructor.resourceType.id || !event.resourceChange) {\r\n      return;\r\n    }\r\n    const eventResource = this.getResource(event);\r\n    const drain = this.getReducedDrain(event);\r\n\r\n    const shouldAccumulate = !eventResource || eventResource.amount == null ||\r\n      this.constructor.energizersToApplyCumulatively.includes(event.ability.guid) ||\r\n      this.isLastUpdateRecent(event.timestamp);\r\n\r\n    // eventResource.amount for a drain is the value before the change\r\n    const current = (shouldAccumulate ? this.predictValue(event.timestamp) : eventResource.amount) - drain;\r\n    if (debug && !shouldAccumulate) {\r\n      this.debugActualVsPredicted(eventResource.amount, event.timestamp);\r\n    }\r\n    const max = this.currentMaxResourceWithFallback(event);\r\n    this.updateState(current, max);\r\n  }\r\n\r\n  isLastUpdateRecent(timestamp) {\r\n    return this.regenState.timestamp + this.constructor.cumulativeEventWindow >= timestamp;\r\n  }\r\n\r\n  onApplyBuff(event) {\r\n    if (this.constructor.buffsChangeMax.includes(event.ability.guid)) {\r\n      this.buffChangesResourceMax(event);\r\n    }\r\n    if (this.constructor.buffsChangeRegen.includes(event.ability.guid)) {\r\n      this.buffChangesRegen();\r\n    }\r\n  }\r\n\r\n  onRemoveBuff(event) {\r\n    if (this.constructor.buffsChangeMax.includes(event.ability.guid)) {\r\n      this.buffChangesResourceMax(event);\r\n    }\r\n    if (this.constructor.buffsChangeRegen.includes(event.ability.guid)) {\r\n      this.buffChangesRegen();\r\n    }\r\n  }\r\n\r\n  onChangeHaste() {\r\n    const regen = this.naturalRegenRate();\r\n    this.updateState(null, null, regen);\r\n  }\r\n\r\n  buffChangesResourceMax(event) {\r\n    const max = this.currentMaxResourceWithFallback(event);\r\n    this.updateState(null, max);\r\n  }\r\n\r\n  buffChangesRegen() {\r\n    const regen = this.naturalRegenRate();\r\n    this.updateState(null, null, regen);\r\n  }\r\n\r\n  /**\r\n   * Called when current, max, or regen rate for the resource has changed.\r\n   * Builds a new regenState reflecting the current state.\r\n   * Detects if resource capping occurred since the last regenState.\r\n   * @param {number} amount Current amount of resource, or null to use prediction.\r\n   * @param {number} max Current resource maximum, or null to use calculation.\r\n   * @param {number} regen Current resource regeneration rate, or null to use calculation.\r\n   */\r\n  updateState(amount = null, max = null, regen = null) {\r\n    const timestamp = this.owner.currentTimestamp;\r\n    verboseDebug && console.log(`${this.owner.formatTimestamp(timestamp, 3)} amount: ${amount ? amount.toFixed(1) : 'n/a'}, max: ${max ? max.toFixed(1) : 'n/a'} , regen: ${regen ? (regen * 1000).toFixed(3) : 'n/a'}`);\r\n    if (amount == null || isNaN(amount)) {\r\n      amount = this.predictValue(timestamp);\r\n    }\r\n    if (max == null || isNaN(max)) {\r\n      max = this.currentMaxResourceWithFallback();\r\n    }\r\n    if (regen == null || isNaN(regen)) {\r\n      regen = this.naturalRegenRate();\r\n    }\r\n    amount = max ? Math.min(max, amount) : amount;\r\n    const oldState = this.regenState;\r\n    const newState = {\r\n      amount,\r\n      max,\r\n      regen,\r\n      timestamp,\r\n    };\r\n    this.regenState = newState;\r\n    if (oldState) {\r\n      const durationCapped = this.timeCappedBetweenStates(oldState, newState);\r\n      this.atCap += durationCapped;\r\n      this.missedRegen += durationCapped * oldState.regen;\r\n      this.naturalRegen += (newState.timestamp - oldState.timestamp) * oldState.regen;\r\n    }\r\n    if (newState.amount < newState.max) {\r\n      this.onBelowCap(newState.timestamp);\r\n    }\r\n  }\r\n\r\n  timeCappedBetweenStates(oldState, newState) {\r\n    if (!oldState || !newState){\r\n      throw new Error(`timeCappedBetweenStates called without required parameters. oldState: ${oldState}, newState: ${newState}`);\r\n    }\r\n    const reachCap = oldState.max ? this.predictReachValue(oldState.timestamp, oldState.amount, oldState.regen, oldState.max) : Infinity;\r\n    if (reachCap >= newState.timestamp) {\r\n      return 0;\r\n    }\r\n    this.onAtCap(reachCap);\r\n\r\n    return newState.timestamp - reachCap;\r\n  }\r\n\r\n  currentMaxResourceWithFallback(event = null) {\r\n    const calculated = this.currentMaxResource();\r\n    if (calculated) {\r\n      return calculated;\r\n    }\r\n    const eventResource = this.getResource(event);\r\n    if (eventResource && eventResource.max != null && !isNaN(eventResource.max)) {\r\n      return eventResource.max;\r\n    }\r\n    // when neither source provides a value just use the existing\r\n    return this.regenState.max;\r\n  }\r\n\r\n  /**\r\n   * Given a start value and regen rate, calculate when resource will reach a given value.\r\n   * @param {number} startTime Timestamp for known resource value\r\n   * @param {number} startValue Known resource value\r\n   * @param {number} regen Regeneration rate in units per ms\r\n   * @param {number} targetValue Resource value being aimed for\r\n   * @returns {number} Timestamp when targetValue would be reached through natural regen.\r\n   */\r\n  predictReachValue(startTime, startValue, regen, targetValue) {\r\n    if (startValue == null || isNaN(startValue) ||\r\n        regen == null || isNaN(regen) ||\r\n        targetValue == null || isNaN(targetValue) ||\r\n        startTime == null || isNaN(startTime)) {\r\n      throw new Error(`predictReachValue called without required parameters. startValue: ${startValue}, regen: ${regen}, cap: ${targetValue}, startTime: ${startTime}`);\r\n    }\r\n    if (startValue >= targetValue) {\r\n      return startTime;\r\n    }\r\n    if (regen === 0) {\r\n      return Infinity;\r\n    }\r\n    return startTime + ((targetValue - startValue) / regen);\r\n  }\r\n\r\n  /**\r\n   * Calculates available resource accounting for natural regen.\r\n   * @param {number} time Timestamp for which to create a prediction, or null for current timestamp.\r\n   * @returns {number} Predicted resource value at given time.\r\n   */\r\n  predictValue(time = null) {\r\n    if (!time) {\r\n      time = this.owner.currentTimestamp;\r\n    }\r\n    if (time < this.regenState.timestamp) {\r\n      debug && console.warn(`Attempting to predict the past. State's time: ${this.owner.formatTimestamp(this.regenState.timestamp, 3)}, target time: ${this.owner.formatTimestamp(time, 3)}`);\r\n      return this.regenState.amount;\r\n    }\r\n    const elapsed = time - this.regenState.timestamp;\r\n    const predicted = this.regenState.amount + this.regenState.regen * elapsed;\r\n    return this.regenState.max ? Math.min(this.regenState.max, predicted) : predicted;\r\n  }\r\n\r\n  onBelowCap(time) {\r\n    if (this.hasReportedBelowCap) {\r\n      return;\r\n    }\r\n    this.fabricateEndCap(time);\r\n    this.hasReportedBelowCap = true;\r\n  }\r\n\r\n  onAtCap(time) {\r\n    if (!this.hasReportedBelowCap) {\r\n      return;\r\n    }\r\n    this.fabricateBeginCap(time);\r\n    this.hasReportedBelowCap = false;\r\n  }\r\n\r\n  /**\r\n   * Fabricates an event indicating the tracked resource has reached its cap value.\r\n   * May be triggered by an energize or natural regeneration bringing the value to the cap, or\r\n   * by the cap being lowered.\r\n   *\r\n   * Although the timestamp of this event should be accurate, because cap events are sometimes\r\n   * only detected after they happen it may be misplaced within the event stream.\r\n   * So do NOT assume that an event parsed between beginresourcecap and endresourcecap events\r\n   * being parsed happened while the resource was capped. Either look at the timestamps of\r\n   * the events or if you're interested in the current cap state use this analyzer's isCapped\r\n   *\r\n   * Also note that endresourcecap and beginresourcecap events may occur extremely close to\r\n   * one-another, sometimes on the same timestamp if there's a spend and energize event.\r\n   *\r\n   * @param {number} time Timestamp for when the resource reached cap.\r\n   */\r\n  fabricateBeginCap(time) {\r\n    if (time == null || isNaN(time)) {\r\n      throw new Error(`fabricateBeginCap called without required parameter. time: ${time}`);\r\n    }\r\n    verboseDebug && console.log(`${this.owner.formatTimestamp(time, 3)} begin cap`);\r\n    this.eventEmitter.fabricateEvent({\r\n      type: 'beginresourcecap',\r\n      timestamp: time,\r\n      sourceID: this.owner.playerId,\r\n      targetID: this.owner.playerId,\r\n      resourceType: this.constructor.resourceType.id,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Fabricates an event indicating that the tracked resource is no longer at its cap.\r\n   * May be triggered by cast or drain using resource or the cap value being increased.\r\n   * @param {number} time Timestamp for when the resource ceased to be at the cap.\r\n   */\r\n  fabricateEndCap(time) {\r\n    if (time == null || isNaN(time)) {\r\n      throw new Error(`fabricateEndCap called without required parameter. time: ${time}`);\r\n    }\r\n    verboseDebug && console.log(`${this.owner.formatTimestamp(time, 3)} end cap`);\r\n    this.eventEmitter.fabricateEvent({\r\n      type: 'endresourcecap',\r\n      timestamp: time,\r\n      sourceID: this.owner.playerId,\r\n      targetID: this.owner.playerId,\r\n      resourceType: this.constructor.resourceType.id,\r\n    });\r\n  }\r\n\r\n  // -- debug code to check accuracy of predictions against values reported by log\r\n  debugErrorSum = 0;\r\n  debugGreatestError = 0;\r\n  debugAccuracyCheckCount = 0;\r\n  debugActualVsPredicted(actual, timestamp) {\r\n    if (!debug) {\r\n      return;\r\n    }\r\n    const predicted = this.predictValue(timestamp);\r\n    const difference = predicted - actual;\r\n    const errorMagnitude = Math.abs(difference);\r\n    this.debugGreatestError = Math.max(this.debugGreatestError, errorMagnitude);\r\n    this.debugAccuracyCheckCount += 1;\r\n    this.debugErrorSum += errorMagnitude;\r\n    if (errorMagnitude > 3) {\r\n      console.log(`${this.owner.formatTimestamp(timestamp, 3)} actual: ${actual} prediction: ${predicted.toFixed(1)} (error: ${difference > 0 ? '+' : ''}${difference.toFixed(1)})`);\r\n    }\r\n  }\r\n  get debugMeanPredictionError() {\r\n    return this.debugErrorSum / this.debugAccuracyCheckCount;\r\n  }\r\n}\r\n\r\nexport default RegenResourceCapTracker;\r\n","import RESOURCE_TYPES from 'game/RESOURCE_TYPES';\r\nimport ResourceTracker from 'parser/shared/modules/resources/resourcetracker/ResourceTracker';\r\n\r\nclass ComboPointTracker extends ResourceTracker {\r\n  constructor(...args) {\r\n    super(...args);\r\n    this.resource = RESOURCE_TYPES.COMBO_POINTS;\r\n  }\r\n}\r\n\r\nexport default ComboPointTracker;\r\n","import RESOURCE_TYPES from 'game/RESOURCE_TYPES';\r\nimport ResourceTracker from 'parser/shared/modules/resources/resourcetracker/ResourceTracker';\r\n\r\nclass EnergyTracker extends ResourceTracker {\r\n  constructor(...args) {\r\n    super(...args);\r\n    this.resource = RESOURCE_TYPES.ENERGY;\r\n  }\r\n}\r\n\r\nexport default EnergyTracker;\r\n","import React from 'react';\r\n\r\nimport Icon from 'common/Icon';\r\nimport SPELLS from 'common/SPELLS';\r\nimport RESOURCE_TYPES from 'game/RESOURCE_TYPES';\r\nimport { formatDuration, formatPercentage } from 'common/format';\r\nimport StatisticBox, { STATISTIC_ORDER } from 'interface/others/StatisticBox';\r\nimport Tooltip from 'common/Tooltip';\r\nimport RegenResourceCapTracker from 'parser/shared/modules/resources/resourcetracker/RegenResourceCapTracker';\r\nimport { i18n } from '@lingui/core';\r\nimport { t } from '@lingui/macro';\r\n\r\nimport SpellEnergyCost from './SpellEnergyCost';\r\n\r\nconst BASE_ENERGY_REGEN = 10;\r\nconst VIGOR_REGEN_MULTIPLIER = 1.1;\r\n\r\nconst BASE_ENERGY_MAX = 100;\r\nconst VIGOR_MAX_ADDITION = 50;\r\n\r\nconst RESOURCE_REFUND_ON_MISS = 0.8;\r\n\r\n/**\r\n * Sets up RegenResourceCapTracker to accurately track the regenerating energy of rogues.\r\n * Taking into account the effect of buffs, talents, and items on the energy cost of abilities,\r\n * the maximum energy amount, and the regeneration rate.\r\n */\r\nclass EnergyCapTracker extends RegenResourceCapTracker {\r\n  get wastedPercent() {\r\n    return (this.missedRegen / this.naturalRegen) || 0;\r\n  }\r\n\r\n  get suggestionThresholds() {\r\n    return {\r\n      actual: 1 - this.wastedPercent,\r\n      isLessThan: {\r\n        minor: 0.95,\r\n        average: 0.9,\r\n        major: 0.8,\r\n      },\r\n      style: 'percentage',\r\n    };\r\n  }\r\n\r\n  static dependencies = {\r\n    ...RegenResourceCapTracker.dependencies,\r\n    // Needed for the `resourceCost` prop of events\r\n    spellResourceCost: SpellEnergyCost,\r\n  };\r\n  static resourceType = RESOURCE_TYPES.ENERGY;\r\n  static baseRegenRate = BASE_ENERGY_REGEN;\r\n  static isRegenHasted = true;\r\n  static cumulativeEventWindow = 400;\r\n  static resourceRefundOnMiss = RESOURCE_REFUND_ON_MISS;\r\n  static exemptFromRefund = [];\r\n\r\n  naturalRegenRate() {\r\n    let regen = super.naturalRegenRate();\r\n    if (this.selectedCombatant.hasTalent(SPELLS.VIGOR_TALENT.id)) {\r\n      regen *= VIGOR_REGEN_MULTIPLIER;\r\n    }\r\n    return regen;\r\n  }\r\n\r\n  currentMaxResource() {\r\n    let max = BASE_ENERGY_MAX;\r\n    if (this.selectedCombatant.hasTalent(SPELLS.VIGOR_TALENT.id)) {\r\n      max += VIGOR_MAX_ADDITION;\r\n    }\r\n    // What should be x.5 becomes x in-game.\r\n    return Math.floor(max);\r\n  }\r\n\r\n  suggestions(when) {\r\n    when(this.suggestionThresholds).addSuggestion((suggest, actual, recommended) => suggest(\r\n      <>\r\n        You're allowing your energy to reach its cap. While at its maximum value you miss out on the energy that would have regenerated. Although it can be beneficial to let energy pool ready to be used at the right time, try to spend some before it reaches the cap.\r\n      </>,\r\n    )\r\n      .icon('spell_shadow_shadowworddominate')\r\n      .actual(i18n._(t('rogue.shared.suggestions.energy.capped')`${actual.toFixed(1)} regenerated energy lost per minute due to being capped.`))\r\n      .recommended(`<${recommended} is recommended.`));\r\n  }\r\n\r\n  statistic() {\r\n    return (\r\n      <StatisticBox\r\n        position={STATISTIC_ORDER.CORE(1)}\r\n        icon={<Icon icon=\"spell_shadow_shadowworddominate\" alt=\"Capped Energy\" />}\r\n        value={`${formatPercentage(this.wastedPercent)} %`}\r\n        label=\"Wasted energy from being capped\"\r\n        tooltip={(\r\n          <>\r\n            Although it can be beneficial to wait and let your energy pool ready to be used at the right time, you should still avoid letting it reach the cap.<br />\r\n            You spent <strong>{formatPercentage(this.cappedProportion)}%</strong> of the fight at capped energy, causing you to miss out on a total of <strong>{this.missedRegen.toFixed(0)}</strong> energy from regeneration.\r\n          </>\r\n        )}\r\n        footer={(\r\n          <div className=\"statistic-box-bar\">\r\n            <Tooltip content={`Not at capped energy for ${formatDuration((this.owner.fightDuration - this.atCap) / 1000)}`}>\r\n              <div\r\n                className=\"stat-healing-bg\"\r\n                style={{ width: `${(1 - this.cappedProportion) * 100}%` }}\r\n              >\r\n                <img src=\"/img/sword.png\" alt=\"Uncapped Energy\" />\r\n              </div>\r\n            </Tooltip>\r\n\r\n            <Tooltip content={`At capped energy for ${formatDuration(this.atCap / 1000)}`}>\r\n              <div className=\"remainder DeathKnight-bg\">\r\n                <img src=\"/img/overhealing.png\" alt=\"Capped Energy\" />\r\n              </div>\r\n            </Tooltip>\r\n          </div>\r\n        )}\r\n      />\r\n    );\r\n  }\r\n}\r\n\r\nexport default EnergyCapTracker;\r\n","import React from 'react';\r\n\r\nimport Analyzer from 'parser/core/Analyzer';\r\nimport Panel from 'interface/others/Panel';\r\nimport StatisticBox, { STATISTIC_ORDER } from 'interface/others/StatisticBox';\r\nimport Icon from 'common/Icon';\r\nimport { formatPercentage } from 'common/format';\r\nimport ResourceBreakdown from 'parser/shared/modules/resources/resourcetracker/ResourceBreakdown';\r\n\r\nimport ComboPointTracker from './ComboPointTracker';\r\n\r\nconst MINOR_THRESHOLD = 0.05;\r\nconst AVERAGE_THRESHOLD = 0.1;\r\nconst MAJOR_THRESHOLD = 0.2;\r\n\r\nclass ComboPointDetails extends Analyzer {\r\n  get wasted() {\r\n    return this.comboPointTracker.wasted || 0;\r\n  }\r\n\r\n  get total() {\r\n    return this.comboPointTracker.wasted + this.comboPointTracker.generated || 0;\r\n  }\r\n\r\n  get wastedPercent() {\r\n    return this.wasted / this.total || 0;\r\n  }\r\n\r\n  get suggestionThresholds() {\r\n    return {\r\n      actual: 1 - this.wastedPercent,\r\n      isLessThan: {\r\n        minor: 1 - MINOR_THRESHOLD,\r\n        average: 1 - AVERAGE_THRESHOLD,\r\n        major: 1 - MAJOR_THRESHOLD,\r\n      },\r\n      style: 'percentage',\r\n    };\r\n  }\r\n\r\n  static dependencies = {\r\n    comboPointTracker: ComboPointTracker,\r\n  };\r\n\r\n  statistic() {\r\n    return (\r\n      <StatisticBox\r\n        position={STATISTIC_ORDER.CORE(3)}\r\n        icon={<Icon icon=\"ability_rogue_masterofsubtlety\" alt=\"Wasted Combo Points\" />}\r\n        value={`${formatPercentage(this.wastedPercent)} %`}\r\n        label=\"Wasted Combo Points\"\r\n        tooltip={`You wasted ${this.wasted} out of ${this.total} Combo Points. Some waste is expected due to the random nature of some generation abilities.`}\r\n      />\r\n    );\r\n  }\r\n\r\n  tab() {\r\n    return {\r\n      title: 'Combo Point usage',\r\n      url: 'combo-points',\r\n      render: () => (\r\n        <Panel>\r\n          <ResourceBreakdown\r\n            tracker={this.comboPointTracker}\r\n            showSpenders\r\n          />\r\n        </Panel>\r\n      ),\r\n    };\r\n  }\r\n}\r\n\r\nexport default ComboPointDetails;\r\n","import React from 'react';\r\n\r\nimport Analyzer from 'parser/core/Analyzer';\r\nimport Panel from 'interface/others/Panel';\r\nimport StatisticBox, { STATISTIC_ORDER } from 'interface/others/StatisticBox';\r\nimport Icon from 'common/Icon';\r\nimport { formatPercentage } from 'common/format';\r\nimport ResourceBreakdown from 'parser/shared/modules/resources/resourcetracker/ResourceBreakdown';\r\n\r\nimport EnergyTracker from './EnergyTracker';\r\n\r\nconst MINOR_THRESHOLD = 0.05;\r\nconst AVERAGE_THRESHOLD = 0.1;\r\nconst MAJOR_THRESHOLD = 0.2;\r\n\r\nclass EnergyDetails extends Analyzer {\r\n  get wasted() {\r\n    return this.energyTracker.wasted || 0;\r\n  }\r\n\r\n  get total() {\r\n    return this.energyTracker.wasted + this.energyTracker.generated || 0;\r\n  }\r\n\r\n  get wastedPercent() {\r\n    return this.wasted / this.total || 0;\r\n  }\r\n\r\n  get suggestionThresholds() {\r\n    return {\r\n      actual: 1 - this.wastedPercent,\r\n      isLessThan: {\r\n        minor: 1 - MINOR_THRESHOLD,\r\n        average: 1 - AVERAGE_THRESHOLD,\r\n        major: 1 - MAJOR_THRESHOLD,\r\n      },\r\n      style: 'percentage',\r\n    };\r\n  }\r\n\r\n  static dependencies = {\r\n    energyTracker: EnergyTracker,\r\n  };\r\n\r\n  statistic() {\r\n    return (\r\n      <StatisticBox\r\n        position={STATISTIC_ORDER.CORE(2)}\r\n        icon={<Icon icon=\"ability_warrior_decisivestrike\" alt=\"Wasted Energy\" />}\r\n        value={`${formatPercentage(this.wastedPercent)} %`}\r\n        label=\"Wasted generator Energy\"\r\n        tooltip={`You wasted ${this.wasted} out of ${this.total} Energy from generators. Some waste is expected due to the random nature of some generation abilities.`}\r\n      />\r\n    );\r\n  }\r\n\r\n  tab() {\r\n    return {\r\n      title: 'Energy usage',\r\n      url: 'energy-usage',\r\n      render: () => (\r\n        <Panel>\r\n          <ResourceBreakdown\r\n            tracker={this.energyTracker}\r\n            showSpenders\r\n          />\r\n        </Panel>\r\n      ),\r\n    };\r\n  }\r\n\r\n}\r\n\r\nexport default EnergyDetails;\r\n","import SPELLS from 'common/SPELLS';\r\nimport RESOURCE_TYPES from 'game/RESOURCE_TYPES';\r\n\r\nimport SpellResourceCost from 'parser/shared/modules/SpellResourceCost';\r\n\r\nimport { isStealthOrDance } from '../stealth/IsStealth';\r\n\r\nconst SHADOW_FOCUS_MULTIPLIER = 0.8;\r\n\r\nclass SpellEnergyCost extends SpellResourceCost {\r\n  static resourceType = RESOURCE_TYPES.ENERGY;\r\n\r\n  discountShadowFocus = false;\r\n\r\n  constructor(...args) {\r\n    super(...args);\r\n    this.discountShadowFocus = this.selectedCombatant.hasTalent(SPELLS.SHADOW_FOCUS_TALENT.id);\r\n  }\r\n\r\n  getResourceCost(event) {\r\n    const cost = super.getResourceCost(event);\r\n\r\n    if (this.discountShadowFocus && isStealthOrDance(this.selectedCombatant, 100)) {\r\n      return cost * SHADOW_FOCUS_MULTIPLIER;\r\n    }\r\n    return cost;\r\n  }\r\n}\r\n\r\nexport default SpellEnergyCost;\r\n","import SPELLS from 'common/SPELLS';\r\n\r\nimport CoreSpellUsable from 'parser/shared/modules/SpellUsable';\r\nimport { encodeTargetString } from 'parser/shared/modules/EnemyInstances';\r\nimport Events from 'parser/core/Events';\r\nimport { SELECTED_PLAYER } from 'parser/core/Analyzer';\r\n\r\nconst MARK_FOR_DEATH_DURATION = 60 * 1000;\r\n\r\nclass SpellUsable extends CoreSpellUsable {\r\n  /**\r\n   * A map of target strings to the timestamp of when Marked for Death was cast on them.\r\n   */\r\n  markMap = {};\r\n\r\n  constructor(options) {\r\n    super(options);\r\n    this.addEventListener(Events.removebuff.by(SELECTED_PLAYER).spell(SPELLS.MARKED_FOR_DEATH_TALENT), this.onRemoveBuff);\r\n  }\r\n\r\n  onCast(event) {\r\n    super.onCast(event);\r\n\r\n    if (event.ability.guid !== SPELLS.MARKED_FOR_DEATH_TALENT.id) {\r\n      return;\r\n    }\r\n\r\n    const targetString = encodeTargetString(event.targetID, event.targetInstance);\r\n    this.markMap[targetString] = event.timestamp;\r\n  }\r\n\r\n  onRemoveBuff(event) {\r\n    if (!this.isOnCooldown(SPELLS.MARKED_FOR_DEATH_TALENT.id)) {\r\n      return;\r\n    }\r\n\r\n    const targetString = encodeTargetString(event.targetID, event.targetInstance);\r\n\r\n    // Only refresh cooldown if the target died, which is not the case if the debuff is removed at the end of its duration.\r\n    if (event.timestamp - this.markMap[targetString] < MARK_FOR_DEATH_DURATION) {\r\n      this.endCooldown(SPELLS.MARKED_FOR_DEATH_TALENT.id);\r\n    }\r\n  }\r\n}\r\n\r\nexport default SpellUsable;\r\n","import React from 'react';\r\nimport Analyzer, { Options, SELECTED_PLAYER } from 'parser/core/Analyzer';\r\nimport Abilities from 'parser/core/modules/Abilities';\r\nimport SpellUsable from 'parser/shared/modules/SpellUsable';\r\nimport SPELLS from 'common/SPELLS';\r\nimport Events, { DamageEvent, EnergizeEvent, RemoveDebuffEvent } from 'parser/core/Events';\r\nimport RESOURCE_TYPES from 'game/RESOURCE_TYPES';\r\nimport Statistic from 'interface/statistics/Statistic';\r\nimport STATISTIC_CATEGORY from 'interface/others/STATISTIC_CATEGORY';\r\nimport COVENANTS from 'game/shadowlands/COVENANTS';\r\nimport ItemDamageDone from 'interface/ItemDamageDone';\r\nimport BoringSpellValueText from 'interface/statistics/components/BoringSpellValueText';\r\nimport ResourceIcon from 'common/ResourceIcon';\r\n\r\nclass SerratedBoneSpike extends Analyzer {\r\n  static dependencies = {\r\n    abilities: Abilities,\r\n    spellUsable: SpellUsable,\r\n  };\r\n  damage: number = 0;\r\n  comboPointsGained: number = 0;\r\n  comboPointsWasted: number = 0;\r\n\r\n  protected abilities!: Abilities;\r\n  protected spellUsable!: SpellUsable;\r\n\r\n  constructor(options: Options) {\r\n    super(options);\r\n    this.active = this.selectedCombatant.hasCovenant(COVENANTS.NECROLORD.id);\r\n    this.addEventListener(Events.damage.by(SELECTED_PLAYER).spell(SPELLS.SERRATED_BONE_SPIKE), this.onDamage);\r\n    this.addEventListener(Events.energize.by(SELECTED_PLAYER).spell(SPELLS.SERRATED_BONE_SPIKE_ENERGIZE), this.onEnergize);\r\n    this.addEventListener(Events.removedebuff.by(SELECTED_PLAYER).spell(SPELLS.SERRATED_BONE_SPIKE_DEBUFF), this.onSBSRemoveDebuff);\r\n  }\r\n\r\n  onDamage(event: DamageEvent) {\r\n    this.damage += event.amount + (event.absorbed || 0);\r\n  }\r\n\r\n  onEnergize(event: EnergizeEvent) {\r\n    if (event.resourceChangeType === RESOURCE_TYPES.COMBO_POINTS.id) {\r\n      this.comboPointsGained += event.resourceChange;\r\n      this.comboPointsWasted += event.waste;\r\n    }\r\n  }\r\n\r\n  onSBSRemoveDebuff(event: RemoveDebuffEvent) {\r\n    if (this.spellUsable.isOnCooldown(SPELLS.SERRATED_BONE_SPIKE.id)) {\r\n      const expectedCooldownDuration = this.abilities.getExpectedCooldownDuration(SPELLS.SERRATED_BONE_SPIKE.id, this.spellUsable.cooldownTriggerEvent(SPELLS.SERRATED_BONE_SPIKE.id));\r\n      if (expectedCooldownDuration) {\r\n        this.spellUsable.reduceCooldown(SPELLS.SERRATED_BONE_SPIKE, expectedCooldownDuration, event.timestamp);\r\n      }\r\n    }\r\n  }\r\n\r\n  statistic() {\r\n    return (\r\n      <Statistic\r\n        size=\"flexible\"\r\n        category={STATISTIC_CATEGORY.COVENANTS}\r\n      >\r\n        <BoringSpellValueText spell={SPELLS.SERRATED_BONE_SPIKE_DEBUFF}>\r\n          <>\r\n            <ItemDamageDone amount={this.damage} />\r\n            <br />\r\n            <ResourceIcon id={RESOURCE_TYPES.COMBO_POINTS.id} noLink />\r\n            {this.comboPointsGained}/{this.comboPointsWasted + this.comboPointsGained}\r\n            <small> gained Combo Points</small>\r\n          </>\r\n        </BoringSpellValueText>\r\n      </Statistic>\r\n    );\r\n  }\r\n}\r\n\r\nexport default SerratedBoneSpike;\r\n","import React from 'react';\r\nimport Analyzer, { Options, SELECTED_PLAYER } from 'parser/core/Analyzer';\r\nimport Abilities from 'parser/core/modules/Abilities';\r\nimport SPELLS from 'common/SPELLS';\r\nimport Events, { DamageEvent, EnergizeEvent } from 'parser/core/Events';\r\nimport RESOURCE_TYPES from 'game/RESOURCE_TYPES';\r\nimport Statistic from 'interface/statistics/Statistic';\r\nimport STATISTIC_CATEGORY from 'interface/others/STATISTIC_CATEGORY';\r\nimport COVENANTS from 'game/shadowlands/COVENANTS';\r\nimport ItemDamageDone from 'interface/ItemDamageDone';\r\nimport BoringSpellValueText from 'interface/statistics/components/BoringSpellValueText';\r\nimport ResourceIcon from 'common/ResourceIcon';\r\n\r\nclass EchoingReprimand extends Analyzer {\r\n  static dependencies = {\r\n    abilities: Abilities,\r\n  };\r\n  damage: number = 0;\r\n  comboPointsGained: number = 0;\r\n  comboPointsWasted: number = 0;\r\n  protected abilities!: Abilities;\r\n\r\n  constructor(options: Options) {\r\n    super(options);\r\n    this.active = this.selectedCombatant.hasCovenant(COVENANTS.KYRIAN.id);\r\n    this.addEventListener(Events.damage.by(SELECTED_PLAYER).spell(SPELLS.ECHOING_REPRIMAND), this.onDamage);\r\n    this.addEventListener(Events.energize.by(SELECTED_PLAYER).spell(SPELLS.ECHOING_REPRIMAND_ENERGIZE), this.onEnergize);\r\n  }\r\n\r\n  onDamage(event: DamageEvent) {\r\n    this.damage += event.amount + (event.absorbed || 0);\r\n  }\r\n\r\n  onEnergize(event: EnergizeEvent) {\r\n    if (event.resourceChangeType === RESOURCE_TYPES.COMBO_POINTS.id) {\r\n      this.comboPointsGained += event.resourceChange;\r\n      this.comboPointsWasted += event.waste;\r\n    }\r\n  }\r\n\r\n  statistic() {\r\n    return (\r\n      <Statistic\r\n        size=\"flexible\"\r\n        category={STATISTIC_CATEGORY.COVENANTS}\r\n      >\r\n        <BoringSpellValueText spell={SPELLS.ECHOING_REPRIMAND}>\r\n          <>\r\n            <ItemDamageDone amount={this.damage} />\r\n            <br />\r\n            <ResourceIcon id={RESOURCE_TYPES.COMBO_POINTS.id} noLink />\r\n            {this.comboPointsGained}/{this.comboPointsWasted + this.comboPointsGained}\r\n            <small> Combo Points gained</small>\r\n          </>\r\n        </BoringSpellValueText>\r\n      </Statistic>\r\n    );\r\n  }\r\n}\r\n\r\nexport default EchoingReprimand;\r\n","import React from 'react';\r\nimport Analyzer, { Options, SELECTED_PLAYER } from 'parser/core/Analyzer';\r\nimport Abilities from 'parser/core/modules/Abilities';\r\nimport SPELLS from 'common/SPELLS';\r\nimport Events, { DamageEvent } from 'parser/core/Events';\r\nimport Statistic from 'interface/statistics/Statistic';\r\nimport STATISTIC_CATEGORY from 'interface/others/STATISTIC_CATEGORY';\r\nimport COVENANTS from 'game/shadowlands/COVENANTS';\r\nimport { formatNumber } from 'common/format';\r\nimport ItemDamageDone from 'interface/ItemDamageDone';\r\nimport BoringSpellValueText from 'interface/statistics/components/BoringSpellValueText';\r\n\r\nclass Sepsis extends Analyzer {\r\n  static dependencies = {\r\n    abilities: Abilities,\r\n  };\r\n  damage: number = 0;\r\n  poisonDamage: number = 0;\r\n  protected abilities!: Abilities;\r\n\r\n  constructor(options: Options) {\r\n    super(options);\r\n    this.active = this.selectedCombatant.hasCovenant(COVENANTS.NIGHT_FAE.id);\r\n    this.addEventListener(Events.damage.by(SELECTED_PLAYER).spell(SPELLS.SEPSIS), this.onDamage);\r\n    this.addEventListener(Events.damage.by(SELECTED_PLAYER).spell(SPELLS.SEPSIS_POISON), this.onPoisonDamage);\r\n  }\r\n\r\n  onDamage(event: DamageEvent) {\r\n    this.damage += event.amount + (event.absorbed || 0);\r\n  }\r\n\r\n  onPoisonDamage(event: DamageEvent) {\r\n    this.damage += event.amount + (event.absorbed || 0);\r\n    this.poisonDamage += event.amount + (event.absorbed || 0);\r\n  }\r\n\r\n  statistic() {\r\n    return (\r\n      <>\r\n        <Statistic\r\n          size=\"flexible\"\r\n          category={STATISTIC_CATEGORY.COVENANTS}\r\n          tooltip={\r\n            <ul>\r\n              <li>{formatNumber(this.damage)} damage done by Sepsis Ability</li>\r\n              <li>{formatNumber(this.poisonDamage)} damage done by Sepsis poison</li>\r\n            </ul>\r\n          }\r\n        >\r\n          <BoringSpellValueText spell={SPELLS.SEPSIS}>\r\n            <ItemDamageDone amount={this.damage + this.poisonDamage} />\r\n          </BoringSpellValueText>\r\n        </Statistic>\r\n      </>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Sepsis;\r\n","import React from 'react';\r\nimport Analyzer, { Options, SELECTED_PLAYER } from 'parser/core/Analyzer';\r\nimport Abilities from 'parser/core/modules/Abilities';\r\nimport SPELLS from 'common/SPELLS';\r\nimport Events, { DamageEvent } from 'parser/core/Events';\r\nimport Statistic from 'interface/statistics/Statistic';\r\nimport STATISTIC_CATEGORY from 'interface/others/STATISTIC_CATEGORY';\r\nimport COVENANTS from 'game/shadowlands/COVENANTS';\r\nimport ItemDamageDone from 'interface/ItemDamageDone';\r\nimport BoringSpellValueText from 'interface/statistics/components/BoringSpellValueText';\r\n\r\nclass Flagellation extends Analyzer {\r\n  static dependencies = {\r\n    abilities: Abilities,\r\n  };\r\n  damage: number = 0;\r\n  lashDamage: number = 0;\r\n  protected abilities!: Abilities;\r\n\r\n  constructor(options: Options) {\r\n    super(options);\r\n    this.active = this.selectedCombatant.hasCovenant(COVENANTS.VENTHYR.id);\r\n    this.addEventListener(Events.damage.by(SELECTED_PLAYER).spell(SPELLS.FLAGELLATION), this.onDamage);\r\n    this.addEventListener(Events.damage.by(SELECTED_PLAYER).spell(SPELLS.FLAGELLATION_LASH), this.onLashDamage);\r\n  }\r\n\r\n  onDamage(event: DamageEvent) {\r\n    this.damage += event.amount + (event.absorbed || 0);\r\n  }\r\n\r\n  onLashDamage(event: DamageEvent) {\r\n    this.damage += event.amount + (event.absorbed || 0);\r\n    this.lashDamage += event.amount + (event.absorbed || 0);\r\n  }\r\n\r\n  statistic() {\r\n    return (\r\n      <Statistic\r\n        size=\"flexible\"\r\n        category={STATISTIC_CATEGORY.COVENANTS}\r\n      >\r\n        <BoringSpellValueText spell={SPELLS.FLAGELLATION}>\r\n          <>\r\n            <ItemDamageDone amount={this.damage} />\r\n            <ItemDamageDone amount={this.lashDamage} />\r\n          </>\r\n        </BoringSpellValueText>\r\n      </Statistic>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Flagellation;\r\n","import React from 'react';\r\nimport Analyzer, { Options, SELECTED_PLAYER } from 'parser/core/Analyzer';\r\nimport SPELLS from 'common/SPELLS';\r\nimport Events, { DamageEvent, HealEvent } from 'parser/core/Events';\r\nimport Statistic from 'interface/statistics/Statistic';\r\nimport STATISTIC_CATEGORY from 'interface/others/STATISTIC_CATEGORY';\r\nimport ItemDamageDone from 'interface/ItemDamageDone';\r\nimport ItemHealingDone from 'interface/ItemHealingDone';\r\nimport BoringSpellValueText from 'interface/statistics/components/BoringSpellValueText';\r\n\r\nclass EssenceOfBloodfang extends Analyzer {\r\n  bloodfangDamage: number = 0;\r\n  bloodfangHealing: number = 0;\r\n\r\n  constructor(options: Options) {\r\n    super(options);\r\n    this.active = this.selectedCombatant.hasLegendaryByBonusID(SPELLS.ESSENCE_OF_BLOODFANG.bonusID);\r\n    this.addEventListener(Events.heal.by(SELECTED_PLAYER).spell(SPELLS.ESSENCE_OF_BLOODFANG_BUFF), this.onHeal);\r\n    this.addEventListener(Events.damage.by(SELECTED_PLAYER).spell(SPELLS.ESSENCE_OF_BLOODFANG_BUFF), this.onDamage);\r\n  }\r\n\r\n  onDamage(event: DamageEvent) {\r\n    this.bloodfangDamage += event.amount + (event.absorbed || 0);\r\n  }\r\n\r\n  onHeal(event: HealEvent) {\r\n    this.bloodfangHealing += event.amount + (event.absorbed || 0);\r\n  }\r\n\r\n  statistic() {\r\n    return (\r\n      <Statistic\r\n        size=\"flexible\"\r\n        category={STATISTIC_CATEGORY.ITEMS}\r\n      >\r\n        <BoringSpellValueText spell={SPELLS.ESSENCE_OF_BLOODFANG}>\r\n          <ItemDamageDone amount={this.bloodfangDamage} />\r\n          <br />\r\n          <ItemHealingDone amount={this.bloodfangHealing} />\r\n        </BoringSpellValueText>\r\n      </Statistic>\r\n    );\r\n  }\r\n}\r\n\r\nexport default EssenceOfBloodfang;\r\n","import Analyzer, { Options, SELECTED_PLAYER } from 'parser/core/Analyzer';\r\nimport Abilities from 'parser/core/modules/Abilities';\r\nimport SpellUsable from 'parser/shared/modules/SpellUsable';\r\nimport SPELLS from 'common/SPELLS';\r\nimport Events, { CastEvent } from 'parser/core/Events';\r\n\r\nimport { ASSASSINATION_ABILITY_COOLDOWNS, OUTLAW_ABILITY_COOLDOWNS, SUBTLETY_ABILITY_COOLDOWNS } from 'parser/rogue/shared/constants';\r\nimport { SpellList } from 'common/SPELLS/Spell';\r\n\r\n/**\r\n * The Inigorating Shadowdust legendary reduces the cooldown of ALL abilities by 15 seconds after using Vanish. This is usable by all 3 Rogue specs.\r\n *\r\n * 10/20/2020 -- Have not been able to find any logs to test this against during the current Beta. Will implement and modify trackable statistic(s), if any, when there are logs available.\r\n */\r\n\r\nclass InvigoratingShadowdust extends Analyzer {\r\n  static dependencies = {\r\n    abilities: Abilities,\r\n    spellUsable: SpellUsable,\r\n  };\r\n  spec: string = '';\r\n  cooldownReduction: number = 15000; // 15 seconds\r\n  cooldowns: SpellList[] = [];\r\n  protected spellUsable!: SpellUsable;\r\n\r\n  constructor(options: Options) {\r\n    super(options);\r\n    this.spec = this.selectedCombatant.spec.specName;\r\n    switch (this.spec) {\r\n      case 'Assassination':\r\n        this.cooldowns = ASSASSINATION_ABILITY_COOLDOWNS;\r\n        break;\r\n      case 'Outlaw':\r\n        this.cooldowns = OUTLAW_ABILITY_COOLDOWNS;\r\n        break;\r\n      case 'Subtlety':\r\n        this.cooldowns = SUBTLETY_ABILITY_COOLDOWNS;\r\n        break;\r\n      default:\r\n        break;\r\n    }\r\n    this.active = this.selectedCombatant.hasLegendaryByBonusID(SPELLS.INVIGORATING_SHADOWDUST.bonusID);\r\n    this.addEventListener(Events.cast.by(SELECTED_PLAYER).spell(SPELLS.VANISH), this.onCast);\r\n  }\r\n\r\n  onCast(event: CastEvent) {\r\n    this.cooldowns.map((cooldown, index) => {\r\n      const { id } = cooldown[index];\r\n      if (!this.spellUsable.isOnCooldown(id)) {\r\n        // eslint-disable-next-line array-callback-return\r\n        return;\r\n      }\r\n      return this.spellUsable.reduceCooldown(id, this.cooldownReduction, event.timestamp);\r\n    });\r\n  }\r\n}\r\n\r\nexport default InvigoratingShadowdust;\r\n"],"sourceRoot":""}